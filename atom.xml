<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Siyao&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-19T09:32:35.001Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Siyao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【机器学习】朴素贝叶斯</title>
    <link href="http://yoursite.com/2018/03/19/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <id>http://yoursite.com/2018/03/19/【机器学习】朴素贝叶斯/</id>
    <published>2018-03-19T09:32:34.000Z</published>
    <updated>2018-03-19T09:32:35.001Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【机器学习】k近邻</title>
    <link href="http://yoursite.com/2018/03/19/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91k%E8%BF%91%E9%82%BB/"/>
    <id>http://yoursite.com/2018/03/19/【机器学习】k近邻/</id>
    <published>2018-03-19T09:32:28.000Z</published>
    <updated>2018-03-19T09:32:28.409Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【机器学习】CART算法、决策树总结</title>
    <link href="http://yoursite.com/2018/03/19/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91CART%E7%AE%97%E6%B3%95%E3%80%81%E5%86%B3%E7%AD%96%E6%A0%91%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/19/【机器学习】CART算法、决策树总结/</id>
    <published>2018-03-19T09:32:04.000Z</published>
    <updated>2018-03-19T12:12:36.202Z</updated>
    
    <content type="html"><![CDATA[<p><strong>决策树</strong>学习的本质是从训练数据集中归纳出一组分类规则，从另一个角度看，决策树学习是由训练数据集估计条件概率模型，我们选择的模型应该不仅对训练数据拟合的好，还应具有很好的泛化能力。</p><p><strong>决策树学习的三个步骤：</strong></p><ol><li>特征选择</li><li>决策树的生成</li><li>决策树的剪枝</li></ol><h1 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h1><p>​    特征选择在于选取对训练数据具有分类能力的特征，如果一个特征的分类效果不优于随机分类，那么这个这个特征是没有分类能力的，应当放弃。特征选择决定用哪个特征来划分空间，特征选择的准则通常是<strong>信息增益</strong> 、<strong>信息增益比</strong> 、<strong>基尼指数</strong>。</p><h2 id="使用信息增益计算"><a href="#使用信息增益计算" class="headerlink" title="使用信息增益计算"></a>使用信息增益计算</h2><p> 特征A对训练数据集D的信息增益<script type="math/tex">g(D,A)</script> ，定义为集合D的经验熵<script type="math/tex">H(D)</script>与特征更A给定条件下D的经验条件熵<script type="math/tex">H(D|A)</script> 之差，即：</p><script type="math/tex; mode=display">g(D,A) = H(D)-H(D|A)</script><p><strong>熵越大，说明系统越混乱，携带的信息就越少。熵越小，说明系统越有序，携带的信息就越多</strong>。信息的作用就是在于消除不确定性。</p><p>ID3划分特征使用的就是信息增益IG。<strong>一个属性的信息增益越大，表明属性对样本的熵减少的能力就更强，该属性使得数据所属类别的不确定性变为确定性的能力越强</strong>。</p><p><strong>信息增益计算</strong></p><p>首先计算特征A对数据集D的经验<strong>条件熵</strong><script type="math/tex">H(D|A)</script>,在数学上就是条件概率分布（Condition Probability）.</p><script type="math/tex; mode=display">H(D|A)=\sum_j\dfrac{|D_j|}{|D|}\times H(D_j) =\sum_j\dfrac{|D_j|}{|D|} \sum_k\dfrac{|D_{jk}|}{|D_j|}log\dfrac{|D_{jk}|}{|D_j|}</script><p>其中项<script type="math/tex">\dfrac{|D_i|}{|D|}</script>充当第j个分区的权重</p><h2 id="信息增益比："><a href="#信息增益比：" class="headerlink" title="信息增益比："></a>信息增益比：</h2><p>在决策树中，<strong>ID3属性划分标准使用的是信息增益，C4.5使用的是信息增益率。</strong></p><p>C4.5算法继承了ID3算法的优点，并在以下几方面对ID3算法进行了改进：</p><ul><li>用信息增益率来选择属性，克<strong>服了用信息增益选择属性时偏向选择取值多的属性的不足</strong>；</li><li>在树构造过程中进行剪枝；</li><li>能够完成对连续属性的离散化处理；</li><li>能够对不完整数据进行处理。</li></ul><p>C4.5算法有如下优点：<strong>产生的分类规则易于理解，准确率较高</strong>。其缺点是：<strong>在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效</strong>。另外，C4.5只适合于能够驻留于内存的数据集，当训练集大得无法在内存容纳时程序无法运行。</p><p>另外，无论是ID3还是C4.5最好在小数据集上使用，决策树分类一般只试用于小数据。当属性取值很多时最好选择C4.5算法，ID3得出的效果会非常差，因为使用信息增益划分时它倾向于取值多的属性。</p><p>计算信息增益率时，用到了<strong>分裂信息计算公式：</strong></p><script type="math/tex; mode=display">Split_H(D|A)=-∑\dfrac{|D_j|}{|D|}\times log_2(\dfrac{|D_j|}{|D|})</script><script type="math/tex; mode=display">Gain_Rate(A)=\dfrac{g(D,A)}{Split_H(D|A)}</script><h2 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h2><p>基尼指数主要在CART算法中用到，随机森林中用到的属性划分标准也是它。Gini index划分是二元的，<strong>它度量的是数据分区或训练元组集D的不纯度，表示的是一个随机选中的样本在子集中被分错的可能性</strong>。计算方式如下：</p><script type="math/tex; mode=display">Gini(D)=1-\sum p^{2}_i ，其中，p_i 是D中元组数以C_i 类的概率，对m个类计算和。</script><p>Gini指数越大，不纯度越大，越不容易区分。假设A有v个不同的值出现在特征D中，它的二元划分有<script type="math/tex">2^v−2</script>种（除去自己和空集）。当考虑二元划分裂时，计算每个结果分区的不纯度加权和。比如A有两个值，则特征D被划分成D1和D2,这时Gini指数为：</p><p><a href="http://latex.codecogs.com/gif.latex?Gini_A%28D%29%20%3D%20%5Cfrac%7BD_1%7D%7BD%7D%20Gini%28D_1%29%20+%20%5Cfrac%7BD_2%7D%7BD%7D%20Gini%28D_2%29" target="_blank" rel="external"><img src="http://latex.codecogs.com/gif.latex?Gini_A%28D%29%20%3D%20%5Cfrac%7BD_1%7D%7BD%7D%20Gini%28D_1%29%20+%20%5Cfrac%7BD_2%7D%7BD%7D%20Gini%28D_2%29" alt="$$Gini_A(D) = \frac{D_1}{D} Gini(D_1) + \frac{D_2}{D} Gini(D_2)$$"></a></p><p>上面的式子表示的是不确定性的大小。对于每个属性，考虑每种可能的二元划分，对于离散值属性，<strong>选择该属性产生最小Gini指数的自己作为它的分裂信息</strong>。</p><h1 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h1><h2 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h2><h2 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h2><h1 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h1><h1 id="CART树"><a href="#CART树" class="headerlink" title="CART树"></a>CART树</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;决策树&lt;/strong&gt;学习的本质是从训练数据集中归纳出一组分类规则，从另一个角度看，决策树学习是由训练数据集估计条件概率模型，我们选择的模型应该不仅对训练数据拟合的好，还应具有很好的泛化能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;决策树学习的三个步骤：&lt;/str
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【机器学习】感知机</title>
    <link href="http://yoursite.com/2018/03/15/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <id>http://yoursite.com/2018/03/15/【机器学习】感知机/</id>
    <published>2018-03-15T07:57:54.000Z</published>
    <updated>2018-03-16T09:35:02.423Z</updated>
    
    <content type="html"><![CDATA[<p><strong>感知机（perceptron）是二分类的线性分类模型，属于监督学习算法。输入为实例的特征向量</strong>，输出为实例的类别（取+1和-1）。感知机对应于输入空间中将实例划分为两类的<strong>分离超平面</strong>。感知机旨在求出该超平面，为求得超平面导入了基于误分类的损失函数，利用梯度下降法 对损失函数进行最优化（最优化）。感知机的学习算法具有简单而易于实现的优点，分为原始形式和对偶形式。感知机预测是用学习得到的感知机模型对新的实例进行预测的，因此属于<strong>判别模型</strong>。感知机由<strong>Rosenblatt</strong>于1957年提出的，是<strong>神经网络</strong>和<strong>支持向量机</strong>的基础。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h2><p>假设输入空间(特征向量)为<script type="math/tex">X⊆Rn</script>，输出空间为Y={-1, +1}。输入<script type="math/tex">x∈X</script>表示实例的特征向量，对应于输入空间的点；输出y∈Y表示示例的类别。由输入空间到输出空间的函数为</p><script type="math/tex; mode=display">f(x)=sign(w⋅x+b)</script><p>称为感知机。其中，参数w叫做权值向量<strong>weight</strong>，b称为偏置<strong>bias</strong>。<script type="math/tex">w⋅x</script>表示w和x的<strong>点积</strong></p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-05-10.png" alt=""> </p><p>sign为符号函数，即</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-04-57.png" alt=""> </p><p>在二分类问题中，<script type="math/tex">f(x)</script>的值（+1或-1）用于分类xx为正样本（+1）还是负样本（-1）。感知机是一种线性分类模型，属于判别模型。我们需要做的就是找到一个最佳的满足<script type="math/tex">w⋅x+b=0</script>的w和b值，即分离超平面（<em>separating hyperplane</em>）。如下图，一个线性可分的感知机模型</p><p><img src="http://img.blog.csdn.net/20151005162258500" alt="这里写图片描述"> </p><p>中间的直线即<script type="math/tex">w⋅x+b=0</script>这条直线。</p><p>线性分类器的几何表示有：直线、平面、超平面。</p><h2 id="学习策略"><a href="#学习策略" class="headerlink" title="学习策略"></a><strong>学习策略</strong></h2><p><strong>核心：极小化损失函数。</strong></p><p>如果训练集是可分的，感知机的学习目的是求得一个能将训练集正实例点和负实例点完全分开的分离超平面。为了找到这样一个平面（或超平面），即确定感知机模型参数w和b，我们采用的是损失函数，同时并将损失函数极小化。</p><p>对于损失函数的选择，我们采用的是<strong>误分类点到超平面的距离</strong>（可以自己推算一下，这里采用的是几何间距，就是点到直线的距离）：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-06-55.png" alt=""> </p><p>其中<script type="math/tex">||w||</script>是<script type="math/tex">L2</script>范数。</p><p>对于误分类点<script type="math/tex">(x_i,y_i)</script>来说：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-07-38.png" alt=""> </p><p>误分类点到超平面的距离为：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-07-48.png" alt=""> </p><p>那么，所有点到超平面的总距离为：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-08-14.png" alt=""> </p><p>不考虑<script type="math/tex">1/||w||</script>,就得到感知机的损失函数了。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-08-21.png" alt=""> </p><p>其中M为误分类的集合。这个损失函数就是感知机学习的<strong>经验风险函数</strong>。</p><p>可以看出，损失函数<script type="math/tex">L(w,b)</script>是非负的。<strong>如果没有误分类点，则损失函数的值为0，而且误分类点越少，误分类点距离超平面就越近，损失函数值就越小</strong>。同时，损失函数<script type="math/tex">L(w,b)</script>是连续可导函数。</p><h2 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a><strong>学习算法</strong></h2><p>感知机学习转变成求解损失函数<script type="math/tex">L(w,b)</script>的最优化问题。最优化的方法是随机梯度下降法（stochastic gradient descent），这里采用的就是该方法。关于梯度下降的详细内容，参考<a href="https://en.wikipedia.org/wiki/Gradient_descent" target="_blank" rel="external">wikipedia Gradient descent</a>。下面给出一个简单的梯度下降的可视化图：</p><p><img src="http://img.blog.csdn.net/20151005203334645" alt="这里写图片描述"> </p><p>上图就是<strong>随机梯度下降</strong>法一步一步达到最优值的过程，说明一下，梯度下降其实是局部最优。感知机学习算法本身是误分类驱动的，因此我们采用随机梯度下降法。首先，任选一个超平面<script type="math/tex">w_0</script>和<script type="math/tex">b_0</script>，然后使用梯度下降法不断地<strong>极小化目标函数</strong></p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-09-32.png" alt=""> </p><p>极小化过程不是一次使M中所有误分类点的梯度下降，而是一次随机的选取一个误分类点使其梯度下降。<script type="math/tex">L(w,b)</script>的梯度通过偏导计算：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-10-07.png" alt=""> </p><p>然后，随机选取一个误分类点，根据上面的规则，计算新的<script type="math/tex">w,b</script>，然后进行更新：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-10-42.png" alt=""> </p><p>其中<script type="math/tex">η</script>是步长，大于0小于1，在统计学习中称之为学习率（<em>learning rate</em>）。这样，通过迭代可以期待损失函数<script type="math/tex">L(w,b)</script>不断减小，直至为0.</p><p>算法描述如下：</p><p><strong>算法：感知机学习算法原始形式</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：T=&#123;(x1,y1),(x2,y2)...(xN,yN)&#125;（其中xi∈X=Rn，yi∈Y=&#123;-1, +1&#125;，i=1,2...N，学习速率为η）</div><div class="line">输出：w, b;感知机模型f(x)=sign(w·x+b)</div><div class="line">(1) 初始化w0,b0，权值可以初始化为0或一个很小的随机数</div><div class="line">(2) 在训练数据集中选取（x_i, y_i）</div><div class="line">(3) 如果yi(w xi+b)≤0</div><div class="line">           w = w + ηy_ix_i</div><div class="line">           b = b + ηy_i</div><div class="line">(4) 转至（2）,直至训练集中没有误分类点12345678</div></pre></td></tr></table></figure><p>解释：当一个实例点被误分类时，调整w,b，使分离超平面向该误分类点的一侧移动，以减少该误分类点与超平面的距离，直至超越该点被正确分类。</p><p>伪代码描述：</p><p><img src="http://img.blog.csdn.net/20151005181037259" alt="这里写图片描述"></p><p>对于每个w⋅xw⋅x其实是这样子的（假设x表示的是七维）：</p><p><img src="http://img.blog.csdn.net/20151005154220192" alt="这里写图片描述"> </p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-12-13.png" alt=""> </p><p>对于输入的每个特征都附加一个权值，然后将相加得到一个和函数f，最后该函数的输出即为输出的y值。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/dream_angel_z/article/details/48915561" target="_blank" rel="external">机器学习-感知机perceptron</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;感知机（perceptron）是二分类的线性分类模型，属于监督学习算法。输入为实例的特征向量&lt;/strong&gt;，输出为实例的类别（取+1和-1）。感知机对应于输入空间中将实例划分为两类的&lt;strong&gt;分离超平面&lt;/strong&gt;。感知机旨在求出该超平面，为
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【机器学习】gbdt/xgboost/lightGBM比较</title>
    <link href="http://yoursite.com/2018/03/12/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91gbdt-xgboost-lightGBM%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2018/03/12/【机器学习】gbdt-xgboost-lightGBM比较/</id>
    <published>2018-03-12T07:34:50.000Z</published>
    <updated>2018-03-16T09:35:02.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>RF、GBDT和XGBoost都属于集成学习（Ensemble Learning），集成学习的目的是通过结合多个基学习器的预测结果来改善单个学习器的泛化能力和鲁棒性。<br>　　根据个体学习器的生成方式，目前的集成学习方法大致分为两大类：即个体学习器之间存在强依赖关系、必须串行生成的序列化方法，以及个体学习器间不存在强依赖关系、可同时生成的并行化方法；前者的代表就是Boosting，后者的代表是Bagging和“随机森林”（Random Forest）。</p><h1 id="2-随机森林RF"><a href="#2-随机森林RF" class="headerlink" title="2. 随机森林RF"></a>2. 随机森林RF</h1><p>提到随机森林，就不得不提Bagging，Bagging可以简单的理解为：放回抽样，多数表决（分类）或简单平均（回归）,同时Bagging的基学习器之间属于并列生成，不存在强依赖关系。<br>　　Random Forest（随机森林）是Bagging的扩展变体，它在以决策树 为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机特征选择，因此可以概括RF包括四个部分：</p><ol><li>随机选择样本（放回抽样）</li><li><strong>随机选择特征</strong></li><li>构建决策树</li><li>随机森林投票（平均）。</li></ol><p>随机选择样本和Bagging相同，随机选择特征是指在树的构建中，会从样本集的特征集合中<strong>随机选择部分特征</strong>，然后再从这个子集中选择最优的属性用于划分，这种随机性导致随机森林的偏差会有稍微的增加（相比于单棵不随机树），但是由于随机森林的‘平均’特性，会使得它的方差减小，而且方差的减小补偿了偏差的增大，因此总体而言是更好的模型。 </p><p>​    在构建决策树的时候，<strong>RF的每棵决策树都最大可能的进行生长而不进行剪枝</strong>；在对预测输出进行结合时，RF通常对分类问题使用简单投票法，回归任务使用简单平均法。<br>　　RF的重要特性是<strong>不用对其进行交叉验证</strong>或者使用一个独立的测试集获得无偏估计，它可以在内部进行评估，也就是说在生成的过程中可以对误差进行无偏估计，由于每个基学习器只使用了训练集中约<strong>63.2%</strong>的样本，剩下约<strong>36.8%</strong>的样本可用做验证集来对其泛化性能进行“包外估计”。<br>　　RF和Bagging对比：RF的起始性能较差，特别当只有一个基学习器时，随着学习器数目增多，随机森林通常会收敛到更低的泛化误差。随机森林的训练效率也会高于Bagging，因为在单个决策树的构建中，Bagging使用的是‘确定性’决策树，在选择特征划分结点时，要对所有的特征进行考虑，而随机森林使用的是‘随机性’特征数，只需考虑特征的子集。</p><p> <strong>优缺点：</strong></p><p>　　随机森林的优点较多，简单总结：</p><ol><li>在数据集上表现良好，训练速度快、预测准确度较高；</li><li>能够处理很高维的数据，并且不用特征选择，而且在训练完后，给出特征的重要性；</li><li>容易做成<strong>并行化</strong>方法。 </li></ol><p>　　RF的缺点：在噪声较大的分类或者回归问题上回过拟合。</p><h1 id="3-GBDT"><a href="#3-GBDT" class="headerlink" title="3. GBDT"></a>3. GBDT</h1><p>​    提GBDT之前，谈一下Boosting，Boosting是一种与Bagging很类似的技术。不论是Boosting还是Bagging，所使用的多个分类器类型都是一致的。但是在前者当中，不同的分类器是通过串行训练而获得的，每个新分类器都根据已训练的分类器的性能来进行训练。Boosting是通过关注被已有分类器错分的那些数据来获得新的分类器。<br>　　由于Boosting分类的结果是基于所有分类器的加权求和结果的，因此Boosting与Bagging不太一样，Bagging中的分类器权值是一样的，而Boosting中的分类器权重并不相等，每个权重代表对应的分类器在上一轮迭代中的成功度。</p><h2 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h2><p>​    原始的Boost算法是在算法开始的时候，为<strong>每一个样本赋上一个权重值</strong>，初始的时候，大家都是一样重要的。在每一步训练中得到的模型，会使得数据点的估计有对有错，我们就在每一步结束后，<strong>增加分错的点的权重</strong>，减少分对的点的权重，这样使得某些点如果老是被分错，那么就会被“严重关注”，也就被赋上一个很高的权重。然后等进行了N次迭代（由用户指定），将会得到N个简单的分类器（basic learner），然后我们将它们组合起来（比如说可以对它们进行加权、或者让它们进行投票等），得到一个最终的模型。</p><p>​    GBDT与传统的Boosting区别较大，它的每一次计算都是为了减少上一次的残差，而为了消除残差，我们可以在残差减小的梯度方向上建立模型,所以说，在GradientBoost中，每个新的模型的建立是为了使得之前的模型的残差往梯度下降的方法，与传统的Boosting中关注正确错误的样本加权有着很大的区别。<br>　　在GradientBoosting算法中，关键就是利用损失函数的负梯度方向在当前模型的值作为残差的近似值，进而<strong>拟合一棵CART回归树</strong>。 </p><p>​    GBDT的会累加所有树的结果，而这种累加是无法通过分类完成的，因此GBDT的树都是CART回归树，而<strong>不是分类树</strong>（尽管GBDT调整后也可以用于分类但不代表GBDT的树为分类树）。</p><p><strong>一些特性</strong></p><ol><li>每次迭代获得的决策树模型都要<strong>乘以一个缩减系数</strong>，从而降低每棵树的作用，提升可学习空间。</li><li>每次迭代拟合的是<strong>一阶梯度</strong>。</li></ol><h2 id="3-2-优缺点"><a href="#3-2-优缺点" class="headerlink" title="3.2 优缺点"></a>3.2 优缺点</h2><p>GBDT的性能在RF的基础上又有一步提升，因此其优点也很明显，</p><ol><li>它能灵活的处理各种类型的数据；</li><li>在相对较少的调参时间下，预测的准确度较高。 </li></ol><p>缺点：当然由于它是Boosting，因此基学习器之前存在串行关系，<strong>难以并行</strong>训练数据。</p><h1 id="4-XGBoost"><a href="#4-XGBoost" class="headerlink" title="4. XGBoost"></a>4. XGBoost</h1><h2 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h2><p>​    XGBoost 是GBDT的一个变种，最大的区别是xgboost通过对目标函数做<strong>二阶泰勒展开</strong>，从而求出下一步要拟合的树的叶子节点权重（需要先确定树的结构），从而根据损失函数求出每一次分裂节点的损失减小的大小，从而根据分裂损失选择合适的属性进行分裂。</p><p>​    这个利用二阶展开的到的损失函数公式与分裂节点的过程是息息相关的。先遍历所有节点的所有属性进行分裂，假设选择了这个a属性的一个取值作为分裂节点，根据泰勒展开求得的公式可计算该树结构各个叶子节点的权重，从而计算损失减小的程度，从而综合各个属性选择使得损失减小最大的那个特征作为当前节点的分裂属性。依次类推，直到满足终止条件。</p><h2 id="4-2-XGBoost与GBDT区别"><a href="#4-2-XGBoost与GBDT区别" class="headerlink" title="4.2 XGBoost与GBDT区别"></a>4.2 XGBoost与GBDT区别</h2><ol><li>传统GBDT以CART作为基分类器，xgboost<strong>还支持线性分类器</strong>，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。</li><li>传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了<strong>二阶泰勒展开</strong>，同时用到了一阶和二阶导数。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。</li><li><strong>xgboost在代价函数里加入了正则项</strong>，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和。从Bias-variance tradeoff角度来讲，正则项降低了模型的variance，使学习出来的模型更加简单，防止过拟合，这也是xgboost优于传统GBDT的一个特性。</li><li>Shrinkage（缩减），相当于<strong>学习速率</strong>（xgboost中的eta）。xgboost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间。<strong>实际应用中，一般把eta设置得小一点</strong>，然后迭代次数设置得大一点。（传统GBDT的实现也有学习速率）</li><li><strong>列抽样</strong>（column subsampling）。<strong>xgboost借鉴了随机森林的做法，支持列抽样</strong>，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。</li><li>对缺失值的处理。<strong>对于特征的值有缺失的样本，xgboost可以自动学习出它的分裂方向</strong>。对于在训练过程中遇到的缺失值，xgboost将其分别归到左子树和右子树分别计算损失，选取较优的哪一个。如果在训练中没有缺失值，在预测时遇到缺失值，就默认分到右子树。</li><li><strong>xgboost工具支持并行</strong>。注意xgboost的并行<strong>不是tree粒度的并行</strong>，xgboost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。<strong>xgboost的并行是在特征粒度上的</strong>。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，<strong>那么各个特征的增益计算就可以开多线程进行</strong>。</li><li><strong>可并行的近似直方图算法</strong>。树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率就会变得很低，所以xgboost还提出了一种可并行的近似直方图算法，用于高效地生成候选的分割点。</li></ol><h2 id="4-3-xgboost正则化（预剪枝）"><a href="#4-3-xgboost正则化（预剪枝）" class="headerlink" title="4.3 xgboost正则化（预剪枝）"></a>4.3 xgboost正则化（预剪枝）</h2><p>xgboost的目标函数如下：<img src="http://img.blog.csdn.net/20170331173239339" alt="img"></p><p>xgboost中树节点分裂时所采用的公式：<img src="http://img.blog.csdn.net/20170331173223980" alt="img"></p><p>这个公式形式上跟ID3算法、CART算法是一致的，都是用分裂后的某种值减去分裂前的某种值，从而得到增益。为了限制树的生长，我们可以加入阈值，<strong>当增益大于阈值时才让节点分裂，上式中的gamma即阈值</strong>，它是正则项里叶子节点数T的系数，所以<strong>xgboost在优化目标函数的同时相当于做了预剪枝</strong>。另外，上式中还有一个系数lambda，是正则项里leaf score的L2模平方的系数，对leaf score做了平滑，也起到了防止过拟合的作用，这个是传统GBDT里不具备的特性。</p><h1 id="5-lightGBM与XGBoost区别"><a href="#5-lightGBM与XGBoost区别" class="headerlink" title="5. lightGBM与XGBoost区别"></a>5. lightGBM与XGBoost区别</h1><h2 id="5-1-决策树算法"><a href="#5-1-决策树算法" class="headerlink" title="5.1 决策树算法"></a>5.1 决策树算法</h2><p>由于在决策树在每一次选择节点特征的过程中，要遍历所有的属性的所有取值并选择一个较好的。</p><p>XGBoost使用的是pre-sorted算法（对所有特征都按照特征的数值进行预排序，在遍历分割点的时候用O(data)的代价找到一个特征上的最好分割点），能够更精确的找到数据分隔点；（xgboost的分布式实现也是基于直方图的，利于并行）</p><p><a href="https://www.msra.cn/zh-cn/news/features/lightgbm-20170105" target="_blank" rel="external">LightGBM</a>使用的是histogram算法（X发给类似一种分桶算法），占用的内存更低，数据分隔的复杂度更低。</p><p>直方图优化参考：<a href="https://www.msra.cn/zh-cn/news/features/lightgbm-20170105" target="_blank" rel="external">开源 | LightGBM：三天内收获GitHub 1000  星</a></p><p>而这两个算法的比较见参考文献<a href="https://www.zhihu.com/question/51644470/answer/130946285" target="_blank" rel="external">如何看待微软新开源的LightGBM?</a></p><h2 id="5-2-决策树生长策略"><a href="#5-2-决策树生长策略" class="headerlink" title="5.2 决策树生长策略"></a>5.2 决策树生长策略</h2><p>XGBoost采用的是level-wise生长策略，如Figure 1所示，能够同时分裂同一层的叶子，从而进行多线程优化，也好控制模型复杂度，不容易过拟合；但实际上Level-wise是一种低效的算法，它不加区分的对待同一层的叶子，带来了很多没必要的开销，因为实际上很多叶子的分裂增益较低，没必要进行搜索和分裂。</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-06-15-39-52.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-06-15-39-52.png" alt="img"></a></p><p>LightGBM采用leaf-wise生长策略，如Figure 2所示，每次从当前所有叶子中找到分裂增益最大（一般也是数据量最大）的一个叶子，然后分裂，如此循环；但会生长出比较深的决策树，产生过拟合。因此 LightGBM 在leaf-wise之上增加了一个最大深度的限制，在保证高效率的同时防止过拟合。</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-06-15-41-19.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-06-15-41-19.png" alt="img"></a></p><h2 id="5-3-其他"><a href="#5-3-其他" class="headerlink" title="5.3 其他"></a>5.3 其他</h2><ol><li><p>直方图做差加速 </p><p>一个<strong>子节点的直方图可以通过父节点的直方图减去兄弟节点的直方图</strong>得到，从而加速计算。 </p><ol><li><p>lightgbm支持直接输入categorical 的feature </p><p>在对离散特征分裂时，每个取值都当作一个桶，分裂时的增益算的是”是否属于某个category“的gain。类似于one-hot编码。 </p></li><li><p>多线程优化</p></li></ol></li></ol><h1 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/24498293" target="_blank" rel="external">XGBoost, LightGBM性能大对比</a></li><li><a href="https://www.msra.cn/zh-cn/news/features/lightgbm-20170105" target="_blank" rel="external">LightGBM微软官方中文介绍</a></li><li><a href="http://blog.csdn.net/xwd18280820053/article/details/68927422" target="_blank" rel="external">关于树的几个ensemble模型的比较（GBDT、xgBoost、lightGBM、RF）</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;RF、GBDT和XGBoost都属于集成学习（Ensemble Learning），集成学习的目的是通过结合多个基学习器
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【腾讯转化率预估】SVD分解提取用户-APP特征</title>
    <link href="http://yoursite.com/2018/03/12/%E3%80%90%E8%85%BE%E8%AE%AF%E8%BD%AC%E5%8C%96%E7%8E%87%E9%A2%84%E4%BC%B0%E3%80%91SVD%E5%88%86%E8%A7%A3%E6%8F%90%E5%8F%96%E7%94%A8%E6%88%B7-APP%E7%89%B9%E5%BE%81/"/>
    <id>http://yoursite.com/2018/03/12/【腾讯转化率预估】SVD分解提取用户-APP特征/</id>
    <published>2018-03-12T04:10:12.000Z</published>
    <updated>2018-03-12T12:35:15.861Z</updated>
    
    <content type="html"><![CDATA[<p>用SVD可以很容易得到任意矩阵的满秩分解，用满秩分解可以对数据做压缩。可以用SVD来证明对任意M*N的矩阵均存在如下分解：</p><p><img src="http://img.blog.csdn.net/20150123160014873?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhvbmdrZWppbmd3YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>这个可以应用在数据降维压缩上！在数据相关性特别大的情况下存储X和Y矩阵比存储A矩阵占用空间更小！其中k为矩阵A的秩的个数。</p><p>在推荐系统中，我们通常可以根据历史数据，得到用户和商品打分矩阵：</p><p><a href="https://ooo.0o0.ooo/2017/03/13/58c6aa26b83c6.png" target="_blank" rel="external"><img src="https://ooo.0o0.ooo/2017/03/13/58c6aa26b83c6.png" alt="img"></a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用SVD可以很容易得到任意矩阵的满秩分解，用满秩分解可以对数据做压缩。可以用SVD来证明对任意M*N的矩阵均存在如下分解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150123160014873?watermark/2/tex
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【面经】海量数据处理相关</title>
    <link href="http://yoursite.com/2018/03/12/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2018/03/12/【面经】海量数据处理相关/</id>
    <published>2018-03-11T16:16:50.000Z</published>
    <updated>2018-03-16T09:35:02.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一部分-分而治之-Hash映射-Hash-map统计-堆-快速-归并排序"><a href="#第一部分-分而治之-Hash映射-Hash-map统计-堆-快速-归并排序" class="headerlink" title="第一部分 分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序"></a>第一部分 分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序</h2><h3 id="1-海量数据选取TOPK"><a href="#1-海量数据选取TOPK" class="headerlink" title="1. 海量数据选取TOPK"></a>1. 海量数据选取TOPK</h3><p>baseline：</p><p>用堆，如果取最大的K个，就用最小堆，遍历数组，遇到比堆顶元素大的元素就入堆，同时堆中元素超过k个需要poll操作，保证堆中只有K个元素，最终的topk元素在堆中。</p><p>时间复杂度分析:</p><script type="math/tex; mode=display">O(n*logk)$$ ，元素入堆复杂度$$O(logk)</script><p><strong><script type="math/tex">O(n)</script>算法：</strong></p><p>先用quick select方法找到第K大的元素，复杂度<script type="math/tex">O(n)</script></p><p>然后再遍历一遍，将大于K的元素取出，复杂度<script type="math/tex">O(n)</script></p><p>总复杂度<script type="math/tex">O(n)</script></p><p>！！！！！卧槽！神奇！！！！</p><h3 id="2-海量数据选取第K大"><a href="#2-海量数据选取第K大" class="headerlink" title="2. 海量数据选取第K大"></a>2. 海量数据选取第K大</h3><p>Quick Select，详见<a href="/2018/02/02/【九章算法强化班】两指针/" title="【九章算法强化班】两指针">【九章算法强化班】两指针</a> </p><p>时间复杂度<script type="math/tex">O(n)</script></p><h3 id="3-大数排序问题"><a href="#3-大数排序问题" class="headerlink" title="3. 大数排序问题"></a>3. 大数排序问题</h3><p>海量数据排序怎么做？</p><p>baseline：快排，问题：数据量很大，内存根本存不下，不可行</p><p><strong>桶排序：</strong></p><p>将数据分桶，每个桶存入一个文件，然后文件内部有序，取出合并的时候可以用K路归并，优化：k路可以建个堆</p><h3 id="4-海量日志数据，提取出某日访问百度次数最多的那个IP"><a href="#4-海量日志数据，提取出某日访问百度次数最多的那个IP" class="headerlink" title="4. 海量日志数据，提取出某日访问百度次数最多的那个IP"></a>4. 海量日志数据，提取出某日访问百度次数最多的那个IP</h3><ol><li>首先将这一天的访问百度的日志IP取出来，写到一个大文件中，IP是32位的，因此最多有<script type="math/tex">2^{32}</script>个IP。</li><li>将整个文件的所有IP映射为10000个小文件，再找出每个小文件中出现次数最多的IP，此时可以用HashMap统计一下</li><li>在10000个小文件的top1中寻找整体top1</li></ol><h3 id="5-300万个查询字符串中统计最热门的10个查询"><a href="#5-300万个查询字符串中统计最热门的10个查询" class="headerlink" title="5. 300万个查询字符串中统计最热门的10个查询"></a>5. 300万个查询字符串中统计最热门的10个查询</h3><p>原题：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p><p>​    解答：由上面第1题，我们知道，数据大则划为小的，如如一亿个Ip求Top 10，可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hashmap计数统计并按数量排序，最后归并或者最小堆依次处理每个小文件的top10以得到最后的结。</p><p>​    但如果数据规模比较小，能一次性装入内存呢?比如这道题，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把他们都放进内存中去（300万个字符串假设没有重复，都是最大长度，那么最多占用内存3M*1K/4=0.75G。所以可以将所有字符串都存放在内存中进行处理），而现在只是需要一个合适的数据结构，在这里，HashTable绝对是我们优先的选择。<script type="math/tex">O(1)</script></p><p>解法：</p><ol><li>Hash_map统计字符串出现次数</li><li>借助堆找出出现次数最多的topK个query <script type="math/tex">O(logk)</script></li></ol><h3 id="6-有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"><a href="#6-有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。" class="headerlink" title="6. 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"></a>6. 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</h3><ol><li>分而治之/hash映射：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。</li><li>hash_map统计：对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。</li><li>堆/归并排序：对于每个小文件，利用堆取出top100的单词，存入新文件，这样又得到了5000个新文件，然后对5000个文件做归并排序，取出全局top100，依然可以用堆优化</li></ol><h3 id="7-海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"><a href="#7-海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。" class="headerlink" title="7. 海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"></a>7. 海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</h3><p>分两种情况：</p><ol><li>如果每个数据元素只出现在一台机器上：可以直接分机器统计，得到top10，然后再100台机器的top10中求全局top10，k路归并，用堆优化</li><li>每个元素不一定只出现在一台机器上，可能同时出现在多台机器上：<ol><li>遍历一遍所有数据，重新hash取摸，如此使得同一个元素只出现在单独的一台电脑中，然后采用上面所说的方法，统计每台电脑中各个元素的出现次数找出TOP10，继而组合100台电脑上的TOP10，找出最终的TOP10。</li><li>暴力求解：直接统计统计每台电脑中各个元素的出现次数，然后把同一个元素在不同机器中的出现次数相加，最终从所有数据中找出TOP10。</li></ol></li></ol><h3 id="8-有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"><a href="#8-有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。" class="headerlink" title="8. 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"></a>8. 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</h3><h3 id="有海量个文件，知道每个文件的大小，给定100个桶，把这些文件塞到桶里，尽量使得每个桶里装的东西大小差不多"><a href="#有海量个文件，知道每个文件的大小，给定100个桶，把这些文件塞到桶里，尽量使得每个桶里装的东西大小差不多" class="headerlink" title="有海量个文件，知道每个文件的大小，给定100个桶，把这些文件塞到桶里，尽量使得每个桶里装的东西大小差不多"></a>有海量个文件，知道每个文件的大小，给定100个桶，把这些文件塞到桶里，尽量使得每个桶里装的东西大小差不多</h3><ol><li>先对文件按照文件大小<strong>从大到小排序</strong> </li><li>将文件顺序放入桶中，每次都选取当前容量最小的桶，这里就需要用一个堆来维护当前这100个桶里面的文件大小了，每次需要选出当前容量最小的桶，加了数据之后，更新这个桶的容量，再放回堆中。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一部分-分而治之-Hash映射-Hash-map统计-堆-快速-归并排序&quot;&gt;&lt;a href=&quot;#第一部分-分而治之-Hash映射-Hash-map统计-堆-快速-归并排序&quot; class=&quot;headerlink&quot; title=&quot;第一部分 分而治之/Hash映射 +
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【Java】HashMap原理探究</title>
    <link href="http://yoursite.com/2018/03/11/%E3%80%90Java%E3%80%91HashMap%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/03/11/【Java】HashMap原理探究/</id>
    <published>2018-03-11T04:34:46.000Z</published>
    <updated>2018-03-12T12:35:15.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-HashMap概述"><a href="#1-HashMap概述" class="headerlink" title="1. HashMap概述"></a>1. HashMap概述</h1><p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是不保证该顺序恒久不变。</p><p>此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get和put）提供稳定的性能。</p><p>迭代colletction视图所需要的时间与HashMap实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以如果迭代性能很重要，则不能将初始容量设置得太高，或者将加载因子设置的太低。</p><p>需要注意的是，HashMap是不同步的。如果多个线程同时访问一个HashMap，若其中某个线程修改了HashMap的结构（即删除或者添加映射关系），那么必须要保持外部同步。</p><h1 id="2-HashMap的数据结构"><a href="#2-HashMap的数据结构" class="headerlink" title="2. HashMap的数据结构"></a>2. HashMap的数据结构</h1><p>在Java中，最基本的结构就是数组和指针（引用）。HashMap就是结合了这两种结构进行实现。</p><p><strong>HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体</strong></p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-14-21-36-42.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-14-21-36-42.png" alt="img"></a></p><p>从上图中可以看出，HashMap 底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个 HashMap 的时候，就会初始化一个数组。</p><p>我们通过 JDK 中的 HashMap 源码进行一些学习，首先看一下构造函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</div><div class="line">        if (initialCapacity &lt; 0)</div><div class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</div><div class="line">                                               initialCapacity);</div><div class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</div><div class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</div><div class="line">                                               loadFactor);</div><div class="line"></div><div class="line">        // Find a power of 2 &gt;= initialCapacity</div><div class="line">        int capacity = 1;</div><div class="line">        while (capacity &lt; initialCapacity)</div><div class="line">            capacity &lt;&lt;= 1;</div><div class="line"></div><div class="line">        this.loadFactor = loadFactor;</div><div class="line">        threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</div><div class="line">        table = new Entry[capacity]; // 新建数组</div><div class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</div><div class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">        init();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们看到第18行<code>table = new Entry[capacity];</code> 其实是创建了一个<code>Entry</code> 的数组，其大小为<code>capacity</code> 。那么<code>Entry</code> 又是什么呢？看一下源码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">    final K key; //键</div><div class="line">    V value;     //值</div><div class="line">    Entry&lt;K,V&gt; next; //指向下一个元素的引用 --&gt; 构成了链表</div><div class="line">    final int hash;</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们目前还是只着重核心的部分，Entry 是一个 static class，其中包含了 key 和 value，也就是键值对，另外还包含了一个 next 的 Entry 指针。我们可以总结出：Entry 就是数组中的元素，每个 Entry 其实就是一个 key-value 对，它持有一个指向下一个元素的引用，这就构成了链表。</p><h1 id="3-HashMap核心方法解读"><a href="#3-HashMap核心方法解读" class="headerlink" title="3. HashMap核心方法解读"></a>3. HashMap核心方法解读</h1><h2 id="3-1-put-方法"><a href="#3-1-put-方法" class="headerlink" title="3.1. put()方法"></a>3.1. put()方法</h2><p><strong>流程图</strong></p><p>下面这个流程图很好地说明了总过程，接下来我们会一步步分析这个步骤。</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-14-21-57-57.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-14-21-57-57.png" alt="img"></a></p><p><strong>put()主方法</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">     * Associates the specified value with the specified key in this map.</div><div class="line">     * If the map previously contained a mapping for the key, the old</div><div class="line">     * value is replaced.</div><div class="line">     *</div><div class="line">     * @param key key with which the specified value is to be associated</div><div class="line">     * @param value value to be associated with the specified key</div><div class="line">     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</div><div class="line">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</div><div class="line">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</div><div class="line">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</div><div class="line">     */</div><div class="line">public V put(K key, V value) &#123;</div><div class="line">        //其允许存放null的key和null的value，当其key为null时，调用putForNullKey方法，放入到table[0]的这个位置</div><div class="line">        if (key == null)</div><div class="line">            return putForNullKey(value);</div><div class="line">        </div><div class="line">//1. 通过调用hash方法对key进行哈希，得到哈希之后的数值。</div><div class="line">        int hash = hash(key);</div><div class="line">  </div><div class="line">        //2. 根据上一步骤中求出的hash得到在数组中是索引i</div><div class="line">        int i = indexFor(hash, table.length);</div><div class="line">  </div><div class="line">        //3.1 如果i处的Entry不为null，则寻找是否存在过key</div><div class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">             // 3.1.1若曾经有过key值，则直接覆盖</div><div class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(this);</div><div class="line">                return oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">// 3.2、3.1.2 : 如果i处Entry为空，或者不曾存在过key，则添加key</div><div class="line">        modCount++;</div><div class="line">        addEntry(hash, key, value, i); //根据计算出的 hash 值，将 key-value 对放在数组 table 的 i 索引处</div><div class="line">        return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们看一下方法的标准注释：在注释中首先提到了，当我们 put 的时候，如果 key 存在了，那么新的 value 会代替旧的 value，并且如果 key 存在的情况下，该方法返回的是旧的 value，如果 key 不存在，那么返回 null。</p><p>从上面的源代码中可以看出：当我们往 HashMap 中 put 元素的时候，先根据 key 的 hashCode 重新计算 hash 值，根据 hash 值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p><p>也就是说，put方法主要做了以下几个步骤：</p><ol><li>计算key的hashCode值。其目的是为了尽可能的让键值对可以分不到不同的桶中</li><li>根据hashCode得到在table中的索引i</li><li>将value插入到table中：<ol><li>如果table[i]不为空，则表示两个key的hash值重叠了。那就根据key将值插入table[i]指向的链表中：<ol><li>要么覆盖原来的值（曾经有过这个key）</li><li>要么插入链表末尾（曾经没有过这个key） –&gt; 调用<code>addEntry()</code></li></ol></li><li>如果table[i]为空，就直接插入 –&gt; 调用<code>addEntry()</code></li></ol></li></ol><p><strong>addEntry()方法</strong></p><p>addEntry(hash, key, value, i)方法根据计算出的 hash 值，将 key-value 对放在数组 table 的 i 索引处。addEntry 是 HashMap 提供的一个包访问权限的方法，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">     * Adds a new entry with the specified key, value and hash code to</div><div class="line">     * the specified bucket.  It is the responsibility of this</div><div class="line">     * method to resize the table if appropriate.</div><div class="line">     *</div><div class="line">     * Subclass overrides this to alter the behavior of put method.</div><div class="line">     */</div><div class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</div><div class="line">        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</div><div class="line">            resize(2 * table.length);</div><div class="line">            hash = (null != key) ? hash(key) : 0;</div><div class="line">            bucketIndex = indexFor(hash, table.length);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        createEntry(hash, key, value, bucketIndex);</div><div class="line">&#125;</div><div class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</div><div class="line">        // 获取指定 bucketIndex 索引处的 Entry</div><div class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">        // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entr</div><div class="line">        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</div><div class="line">        size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当系统决定存储 HashMap 中的 key-value 对时，完全没有考虑 Entry 中的 value，仅仅只是根据 key 来计算并决定每个 Entry 的存储位置。我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。</p><p><strong>hash()方法</strong></p><p>hash(int h)方法根据 key 的 hashCode 重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的 hash 冲突。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">final int hash(Object k) &#123;</div><div class="line">        int h = 0;</div><div class="line">        if (useAltHashing) &#123;</div><div class="line">            if (k instanceof String) &#123;</div><div class="line">                return sun.misc.Hashing.stringHash32((String) k);</div><div class="line">            &#125;</div><div class="line">            h = hashSeed;</div><div class="line">        &#125;</div><div class="line">        //得到k的hashcode值</div><div class="line">        h ^= k.hashCode();</div><div class="line">        //进行计算</div><div class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</div><div class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以看到在 HashMap 中要找到某个元素，需要根据 key 的 hash 值来求得对应数组中的位置。如何计算这个位置就是 hash 算法。前面说过 HashMap 的数据结构是数组和链表的结合，所以我们当然希望这个 HashMap 里面的 元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用 hash 算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。</p><p>对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(int h) 方法所计算得到的 hash 码值总是相同的。我们首先想到的就是把 hash 值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在 HashMap 中是这样做的：调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">     * Returns index for hash code h.</div><div class="line">     */</div><div class="line">static int indexFor(int h, int length) &#123;  </div><div class="line">    return h &amp; (length-1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而 HashMap 底层数组的长度总是 2 的 n 次方，这是 HashMap 在速度上的优化。在 HashMap 构造器中有如下代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// Find a power of 2 &gt;= initialCapacity</div><div class="line">int capacity = 1;</div><div class="line">    while (capacity &lt; initialCapacity)  </div><div class="line">        capacity &lt;&lt;= 1;</div></pre></td></tr></table></figure><p><strong>这段代码保证初始化时 HashMap 的容量总是 2 的 n 次方</strong>，即底层数组的长度总是为 2 的 n 次方。</p><p>当 length 总是 2 的 n 次方时，h&amp; (length-1)运算等价于对 length 取模，也就是 h%length，但是 &amp; 比 % 具有更高的效率。这看上去很简单，其实比较有玄机的，我们举个例子来说明：</p><p>假设数组长度分别为 15 和 16，优化后的 hash 码分别为 8 和 9，那么 &amp; 运算后的结果如下：</p><div class="table-container"><table><thead><tr><th>h &amp; (table.length-1)</th><th>hash</th><th></th><th>table.length-1</th><th></th></tr></thead><tbody><tr><td>8 &amp; (15-1)：</td><td>0100</td><td>&amp;</td><td>1110</td><td>= 0100</td></tr><tr><td>9 &amp; (15-1)：</td><td>0101</td><td>&amp;</td><td>1110</td><td>= 0100</td></tr><tr><td>8 &amp; (16-1)：</td><td>0100</td><td>&amp;</td><td>1111</td><td>= 0100</td></tr><tr><td>9 &amp; (16-1)：</td><td>0101</td><td>&amp;</td><td>1111</td><td>= 0101</td></tr></tbody></table></div><p>从上面的例子中可以看出：当它们和 15-1（1110）“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8 和 9 会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链 表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为 15 的时候，hash 值会与 15-1（1110）进行“与”，那么最后一位永远是 0，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！而当数组长度为16时，即为2的n次方时，2n-1 得到的二进制数的每个位上的值都为 1，这使得在低位上&amp;时，得到的和原 hash 的低位相同，加之 hash(int h)方法对 key 的 hashCode 的进一步优化，加入了高位计算，就使得只有相同的 hash 值的两个值才会被放到数组中的同一个位置上形成链表。</p><p>所以说，<strong>当数组长度为 2 的 n 次幂的时候，不同的 key 算得得 index 相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</strong></p><p><strong>总结</strong></p><p>根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p><h2 id="3-2-get-方法"><a href="#3-2-get-方法" class="headerlink" title="3.2. get()方法"></a>3.2. get()方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">     * Returns the value to which the specified key is mapped,</div><div class="line">     * or &#123;@code null&#125; if this map contains no mapping for the key.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;More formally, if this map contains a mapping from a key</div><div class="line">     * &#123;@code k&#125; to a value &#123;@code v&#125; such that &#123;@code (key==null ? k==null :</div><div class="line">     * key.equals(k))&#125;, then this method returns &#123;@code v&#125;; otherwise</div><div class="line">     * it returns &#123;@code null&#125;.  (There can be at most one such mapping.)</div><div class="line">     *</div><div class="line">     * &lt;p&gt;A return value of &#123;@code null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</div><div class="line">     * indicate that the map contains no mapping for the key; it&apos;s also</div><div class="line">     * possible that the map explicitly maps the key to &#123;@code null&#125;.</div><div class="line">     * The &#123;@link #containsKey containsKey&#125; operation may be used to</div><div class="line">     * distinguish these two cases.</div><div class="line">     *</div><div class="line">     * @see #put(Object, Object)</div><div class="line">     */</div><div class="line">    public V get(Object key) &#123;</div><div class="line">        if (key == null)</div><div class="line">            return getForNullKey();</div><div class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line"></div><div class="line">        return null == entry ? null : entry.getValue();</div><div class="line">    &#125;</div><div class="line">    final Entry&lt;K,V&gt; getEntry(Object key) &#123;</div><div class="line">        int hash = (key == null) ? 0 : hash(key);</div><div class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">             e != null;</div><div class="line">             e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            if (e.hash == hash &amp;&amp;</div><div class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                return e;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>有了上面存储时的 hash 算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从 HashMap 中 get 元素时，首先计算 key 的 hashCode，找到数组中对应位置的某一元素，然后通过 key 的 equals 方法在对应位置的链表中找到需要的元素。</p><h2 id="3-3-归纳"><a href="#3-3-归纳" class="headerlink" title="3.3. 归纳"></a>3.3. 归纳</h2><p>简单地说，HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。</p><ul><li>HashMap底层采用一个<code>Entry[]</code> 数组来保存所有的key-value对。</li><li>当需要存储一个Entry对象时，会根据hash算法来决定其在数组中的存储位置，再根据equals方法决定其在该数组位置上的链表中的存储位置。</li><li>当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置的链表中取出该Entry。</li></ul><h1 id="4-HashMap相关机制"><a href="#4-HashMap相关机制" class="headerlink" title="4. HashMap相关机制"></a>4. HashMap相关机制</h1><h2 id="4-1-resize机制（rehash）"><a href="#4-1-resize机制（rehash）" class="headerlink" title="4.1. resize机制（rehash）"></a>4.1. resize机制（rehash）</h2><p>当HashMap中的元素越来越多的时候，hash冲突的几率也越来越高，因为数组的长度时固定的。所以为了提高查询的效率，就需要对HashMap的数组进行扩容。那么此时最消耗性能的点就出现了：原数组中的每一个数据必须重新计算其在新数组中的位置，并放进去，这就是resize操作。</p><p>那么HashMap是什么时候进行扩容的呢？当HashMap中的元素超过<code>threshold = (int)(capacity * loadFactor)</code> 时，就会进行数组扩容。<strong>loadFactor的默认值为0.75。</strong>其中threshold是HashMap的一个字段。</p><p><strong>每次扩容时，都新建一个2倍的数组，</strong>然后重新计算每一个元素在数组中的位置。这是一个非常耗时的操作。所以我们<strong>如果预知HashMap中的元素个数，那么预设元素的个数就能有效地提高HashMap的性能</strong>。</p><p>而负载因子loadFactor 衡量的是一个散列表的空间使用程度。负载因子越大表示散列的装填程度越高。对于使用链表法的散列表来说，查找元素的平均时间是<script type="math/tex">O(1+a)</script> 。a是链表平均长度。因此如果负载因子越大，对空间的利用更充分，但查找效率就会更低。如果负载因子太小，散列表的数据又过于稀疏，对空间造成严重浪费。</p><h2 id="4-2-HashMap的构造器"><a href="#4-2-HashMap的构造器" class="headerlink" title="4.2. HashMap的构造器"></a>4.2. HashMap的构造器</h2><p>HashMap包含以下几个构造器：</p><ul><li><code>HashMap()</code> : 构建一个初始容量为16，负载因子为0.75的HashMap。</li><li><code>HashMap(int initialCapcity)</code> : 构建一个初始容量为initialCapcity, 负载因子为0.75的HashMap。</li><li><code>HashMap(int initialCapacity, float loadFactor)</code>: 以指定初始容量、指定的负载因子创建一个HashMap。<ul><li>initialCapcity * loadFactor过大时，会造成空间的严重浪费</li><li>initialCapcity * loadFactor过小时，会造成查找效率很低</li></ul></li></ul><h2 id="4-3-Fail-Fast机制"><a href="#4-3-Fail-Fast机制" class="headerlink" title="4.3. Fail-Fast机制"></a>4.3. Fail-Fast机制</h2><p>​    <strong>我们知道 java.util.HashMap 不是线程安全的</strong>，因此如果在使用迭代器的过程中有其他线程修改了 map，那么将抛出 ConcurrentModificationException，这就是所谓 fail-fast 策略。</p><p>ail-fast 机制是 java 集合(Collection)中的一种错误机制。 当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。</p><p>例如：当某一个线程 A 通过 iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程 A 访问集合时，就会抛出 ConcurrentModificationException 异常，产生 fail-fast 事件。</p><p>这一策略在源码中的实现是通过 modCount 域，modCount 顾名思义就是修改次数，对 HashMap 内容（当然不仅仅是 HashMap 才会有，其他例如 ArrayList 也会）的修改都将增加这个值（大家可以再回头看一下其源码，在很多操作中都有 modCount++ 这句），那么在迭代器初始化过程中会将这个值赋给迭代器的 expectedModCount。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">HashIterator() &#123;</div><div class="line">    expectedModCount = modCount;</div><div class="line">    if (size &gt; 0) &#123; // advance to first entry</div><div class="line">    Entry[] t = table;</div><div class="line">    while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)  </div><div class="line">        ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在迭代过程中，判断 modCount 跟 expectedModCount 是否相等，如果不相等就表示已经有其他线程修改了 Map：</p><p>注意到 modCount 声明为 volatile，保证线程之间修改的可见性。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">final Entry&lt;K,V&gt; nextEntry() &#123;</div><div class="line">    if (modCount != expectedModCount)</div><div class="line">        throw new ConcurrentModificationException();</div></pre></td></tr></table></figure><p>在 HashMap 的 API 中指出：</p><p>由所有 HashMap 类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。</p><p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p><p><strong>解决方案</strong></p><p>在上文中也提到，f<strong>ail-fast 机制，是一种错误检测机制</strong>。它只能被用来检测错误，因为 JDK 并不保证 fail-fast 机制一定会发生。若在多线程环境下使用 fail-fast 机制的集合，建议使用“java.util.concurrent 包下的类”去取代“java.util 包下的类”。</p><h2 id="4-4-HashMap的两种遍历方式"><a href="#4-4-HashMap的两种遍历方式" class="headerlink" title="4.4. HashMap的两种遍历方式"></a>4.4. HashMap的两种遍历方式</h2><h2 id="4-5-第一种"><a href="#4-5-第一种" class="headerlink" title="4.5. 第一种"></a>4.5. 第一种</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">　　Map map = new HashMap();</div><div class="line">　　Iterator iter = map.entrySet().iterator();</div><div class="line">　　while (iter.hasNext()) &#123;</div><div class="line">Map.Entry entry = (Map.Entry) iter.next();</div><div class="line">Object key = entry.getKey();</div><div class="line">Object val = entry.getValue();</div><div class="line">　　&#125;</div></pre></td></tr></table></figure><p>效率高,以后一定要使用此种方式！</p><h2 id="4-6-第二种"><a href="#4-6-第二种" class="headerlink" title="4.6. 第二种"></a>4.6. 第二种</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">　　Map map = new HashMap();</div><div class="line">　　Iterator iter = map.keySet().iterator();</div><div class="line">　　while (iter.hasNext()) &#123;</div><div class="line">Object key = iter.next();</div><div class="line">Object val = map.get(key);</div><div class="line">　　&#125;</div></pre></td></tr></table></figure><p>效率低,以后尽量少使用！</p><h1 id="5-为什么HashMap线程不安全？"><a href="#5-为什么HashMap线程不安全？" class="headerlink" title="5. 为什么HashMap线程不安全？"></a>5. 为什么HashMap线程不安全？</h1><h2 id="5-1-put的时候导致的多线程数据不一致。"><a href="#5-1-put的时候导致的多线程数据不一致。" class="headerlink" title="5.1 put的时候导致的多线程数据不一致。"></a>5.1 put的时候导致的多线程数据不一致。</h2><p>​    这个问题比较好想象，比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</p><h2 id="5-2-get操作可能因为resize而引起死循环（cpu100-）"><a href="#5-2-get操作可能因为resize而引起死循环（cpu100-）" class="headerlink" title="5.2 get操作可能因为resize而引起死循环（cpu100%）"></a>5.2 get操作可能因为resize而引起死循环（cpu100%）</h2><p>下面的代码是resize的核心内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void transfer(Entry[] newTable, boolean rehash) &#123;  </div><div class="line">        int newCapacity = newTable.length;  </div><div class="line">        for (Entry&lt;K,V&gt; e : table) &#123;  </div><div class="line">  </div><div class="line">            while(null != e) &#123;  </div><div class="line">                Entry&lt;K,V&gt; next = e.next;           </div><div class="line">                if (rehash) &#123;  </div><div class="line">                    e.hash = null == e.key ? 0 : hash(e.key);  </div><div class="line">                &#125;  </div><div class="line">                int i = indexFor(e.hash, newCapacity);   </div><div class="line">                e.next = newTable[i];  </div><div class="line">                newTable[i] = e;  </div><div class="line">                e = next;  </div><div class="line">            &#125; </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>这个方法的功能是将原来的记录重新计算在新桶的位置，然后迁移过去。</p><p><img src="http://upload-images.jianshu.io/upload_images/7853175-ab75cd3738471507.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p><p>​    我们假设有两个线程同时需要执行resize操作，我们原来的桶数量为2，记录数为3，需要resize桶到4，原来的记录分别为：[3,A],[7,B],[5,C]，在原来的map里面，我们发现这三个entry都落到了第二个桶里面。<br>​    假设线程thread1执行到了transfer方法的Entry next = e.next这一句，然后时间片用完了，此时的e = [3,A], next = [7,B]。线程thread2被调度执行并且顺利完成了resize操作，需要注意的是，此时的[7,B]的next为[3,A]。此时线程thread1重新被调度运行，此时的thread1持有的引用是已经被thread2 resize之后的结果。线程thread1首先将[3,A]迁移到新的数组上，然后再处理[7,B]，而[7,B]被链接到了[3,A]的后面，处理完[7,B]之后，就需要处理[7,B]的next了啊，而通过thread2的resize之后，[7,B]的next变为了[3,A]，此时，[3,A]和[7,B]形成了环形链表，在get的时候，如果get的key的桶索引和[3,A]和[7,B]一样，那么就会陷入死循环。</p><p>参考：<a href="https://www.jianshu.com/p/e2f75c8cce01" target="_blank" rel="external">一字马胡链接</a></p><h1 id="6-HashSet-HashTable-currentHashMap-LinkedHashMap"><a href="#6-HashSet-HashTable-currentHashMap-LinkedHashMap" class="headerlink" title="6. HashSet\HashTable\currentHashMap\LinkedHashMap"></a>6. HashSet\HashTable\currentHashMap\LinkedHashMap</h1><h2 id="6-1-HashSet"><a href="#6-1-HashSet" class="headerlink" title="6.1 HashSet"></a>6.1 HashSet</h2><p>在Java里，其实<strong>HashSet</strong>内部是一个HashMap。此处不再过多阐述。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-11-13-17-37.png" alt=""> </p><h2 id="6-2-HashSet"><a href="#6-2-HashSet" class="headerlink" title="6.2 HashSet"></a>6.2 HashSet</h2><p><strong>Hashtable</strong>和 HashMap 一样， 也是一个散列表，它存储的内容是键值对，继承于 Dictionary 类</p><p><strong>Hashtable 与 HashMap 的简单比较</strong></p><ol><li>HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap。Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。</li><li>HashMap 的 key 和 value 都允许为 null，而 Hashtable 的 key 和 value 都不允许为 null。HashMap 遇到 key 为 null 的时候，调用 putForNullKey 方法进行处理，而对 value 没有处理；Hashtable遇到 null，直接返回 NullPointerException。</li><li><strong>Hashtable 方法是同步的，而HashMap则不是，也就是说Hashtable是线程安全的</strong>。我们可以看一下源码，Hashtable 中的几乎所有的 public 的方法都是 synchronized 的，而有些方法也是在内部通过 synchronized 代码块来实现。所以有人一般都建议如果是涉及到多线程同步时采用 HashTable，没有涉及就采用 HashMap，但是在 Collections 类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的 Map 对象，并把它作为一个封装的对象来返回。</li></ol><h2 id="6-3-currentHashMap"><a href="#6-3-currentHashMap" class="headerlink" title="6.3 currentHashMap"></a>6.3 currentHashMap</h2><p>​    我们在之前的博文中了解到关于 HashMap 和 Hashtable 这两种集合。其中 HashMap 是非线程安全的，当我们只有一个线程在使用 HashMap 的时候，自然不会有问题，但如果涉及到多个线程，并且有读有写的过程中，HashMap 就不能满足我们的需要了(fail-fast)。在不考虑性能问题的时候，我们的解决方案有 Hashtable 或者Collections.synchronizedMap(hashMap)，这两种方式基本都是对整个 hash 表结构做锁定操作的，这样在锁表的期间，别的线程就需要等待了，无疑性能不高。</p><p>​    <strong>currentHashMap的加锁操作是针对的 hash 值对应的某个 Segment</strong>，而不是整个 ConcurrentHashMap。因为 put 操作只是在这个 Segment 中完成，所以并不需要对整个 ConcurrentHashMap 加锁。所以，此时，其他的线程也可以对另外的 Segment 进行 put 操作，因为虽然该 Segment 被锁住了，但其他的 Segment 并没有加锁。同时，读线程并不会因为本线程的加锁而阻塞。</p><p>​    正是因为其内部的结构以及机制，所以 ConcurrentHashMap 在并发访问的性能上要比Hashtable和同步包装之后的HashMap的性能提高很多。在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。</p><p>​    ConcurrentHashMap 针对读操作做了大量的优化。通过 HashEntry 对象的不变性和用 volatile 型变量协调线程间的内存可见性，使得 大多数时候，读操作不需要加锁就可以正确获得值。这个特性使得 ConcurrentHashMap 的并发性能在分离锁的基础上又有了近一步的提高。</p><p><strong>总结一下：</strong>ConcurrentHashMap 的高并发性主要来自于三个方面：</p><ul><li>用分离锁实现多个线程间的更深层次的共享访问。</li><li>用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。</li><li>通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。</li></ul><p><a href="http://wiki.jikexueyuan.com/project/java-collection/concurrenthashmap.html" target="_blank" rel="external">极客学院Java集合学习指南</a></p><h2 id="6-4-LinkedHashMap"><a href="#6-4-LinkedHashMap" class="headerlink" title="6.4 LinkedHashMap"></a>6.4 LinkedHashMap</h2><p>HashMap 是无序的，HashMap 在 put 的时候是根据 key 的 hashcode 进行 hash 然后放入对应的地方。所以在按照一定顺序 put 进 HashMap 中，然后遍历出 HashMap 的顺序跟 put 的顺序不同（除非在 put 的时候 key 已经按照 hashcode 排序号了，这种几率非常小）</p><p>JAVA 在 JDK1.4 以后提供了 <strong>LinkedHashMap 来帮助我们实现了有序的 HashMap</strong>！</p><p><strong>LinkedHashMap 实现与 HashMap 的不同之处在于，LinkedHashMap 维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</strong></p><p>根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用 get 方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。</p><h1 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h1><ol><li><a href="http://wiki.jikexueyuan.com/project/java-collection/hashmap.html" target="_blank" rel="external">极客学院，HashMap 的实现原理</a></li><li><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">美团点评技术团队，Java 8系列之重新认识HashMap</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-HashMap概述&quot;&gt;&lt;a href=&quot;#1-HashMap概述&quot; class=&quot;headerlink&quot; title=&quot;1. HashMap概述&quot;&gt;&lt;/a&gt;1. HashMap概述&lt;/h1&gt;&lt;p&gt;HashMap是基于哈希表的Map接口的非同步实现。此实现提供所
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章系统设计】爬虫系统与搜索建议系统</title>
    <link href="http://yoursite.com/2018/03/10/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%BB%BA%E8%AE%AE%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/03/10/【九章系统设计】爬虫系统与搜索建议系统/</id>
    <published>2018-03-10T09:08:29.000Z</published>
    <updated>2018-03-16T09:35:02.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-outline"><a href="#1-outline" class="headerlink" title="1. outline"></a>1. outline</h1><ul><li>Design a web crawler 爬虫</li><li>Design thread-safe producer and  consumer 线程安全的生产者-消费者</li><li>Design a Typeahead 搜索建议</li></ul><h1 id="2-爬虫"><a href="#2-爬虫" class="headerlink" title="2. 爬虫"></a>2. 爬虫</h1><h2 id="2-1-Scenario"><a href="#2-1-Scenario" class="headerlink" title="2.1 Scenario"></a>2.1 Scenario</h2><p>思考：搜索引擎是如爬取网页的？我们需要获取什么样的表格？</p><p>URL-网页内容</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-21-08-16.png" alt=""> </p><p>爬到了这些数据怎么用呢？</p><p>用户搜索关键词，google去数据表中的网页内容字段寻找包含用户query的数据，返回对应的url给用户，之后进行排序等优化操作。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-21-09-32.png" alt=""> </p><p>那么想要用程序完成爬取互联网上所有网页及其内容这个目标，我们首先要知道一个事实，也就是互联网上的内容其实是互相索引的，也就是就像如下的大网一样：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-21-11-23.png" alt=""> </p><p><strong>总结分析爬虫的工作量：</strong></p><p><strong>假设我们需要在一周内爬取互联网中所有的网页，之后至少一周更新一次。</strong></p><ol><li>互联网上共有1trillion个网页，则每秒需要爬取1.6m个网页</li><li><strong>每个网页大概10K</strong>，那么将这些网页存下来需要<strong>10P</strong>的存储空间</li></ol><p>把互联网上的网页看成是一张图，爬虫相当于遍历这个图，有DFS和BFS两种实现方式，<strong>一般采用BFS进行爬取</strong>，因为DFS不好并行爬取。</p><h3 id="2-1-1单线程爬取"><a href="#2-1-1单线程爬取" class="headerlink" title="2.1.1单线程爬取"></a>2.1.1单线程爬取</h3><p>对于单线程的爬虫来说，就是搞一个队列，用BFS爬取集合：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-21-25-03.png" alt=""> </p><h3 id="2-1-2-生产者消费者模型"><a href="#2-1-2-生产者消费者模型" class="headerlink" title="2.1.2 生产者消费者模型"></a>2.1.2 生产者消费者模型</h3><p>producer-consumer pattern生产者消费者模型</p><p>由于存取速度不一样，所以二者中间有一个buffer</p><p><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-11-21-16-37.png" alt="img"></p><p>但是单线程有一个问题，就是慢的很。解决——多线程爬虫</p><h3 id="2-1-3-多线程爬取"><a href="#2-1-3-多线程爬取" class="headerlink" title="2.1.3 多线程爬取"></a>2.1.3 多线程爬取</h3><p> 不同线程之间共享同一个队列</p><p>为什么多线程会比单线程快呢？</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-21-37-28.png" alt=""> </p><p>多线程存在的问题：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-21-38-56.png" alt=""> </p><p>多个线程都会从队列里向外拿URL，相当于对队列的一次写操作，这时候就会发生冲突，也就是互斥</p><p>需要注意的是，争取共享资源，就要<strong>考虑以下三个机制</strong>：</p><ul><li>sleep —— 就是睡一会，设置一定的时间，然后回来看看资源能用了不。但问题是：在道资源可以使用的第一时间知道，效率很低</li><li>condition variable 信号量（实现互斥）—— 相当于所有的线程都在等着，然后信号量通知他们能用的时候，就都立马去抢占用资源，谁抢到算谁的</li><li>semaphore —— 就像门上挂上五把钥匙一样，每次可以进去5个人，出来的时候还钥匙，也就是允许同一时间有多个线程访问用一个资源。</li></ul><p>单线程 –&gt; 多线程：</p><p>思考一个问题，既然多线程这么快，是否可以尽量多的开线程，比如开一万个？</p><p>不行，原因如下：</p><ul><li>线程之间来回切换(context switch)还是有花费（需要保存线程执行状态，还需要切换二级缓存等）的，因此线程不能太多，线程过多效率会很低</li><li>一个CPU在同一时间只能处理一个线程，如果机器只有一个CPU线程依然在排队</li><li>线程端口数目是有限的（TCP/IP协议中，端口只有2个字节，也就是65536个端口，操作系统还会预留一些端口给其他服务）</li><li>网络带宽有限制，线程很多，单台的带宽是不能够满足的</li></ul><p>因此我们可以改进一下：</p><h3 id="2-1-4-分布式爬取"><a href="#2-1-4-分布式爬取" class="headerlink" title="2.1.4 分布式爬取"></a>2.1.4 分布式爬取</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-22-02-00.png" alt=""> </p><p>分多台机器爬取，就可以突破单台机器的限制了！此时分布式爬虫依然共享一个内存中的URL queue.</p><p>分布式爬虫虽然解决了线程不能太多的问题，但是又带来了一个问题：URL队列在内存中放不下了（假设1trillion，差不多要40T的内存）！这是不行的。那么我们考虑一下把URL queue存在硬盘里，也就是数据库里。</p><p>但是放到数据库里之后，又有一个很要命的限制是：没有办法控制网页抓取的顺序和优先级啊！</p><p>解决：给数据库加入一个优先级的列，再加一个频率的列</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-22-08-58.png" alt=""> </p><p>每一行是一个任务：</p><ul><li>ID,URL</li><li>state：是否正在运行的状态（即能去重，也能防止重复运算）</li><li>priority：优先级</li><li>available_time：控制抓取频率，也就是这个时刻之后再进行抓取。如果本次有更新，那么就把时间设置地更近一些；如果本次没有更新，那么就把时间设置地更远一些</li></ul><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-22-09-49.png" alt=""> </p><ul><li>webPage Storage : 分布式存储系统，存储爬取的东西</li><li>分布式爬虫</li><li>Task table : 就是上面的任务表</li></ul><h2 id="2-4-Scale-优化"><a href="#2-4-Scale-优化" class="headerlink" title="2.4 Scale 优化"></a>2.4 Scale 优化</h2><h3 id="2-4-1-Task-Table-拆分"><a href="#2-4-1-Task-Table-拆分" class="headerlink" title="2.4.1 Task Table 拆分"></a>2.4.1 Task Table 拆分</h3><p><strong>task table 最终会非常大！1 trillion 个task，而且会越来越大</strong></p><p>解决——拆表sharding，加速访问</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-22-26-40.png" alt=""> </p><p>那么拆表就有一个细节需要注意，需要一个scheduler，用来安排去哪里要数据。</p><h3 id="2-4-2-抓取频率问题"><a href="#2-4-2-抓取频率问题" class="headerlink" title="2.4.2 抓取频率问题"></a>2.4.2 抓取频率问题</h3><p>如何控制抓取频率呢？有一个暴力的方法：</p><ul><li>如果本次抓了有更新（更新频繁），那就把下次抓取的时间提前一半</li><li>如果本次抓了没更新（更新不频繁），就把下次抓取的时间往后移2倍</li></ul><p>调整合适的抓频率可以优化计算资源</p><h3 id="2-4-3-死循环问题"><a href="#2-4-3-死循环问题" class="headerlink" title="2.4.3 死循环问题"></a>2.4.3 死循环问题</h3><p>比如爬取新浪新闻，基本上连接也都是新浪新闻，</p><p>有些网站是互相指向的，比如sina.com。而且所有的URL都是与sina.com差不多的。这样就会使用大量的资源去抓取这种巨型网站，太耗费资源了。对于那些小博客就不公平。</p><p>解决办法：单位时间对同一个网站，不要分配过多的计算资源给巨型网站就好啦。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-23-51-10.png" alt=""> </p><h3 id="2-4-4-分区域问题"><a href="#2-4-4-分区域问题" class="headerlink" title="2.4.4 分区域问题"></a>2.4.4 分区域问题</h3><p>中国的爬虫爬美国的网站，或者网站在美国爬中国的网站就会很慢</p><p>解决：分区域爬取，分区域简历task table，然后定期和全世界的数据库进行同步</p><h1 id="3-Typeahead-搜索建议"><a href="#3-Typeahead-搜索建议" class="headerlink" title="3. Typeahead 搜索建议"></a>3. Typeahead 搜索建议</h1><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-23-54-59.png" alt=""> </p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-23-55-53.png" alt=""> </p><h2 id="3-1-scenario-场景分析"><a href="#3-1-scenario-场景分析" class="headerlink" title="3.1 scenario 场景分析"></a>3.1 scenario 场景分析</h2><p>我们以google Suggesion为例分析</p><ul><li>DAU日活跃用户：500m</li><li>搜索量：4 x 6 x 500m = 12b （每人搜索6次，输入4个单词 = 使用了typeahead四次）</li><li>QPS : 12b / 86400 = 138k</li><li>Peak QPS = QPS X 2 = 276k</li></ul><p>typeahead的最关键问题是快！一定要在用户敲字母的同时给出建议</p><h2 id="3-2-service-需求"><a href="#3-2-service-需求" class="headerlink" title="3.2 service 需求"></a>3.2 service 需求</h2><ol><li>query survice 处理检索，在极短的时间内返回以输入为前缀的建议热门词</li><li>data collection service 收集某段时间内用户搜索的热门词</li></ol><h3 id=""><a href="#" class="headerlink" title=""></a><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-13-00-24-11.png" alt=""></h3><h2 id="3-3-Storage"><a href="#3-3-Storage" class="headerlink" title="3.3 Storage"></a>3.3 Storage</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-outline&quot;&gt;&lt;a href=&quot;#1-outline&quot; class=&quot;headerlink&quot; title=&quot;1. outline&quot;&gt;&lt;/a&gt;1. outline&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Design a web crawler 爬虫&lt;/li&gt;
&lt;li&gt;D
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>排序算法终极大总结</title>
    <link href="http://yoursite.com/2018/03/10/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%BB%88%E6%9E%81%E5%A4%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/10/【排序】排序算法终极大总结/</id>
    <published>2018-03-10T08:47:53.000Z</published>
    <updated>2018-03-13T02:18:42.346Z</updated>
    
    <content type="html"><![CDATA[<p>常见的排序算法有以下几种：</p><ul><li>递归性排序<ul><li><a href="/2017/07/23/【排序】归并排序/" title="归并排序">归并排序</a>：归并排序的主要思想是分治，也就是先把数组分成两部分，当两部分都有序时，然后再将两部分进行二路归并。需要注意的是归并排序的时间复杂度分析方法，就是画出$T(n) = 2T(n/2) + cn$ 的递归树，并计算最终时间复杂度。但是要注意的是，归并排序在进行二路归并时，可能会产生额外的空间复杂度。</li><li>：快速排序的思路也是分治，但分治之前需要选择一个主元作为基准，将主元放在应该在的位置，并且数组左边比主元小，右边比主元大。这样如果当左边有序和右边有序时，整个数组就有序了。假设主元位置为i，快速排序复杂度为$T(n) = T(i) + T(n - i - 1) + cn$ 。由于i的不确定性导致快速排序的最坏情况下时间复杂度为$T(n) = T(n-1) + T(0) +  cn = O(n^2)$ ，而平均情况下是$T(n) = 2T(\frac{n-1}{2}) +cn = nlogn$。 快速排序不需要额外的空间。</li></ul></li><li>非递归型排序<ul><li><a href="/2017/07/20/【排序】插入排序/" title="插入排序">插入排序</a>：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。</li><li><a href="/2017/07/22/【排序】选择排序/" title="选择排序">选择排序</a>：每次从无序区选择一个最小的放大有序区的最后</li><li><a href="/2017/07/20/【排序】冒泡排序/" title="冒泡排序">冒泡排序</a>：依次比较相邻的两个数据，如果前面的比后面的大，就将其交换；这样交换一轮之后，整个序列中最大的就“沉”到了最后面的位置；重复上述过程，依次把第二大、第三大…的数字放到后面的位置。</li><li><a href="/2017/07/22/【排序】希尔排序/" title="希尔排序">希尔排序</a>：分组插入排序</li></ul></li><li>非比较排序：非比较排序的时间复杂度可以达到$O(n)$ 。<ul><li><a href="/2018/02/08/【排序】计数排序、基数排序、桶排序/" title="计数排序、基数排序、桶排序">计数排序、基数排序、桶排序</a><ul><li>计数排序：已知最大值K。利用数组<code>int[K]</code> 统计每个数字的小于等于它的个数，将这个个数作为这个数字的idx</li><li>基数排序：分别对数字的个位、十位、…、d位依次进行计数排序</li><li>桶排序：将数字分别放入桶里。</li></ul></li></ul></li></ul><p>因此我们做出如下总结：</p><div class="table-container"><table><thead><tr><th>排序方法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>其它要点</th></tr></thead><tbody><tr><td>归并</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(n)$</td><td>递归树</td></tr><tr><td>快排</td><td>$O(nlogn)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>快速选择<a href="/2018/02/02/【九章算法强化班】两指针/" title="【九章算法强化班】两指针">【九章算法强化班】两指针</a> <br>快排优化算法：随机选择pivot<br></td></tr><tr><td>插入、<br>选择、<br>冒泡、<br>希尔</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td></td></tr><tr><td>计数排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(K)$</td><td>已知数组最大值K</td></tr><tr><td>基数排序</td><td>$O(d(n+10))$</td><td>$O(d(n+10))$</td><td>$O(10)$</td><td></td></tr><tr><td>桶排序</td><td>$O(n)$</td><td></td><td>$O(n)$</td><td>大数排序<br></td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常见的排序算法有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递归性排序&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2017/07/23/【排序】归并排序/&quot; title=&quot;归并排序&quot;&gt;归并排序&lt;/a&gt;：归并排序的主要思想是分治，也就是先把数组分成两部分，当两部分都有序时，然后再将两部分
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【面经】开发相关基础知识</title>
    <link href="http://yoursite.com/2018/03/09/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/03/09/【面经】开发相关基础知识/</id>
    <published>2018-03-09T15:46:50.000Z</published>
    <updated>2018-03-12T12:35:15.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JDK和JRE、JVM的区别是什么"><a href="#1-JDK和JRE、JVM的区别是什么" class="headerlink" title="1. JDK和JRE、JVM的区别是什么"></a>1. JDK和JRE、JVM的区别是什么</h2><p><strong>JRE（Java运行时环境）： Java Runtime Environment</strong></p><p>JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。</p><p><strong>JDK（Java 开发工具包）：Java Development Kit</strong></p><p>JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。</p><p><strong>JVM（Java 虚拟机）：Java Virtual Machine</strong></p><p>JVM是Java编程语言的核心。当我们运行一个程序时，JVM负责将字节码转换为特定机器代码。JVM也是<strong>平台特定</strong>的，并提供核心的Java方法，例如内存管理、垃圾回收和安全机制等。JVM 是可定制化的，我们可以通过Java 选项(java options)定制它，比如配置JVM 内存的上下界。JVM之所以被称为虚拟的是因为它提供了一个不依赖于底层操作系统和机器硬件的接口。这种独立于硬件和操作系统的特性正是Java程序可以一次编写多处执行的原因。</p><p><strong>JDK, JRE 和JVM的区别</strong></p><ul><li>JDK是用于开发的而JRE是用于运行Java程序的。</li><li>JDK和JRE都包含了JVM，从而使得我们可以运行Java程序。</li><li>JVM是Java编程语言的核心并且具有平台独立性。</li></ul><h2 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2. 进程和线程"></a>2. 进程和线程</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong>程序</strong></p><p>​    程序是指令和数据的有序集合，其本身没有任何运动的含义，是一个静态的概念，而进程则是在处理机上的一次执行过程，它是一个动态的概念。进程是包含程序的，进程的执行离不开程序，进程中的文本区域就是代码区，也就是程序。</p><p><strong>进程(process)</strong></p><p>狭义的定义：进程就是一段程序的执行过程。</p><p>广义定义：进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元。</p><p>​    简单来讲进程的概念主要有两点：第一，进程是一个实体。<strong>每一个进程都有它自己的地址空间</strong>，一般情况下，包括<strong>文本区域（text region）、数据区域（data region）和堆栈（stack region）</strong>。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程中调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。</p><p>​    进程状态：进程有三个状态，就绪，运行和阻塞。就绪状态其实就是获取了除cpu外的所有资源，只要处理器分配资源马上就可以运行。运行态就是获取了处理器分配的资源，程序开始执行，阻塞态，当程序条件不够时，需要等待条件满足时候才能执行，如等待I/O操作的时候，此刻的状态就叫阻塞态。</p><p><strong>线程(thread)</strong></p><p>​    通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p><h3 id="2-2进程与线程的区别"><a href="#2-2进程与线程的区别" class="headerlink" title="2.2进程与线程的区别"></a>2.2进程与线程的区别</h3><p>​    进程和线程的主要差别在于它们是不同的操作系统资源管理方式。<strong>进程有独立的地址空间</strong>，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。<strong>线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间</strong>，<strong>一个线程死掉就等于整个进程死掉</strong>，<strong>所以多进程的程序要比多线程的程序健壮</strong>，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><p>1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</p><p>2) 线程的划分尺度小于进程，使得多线程程序的并发性高。</p><p>3) 另外，<strong>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</strong>。</p><p>4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p>5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><h3 id="2-3-优缺点"><a href="#2-3-优缺点" class="headerlink" title="2.3 优缺点"></a>2.3 优缺点</h3><p>​    线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP(多核处理机)机器上运行，而进程则可以跨机器迁移。</p><p><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="external">用一个工厂的形象的解释进程和线程</a></p><p><a href="https://www.jianshu.com/p/7ce30a806c51" target="_blank" rel="external">简书的王布斯</a></p><h2 id="3-如何预防死锁"><a href="#3-如何预防死锁" class="headerlink" title="3. 如何预防死锁"></a>3. 如何预防死锁</h2><h3 id="3-1-死锁"><a href="#3-1-死锁" class="headerlink" title="3.1 死锁"></a>3.1 死锁</h3><p>​    当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><h3 id="3-2-造成死锁必须达成的4个条件（原因）"><a href="#3-2-造成死锁必须达成的4个条件（原因）" class="headerlink" title="3.2 造成死锁必须达成的4个条件（原因）"></a>3.2 造成死锁必须达成的4个条件（原因）</h3><ul><li>互斥：指进程对所分配到的资源进行排他性使用，即一段时间内某资源只能由一个进程占用</li><li>请求和保持：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺：指进程已获得的资源在未使用完之前不能被剥夺，只能在使用完时自己释放</li><li>循环等待：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ul><h3 id="3-3死锁的预防"><a href="#3-3死锁的预防" class="headerlink" title="3.3死锁的预防"></a>3.3<strong>死锁的预防</strong></h3><blockquote><p>破坏互斥条件</p></blockquote><ul><li>一般来说在所列的四个条件中，“互斥”条件是无法破坏的</li></ul><blockquote><p>破坏请求和保持条件</p></blockquote><ul><li>一次性分配方案</li><li>要求每个进程提出新的资源申请前，释放它所占有的资源</li></ul><blockquote><p>破坏不剥夺条件</p></blockquote><ul><li>如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源</li><li>进程划分优先级，高优先级进程可以剥夺低优先级进程的资源</li></ul><blockquote><p>破坏循环等待条件</p></blockquote><ul><li>将系统中的所有资源统一编号，进程提出的所有资源申请必须按照资源的编号顺序提出</li></ul><h2 id="4-tcp-udp-区别"><a href="#4-tcp-udp-区别" class="headerlink" title="4. tcp udp 区别"></a>4. tcp udp 区别</h2><p><strong>TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</strong></p><p>1)提供IP环境下的数据可靠传输(一台计算机发出的字节流会无差错的发往网络上的其他计算机，而且计算机A接收数据包的时候，也会向计算机B回发数据包，这也会产生部分通信量)，有效流控，全双工操作(数据在两个方向上能同时传递)，多路复用服务，是面向连接，端到端的传输;</p><p>2)面向连接：正式通信前必须要与对方建立连接。事先为所发送的数据开辟出连接好的通道，然后再进行数据发送，像打电话。</p><p>3)TCP支持的应用协议：Telnet(远程登录)、FTP(文件传输协议)、SMTP(简单邮件传输协议)。TCP用于传输数据量大，可靠性要求高的应用。</p><p><strong>UDP(用户数据报协议）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</strong></p><p>1)面向非连接的(正式通信前不必与对方建立连接，不管对方状态就直接发送，像短信，QQ)，不能提供可靠性、流控、差错恢复功能。UDP用于一次只传送少量数据，可靠性要求低、传输经济等应用。</p><ol><li>UDP支持的应用协议：NFS(网络文件系统)、SNMP(简单网络管理系统)、DNS(主域名称系统)、TFTP(通用文件传输协议)等。</li></ol><p><strong>总结：</strong></p><p><strong>TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。</strong></p><p><strong>UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。</strong></p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-11-01-23-00.png" alt=""> </p><h3 id="5-TCP-IP-协议族常用协议"><a href="#5-TCP-IP-协议族常用协议" class="headerlink" title="5. TCP/IP 协议族常用协议"></a>5. TCP/IP 协议族常用协议</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-11-01-26-11.png" alt=""> </p><h2 id="6-三次握手四次挥手"><a href="#6-三次握手四次挥手" class="headerlink" title="6. 三次握手四次挥手"></a>6. 三次握手四次挥手</h2><h3 id="6-1-TCP特性"><a href="#6-1-TCP特性" class="headerlink" title="6.1 TCP特性"></a>6.1 TCP特性</h3><ul><li>TCP 提供一种<strong>面向连接的、可靠的</strong>字节流服务</li><li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li><li>TCP 使用校验和，确认和重传机制来保证可靠传输</li><li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li><li>TCP 使用<strong>滑动窗口机制</strong>来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li></ul><p><strong>那为什么需要三次握手呢？</strong>请看如下的过程：</p><ol><li>A向B发起建立连接请求：A——&gt;B；</li><li>B收到A的发送信号，并且向A发送确认信息：B——&gt;A；</li><li>A收到B的确认信号，并向B发送确认信号：A——&gt;B。</li></ol><p>三次握手大概就是这么个过程。<br>通过第一次握手，B知道A能够发送数据。通过第二次握手，A知道B能发送数据。结合第一次握手和第二次握手，A知道B能接收数据。结合第三次握手，B知道A能够接收数据。</p><p>至此，完成了握手过程，A知道B能收能发，B知道A能收能发，通信连接至此建立。三次连接是保证可靠的最小握手次数，再多次握手也不能提高通信成功的概率，反而浪费资源。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-11-12-21-02.png" alt=""> </p><p><strong>那为什么需要四次挥手呢？</strong>请看如下过程：</p><ol><li>A向B发起请求，表示A没有数据要发送了：A——&gt;B；</li><li>B向A发送信号，确认A的断开请求请求：B——&gt;A；</li><li>B向A发送信号，请求断开连接，表示B没有数据要发送了：B——&gt;A；</li><li>A向B发送确认信号，同意断开：A——&gt;B。</li></ol><p>B收到确认信号，断开连接，而A在一段时间内没收到B的信号，表明B已经断开了，于是A也断开了连接。至此，完成挥手过程。</p><p>可能有捧油会问，为什么2、3次挥手不能合在一次挥手中？那是因为此时A虽然不再发送数据了，但是还可以接收数据，B可能还有数据要发送给A，所以两次挥手不能合并为一次。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-11-12-21-13.png" alt=""> </p><p>挥手次数比握手多一次，是因为握手过程，通信只需要处理<strong>连接</strong>。而挥手过程，通信需要处理<strong>数据+连接</strong>。</p><h2 id="7-局部变量和函数参数为什么要放在栈中"><a href="#7-局部变量和函数参数为什么要放在栈中" class="headerlink" title="7.  局部变量和函数参数为什么要放在栈中"></a>7.  局部变量和函数参数为什么要放在栈中</h2><p>​    局部变量，顾名思义其作用域属于局部。全局的变量，意味着谁都随时随地可以访问，所以其放在数据段中。而局部变量只是自己在用，放在数据段中纯属浪费空间，没有必要，<strong>故将其放在自己的栈中，随时可以清理，真正体现了局部的意义</strong>。</p><p>​    函数参数为什么放在栈区呢？第一也是其局限性导致，只有这个函数用这个参数，何必将其放在数据段呢？二是因为函数是在程序执行过程中调用的，属于动态的调用，编译时无法预测何时调用及被调用的次数，函数的参数及返回值都需要内存来存储，如果是递归调用的话，参数及返回值需要的内存空间也就不确定了，这取决于递归的次数。有些体系结构的计算机也把函数参数放到寄存器里面去。</p><p>参考：<a href="https://www.jianshu.com/p/ac325bd601f8" target="_blank" rel="external">无敌大灰狼me链接</a></p><h2 id="2-常见设计原则和设计模式"><a href="#2-常见设计原则和设计模式" class="headerlink" title="2. 常见设计原则和设计模式"></a>2. 常见设计原则和设计模式</h2><p>6大设计原则：</p><ol><li><strong>单一职责原则</strong>：就是开发人员经常说的”高内聚，低耦合”。也就是说，每个类应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个。在设计模式中，所有的设计模式都遵循这一原则。</li><li><strong>开闭原则</strong>：一个对象对扩展开放，对修改关闭。也就是说，对类的改动是通过增加代码进行的，而不是修改现有代码。软件开发人员一旦写出了可以运行的代码，就不应该去改动它，而是要保证它能一直运行下去，如何能够做到这一点呢?这就需要借助于抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现则是可以改变和扩展的。</li><li><strong>里氏替换原则</strong>：在任何父类出现的地方都可以用它的子类来替代。也就是说，同一个继承体系中的对象应该有共同的行为特征。</li><li><strong>依赖注入原则</strong>：要依赖于抽象，不要依赖于具体实现。也就是说，在应用程序中，所有的类如果使用或依赖于其他的类，则应该依赖这些其他类的抽象类，而不是这些其他类的具体类。为了实现这一原则，就要求我们在编程的时候针对抽象类或者接口编程，而不是针对具体实现编程。</li><li><strong>接口分离原则</strong>：不应该强迫程序依赖它们不需要使用的方法。也就是说，一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中。</li><li><strong>迪米特原则：</strong>一个对象应当对其他对象尽可能少的了解。也就是说，降低各个对象之间的耦合，提高系统的可维护性。在模块之间应该只通过接口编程，而不理会模块的内部工作原理，它可以使各个模块耦合度降到最低，促进软件的复用</li></ol><p>常见设计模式:</p><ol><li><p>简单工厂模式</p><p> · 工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。</p><p>​        · 优点：客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性。</p><p>​        · 缺点：需要额外的编写代码，增加了工作量。</p></li><li><p>单例设计模式</p><p> 单例模式就是要确保类在内存中只有一个对象，该实例必须自动创建，并且对外提供。</p><p>​        · 优点：在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</p><p>​        · 缺点：没有抽象层，因此扩展很难。职责过重，在一定程序上违背了单一职责</p></li><li><p>模板设计模式</p><p>· 模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现</p><p>​        · 优点：使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求</p><p>​        · 缺点：如果算法骨架有修改的话，则需要修改抽象类</p></li></ol><h3 id="2-volatile关键字作用是什么"><a href="#2-volatile关键字作用是什么" class="headerlink" title="2. volatile关键字作用是什么"></a>2. volatile关键字作用是什么</h3><p>英文翻译：不稳定的</p><p>弱同步机制</p><p>在多线程的化境下，Volatile 修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p><p>数据量过大内存存不下了怎么办</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-JDK和JRE、JVM的区别是什么&quot;&gt;&lt;a href=&quot;#1-JDK和JRE、JVM的区别是什么&quot; class=&quot;headerlink&quot; title=&quot;1. JDK和JRE、JVM的区别是什么&quot;&gt;&lt;/a&gt;1. JDK和JRE、JVM的区别是什么&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【本科毕设】pub/sub框架</title>
    <link href="http://yoursite.com/2018/03/09/%E3%80%90%E6%9C%AC%E7%A7%91%E6%AF%95%E8%AE%BE%E3%80%91pub-sub%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/03/09/【本科毕设】pub-sub框架/</id>
    <published>2018-03-09T13:58:01.000Z</published>
    <updated>2018-03-12T12:35:15.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-09-21-59-34.png" alt=""> </p><p>本文中研究的问题为位置感知的发布/订阅框架设计与实现。订阅者以订阅（subscription）的形式向发布/订阅系统注册，表达对特定事件的兴趣；发布者发布消息到发布/订阅系统；发布/订阅系统充当订阅者和发布者的中介，负责订阅的管理，并以通知的形式发送消息到感兴趣的订阅者。</p><p>与传统的基于文本的发布订阅问题不同，在我们所研究的问题中，发布者发布的消息和订阅者的订阅都是同时包含了空间位置和文本描述两种信息。</p><p>​    订阅者对于空间位置和文本描述的相似性有着不同的偏好，比如一些订阅者更希望得到与自己的订阅文本相似程度更高的消息，而另一些订阅者则更关注获得的消息与自己所在的空间位置的相近程度，因此我们允许用户进行参数化订阅，研究基于参数化的空间文本订阅的位置感知发布/订阅框架，力求实现高效、有针对性的发布/订阅过程。</p><h2 id="2-前缀过滤技术"><a href="#2-前缀过滤技术" class="headerlink" title="2. 前缀过滤技术"></a>2. 前缀过滤技术</h2><p>​    文本过滤即为利用数据的文本信息进行剪枝。旨在通过执行较快捷的基于文本的算法来减少记录点之间文本相似度的直接计算，从而提高计算效率。常用的文本过滤有长度过滤，前缀过滤，索引前缀过滤，位置过滤和后缀过滤五种过滤机，我们采用其中的前缀过滤机制，结合空间文本订阅的文本信息对不符合条件的订阅进行剪枝。</p><p>​    前缀过滤技术中，我们需要结合倒排文件列表构建前缀索引，前缀索引即根据计算出的前缀长度，只在倒排文件中存储前缀词。当且仅当两个记录点的文件中前缀有一个以上相同时，两个记录点才有可能成为匹配对</p><h2 id="3-方案"><a href="#3-方案" class="headerlink" title="3. 方案"></a>3. 方案</h2><h3 id="3-1-baseline"><a href="#3-1-baseline" class="headerlink" title="3.1 baseline"></a>3.1 baseline</h3><p>通过计算订阅和消息的相似度，如果超过阈值则可以推送。</p><p>问题：计算量大，效率低。</p><h3 id="3-2-空间感知前缀"><a href="#3-2-空间感知前缀" class="headerlink" title="3.2 空间感知前缀"></a>3.2 空间感知前缀</h3><p>根据阈值和文本权重，可以计算出每个subscription的前缀长度，因此倒排索引简化为只对前缀词做倒排</p><p>根据每个subscription中所有词的权重，可以估算出其文本相似度下界，从而可以得到空间相似度下界。</p><p>接下来利用过滤-验证机制，对m中的关键词访问倒排表，找到包含关键词的subscription，计算这些subscription和m的距离，根据之前存储的空间相似度下界进行过滤，得到候选集。最后再用相似度公式验证得到最终结果。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-09-23-02-13.png" alt=""> </p><h3 id="3-3-区域感知前缀"><a href="#3-3-区域感知前缀" class="headerlink" title="3.3 区域感知前缀"></a>3.3 区域感知前缀</h3><p> 利用R树对subscriptions做空间索引，在R树的节点中存储倒排索引，空间相似度下界等，当消息过来时，可以一次性过滤掉不符合条件的整个区域。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-09-23-03-19.png" alt=""> </p><h3 id="3-4-进一步优化"><a href="#3-4-进一步优化" class="headerlink" title="3. 4 进一步优化"></a>3. 4 进一步优化</h3><p>对消息流按时间段进行R树空间索引，匹配消息和订阅两个R树，进行过滤</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://omaby2s5z.bkt.clouddn.com/2018-03-09-21-59-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>生成模型vs判别模型、有监督vs无监督</title>
    <link href="http://yoursite.com/2018/03/09/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8Bvs%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B%E3%80%81%E6%9C%89%E7%9B%91%E7%9D%A3vs%E6%97%A0%E7%9B%91%E7%9D%A3/"/>
    <id>http://yoursite.com/2018/03/09/【机器学习】生成模型vs判别模型、有监督vs无监督/</id>
    <published>2018-03-09T11:40:12.000Z</published>
    <updated>2018-03-12T12:35:15.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-监督学习-vs-无监督学习"><a href="#1-监督学习-vs-无监督学习" class="headerlink" title="1. 监督学习 vs 无监督学习"></a>1. 监督学习 vs 无监督学习</h2><ol><li>有监督学习：输入数据有标签，比如分类回归</li><li>无监督学习：输入数据没有标签，比如聚类</li><li>半监督学习：输入数据部分有标签，部分没有，或者有标签的部分不确定是否正确，让学习器不依赖外界交互、自动地利用未标记样本来提升学习性能，就是半监督学习</li></ol><h2 id="2-生成模型-vs-判别模型"><a href="#2-生成模型-vs-判别模型" class="headerlink" title="2. 生成模型 vs 判别模型"></a>2. 生成模型 vs 判别模型</h2><p>监督学习方法又可以分为<strong>生成方法</strong>(generative approach)和<strong>判别方法</strong>(discriminative approach)。所学到的模型分别为生成模型(generative model)和判别模型(discriminative model)。</p><h3 id="2-1-生成方法和生成模型"><a href="#2-1-生成方法和生成模型" class="headerlink" title="2.1 生成方法和生成模型"></a>2.1 生成方法和生成模型</h3><p>生成模型：无穷样本==》概率密度模型 = 产生模型==》预测</p><p>生成方法<strong>由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)=P(X,Y)/P(X)作为预测的模型</strong>。这样的方法之所以成为生成方法，是因为<strong>模型表示了给定输入X产生输出Y的生成关系</strong>。用于随机生成的观察值建模，特别是在给定某些隐藏参数情况下。典型的生成模型有：朴素贝叶斯法、马尔科夫模型、高斯混合模型。这种方法一般建立在统计学和Bayes理论的基础之上。</p><p><strong>生成方法的特点：</strong></p><ul><li>从统计的角度表示数据的分布情况，能够<strong>反映同类数据本身的相似度</strong>;</li><li>生成方法还原出联合概率分布，而判别方法不能；</li><li>生成方法的学习<strong>收敛速度更快</strong>、即当样本容量增加的时候，学到的模型可以更快地收敛于真实模型；</li><li>当存在隐变量时，仍然可以用生成方法学习，此时判别方法不能用</li></ul><h3 id="2-2-判别方法和判别模型"><a href="#2-2-判别方法和判别模型" class="headerlink" title="2.2 判别方法和判别模型"></a>2.2 判别方法和判别模型</h3><p>判别模型：有限样本==》判别函数 = 预测模型==》预测</p><p>判别方法由数据<strong>直接学习决策函数f(X)或者条件概率分布P(Y|X)作为预测的模型</strong>，即判别模型。判别方法关心的是对给定的输入X，应该预测什么样的输出Y。典型的判别模型包括：k近邻法、感知机、决策树、逻辑斯蒂回归模型、最大熵模型、支持向量机、boosting方法和条件随机场等。判别模型利用正负例和分类标签，关注在判别模型的边缘分布。</p><p><strong>判别方法的特点：</strong></p><blockquote><ul><li>判别方法寻找不同类别之间的最优分类面，<strong>反映的是异类数据之间的差异</strong>;</li><li>判别方法利用了训练数据的类别标识信息，直接学习的是条件概率P(Y|X)或者决策函数f(X)，直接面对预测，<strong>往往学习的准确率更高</strong>；</li><li>由于直接学习条件概率P(Y|X)或者决策函数f(X)，<strong>可以对数据进行各种程度上的抽象、定义特征并使用特征</strong>，因此可以简化学习问题。</li><li><strong>缺点是不能反映训练数据本身的特性</strong></li></ul></blockquote><h3 id="2-3-生成模型和判别模型对比"><a href="#2-3-生成模型和判别模型对比" class="headerlink" title="2.3 生成模型和判别模型对比"></a>2.3 生成模型和判别模型对比</h3><ul><li><p>训练时，二者优化准则不同</p><p>生成模型优化训练数据的联合分布概率；</p><p>判别模型优化训练数据的条件分布概率，判别模型与序列标记问题有较好的对应性。</p></li><li><p>对于观察序列的处理不同</p><p>生成模型中，观察序列作为模型的一部分；</p><p><strong>判别模型中，观察序列只作为条件，因此可以针对观察序列设计灵活的特征。</strong></p><p>训练复杂度不同</p><p><strong>判别模型训练复杂度较高</strong>。</p></li><li><p>是否支持无指导训练</p><p>生成模型支持无指导训练。</p></li><li><p>本质区别</p><p>判别估计的是条件概率分布(conditional distribution)p(Y|X)</p><p>生成模型估计的是联合概率分布（joint probability distribution）p(X,Y)</p></li></ul><p>另外，由生成模型可以得到判别模型，但由判别模型得不到生成模型。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.jianshu.com/p/d195b887a32e" target="_blank" rel="external">【机器学习基础】生成模型和判别模型</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-监督学习-vs-无监督学习&quot;&gt;&lt;a href=&quot;#1-监督学习-vs-无监督学习&quot; class=&quot;headerlink&quot; title=&quot;1. 监督学习 vs 无监督学习&quot;&gt;&lt;/a&gt;1. 监督学习 vs 无监督学习&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;有监督学习：输入数据
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>B树、B+树、AVL树、Trie树及其应用场景</title>
    <link href="http://yoursite.com/2018/03/09/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81AVL%E6%A0%91%E3%80%81Trie%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2018/03/09/B树、B-树、AVL树、Trie树及其应用场景/</id>
    <published>2018-03-09T03:10:57.000Z</published>
    <updated>2018-03-12T12:35:15.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h2><p>AVL树：平衡二叉树之一，应用相对其他数据结构比较少，windows对进程地址空间的管理用到了AVL</p><p>红黑树：平衡二叉树，广泛应用在C++STL中，比如map和set，Java的TreeMap</p><p>B和B+树：主要用在文件系统以及数据库中做索引等</p><p>Trie 树：用在统计和排序大量字符串中，一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示。还有比如IP选路，也是前缀匹配</p><p>R树：空间数据库索引</p><h2 id="2-二叉搜索树"><a href="#2-二叉搜索树" class="headerlink" title="2. 二叉搜索树"></a>2. 二叉搜索树</h2><p>不必多说了，可以参考 <a href="https://siyaozhang.github.io/2017/11/29/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95/" target="_blank" rel="external">【九章算法基础班】二叉树与分治法</a></p><p><strong>时间复杂度</strong>最好情况是<script type="math/tex">O(logn)</script> ，最坏情况下时间复杂度<script type="math/tex">O(n)</script>，恰好选择了最小或者最大的节点做root，节点排在了一条直线上。</p><h2 id="3-AVL树"><a href="#3-AVL树" class="headerlink" title="3. AVL树"></a>3. AVL树</h2><p>AVL树是二叉搜索树的改进</p><p><strong>AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡</strong>，左右子树树高不超过1，和红黑树相比，它是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而<strong>旋转是非常耗时</strong>的，由此我们可以知道<strong>AVL树适合用于插入删除次数比较少，但查找多的情况。</strong></p><p><strong><img src="http://img.blog.csdn.net/20180307121339361" alt="img"></strong></p><p>上图是一个普通的平衡二叉树，这张图我们可以看出，<strong>任意节点的左右子树的平衡因子差值都不会大于1</strong>。</p><p>局限性：</p><p>由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。</p><h2 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4. 红黑树"></a>4. 红黑树</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><p><strong>一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是red或black（非红即黑）</strong>。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，<strong>红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树</strong>(由于是弱平衡，可以推出，相同的节点情况下，AVL树的高度低于红黑树)，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索、插入、删除操作较多的情况下，我们就用红黑树。</p><h3 id="4-2-性质"><a href="#4-2-性质" class="headerlink" title="4.2 性质"></a>4.2 性质</h3><p>1、每个节点非红即黑；</p><p>2、根节点是黑的；</p><p>3、每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的；</p><p>4、如果一个节点是红的,那么它的两儿子都是黑的；</p><p>5、对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点；</p><p>6、高度始终保持在h = logn</p><p>7、<strong>红黑树的查找、插入、删除的时间复杂度最坏为O(log n)</strong></p><p>如下图所示，即是一颗红黑树(下图引自wikipedia：<a href="http://t.cn/hgvH1l" target="_blank" rel="external">http://t.cn/hgvH1l</a>)：</p><p><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/images/rbtree/1.png" target="_blank" rel="external"><img src="https://github.com/julycoding/The-Art-Of-Programming-By-July/raw/master/ebook/images/rbtree/1.png" alt="img"></a></p><p>上文中我们所说的 “叶结点” 或”NULL结点”，它不包含数据而只充当树在此结束的指示，这些结点以及它们的父结点，在绘图中都会经常被省略。</p><h3 id="4-3-应用"><a href="#4-3-应用" class="headerlink" title="4.3 应用"></a>4.3 应用</h3><p>1、广泛用于C++的STL中，Map和Set都是用红黑树实现的；</p><p>2、著名的<strong>Linux进程调度Completely Fair Scheduler</strong>，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间；</p><p>3、IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查；</p><p>4、Nginx中用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器；</p><p>5、<strong>Java中TreeMap的实现</strong>；</p><p>详细的插入、删除、旋转等操作可以参考：</p><p><a href="https://juejin.im/entry/58371f13a22b9d006882902d" target="_blank" rel="external">面试旧敌之红黑树（直白介绍深入理解）</a></p><h2 id="5-B树"><a href="#5-B树" class="headerlink" title="5. B树"></a>5. B树</h2><h3 id="5-1-B-树简介"><a href="#5-1-B-树简介" class="headerlink" title="5.1 B-树简介"></a>5.1 B-树简介</h3><p>B树是为实现<strong>高效的磁盘存取</strong>而设计的多叉平衡搜索树。这个概念在文件系统，数据库系统中非常重要。</p><p>​    B树是一种查找树，我们知道，这一类树（比如二叉查找树，红黑树等等）最初生成的目的都是为了解决某种系统中，查找效率低的问题。B树也是如此，它最初启发于二叉查找树，二叉查找树的特点是每个非叶节点都只有两个孩子节点。然而这种做法会导致当数据量非常大时，二叉查找树的深度过深，搜索算法自根节点向下搜索时，需要访问的节点也就变的相当多。如果这些节点存储在外存储器中，每访问一个节点，相当于就是进行了一次I/O操作，随着树高度的增加，频繁的I/O操作一定会降低查询的效率。</p><p>​    这里有一个基本的概念，就是说我们从外存储器中读取信息的步骤，简单来分，大致有两步：</p><ol><li>找到存储这个数据所对应的磁盘页面，这个过程是机械化的过程，需要依靠磁臂的转动，找到对应磁道，所以耗时长。</li><li>读取数据进内存，并实施运算，这是电子化的过程，相当快。</li></ol><p>总的来说，<strong>B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树</strong>(相对于二叉，B树每个内节点有多个分支)，<strong>与红黑树相比，在相同的的节点的情况下，一颗B/B+树的高度远远小于红黑树的高度</strong>(在下面B/B+树的性能分析中会提到)。<strong>B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成</strong>，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，<strong>在关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少</strong>。而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。</p><h3 id="5-2-B-树结构"><a href="#5-2-B-树结构" class="headerlink" title="5.2 B-树结构"></a>5.2 B-树结构</h3><p>B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p><p>B树的结构要求：<br><strong>1）根节点至少有两个子节点</strong><br><strong>2）每个节点有M-1个key，并且以升序排列</strong><br><strong>3）位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</strong><br><strong>4）其它节点至少有M/2个子节点</strong> [M/2,M-1]<br><strong>5）所有叶子节点都在同一层</strong><br><img src="http://img.blog.csdn.net/20161117122843822" alt="这里写图片描述"> </p><p><strong>B树高度</strong></p><p>对于一个包含n个关键字，最小度数t≥2t≥2 的B树，其高度hh 一定满足：</p><script type="math/tex; mode=display">h \leq \log_{t}{\frac{n + 1}{2}}</script><p>在搜索B树时，很明显，访问节点（即读取磁盘）的次数与树的高度呈正比，而B树与红黑树和普通的二叉查找树相比，虽然高度都是对数数量级，但是显然B树中log函数的底可以比2更大，因此，和二叉树相比，极大地减少了磁盘读取的次数。</p><h3 id="5-3-B-树操作"><a href="#5-3-B-树操作" class="headerlink" title="5.3 B-树操作"></a>5.3 B-树操作</h3><ol><li><p><strong>查找</strong></p><p>一棵已经建立好的B树如下图所示，我们的目的是查找关键字为29的文件：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-14-53-26.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-14-53-26.png" alt="img"></a></p><p>先简单说明一下上图：</p><ul><li>图中小红方块表示对应关键字锁代表的文件存储位置。实际上可以看做一个地址。比如根节点17旁边的小红块表示关键字17所对应的文件在硬盘中的存储地址。</li><li>P是指针。需要注意的是：指针 + 关键字 + 小红块 这三个东西合起来构成了一个B树的节点。这个节点存储在一个磁盘块上。</li></ul><p>下面看看搜索关键字29的文件的过程：</p><ol><li>从根节点开始，读取根节点信息，根节点有2个关键字：17和35。因为17 &lt; 29 &lt; 35，所以找到指针P2指向的子树，也就是磁盘块3（1次I/0操作）</li><li>读取当前节点信息，当前节点有2个关键字：26和30。26 &lt; 29 &lt; 30，找到指针P2指向的子树，也就是磁盘块8（2次I/0操作）</li><li>读取当前节点信息，当前节点有2个关键字：28和29。找到了！（3次I/0操作）</li></ol><p>由上面的过程可见，同样的操作，如果使用平衡二叉树，那么需要至少4次I/O操作，B树比之二叉树的这种优势，还会随着节点数的增加而增加。另外，因为B树节点中的关键字都是排序好的，所以，在节点中的信息被读入内存之后，可以采用二分查找这种快速的查找方式，更进一步减少了读入内存之后的计算时间，由此更能说明对于外存数据结构来说，I/O次数是其查找信息中最大的时间消耗，而我们要做的所有努力就是尽量在搜索过程中减少I/O操作的次数。</p></li><li><p><strong>插入</strong></p><p>​    向B树种插入关键字的过程与向二叉查找树中插入关键字的过程类似，但是要稍微复杂一点，因为根据上面B树的定义，我们可以看出，B树每个节点中关键字的个数是有范围要求的，同时，B树是平衡的，所以，如果像二叉查找树那样，直接找到相关的叶子，插入关键字，有可能会导致B树的结构发生变化而这种变化会使得B树不再是B树。</p><p>​    所以，我们这样来设计B树种对新关键字的插入：首先找到要插入的关键字应该插入的叶子节点（为方便描述，设这个叶子节点为u），如果u是满的（恰好有2t−1个关键字），那么由于不能将一个关键字插入满的节点，我们需要对u按其当前<strong>排在中间关键字</strong><script type="math/tex">u.key_t</script>进行分裂，<strong>分裂</strong>成两个节点u1,u2；同时，作为分裂标准的关键字<script type="math/tex">u.key_t</script>被<strong>上移到u的父节点中</strong>，在<script type="math/tex">u.key_t</script>插入前，如果u的父节点未满，则直接插入即可；如果u的父节点已满，则按照上面的方法对u的父节点分裂，这个过程如果一直不停止的话，最终会导致B树的根节点分裂，B树的高度增加一层。</p><p>​    下面用《算法导论》中的一个题目展示一下这种插入关键字的过程。</p><p>现在我们要将关键字序列：F, S, Q, K, C, L, H, T, V, W, M, R, N, P, A, B, X, Y依次插入一棵最小度为2的B树中。也就是说，这棵树的节点中，最多有3个关键字，最少有1个关键字。</p><p><strong>第1步</strong>，F, S, Q可以被插入一个节点（也就是根节点）</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-28.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-28.png" alt="img"></a></p><p><strong>第2步</strong>，插入关键字K，因为节点已满，所以在插入前，发生分裂，中间关键字Q上移，建立了一个新的根节点：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-42.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-42.png" alt="img"></a></p><p><strong>第3步</strong>，插入关键字C:</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-55.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-55.png" alt="img"></a></p><p><strong>第4步</strong>，插入关键字L，L应该被插入到根节点的左侧的孩子中，因为此时该节点已满，所以在插入前，发生分裂：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-12.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-12.png" alt="img"></a></p><p><strong>第5步</strong>，插入关键字H, T, V，这个过程没有发生节点的分裂：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-26.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-26.png" alt="img"></a></p><p><strong>第6步</strong>，插入关键字W，W应该被插入到根节点的最右侧的孩子中，因为此时该节点已满，所以在插入前，关键字T上移，最右端的叶子节点发生分裂：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-03-33.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-03-33.png" alt="img"></a></p><p><strong>第7步</strong>，插入关键字M，M应该被插入到根节点的左起第2个孩子中，因为此时该节点已满，所以在插入前，发生分裂，分裂之后，中间关键字K上移，导致根节点发生分裂，树高增加1：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-27.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-27.png" alt="img"></a></p><p>第8步，同样的道理，插入关键字R, N, P, A, B, X, Y：最终得到的B树如下：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-41.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-41.png" alt="img"></a></p></li><li><p><strong>删除</strong></p><p>​    删除操作的基本思想和插入操作是一样的，都是不能因为关键字的改变而改变B树的结构。<strong>插入操作主要防止的是某个节点中关键字的个数太多，所以采用了分裂；删除则是要防止某个节点中，因删除了关键字而导致这个节点的关键字个数太少，所以采用了合并操作。</strong></p><p>下面分三种情况来讨论下删除操作是如何工作的，这个过程的顺序是自根节点起向下遍历B树</p><p><strong>Case - 1：</strong>如果要删除的关键字k在节点u中，而且u是<strong>叶子节点</strong>，那么直接删除k</p><p><strong>Case - 2：</strong>如果要删除的关键字k在节点u中，而且u是<strong>内部节点</strong>。由于关键字影响着子树的范围，因此不能随意删除。必须<strong>从子树中找到一个合适的数字来替代k</strong>才可以。需要分以下3种情况讨论：</p><p>(1) 如果u中前于k的子节点u1中至少含有t个关键字，则找出k在以u1为根的子树中的前驱k′（前驱的意思是u1中比k小的关键字中最大的），然后在以u1为根的子树中删除k′，并在u中以k′替代k</p><p>(2) 如果上面的条件(1)不成立，也就是说，前于k的子节点中关键字的个数小于t了，那么就去找后于k的子节点，记为u2。若u2中至少含有t个关键字，则找出k在以u2为根的子树中的后继k′(大于k的关键字中最小的)，然后在以u2为根的子树中删除k′，并在u中以k′替代k。可以看出（2）是（1）的一个对称过程</p><p>(3) 如果u1,u2中的关键字个数都是t−1，则将k和u2合并后并入u1，这样u就失去了k和指向u2的指针，最后递归地从u1中删除k</p><p><strong>Case - 3：</strong>如果要删除的关键字k不在当前节点u中，而且u是内部节点（如果自上而下扫描到叶子都没有这个关键字的话，那就说明要删除的关键字根本就不存在，所以此处只考虑u是内部节点的情况），则首先确定包含k的u的子树，我们这里设为u.pi。如果u.pi中至少含有t个关键字，那么继续扫描，寻找下一个要被扫描的子树；如果u.pi中只含有t−1个关键字，则需要分下面两种情况进行操作：</p><p>(1) 如果u.pi至少有一个相邻的兄弟比较“丰满”（即这个兄弟至少有t个关键字）。则将u中的一个关键字降至u.pi，同时令u.pi的最“丰满”的兄弟中升一个关键至u。然后继续扫描B树，寻找k</p><p>(2) 如果u.pi的两个相邻的兄弟都不“丰满”（都只有t−1个关键字）。则令u.pi和其一个兄弟合并，再将u的一个关键字降至新合并的节点。使之成为该节点的中间关键字。</p><p>举个例子</p><p>1、初始状态<br><img src="http://img.blog.csdn.net/20160915145726227" alt="这里写图片描述"></p><p>2、删除元素H<br>首先查找H，H在一个叶子结点中，且该叶子结点元素数目3 &gt; 2<br>移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）<br><img src="http://img.blog.csdn.net/20160915150104895" alt="这里写图片描述"></p><p>3、删除T<br>在中间结点中找到T，此时删了T后该节点关键字个数 1 &lt; 2<br>将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该叶子结点中元素个数 &gt; 2，无需进行合并操作<br><img src="http://img.blog.csdn.net/20160915150446557" alt="这里写图片描述"></p><p>4、删除R<br>R所在叶子结点中元素数目为2，删除导致只有1个元素</p><blockquote><p>如果其某个相邻兄弟结点中比较丰满（元素个数 &gt; [M/2] - 1），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中</p></blockquote><p>在这个实例中，右相邻兄弟结点中比较丰满（3 &gt; 2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。<br><img src="http://img.blog.csdn.net/20160915150946108" alt="这里写图片描述"></p><p>5、删除E<br>删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（[M/2] - 1），而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件<br>所以需要该节点与某相邻兄弟结点进行合并操作：</p><blockquote><p>首先，移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中；<br>然后将这两个结点进行合并成一个结点。</p></blockquote><p>即，将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点。<br><img src="http://img.blog.csdn.net/20160915152043269" alt="这里写图片描述"><br>此时G所在节点只有一个元素，不行。<br>此时该结点的相邻兄弟又不丰满，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，这样，树的高度减少一层。<br><img src="http://img.blog.csdn.net/20160915152349100" alt="这里写图片描述"></p></li></ol><h2 id="6-B-树"><a href="#6-B-树" class="headerlink" title="6. B+树"></a>6. B+树</h2><p>​    B+树是B树的一种变形，<strong>它更适合实际应用中操作系统的文件索引和数据库索引</strong>。定义如下：（为和大多资料保持一致，这里使用阶数m来定义B+树，而不像之前的B树中，使用的是最小度t来定义）</p><ol><li>每个内部节点的关键字个数为[m/2,m] 个。其中每个关键字对应一个子树；</li><li>根节点要么没有子树，要么至少有2颗子树</li><li>叶子节点包含了全部的关键字以及关键字指向文件的指针，且：<ol><li>所有叶子节点中的关键字按大小顺序排列</li><li>相邻的叶子节点顺序链接（相当于是构成了一个顺序链表）</li><li>所有叶子节点在同一层</li></ol></li><li>所有分支节点的关键字都是对应子树中关键字的最大值</li></ol><p>比如，下图就是一个非常典型的B+树的例子。</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-31-31.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-31-31.png" alt="img"></a></p><p>B+树和B树相比，主要的不同点在以下3项：</p><ul><li>内部节点中，关键字的个数与其子树的个数相同，不像B树中，子树的个数总比关键字个数多1个</li><li>所有指向文件的关键字及其指针都在叶子节点中，不像B树，有的指向文件的关键字是在内部节点中。换句话说，B+树中，内部节点仅仅起到索引的作用</li><li>在搜索过程中，如果查询和内部节点的关键字一致，那么搜索过程不停止，而是继续向下搜索这个分支</li></ul><h2 id="6-R树"><a href="#6-R树" class="headerlink" title="6. R树"></a>6. R树</h2><h3 id="6-1-R树的结构"><a href="#6-1-R树的结构" class="headerlink" title="6.1 R树的结构"></a>6.1 R树的结构</h3><p>​    R树是B树在<strong>高维</strong>空间的扩展，是一棵<strong>平衡树</strong>。每个R树的叶子结点包含了多个指向不同数据的指针，这些数据可以是存放在硬盘中的，也可以是存在内存中。根据R树的这种数据结构，当我们需要进行一个高维空间查询时，我们只需要遍历少数几个叶子结点所包含的指针，查看这些指针指向的数据是否满足要求即可。这种方式使我们不必遍历所有数据即可获得答案，效率显著提高。下图1是R树的一个简单实例：</p><p><img src="https://images2015.cnblogs.com/blog/1051369/201704/1051369-20170404131434878-399064987.jpg" alt="img"></p><p>在R树中存放的数据并不是原始数据，而是这些数据的<strong>最小边界矩形（MBR</strong>），空间对象的MBR被包含于R树的叶结点中。</p><p>R树满足如下的性质：</p><p>1)       根结点至少有两个子结点，除非它同时是叶子结点</p><p>2)       每一个叶子结点包含 m至M个索引项记录，通常， m=M/2。</p><p>3)       每一个非叶子节点拥有m至M个子节点，除非它是跟节点。</p><p>4)       所有叶子节点都位于同一层。</p><p>支持搜索、增加、删除等操作，可以自定义矩形的最大子节点数。</p><p>更详细的内容可以参考<a href="http://www.cnblogs.com/cmi-sh-love/p/kong-jian-shud-ju-suo-yinRTree-wan-quan-jie-xi-jiJa.html" target="_blank" rel="external">空间数据索引RTree（R树）完全解析及Java实现</a></p><h2 id="7-对比"><a href="#7-对比" class="headerlink" title="7. 对比"></a>7. 对比</h2><h3 id="7-1-B树和B-树的区别"><a href="#7-1-B树和B-树的区别" class="headerlink" title="7.1 B树和B+树的区别"></a>7.1 B树和B+树的区别</h3><p>​    B/B+树用在磁盘文件组织、数据索引和数据库索引中。其中B+树比B 树更适合实际应用中操作系统的文件索引和数据库索引，因为：<br><strong>1、B+树的磁盘读写代价更低</strong><br>B+树的内部结点并没有指向关键字具体信息的指针。因此其<strong>内部结点</strong>相对B 树<strong>更小</strong>。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><blockquote><p>举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。</p></blockquote><p><strong>2、B+-tree的查询效率更加稳定</strong><br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的<strong>路径长度相同</strong>，导致每一个数据的查询效率相当。</p><p>3、<strong>B树在元素遍历的时候效率较低</strong> </p><p>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库<strong>，只需要扫一遍叶子结点即可</strong>，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。在数据库中基于范围的查询相对频繁，所以此时B+树优于B树。</p><h3 id="7-2-红黑树与B树区别"><a href="#7-2-红黑树与B树区别" class="headerlink" title="7.2 红黑树与B树区别"></a>7.2 红黑树与B树区别</h3><p>  一言而知就是树的深度较高，在磁盘I/O方面的表现不如B树。<br>  要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定。<br>  所以，在大规模数据存储的时候，<strong>红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁</strong>，进而导致效率低下。在这方面，B树表现相对优异，B树可以有多个子女，从几十到上千，可以降低树的高度。</p><h3 id="7-3-AVL树和红黑树"><a href="#7-3-AVL树和红黑树" class="headerlink" title="7.3 AVL树和红黑树"></a>7.3 AVL树和红黑树</h3><p>红黑树的算法时间复杂度和AVL相同，但<strong>统计性能</strong>比AVL树更高。</p><blockquote><p>1、红黑树和AVL树都能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。<br>2、由于设计，红黑树的任何不平衡都会在三次旋转之内解决。AVL树增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p></blockquote><p>在<strong>查找</strong>方面：<br>  红黑树的性质(最长路径长度不超过最短路径长度的2倍)，其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点。<br>  AVL是严格平衡的二叉查找树（平衡因子不超过1）。查找过程中不会出现最差情况的单支树。因此查找效率最好，最坏情况都是O(logN)数量级的。</p><p>所以，综上：<br>  AVL比RBtree更加平衡，但是AVL的插入和删除会带来大量的旋转。 所以如果<strong>插入和删除比较多</strong>的情况，应该使用<strong>RBtree</strong>, 如果<strong>查询操作比较多</strong>，应该使用<strong>AVL</strong>。</p><blockquote><p>AVL是一种高度平衡的二叉树，维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果场景中对插入删除不频繁，只是对查找特别有要求，AVL还是优于红黑的。</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://blog.csdn.net/u010899985/article/details/79468080" target="_blank" rel="external">为什么MySQL数据库索引选择使用B+树</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-应用场景&quot;&gt;&lt;a href=&quot;#1-应用场景&quot; class=&quot;headerlink&quot; title=&quot;1. 应用场景&quot;&gt;&lt;/a&gt;1. 应用场景&lt;/h2&gt;&lt;p&gt;AVL树：平衡二叉树之一，应用相对其他数据结构比较少，windows对进程地址空间的管理用到了AVL&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>过拟合、欠拟合及其解决办法</title>
    <link href="http://yoursite.com/2018/03/08/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E8%BF%87%E6%8B%9F%E5%90%88%E3%80%81%E6%AC%A0%E6%8B%9F%E5%90%88%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2018/03/08/【机器学习】过拟合、欠拟合及其解决办法/</id>
    <published>2018-03-08T13:27:34.000Z</published>
    <updated>2018-03-16T09:35:02.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-过拟合与欠拟合"><a href="#1-过拟合与欠拟合" class="headerlink" title="1. 过拟合与欠拟合"></a>1. 过拟合与欠拟合</h2><p>​    <strong>机器学习中一个重要的话题便是模型的泛化能力，泛化能力强的模型才是好模型</strong>.</p><p>​    对于训练好的模型，若在训练集表现差，不必说在测试集表现同样会很差，这可能是欠拟合导致；若模型在训练集表现非常好，却在测试集上差强人意，则这便是过拟合导致的.</p><p>​    过拟合与欠拟合也可以用 Bias 与 Variance （偏差和方差）的角度来解释，<strong>欠拟合会导致高 Bias ，过拟合会导致高 Variance ，所以模型需要在 Bias 与 Variance 之间做出一个权衡。</strong></p><p>​    使用简单的模型去拟合复杂数据时，会导致模型很难拟合数据的真实分布，这时模型便欠拟合了，或者说有很大的 Bias，<strong>Bias 即为模型的期望输出与其真实输出之间的差异</strong>；有时为了得到比较精确的模型而过度拟合训练数据，或者模型复杂度过高时，可能连训练数据的噪音也拟合了，导致模型在训练集上效果非常好，但泛化性能却很差，这时模型便过拟合了，或者说有很大的 Variance，这时模型在不同训练集上得到的模型波动比较大，<strong>Variance 刻画了不同训练集得到的模型的输出与这些模型期望输出的差异</strong>。</p><p><img src="https://pic3.zhimg.com/80/v2-7b5523e2f3ef416698cfecaebc73df36_hd.jpg" alt="img"></p><h2 id="2-常用解决办法"><a href="#2-常用解决办法" class="headerlink" title="2. 常用解决办法"></a>2. 常用解决办法</h2><p><strong>(1)解决欠拟合的方法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1、增加新特征，可以考虑加入进特征组合、高次特征，来增大假设空间;</div><div class="line">2、尝试非线性模型，比如核SVM 、决策树、DNN等模型;</div><div class="line">3、如果有正则项可以较小正则项参数 $\lambda$;</div><div class="line">4、Boosting ,Boosting 往往会有较小的 Bias，比如 Gradient Boosting 等.</div></pre></td></tr></table></figure><p><strong>(2)解决过拟合的方法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1、交叉检验，通过交叉检验得到较优的模型参数;</div><div class="line">2、early stop</div><div class="line">3、特征选择，减少特征数或使用较少的特征组合，对于按区间离散化的特征，增大划分的区间;</div><div class="line">4、正则化，常用的有 L1、L2 正则。而且 L1正则还可以自动进行特征选择;</div><div class="line">5、如果有正则项则可以考虑增大正则项参数 lambda;</div><div class="line">6、增加训练数据可以有限的避免过拟合;</div><div class="line">7、Bagging,将多个弱学习器Bagging 一下效果会好很多，比如随机森林等.</div></pre></td></tr></table></figure><p><strong>（3）DNN中常见的方法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1、早停策略。本质上是交叉验证策略，选择合适的训练次数，避免训练的网络过度拟合训练数据。</div><div class="line">2、集成学习策略。而DNN可以用Bagging的思路来正则化。首先我们要对原始的m个训练样本进行有放回随机采样，构建N组m个样本的数据集，然后分别用这N组数据集去训练我们的DNN。即采用我们的前向传播算法和反向传播算法得到N个DNN模型的W,b参数组合，最后对N个DNN模型的输出用加权平均法或者投票法决定最终输出。不过用集成学习Bagging的方法有一个问题，就是我们的DNN模型本来就比较复杂，参数很多。现在又变成了N个DNN模型，这样参数又增加了N倍，从而导致训练这样的网络要花更加多的时间和空间。因此一般N的个数不能太多，比如5-10个就可以了。</div><div class="line">3、DropOut策略。所谓的Dropout指的是在用前向传播算法和反向传播算法训练DNN模型时，一批数据迭代时，随机的从全连接DNN网络中去掉一部分隐藏层的神经元。　在对训练集中的一批数据进行训练时，我们随机去掉一部分隐藏层的神经元，并用去掉隐藏层的神经元的网络来拟合我们的一批训练数据。使用基于dropout的正则化比基于bagging的正则化简单，这显而易见，当然天下没有免费的午餐，由于dropout会将原始数据分批迭代，因此原始数据集最好较大，否则模型可能会欠拟合。</div></pre></td></tr></table></figure><h2 id="3-L1和L2正则化方法"><a href="#3-L1和L2正则化方法" class="headerlink" title="3. L1和L2正则化方法"></a>3. L1和L2正则化方法</h2><p><strong>目的：防止过拟合，提高泛化能力</strong></p><p>选择经验误差与结构化风险（模型复杂度）同时小的模型。</p><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>给定数据集<script type="math/tex">D={(x_1,y_1),(x_2,y_2),…(x_m,y_m)}</script>,其中<script type="math/tex">x\in R^d,y\in R</script>.</p><p>考虑最简单的线性回归，以平方误差为损失函数，则优化目标为：</p><script type="math/tex; mode=display">min_w\sum_{i=1}^m(y_i-w^Tx_i)^2</script><p>当样本特征很多，而样本数较少时，上式很容易陷入过拟合。解决方案，正则化项。</p><p><strong><script type="math/tex">L2</script>范数正则化（“岭回归”(redge regression)）：</strong></p><script type="math/tex; mode=display">min_w\sum_{i=1}^m(y_i-w^Tx_i)^2+\lambda ||w||_2^2</script><p><strong><script type="math/tex">L1</script>范数正则化：</strong></p><script type="math/tex; mode=display">min_w\sum_{i=1}^m(y_i-w^Tx_i)^2+\lambda ||w||_1</script><h3 id="3-2-L1和L2的异同"><a href="#3-2-L1和L2的异同" class="headerlink" title="3.2 L1和L2的异同"></a>3.2 L1和L2的异同</h3><p>相同点：都用于避免过拟合</p><p>不同点：</p><ol><li>L1可以让一部分特征的系数缩小到0，从而间接实现<strong>特征选择</strong>。所以L1适用于特征之间有关联的情况。</li><li>L2让所有特征的系数都缩小，但是不会减为0，它会使<strong>优化求解稳定快速</strong>。所以L2适用于特征之间没有关联的情况</li></ol><p>总结一下就是 <strong>L1正则化产生稀疏的权值, L2正则化产生平滑的权值</strong>。为什么会这样？这里面的本质原因是什么呢？下面我们从两个角度来解释这个问题。</p><h4 id="角度1：数学公式"><a href="#角度1：数学公式" class="headerlink" title="角度1：数学公式"></a>角度1：数学公式</h4><p><strong>L1 regularization:</strong></p><p>在原始的代价函数后面加上一个L1正则化项，即所有权重w的绝对值的和，乘以λ/n（这里不像L2正则化项那样，需要再乘以1/2，具体原因上面已经说过。）</p><p><img src="http://i.imgur.com/6jbxq15.jpg" alt="img"></p><p>同样先计算导数：</p><p><img src="http://i.imgur.com/kju5RTZ.jpg" alt="img"></p><p>上式中sgn(w)表示w的符号。那么权重w的更新规则为：</p><p><img src="http://i.imgur.com/HCkJZYl.jpg" alt="img"></p><p>比原始的更新规则多出了η <em> λ </em> sgn(w)/n这一项。当w为正时，更新后的w变小。当w为负时，更新后的w变大——因此它的效果就是让w往0靠，使网络中的权重尽可能为0，也就相当于减小了网络复杂度，防止过拟合。</p><p>另外，上面没有提到一个问题，当w为0时怎么办？当w等于0时，|W|是不可导的，所以我们只能按照原始的未经正则化的方法去更新w，这就相当于去掉η<em>λ</em>sgn(w)/n这一项，所以我们可以规定sgn(0)=0，这样就把w=0的情况也统一进来了。（在编程的时候，令sgn(0)=0,sgn(w&gt;0)=1,sgn(w&lt;0)=-1）</p><p><strong>L2 regularization（权重衰减）</strong>:</p><p>L2正则化就是在代价函数后面再加上一个正则化项：</p><p><img src="http://i.imgur.com/9WnBBu1.jpg" alt="img"></p><p>C0代表原始的代价函数，后面那一项就是L2正则化项，它是这样来的：所有参数w的平方的和，除以训练集的样本大小n。λ就是正则项系数，权衡正则项与C0项的比重。另外还有一个系数1/2，1/2经常会看到，主要是为了后面求导的结果方便，后面那一项求导会产生一个2，与1/2相乘刚好凑整。</p><p>L2正则化项是怎么避免overfitting的呢？我们推导一下看看，先求导：</p><p><img src="http://i.imgur.com/mebEC90.jpg" alt="img"></p><p>可以发现L2正则化项对b的更新没有影响，但是对于w的更新有影响:</p><p><img src="http://i.imgur.com/qM83geg.jpg" alt="img"></p><p>在不使用L2正则化时，求导结果中w前系数为1，现在w前面系数为 1−ηλ/n ，因为η、λ、n都是正的，所以 1−ηλ/n小于1，它的效果是减小w，这也就是权重衰减（weight decay）的由来。当然考虑到后面的导数项，w最终的值可能增大也可能减小。</p><p>另外，需要提一下，对于基于mini-batch的随机梯度下降，w和b更新的公式跟上面给出的有点不同：</p><p><img src="http://i.imgur.com/Xs2p2EN.jpg" alt="img"></p><p><img src="http://i.imgur.com/yDETU7x.jpg" alt="img"></p><p>对比上面w的更新公式，可以发现后面那一项变了，变成所有导数加和，乘以η再除以m，m是一个mini-batch中样本的个数。</p><p>到目前为止，我们只是解释了L2正则化项有让w“变小”的效果，但是还没解释为什么w“变小”可以防止overfitting？一个所谓“显而易见”的解释就是：更小的权值w，从某种意义上说，表示网络的复杂度更低，对数据的拟合刚刚好（这个法则也叫做奥卡姆剃刀），而在实际应用中，也验证了这一点，L2正则化的效果往往好于未经正则化的效果。</p><h4 id="角度2：几何空间"><a href="#角度2：几何空间" class="headerlink" title="角度2：几何空间"></a>角度2：几何空间</h4><p>（西瓜书-253页的解释） </p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-08-23-02-04.png" alt=""></p><p>​    简化到2维的情形，如上图所示。其中，左边是L1图示，右边是L2图示，左边的方形线上是L1中w1/w2取值区间，右边得圆形线上是L2中w1/w2的取值区间，绿色的圆圈表示w1/w2取不同值时整个正则化项的值的等高线（凸函数），从等高线和w1/w2取值区间的交点可以看到，L1中两个权值倾向于一个较大另一个为0，L2中两个权值倾向于均为非零的较小数。这也就是L1稀疏，L2平滑的效果。</p><h2 id="4-bagging-and-boosting"><a href="#4-bagging-and-boosting" class="headerlink" title="4. bagging  and boosting"></a>4. bagging  and boosting</h2><h3 id="4-1-bootstrap采样"><a href="#4-1-bootstrap采样" class="headerlink" title="4.1 bootstrap采样"></a>4.1 bootstrap采样</h3><p>​    名字来自成语“pull up by your own bootstraps”，意思是依靠你自己的资源，称为自助法，它是一种有放回的抽样方法，它是非参数统计中一种重要的估计统计量方差进而进行区间估计的统计方法。其核心思想和基本步骤如下：<br>　　（1） 采用重抽样技术从原始样本中抽取一定数量（自己给定）的样本，此过程允许重复抽样。<br>　　（2） 根据抽出的样本计算给定的统计量T。<br>　　（3） 重复上述N次（一般大于1000），得到N个统计量T。<br>　　（4） 计算上述N个统计量T的样本方差，得到统计量的方差。<br>　　应该说Bootstrap是现代统计学较为流行的一种统计方法，在小样本时效果很好。通过方差的估计可以构造置信区间等，其运用范围得到进一步延伸。</p><h3 id="4-2-bagging-bootstrap-aggregating"><a href="#4-2-bagging-bootstrap-aggregating" class="headerlink" title="4.2 bagging (bootstrap aggregating)"></a>4.2 bagging (bootstrap aggregating)</h3><p>Bagging即套袋法，其算法过程如下：</p><p>A）从原始样本集中抽取训练集。每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）。共进行k轮抽取，得到k个训练集。（k个训练集之间是相互独立的）</p><p>B）每次使用一个训练集得到一个模型，k个训练集共得到k个模型。（注：这里并没有具体的分类算法或回归方法，我们可以根据具体问题采用不同的分类或回归方法，如决策树、感知器等）</p><p>C）对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果。（所有模型的重要性相同）</p><h3 id="4-3-boosting"><a href="#4-3-boosting" class="headerlink" title="4.3 boosting"></a>4.3 boosting</h3><p>其主要思想是将弱分类器组装成一个强分类器。在PAC（概率近似正确）学习框架下，则一定可以将弱分类器组装成一个强分类器。</p><p>关于Boosting的两个核心问题：</p><p>1）在每一轮如何改变训练数据的权值或概率分布？</p><p>通过提高那些在前一轮被弱分类器分错样例的权值，减小前一轮分对样例的权值，来使得分类器对误分的数据有较好的效果。</p><p>2）通过什么方式来组合弱分类器？</p><p>通过加法模型将弱分类器进行线性组合，比如AdaBoost通过加权多数表决的方式，即增大错误率小的分类器的权值，同时减小错误率较大的分类器的权值。</p><p>而提升树通过拟合残差的方式逐步减小残差，将每一步生成的模型叠加得到最终模型。</p><h3 id="4-4-Bagging，Boosting二者之间的区别"><a href="#4-4-Bagging，Boosting二者之间的区别" class="headerlink" title="4.4 Bagging，Boosting二者之间的区别"></a>4.4 Bagging，Boosting二者之间的区别</h3><p>Bagging和Boosting的区别：</p><p>1）样本选择上：</p><p>Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。</p><p>Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。</p><p>2）样例权重：</p><p>Bagging：使用均匀取样，每个样例的权重相等</p><p>Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。</p><p>3）预测函数：</p><p>Bagging：所有预测函数的权重相等。</p><p>Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。</p><p>4）并行计算：</p><p>Bagging：各个预测函数可以并行生成</p><p>Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。</p><p>3)方差和偏差：</p><p>Bagging：偏差不变，方差变小，解决过拟合</p><p>Boosting：偏差变小，解决欠拟合</p><p>这两种方法都是把若干个分类器整合为一个分类器的方法，只是整合的方式不一样，最终得到不一样的效果，将不同的分类算法套入到此类算法框架中一定程度上会提高了原单一分类器的分类效果，但是也增大了计算量。</p><p>下面是将决策树与这些算法框架进行结合所得到的新的算法：</p><p>1）Bagging + 决策树 = 随机森林</p><p>2）AdaBoost + 决策树 = 提升树</p><p>3）Gradient Boosting + 决策树 = GBDT</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/29707029" target="_blank" rel="external">机器学习防止欠拟合、过拟合方法</a></p><p><a href="http://blog.csdn.net/u012162613/article/details/44261657" target="_blank" rel="external">正则化方法：L1和L2 regularization、数据集扩增、dropout</a></p><p><a href="https://vimsky.com/article/969.html" target="_blank" rel="external">为什么L1稀疏，L2平滑？</a></p><p><a href="https://www.jianshu.com/p/cb0ad5939629" target="_blank" rel="external">Bagging和Boosting 概念及区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-过拟合与欠拟合&quot;&gt;&lt;a href=&quot;#1-过拟合与欠拟合&quot; class=&quot;headerlink&quot; title=&quot;1. 过拟合与欠拟合&quot;&gt;&lt;/a&gt;1. 过拟合与欠拟合&lt;/h2&gt;&lt;p&gt;​    &lt;strong&gt;机器学习中一个重要的话题便是模型的泛化能力，泛化能力强
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【本站目录】</title>
    <link href="http://yoursite.com/2018/03/08/%E3%80%90%E6%9C%AC%E7%AB%99%E7%9B%AE%E5%BD%95%E3%80%91/"/>
    <id>http://yoursite.com/2018/03/08/【本站目录】/</id>
    <published>2018-03-08T11:57:57.000Z</published>
    <updated>2018-04-02T06:14:28.949Z</updated>
    
    <content type="html"><![CDATA[<p>文章渐渐多了起来，为了方面复习和查找，对本站文章做个目录~</p><h1 id="1-算法与数据结构"><a href="#1-算法与数据结构" class="headerlink" title="1. 算法与数据结构"></a>1. 算法与数据结构</h1><h3 id="1-1-排序算法"><a href="#1-1-排序算法" class="headerlink" title="1.1 排序算法"></a>1.1 排序算法</h3><ul><li><a href="/2018/02/08/【排序】计数排序、基数排序、桶排序/" title="计数排序、基数排序、桶排序">计数排序、基数排序、桶排序</a>，三种非比较排序，理想情况下时间复杂度可以降到<script type="math/tex">O(n)</script></li><li><a href="/2017/07/23/【排序】归并排序/" title="归并排序">归并排序</a></li><li><a href="/2017/07/22/【排序】选择排序/" title="选择排序">选择排序</a></li><li><a href="/2017/07/20/【排序】冒泡排序/" title="冒泡排序">冒泡排序</a></li><li><a href="/2017/07/17/【排序】快速排序/" title="快速排序">快速排序</a></li><li><a href="/2018/01/31/【排序】堆排序/" title="堆排序">堆排序</a></li><li><a href="/2017/07/22/【排序】希尔排序/" title="希尔排序">希尔排序</a></li><li><a href="/2018/03/10/【排序】排序算法终极大总结/" title="排序算法终极大总结">排序算法终极大总结</a> </li></ul><h3 id="1-3-数与数组"><a href="#1-3-数与数组" class="headerlink" title="1.3 数与数组"></a>1.3 数与数组</h3><ul><li><a href="/2017/12/07/【九章算法基础班】二分法/" title="【九章算法基础班】二分法">【九章算法基础班】二分法</a></li><li><a href="/2017/12/24/【九章算法基础班】数与数组/" title="【九章算法基础班】数与数组">【九章算法基础班】数与数组</a></li><li><a href="/2018/02/02/【九章算法强化班】两指针/" title="【九章算法强化班】两指针">【九章算法强化班】两指针</a> 包含<strong>partition、quickSelect</strong></li><li><a href="/2017/11/17/【九章算法强化班】扫描线/" title="【九章算法强化班】课程笔记2——扫描线">【九章算法强化班】课程笔记2——扫描线</a></li></ul><h3 id="1-2-动态规划"><a href="#1-2-动态规划" class="headerlink" title="1.2 动态规划"></a>1.2 动态规划</h3><ul><li><a href="/2017/11/18/【九章算法基础班】动态规划/" title="【九章算法基础班】动态规划">【九章算法基础班】动态规划</a>动态规划四要素，两类常见的动态规划：坐标型动态规划、序列型动态规划</li><li><a href="/2018/03/08/【九章算法强化班】动态规划/" title="【九章算法强化班】动态规划">【九章算法强化班】动态规划</a>包括DP的滚动数组优化、记忆化搜索、博弈类DP、区间型DP、背包DP</li><li><a href="/2017/10/31/【算法导论】钢条切割/" title="【算法导论】动态规划（一）钢条切割">【算法导论】动态规划（一）钢条切割</a></li><li><a href="/2017/11/01/【算法导论】矩阵链乘法/" title="【算法导论】动态规划（二）矩阵链乘法">【算法导论】动态规划（二）矩阵链乘法</a></li></ul><h3 id="1-3-链表"><a href="#1-3-链表" class="headerlink" title="1.3 链表"></a>1.3 链表</h3><ul><li><a href="/2017/12/11/【九章算法基础班】链表/" title="【九章算法基础班】课程笔记——链表">【九章算法基础班】课程笔记——链表</a></li></ul><h3 id="1-4-树模块"><a href="#1-4-树模块" class="headerlink" title="1.4 树模块"></a>1.4 树模块</h3><ul><li><a href="/2017/11/29/【九章算法基础班】二叉树与分治法/" title="【九章算法基础班】二叉树与分治法">【九章算法基础班】二叉树与分治法</a></li><li><a href="/2018/02/08/【数据结构】线段树/" title="【leetcode】线段树">【leetcode】线段树</a></li><li><a href="/2017/11/14/【九章算法强化班】Trie树/" title="【九章算法强化班】课程笔记2——Trie树">【九章算法强化班】课程笔记2——Trie树</a></li><li><a href="/2018/03/09/B树、B-树、AVL树、Trie树及其应用场景/" title="B树、B+树、AVL树、Trie树及其应用场景">B树、B+树、AVL树、Trie树及其应用场景</a></li></ul><ul><li>​</li></ul><h3 id="1-5-图模块"><a href="#1-5-图模块" class="headerlink" title="1.5 图模块"></a>1.5 图模块</h3><ul><li><a href="/2018/01/23/【九章算法基础班】图与搜索/" title="【九章算法基础班】图与搜索">【九章算法基础班】图与搜索</a>主要是BFS、DFS</li><li><a href="/2017/11/04/【算法】回溯法/" title="回溯法、【leetcode】51.52 N-Queens">回溯法、【leetcode】51.52 N-Queens</a></li><li><a href="/2017/11/05/【九章算法强化班】并查集/" title="【九章算法强化班】课程笔记2——并查集">【九章算法强化班】课程笔记2——并查集</a></li></ul><h3 id="1-6-hash表、堆、栈、队列、Trie树、并查集"><a href="#1-6-hash表、堆、栈、队列、Trie树、并查集" class="headerlink" title="1.6 hash表、堆、栈、队列、Trie树、并查集"></a>1.6 hash表、堆、栈、队列、Trie树、并查集</h3><ul><li><a href="/2018/01/19/【九章算法基础班】数据结构/" title="【九章算法基础班】数据结构">【九章算法基础班】数据结构</a>主要是hash表、堆、栈</li><li><a href="/2017/11/18/【九章算法强化班】堆Heap/" title="【九章算法强化班】堆Heap&双端队列Dequeue">【九章算法强化班】堆Heap&双端队列Dequeue</a> 堆&amp;双端队列Deque</li><li><a href="/2017/11/04/【九章算法强化班】第k大/" title="【九章算法强化班】第k大">【九章算法强化班】第k大</a></li><li>​</li></ul><h1 id="2-系统设计"><a href="#2-系统设计" class="headerlink" title="2. 系统设计"></a>2. 系统设计</h1><ul><li><a href="/2018/01/27/【九章系统设计】新鲜事系统/" title="【九章系统设计】新鲜事系统">【九章系统设计】新鲜事系统</a></li><li><a href="/2018/01/30/【九章系统设计】从用户系统理解数据库和缓存/" title="【九章系统设计】从用户系统理解数据库和缓存">【九章系统设计】从用户系统理解数据库和缓存</a></li><li><a href="/2018/03/05/【九章系统设计】一致性哈希-短网址系统设计/" title="【九章系统设计】一致性哈希&短网址系统设计">【九章系统设计】一致性哈希&短网址系统设计</a></li><li><a href="/2018/03/10/【九章系统设计】爬虫系统与搜索建议系统/" title="【九章系统设计】爬虫系统与搜索建议系统">【九章系统设计】爬虫系统与搜索建议系统</a></li></ul><h1 id="3-机器学习"><a href="#3-机器学习" class="headerlink" title="3. 机器学习"></a>3. 机器学习</h1><h3 id="3-1-线性模型"><a href="#3-1-线性模型" class="headerlink" title="3.1 线性模型"></a>3.1 线性模型</h3><ul><li>【机器学习】LR</li><li>【机器学习】svm</li><li>【机器学习】PLA 线性感知机</li></ul><h3 id="3-2-树模型"><a href="#3-2-树模型" class="headerlink" title="3.2 树模型"></a>3.2 树模型</h3><ul><li><a href="/2017/03/04/【机器学习】决策树（一）：基础/" title="决策树（一）：基础">决策树（一）：基础</a></li><li><a href="/2017/03/05/【机器学习】决策树（二）：连续值和缺失处理/" title="决策树（二）：连续值和缺失处理">决策树（二）：连续值和缺失处理</a></li><li><a href="/2017/03/05/【机器学习】决策树（三）：多变量决策树/" title="决策树（三）：多变量决策树">决策树（三）：多变量决策树</a></li></ul><ul><li>gbdt</li><li>RF</li><li><a href="/2018/03/12/【机器学习】gbdt-xgboost-lightGBM比较/" title="【机器学习】gbdt/xgboost/lightGBM比较">【机器学习】gbdt/xgboost/lightGBM比较</a></li></ul><h3 id="3-3-评价指标等"><a href="#3-3-评价指标等" class="headerlink" title="3.3 评价指标等"></a>3.3 评价指标等</h3><ul><li><a href="/2017/04/04/【机器学习】准确率、召回率、F1、ROC、AUC/" title="准确率、召回率、F1、ROC、AUC">准确率、召回率、F1、ROC、AUC</a></li><li><a href="/2017/03/16/【机器学习】熵、交叉熵/" title="交叉熵">交叉熵</a></li><li><a href="/2018/03/08/【机器学习】过拟合、欠拟合及其解决办法/" title="过拟合、欠拟合及其解决办法">过拟合、欠拟合及其解决办法</a></li><li><a href="/2018/03/09/【机器学习】生成模型vs判别模型、有监督vs无监督/" title="生成模型vs判别模型、有监督vs无监督">生成模型vs判别模型、有监督vs无监督</a></li></ul><h3 id="3-4-其他算法"><a href="#3-4-其他算法" class="headerlink" title="3.4 其他算法"></a>3.4 其他算法</h3><ul><li>PCA 主成分分析</li><li>SVD 奇异值分解</li><li>​</li></ul><h1 id="4-项目-amp-竞赛总结"><a href="#4-项目-amp-竞赛总结" class="headerlink" title="4. 项目&amp;竞赛总结"></a>4. 项目&amp;竞赛总结</h1><h3 id="4-1-腾讯社交广告算法大赛"><a href="#4-1-腾讯社交广告算法大赛" class="headerlink" title="4.1 腾讯社交广告算法大赛"></a>4.1 腾讯社交广告算法大赛</h3><ul><li><a href="/2018/03/06/【腾讯转化率预估】比赛总结/" title="【腾讯转化率预估】总结">【腾讯转化率预估】总结</a></li><li><a href="/2018/03/07/【腾讯转化率预估】贝叶斯平滑/" title="【腾讯转化率预估】贝叶斯平滑">【腾讯转化率预估】贝叶斯平滑</a></li><li><a href="/2018/03/12/【机器学习】gbdt-xgboost-lightGBM比较/" title="【机器学习】gbdt/xgboost/lightGBM比较">【机器学习】gbdt/xgboost/lightGBM比较</a></li><li><a href="/2017/03/14/【机器学习】FM，因子分解机/" title="Factorization Machine（FM，因子分解机）">Factorization Machine（FM，因子分解机）</a></li><li><a href="/2017/03/22/【机器学习】FFM（field-aware-Factorization-Machine）——升级版FM/" title="FFM（field-aware Factorization Machine）——升级版FM">FFM（field-aware Factorization Machine）——升级版FM</a>​</li><li><a href="https://jiayi797.github.io/2017/06/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E4%B8%8D%E5%B9%B3%E8%A1%A1%E7%B1%BB%E7%9A%84%E5%A4%84%E7%90%86/" target="_blank" rel="external">机器学习实践-不平衡类的处理</a></li><li><a href="https://jiayi797.github.io/2017/04/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6-xgboost%E5%8F%82%E6%95%B0%E8%B0%83%E8%8A%82%E6%8C%87%E5%8D%97%EF%BC%88Python%E7%89%88%EF%BC%89/" target="_blank" rel="external">机器学习框架-xgboost参数调节指南（Python版</a></li></ul><h3 id="4-2-编程之美"><a href="#4-2-编程之美" class="headerlink" title="4.2 编程之美"></a>4.2 编程之美</h3><ul><li><a href="/2018/03/08/【2017编程之美】搜索引擎总结/" title="【2017编程之美】搜索引擎总结">【2017编程之美】搜索引擎总结</a></li><li>​</li></ul><h3 id="4-3-实习"><a href="#4-3-实习" class="headerlink" title="4.3 实习"></a>4.3 实习</h3><ul><li> item-based 协同过滤</li></ul><h1 id="5-语言相关"><a href="#5-语言相关" class="headerlink" title="5. 语言相关"></a>5. 语言相关</h1><ul><li><a href="/2018/01/27/【Java】Java常用笔记/" title="Java常用笔记">Java常用笔记</a> 写代码的时候总忘记的小东西</li><li><a href="/2018/01/24/【Java】Java垃圾回收机制/" title="理解Java垃圾回收机制">理解Java垃圾回收机制</a></li><li><a href="/2018/03/11/【Java】HashMap原理探究/" title="【Java】HashMap原理探究">【Java】HashMap原理探究</a></li></ul><h1 id="6-面试必备"><a href="#6-面试必备" class="headerlink" title="6. 面试必备"></a>6. 面试必备</h1><ul><li><a href="/2018/03/09/【面经】开发相关基础知识/" title="【面经】开发相关基础知识">【面经】开发相关基础知识</a> </li><li><a href="/2018/03/07/【面经】算法相关/" title="【面经】算法相关">【面经】算法相关</a> </li></ul><h1 id="7-计算广告相关"><a href="#7-计算广告相关" class="headerlink" title="7. 计算广告相关"></a>7. 计算广告相关</h1><h3 id="6-1-系统相关"><a href="#6-1-系统相关" class="headerlink" title="6.1 系统相关"></a>6.1 系统相关</h3><ul><li><a href="https://siyaozhang.github.io/2018/01/10/%E3%80%90DSP%E7%B3%BB%E7%BB%9F%E3%80%91Java-UDP%E9%80%9A%E4%BF%A1%E6%A8%A1%E6%8B%9F%E7%9B%91%E5%90%AC%E6%A8%A1%E5%9D%97/" target="_blank" rel="external">【DSP系统】Java UDP通信模拟监听模块</a></li><li><a href="https://siyaozhang.github.io/2018/01/09/DSP%E7%B3%BB%E7%BB%9Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%90%AD%E5%BB%BA/" target="_blank" rel="external">DSP系统mysql数据库搭建</a></li></ul><h3 id="6-2-论文相关"><a href="#6-2-论文相关" class="headerlink" title="6.2 论文相关"></a>6.2 论文相关</h3><ul><li><a href="https://siyaozhang.github.io/2017/12/10/DeepFM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">DeepFM论文笔记</a></li><li><a href="https://siyaozhang.github.io/2017/12/07/WAND%E7%AE%97%E6%B3%95/" target="_blank" rel="external">WAND检索算法</a></li><li><a href="https://siyaozhang.github.io/2017/11/27/Bid-Optimizing-and-Inventory-Scoring-in-Targeted-Online%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">Bid Optimizing and Inventory Scoring in Targeted Online论文笔记</a></li><li><a href="https://siyaozhang.github.io/2017/07/17/Optimal-Real-Time-Bidding-for-Display-Advertising%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">ptimal Real-Time Bidding for Display Advertising论文笔记</a></li><li><a href="https://siyaozhang.github.io/2017/11/22/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8ETop-k%E5%BF%AB%E9%80%9F%E6%A3%80%E7%B4%A2%E9%97%AE%E9%A2%98/" target="_blank" rel="external">搜索引擎Top-k快速检索问题</a></li><li><a href="https://siyaozhang.github.io/2017/11/20/%E3%80%90RTB%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%91/" target="_blank" rel="external">RTB论文笔记</a></li><li><a href="https://siyaozhang.github.io/2017/11/02/DSP%E5%9B%BD%E5%86%85%E7%A1%95%E5%A3%AB%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/" target="_blank" rel="external">DSP国内硕士论文总结</a></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章渐渐多了起来，为了方面复习和查找，对本站文章做个目录~&lt;/p&gt;
&lt;h1 id=&quot;1-算法与数据结构&quot;&gt;&lt;a href=&quot;#1-算法与数据结构&quot; class=&quot;headerlink&quot; title=&quot;1. 算法与数据结构&quot;&gt;&lt;/a&gt;1. 算法与数据结构&lt;/h1&gt;&lt;h3 id=&quot;1-1-排序算法&quot;&gt;&lt;a href=&quot;#1-1-排序算法&quot; class=&quot;headerlink&quot; title=&quot;1.1 排序算法&quot;&gt;&lt;/a&gt;1.1 排序算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2018/02/08/【排序】计数排序、基数排序、桶排序/&quot; title=&quot;计数排序、基数排序、桶排序&quot;&gt;计数排序、基数排序、桶排序&lt;/a&gt;，三种非比较排序，理想情况下时间复杂度可以降到&lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/07/23/【排序】归并排序/&quot; title=&quot;归并排序&quot;&gt;归并排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/07/22/【排序】选择排序/&quot; title=&quot;选择排序&quot;&gt;选择排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/07/20/【排序】冒泡排序/&quot; title=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/07/17/【排序】快速排序/&quot; title=&quot;快速排序&quot;&gt;快速排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/01/31/【排序】堆排序/&quot; title=&quot;堆排序&quot;&gt;堆排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/07/22/【排序】希尔排序/&quot; title=&quot;希尔排序&quot;&gt;希尔排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/10/【排序】排序算法终极大总结/&quot; title=&quot;排序算法终极大总结&quot;&gt;排序算法终极大总结&lt;/a&gt; 
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-3-数与数组&quot;&gt;&lt;a href=&quot;#1-3-数与数组&quot; class=&quot;headerlink&quot; title=&quot;1.3 数与数组&quot;&gt;&lt;/a&gt;1.3 数与数组&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2017/12/07/【九章算法基础班】二分法/&quot; title=&quot;【九章算法基础班】二分法&quot;&gt;【九章算法基础班】二分法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/12/24/【九章算法基础班】数与数组/&quot; title=&quot;【九章算法基础班】数与数组&quot;&gt;【九章算法基础班】数与数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/02/02/【九章算法强化班】两指针/&quot; title=&quot;【九章算法强化班】两指针&quot;&gt;【九章算法强化班】两指针&lt;/a&gt; 包含&lt;strong&gt;partition、quickSelect&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/11/17/【九章算法强化班】扫描线/&quot; title=&quot;【九章算法强化班】课程笔记2——扫描线&quot;&gt;【九章算法强化班】课程笔记2——扫描线&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-动态规划&quot;&gt;&lt;a href=&quot;#1-2-动态规划&quot; class=&quot;headerlink&quot; title=&quot;1.2 动态规划&quot;&gt;&lt;/a&gt;1.2 动态规划&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2017/11/18/【九章算法基础班】动态规划/&quot; title=&quot;【九章算法基础班】动态规划&quot;&gt;【九章算法基础班】动态规划&lt;/a&gt;动态规划四要素，两类常见的动态规划：坐标型动态规划、序列型动态规划&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/08/【九章算法强化班】动态规划/&quot; title=&quot;【九章算法强化班】动态规划&quot;&gt;【九章算法强化班】动态规划&lt;/a&gt;包括DP的滚动数组优化、记忆化搜索、博弈类DP、区间型DP、背包DP&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/10/31/【算法导论】钢条切割/&quot; title=&quot;【算法导论】动态规划（一）钢条切割&quot;&gt;【算法导论】动态规划（一）钢条切割&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/11/01/【算法导论】矩阵链乘法/&quot; title=&quot;【算法导论】动态规划（二）矩阵链乘法&quot;&gt;【算法导论】动态规划（二）矩阵链乘法&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-3-链表&quot;&gt;&lt;a href=&quot;#1-3-链表&quot; class=&quot;headerlink&quot; title=&quot;1.3 链表&quot;&gt;&lt;/a&gt;1.3 链表&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2017/12/11/【九章算法基础班】链表/&quot; title=&quot;【九章算法基础班】课程笔记——链表&quot;&gt;【九章算法基础班】课程笔记——链表&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-4-树模块&quot;&gt;&lt;a href=&quot;#1-4-树模块&quot; class=&quot;headerlink&quot; title=&quot;1.4 树模块&quot;&gt;&lt;/a&gt;1.4 树模块&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2017/11/29/【九章算法基础班】二叉树与分治法/&quot; title=&quot;【九章算法基础班】二叉树与分治法&quot;&gt;【九章算法基础班】二叉树与分治法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/02/08/【数据结构】线段树/&quot; title=&quot;【leetcode】线段树&quot;&gt;【leetcode】线段树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/11/14/【九章算法强化班】Trie树/&quot; title=&quot;【九章算法强化班】课程笔记2——Trie树&quot;&gt;【九章算法强化班】课程笔记2——Trie树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/09/B树、B-树、AVL树、Trie树及其应用场景/&quot; title=&quot;B树、B+树、AVL树、Trie树及其应用场景&quot;&gt;B树、B+树、AVL树、Trie树及其应用场景&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;​&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-5-图模块&quot;&gt;&lt;a href=&quot;#1-5-图模块&quot; class=&quot;headerlink&quot; title=&quot;1.5 图模块&quot;&gt;&lt;/a&gt;1.5 图模块&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2018/01/23/【九章算法基础班】图与搜索/&quot; title=&quot;【九章算法基础班】图与搜索&quot;&gt;【九章算法基础班】图与搜索&lt;/a&gt;主要是BFS、DFS&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/11/04/【算法】回溯法/&quot; title=&quot;回溯法、【leetcode】51.52 N-Queens&quot;&gt;回溯法、【leetcode】51.52 N-Queens&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/11/05/【九章算法强化班】并查集/&quot; title=&quot;【九章算法强化班】课程笔记2——并查集&quot;&gt;【九章算法强化班】课程笔记2——并查集&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-6-hash表、堆、栈、队列、Trie树、并查集&quot;&gt;&lt;a href=&quot;#1-6-hash表、堆、栈、队列、Trie树、并查集&quot; class=&quot;headerlink&quot; title=&quot;1.6 hash表、堆、栈、队列、Trie树、并查集&quot;&gt;&lt;/a&gt;1.6 hash表、堆、栈、队列、Trie树、并查集&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2018/01/19/【九章算法基础班】数据结构/&quot; title=&quot;【九章算法基础班】数据结构&quot;&gt;【九章算法基础班】数据结构&lt;/a&gt;主要是hash表、堆、栈&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/11/18/【九章算法强化班】堆Heap/&quot; title=&quot;【九章算法强化班】堆Heap&amp;双端队列Dequeue&quot;&gt;【九章算法强化班】堆Heap&amp;双端队列Dequeue&lt;/a&gt; 堆&amp;amp;双端队列Deque&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/11/04/【九章算法强化班】第k大/&quot; title=&quot;【九章算法强化班】第k大&quot;&gt;【九章算法强化班】第k大&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;​&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-系统设计&quot;&gt;&lt;a href=&quot;#2-系统设计&quot; class=&quot;headerlink&quot; title=&quot;2. 系统设计&quot;&gt;&lt;/a&gt;2. 系统设计&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2018/01/27/【九章系统设计】新鲜事系统/&quot; title=&quot;【九章系统设计】新鲜事系统&quot;&gt;【九章系统设计】新鲜事系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/01/30/【九章系统设计】从用户系统理解数据库和缓存/&quot; title=&quot;【九章系统设计】从用户系统理解数据库和缓存&quot;&gt;【九章系统设计】从用户系统理解数据库和缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/05/【九章系统设计】一致性哈希-短网址系统设计/&quot; title=&quot;【九章系统设计】一致性哈希&amp;短网址系统设计&quot;&gt;【九章系统设计】一致性哈希&amp;短网址系统设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/10/【九章系统设计】爬虫系统与搜索建议系统/&quot; title=&quot;【九章系统设计】爬虫系统与搜索建议系统&quot;&gt;【九章系统设计】爬虫系统与搜索建议系统&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-机器学习&quot;&gt;&lt;a href=&quot;#3-机器学习&quot; class=&quot;headerlink&quot; title=&quot;3. 机器学习&quot;&gt;&lt;/a&gt;3. 机器学习&lt;/h1&gt;&lt;h3 id=&quot;3-1-线性模型&quot;&gt;&lt;a href=&quot;#3-1-线性模型&quot; class=&quot;headerlink&quot; title=&quot;3.1 线性模型&quot;&gt;&lt;/a&gt;3.1 线性模型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;【机器学习】LR&lt;/li&gt;
&lt;li&gt;【机器学习】svm&lt;/li&gt;
&lt;li&gt;【机器学习】PLA 线性感知机&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-2-树模型&quot;&gt;&lt;a href=&quot;#3-2-树模型&quot; class=&quot;headerlink&quot; title=&quot;3.2 树模型&quot;&gt;&lt;/a&gt;3.2 树模型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2017/03/04/【机器学习】决策树（一）：基础/&quot; title=&quot;决策树（一）：基础&quot;&gt;决策树（一）：基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/03/05/【机器学习】决策树（二）：连续值和缺失处理/&quot; title=&quot;决策树（二）：连续值和缺失处理&quot;&gt;决策树（二）：连续值和缺失处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/03/05/【机器学习】决策树（三）：多变量决策树/&quot; title=&quot;决策树（三）：多变量决策树&quot;&gt;决策树（三）：多变量决策树&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;gbdt&lt;/li&gt;
&lt;li&gt;RF&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/12/【机器学习】gbdt-xgboost-lightGBM比较/&quot; title=&quot;【机器学习】gbdt/xgboost/lightGBM比较&quot;&gt;【机器学习】gbdt/xgboost/lightGBM比较&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-3-评价指标等&quot;&gt;&lt;a href=&quot;#3-3-评价指标等&quot; class=&quot;headerlink&quot; title=&quot;3.3 评价指标等&quot;&gt;&lt;/a&gt;3.3 评价指标等&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2017/04/04/【机器学习】准确率、召回率、F1、ROC、AUC/&quot; title=&quot;准确率、召回率、F1、ROC、AUC&quot;&gt;准确率、召回率、F1、ROC、AUC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/03/16/【机器学习】熵、交叉熵/&quot; title=&quot;交叉熵&quot;&gt;交叉熵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/08/【机器学习】过拟合、欠拟合及其解决办法/&quot; title=&quot;过拟合、欠拟合及其解决办法&quot;&gt;过拟合、欠拟合及其解决办法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/09/【机器学习】生成模型vs判别模型、有监督vs无监督/&quot; title=&quot;生成模型vs判别模型、有监督vs无监督&quot;&gt;生成模型vs判别模型、有监督vs无监督&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-4-其他算法&quot;&gt;&lt;a href=&quot;#3-4-其他算法&quot; class=&quot;headerlink&quot; title=&quot;3.4 其他算法&quot;&gt;&lt;/a&gt;3.4 其他算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;PCA 主成分分析&lt;/li&gt;
&lt;li&gt;SVD 奇异值分解&lt;/li&gt;
&lt;li&gt;​&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;4-项目-amp-竞赛总结&quot;&gt;&lt;a href=&quot;#4-项目-amp-竞赛总结&quot; class=&quot;headerlink&quot; title=&quot;4. 项目&amp;amp;竞赛总结&quot;&gt;&lt;/a&gt;4. 项目&amp;amp;竞赛总结&lt;/h1&gt;&lt;h3 id=&quot;4-1-腾讯社交广告算法大赛&quot;&gt;&lt;a href=&quot;#4-1-腾讯社交广告算法大赛&quot; class=&quot;headerlink&quot; title=&quot;4.1 腾讯社交广告算法大赛&quot;&gt;&lt;/a&gt;4.1 腾讯社交广告算法大赛&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/06/【腾讯转化率预估】比赛总结/&quot; title=&quot;【腾讯转化率预估】总结&quot;&gt;【腾讯转化率预估】总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/07/【腾讯转化率预估】贝叶斯平滑/&quot; title=&quot;【腾讯转化率预估】贝叶斯平滑&quot;&gt;【腾讯转化率预估】贝叶斯平滑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/12/【机器学习】gbdt-xgboost-lightGBM比较/&quot; title=&quot;【机器学习】gbdt/xgboost/lightGBM比较&quot;&gt;【机器学习】gbdt/xgboost/lightGBM比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/03/14/【机器学习】FM，因子分解机/&quot; title=&quot;Factorization Machine（FM，因子分解机）&quot;&gt;Factorization Machine（FM，因子分解机）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/03/22/【机器学习】FFM（field-aware-Factorization-Machine）——升级版FM/&quot; title=&quot;FFM（field-aware Factorization Machine）——升级版FM&quot;&gt;FFM（field-aware Factorization Machine）——升级版FM&lt;/a&gt;​&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jiayi797.github.io/2017/06/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E4%B8%8D%E5%B9%B3%E8%A1%A1%E7%B1%BB%E7%9A%84%E5%A4%84%E7%90%86/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;机器学习实践-不平衡类的处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jiayi797.github.io/2017/04/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6-xgboost%E5%8F%82%E6%95%B0%E8%B0%83%E8%8A%82%E6%8C%87%E5%8D%97%EF%BC%88Python%E7%89%88%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;机器学习框架-xgboost参数调节指南（Python版&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4-2-编程之美&quot;&gt;&lt;a href=&quot;#4-2-编程之美&quot; class=&quot;headerlink&quot; title=&quot;4.2 编程之美&quot;&gt;&lt;/a&gt;4.2 编程之美&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/08/【2017编程之美】搜索引擎总结/&quot; title=&quot;【2017编程之美】搜索引擎总结&quot;&gt;【2017编程之美】搜索引擎总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;​&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4-3-实习&quot;&gt;&lt;a href=&quot;#4-3-实习&quot; class=&quot;headerlink&quot; title=&quot;4.3 实习&quot;&gt;&lt;/a&gt;4.3 实习&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt; item-based 协同过滤&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;5-语言相关&quot;&gt;&lt;a href=&quot;#5-语言相关&quot; class=&quot;headerlink&quot; title=&quot;5. 语言相关&quot;&gt;&lt;/a&gt;5. 语言相关&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2018/01/27/【Java】Java常用笔记/&quot; title=&quot;Java常用笔记&quot;&gt;Java常用笔记&lt;/a&gt; 写代码的时候总忘记的小东西&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/01/24/【Java】Java垃圾回收机制/&quot; title=&quot;理解Java垃圾回收机制&quot;&gt;理解Java垃圾回收机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/11/【Java】HashMap原理探究/&quot; title=&quot;【Java】HashMap原理探究&quot;&gt;【Java】HashMap原理探究&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;6-面试必备&quot;&gt;&lt;a href=&quot;#6-面试必备&quot; class=&quot;headerlink&quot; title=&quot;6. 面试必备&quot;&gt;&lt;/a&gt;6. 面试必备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/09/【面经】开发相关基础知识/&quot; title=&quot;【面经】开发相关基础知识&quot;&gt;【面经】开发相关基础知识&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/07/【面经】算法相关/&quot; title=&quot;【面经】算法相关&quot;&gt;【面经】算法相关&lt;/a&gt; 
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;7-计算广告相关&quot;&gt;&lt;a href=&quot;#7-计算广告相关&quot; class=&quot;headerlink&quot; title=&quot;7. 计算广告相关&quot;&gt;&lt;/a&gt;7. 计算广告相关&lt;/h1&gt;&lt;h3 id=&quot;6-1-系统相关&quot;&gt;&lt;a href=&quot;#6-1-系统相关&quot; class=&quot;headerlink&quot; title=&quot;6.1 系统相关&quot;&gt;&lt;/a&gt;6.1 系统相关&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/01/10/%E3%80%90DSP%E7%B3%BB%E7%BB%9F%E3%80%91Java-UDP%E9%80%9A%E4%BF%A1%E6%A8%A1%E6%8B%9F%E7%9B%91%E5%90%AC%E6%A8%A1%E5%9D%97/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【DSP系统】Java UDP通信模拟监听模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/01/09/DSP%E7%B3%BB%E7%BB%9Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%90%AD%E5%BB%BA/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DSP系统mysql数据库搭建&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;6-2-论文相关&quot;&gt;&lt;a href=&quot;#6-2-论文相关&quot; class=&quot;headerlink&quot; title=&quot;6.2 论文相关&quot;&gt;&lt;/a&gt;6.2 论文相关&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/12/10/DeepFM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DeepFM论文笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/12/07/WAND%E7%AE%97%E6%B3%95/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WAND检索算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/27/Bid-Optimizing-and-Inventory-Scoring-in-Targeted-Online%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bid Optimizing and Inventory Scoring in Targeted Online论文笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/07/17/Optimal-Real-Time-Bidding-for-Display-Advertising%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ptimal Real-Time Bidding for Display Advertising论文笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/22/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8ETop-k%E5%BF%AB%E9%80%9F%E6%A3%80%E7%B4%A2%E9%97%AE%E9%A2%98/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;搜索引擎Top-k快速检索问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/20/%E3%80%90RTB%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%91/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RTB论文笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/02/DSP%E5%9B%BD%E5%86%85%E7%A1%95%E5%A3%AB%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DSP国内硕士论文总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【2017编程之美】搜索引擎总结</title>
    <link href="http://yoursite.com/2018/03/08/%E3%80%902017%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E3%80%91%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/08/【2017编程之美】搜索引擎总结/</id>
    <published>2018-03-08T03:24:00.000Z</published>
    <updated>2018-03-16T09:35:02.423Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要回顾和总结2017编程之美决赛中校园聊天机器人后端搜索引擎的实现。</p><h2 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h2><p>校园聊天机器人，针对用户的问题进行回答，当然，问题都是跟校园相关的一些问题。</p><p>收集校主页和论坛上的信息，招聘信息、征友信息、失物招领等信息，根据用户的需求返回合适的答案。</p><h2 id="2-爬虫"><a href="#2-爬虫" class="headerlink" title="2. 爬虫"></a>2. 爬虫</h2><p>北邮人论坛格式相对工整，并不需要进行DFS爬取。论坛某个页面如下：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-02-19-39-36.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-02-19-39-36.png" alt="img"></a></p><p>论坛格式基本如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1  [标题，最新回复时刻]</div><div class="line">2  [标题，最新回复时刻]</div><div class="line">...</div><div class="line">10 [标题，最新回复时刻]</div><div class="line"></div><div class="line"></div><div class="line">              第k页</div></pre></td></tr></table></figure><p>因此只需要按页遍历即可。</p><h3 id="2-1-数据库设计"><a href="#2-1-数据库设计" class="headerlink" title="2.1 数据库设计"></a>2.1 数据库设计</h3><p>爬取的内容建立一张表放入MySQL。由于每个帖子都有自己的唯一性ID，因此可以将这个ID作为主键。</p><div class="table-container"><table><thead><tr><th>文章ID（主键）</th><th>标题（已分词）</th><th>最后更新时刻</th><th>内容（已分词）</th><th>链接</th><th>已索引</th></tr></thead><tbody><tr><td>758943</td><td>社招/神马/搜索/北京/资深/广告/算法/研发/工程师</td><td>20180302 165751</td><td>基于/大规模/用户/行为/效果/目标/建立/优化/推荐/系统/基础/算法/策略 ….</td><td><a href="https://bbs.byr.cn/#!article/JobInfo/758943" target="_blank" rel="external">https://bbs.byr.cn/#!article/JobInfo/758943</a></td><td>是/否</td></tr><tr><td></td><td>…</td><td>…</td><td>…</td><td></td></tr></tbody></table></div><h3 id="2-2-实时爬虫"><a href="#2-2-实时爬虫" class="headerlink" title="2.2 实时爬虫"></a>2.2 实时爬虫</h3><p>由于北邮人论坛的【缘分天空】、【毕业生找工作】、【兼职实习信息】等板块很热火，几乎每小时都有新帖。因此可以不考虑资源浪费问题，直接采用定时爬虫进行信息更新和维护。</p><p>实时爬虫的流程如下：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-02-20-13-35.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-02-20-13-35.png" alt="img"></a></p><p>对于每个页面，我们可以从页面目录快速获取【文章ID、标题、发帖时刻、回复量、最新回复时刻、文章链接】信息。因此当获取到本页面的10篇文章的ID和最新回复时刻TimeStamp后：</p><ol><li><p>看库中是否存在此ID</p><ol><li><p>如果存在：</p><ol><li><p>此帖在近期有回复，更新最新回复时刻TimeStamp</p></li><li><p>此帖在近期无回复，有两种可能：</p><ol><li>后面的帖子不再有新的回复，因此可以直接停止本版面的爬虫；</li><li>爬取第1页时，本帖在第1页；爬取第2页时，本帖被顶到第2页；</li></ol><p>为了不让情况2误认为是近期无更新的贴，因此我们设置50次阈值。当连续50篇文章都没有新的更新时，停止爬虫。</p></li></ol></li><li><p>如果不存在，则爬取本页面并添加进数据库</p></li></ol></li></ol><p>对于每个版块的每个页面，执行以上循环操作。每个页面包含10篇左右文章。由于每篇文章打开需要约1秒，因此一页需要10多秒。北邮人论坛设置反爬虫机制，每连续访问10次后就要休息10秒才可以继续爬。而【毕业生找工作】等热门版面每日的更新量达300+条。那么完成一次此版面的爬取需要10分钟。三个版面的爬取大约需要20分钟。这个时间太长了，不利于后续的实施构建索引。</p><p>为了加速爬取速度，我们采用了多线程爬取技术。为了避免重复写入，因此每个线程只负责一个页面。当爬取完毕时，将数据扔到“待写入队列”里排队写入MySQL。</p><h3 id="2-3-分词"><a href="#2-3-分词" class="headerlink" title="2.3 分词"></a>2.3 分词</h3><p>利用jieba分词模块，对爬取的文档进行分词，首先按是否为汉字、数字、英文字符及标点符号对新闻内容进行梳理，去除掉信息缺失的数据，然后用jieba分词对标题及内容进行分词，并去掉停用词、生僻字等，得到文章的分词内容【这一步骤在爬虫模块已完成】。另外对于北邮人常用的找工作模块，需自定义计算机类技术栈关键词，如Python、Java、计算广告、推荐系统等。</p><p>分好词之后就可以存入数据库了。</p><p>jieba分词用到了哪些算法，文档里面如下介绍：</p><p>• 基于Trie树结构实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图（DAG）<br>• 采用了<strong>动态规划查找最大概率路径</strong>, 找出基于词频的最大切分组合<br>• 对于未登录词，采用了基于汉字成词能力的<strong>HMM模型</strong>，使用了Viterbi算法（隐马尔科夫模型）</p><p><strong>日后需要补习</strong></p><h2 id="3-索引构建-amp-检索"><a href="#3-索引构建-amp-检索" class="headerlink" title="3. 索引构建&amp;检索"></a>3. 索引构建&amp;检索</h2><h3 id="3-1-向量空间模型"><a href="#3-1-向量空间模型" class="headerlink" title="3.1 向量空间模型"></a>3.1 向量空间模型</h3><p><strong>检索结果排序是搜索引擎最核心的部分，</strong>很大程度度上决定了搜索引擎的质量好坏及用户满意度。实际搜索结果排序的因子有很多，但最主要的两个因素是用户查询和网页内容的相关度，以及网页链接情况。这里我们主要总结网页内容和用户查询相关的内容。</p><p>​       判断网页内容是否与用户査询相关，这依赖于搜索引擎所来用的检索模型。检索模型是搜索引擎的理论基础，为量化相关性提供了一种数学模型，是对查询词和文档之间进行相似度计算的框架和方法。其本质就是相关度建模。</p><p><strong>常见检索模型：布尔模型，向量空间模型，概率模型，语言模型，机器学习排序算法</strong></p><ol><li><p>布尔模型</p><p>苹果 AND 公司：表示搜索既包含“苹果”，又包含“公司”这两个词的文档。<br>苹果 OR 公司：表示搜索包含“苹果”，或包含“公司”这两个词中任意一个的文档。<br>特点：简单粗暴</p></li><li><p><strong>向量空间模型</strong></p><p>苹果 AND 公司：表示搜索既包含“苹果”，又包含“公司”这两个词的文档。<br>苹果 OR 公司：表示搜索包含“苹果”，或包含“公司”这两个词中任意一个的文档。<br>特点：简单粗暴</p><p>本文就是采用这样的方式</p></li><li><p>概率检索模型</p><p>概率检索模型基于概率排序原理，是目前效果最好的模型之一，okapi BM25这一经典概率模型计算公式已经在商业搜索引擎的网页排序中广泛应用。</p><p>I. 概率排序原理</p><p>基本思想：给定一个用户查询，若搜索系统能在搜索结果排序时按照文档和用户查询的相关性由高到低排序，那么这个搜索系统的准确性是最优的。</p><p>II. 实际实现</p><ol><li>根据用户的查询将文档集合划分为两个集合：相关文档子集和不相关文档子集。</li><li>将相关性衡量转换为分类问题，对某个文档D来说，若其属于相关文档子集的概率大于属于不相关文档的概率，就认为它与查询相关。</li></ol><p>另P(R|D)代表给定一个文档D对应的相关性概率，而P(NR|D)代表该文档的不相关概率，若P(R|D)&gt;P(NR|D)我们就认为此文档与查询相关。</p><p>根据贝叶斯定理（详见<a href="http://blog.csdn.net/zealfory/article/details/77853128" target="_blank" rel="external">贝叶斯公式推导及意义</a>）,最终等价于计算:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(R|D)/P(NR|D)</div></pre></td></tr></table></figure><p>搜索系统无需分类，只需将文档按照上式大小降序排列即可。</p><p>III. 估值公式<br>基于二元独立模型（BIM）的二元假设和词汇独立性假设，得到最终的相关性估算公式：</p><p><img src="http://img.blog.csdn.net/20170923100608912?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemVhbGZvcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="估算公式"><br>其中pi代表第i个单词在相关文档集合中出现的概率，si代表第i个单词在不相关文档集合中出现的概率。</p><p>取log便于计算：<br><img src="http://img.blog.csdn.net/20170923100720285?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemVhbGZvcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li><li><p>统计语言模型</p><p>基本思想：<br>​    其他的检索模型的思考路径是从<strong>查询</strong>到文档，即给定用户<strong>查询</strong>，如何找出相关的文档，该模型的思路正好想法，是由文档到<strong>查询</strong>这个方向，即为每个文档建立不同的语言模型，判断由文档生成用户<strong>查询</strong>的可能性有多大，然后按照这种生成概率由高到低排序，作为搜索结果。语言模型代表了单词或者单词序列在文档中的分布情况；</p><p>举个例子：</p><p>先引入一个概念：抽取概率<br>把一篇文档进行分词，统计其中每个词的出现频率进行计数，则一个词Word在文档Doc中的抽取概率为“Word词的计数/Doc中所有词的计数之和”。所谓抽取概率，就是在Doc中随机抽取一个词的话，Word被抽取到的概率。<br>假设用户搜索“野鸟装备 跑步”，野鸟装备在文档Doc1中的抽取概率1%，跑步的抽取概率为2%，则该次搜索中，Doc1的相关性得分为1%*2%。依此可以计算出所有文档的相关性得分，并按相关性得分对搜索结果进行排序。 </p></li><li><p>机器学习模型</p><p>机器学习与前面的模型相比，有几个显著的不同：<br>1、这里一般使用有监督的机器学习，因此需要对训练结果有监督反馈，用户对搜索结果的隐性评价（即点击）可以看作是一种监督反馈。<br>2、传统搜索计算搜索结果相关性一般也就考虑关键词匹配、词频等少数几个维度的数据，使用前面提到的模型已经足够，只有当考察的数据维度比较多时，机器学习的优势才会体现出来。比如像百度、Google这种大型的商业搜索引擎，考察的数据维度要多很多，比如链入链出链接数、网站类型、网站权威度、用户地理位置、历史搜索习惯、设备类型等等，据说Google考察的数据维度多达几百个。<br>特点：复杂度高，适合大型商业搜索引擎。</p><p><a href="http://blog.csdn.net/starzhou/article/details/51438140" target="_blank" rel="external">机器学习排序之Learning to Rank简单介绍</a></p></li></ol><h3 id="3-2-TF-IDF"><a href="#3-2-TF-IDF" class="headerlink" title="3.2 TF-IDF"></a>3.2 TF-IDF</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-08-13-40-07.png" alt=""></p><h3 id="3-3-倒排索引构建"><a href="#3-3-倒排索引构建" class="headerlink" title="3.3 倒排索引构建"></a>3.3 倒排索引构建</h3><p>对每个词来说更新“词-文章序号”的倒排列表。倒排列表的结构如下：</p><div class="table-container"><table><thead><tr><th>ID</th><th>词</th><th>文档频率</th><th>倒排记录表</th></tr></thead><tbody><tr><td>0</td><td>中国</td><td>3</td><td>1,3,4</td></tr><tr><td>1</td><td>招聘</td><td>1</td><td>4，</td></tr><tr><td>2</td><td>蜜蜂</td><td>2</td><td>1,2</td></tr></tbody></table></div><h3 id="3-4-计算各文档的向量"><a href="#3-4-计算各文档的向量" class="headerlink" title="3.4 计算各文档的向量"></a>3.4 计算各文档的向量</h3><p>假如文档1包含的词有【中国，蜜蜂】，按照上字典序号对应的关系，词向量应该为[1,0,1][1,0,1] 。而用01表示词其实并不科学，这里每个词可以用TF-IDF来优化。那么词向量可能会变成[0.2,0,0.1][0.2,0,0.1]</p><p>计算每个文档的词向量（下表不必存储）：</p><div class="table-container"><table><thead><tr><th>文档</th><th>词</th><th>词向量</th></tr></thead><tbody><tr><td>1</td><td>中国，蜜蜂</td><td>[0.2,0,1][0.2,0,1]</td></tr><tr><td>2</td><td>蜜蜂</td><td>[0,0,0.8][0,0,0.8]</td></tr><tr><td>3</td><td>中国</td><td>[0.7,0,0][0.7,0,0]</td></tr><tr><td>4</td><td>中国，招聘</td><td>[0.4,0.6,0][0.4,0.6,0]</td></tr></tbody></table></div><p>将词向量模型更新添加进倒排索引：</p><div class="table-container"><table><thead><tr><th>词</th><th>文档频率</th><th>倒排记录表[文章ID，权重]</th></tr></thead><tbody><tr><td>中国</td><td>3</td><td>[1,0.2] , [3,0.7] , [4,0.4]</td></tr><tr><td>招聘</td><td>1</td><td>[4,0.6]</td></tr><tr><td>蜜蜂</td><td>2</td><td>[1,0.1], [2,0.8]</td></tr></tbody></table></div><p>其中每个文档中某个词的TF值只与该文档有关，但是IDF是与当前倒排表相关的，计算的时候这里需要主要 </p><h3 id="3-5-检索"><a href="#3-5-检索" class="headerlink" title="3.5 检索"></a>3.5 检索</h3><p>当用户输入查询词时，例如查询【中国，招聘】这两个关键字时，由于关键字无权重，因此可以直接设查询向量qq为[1,1,0][1,1,0] 。按理来说应该直接对着【文档dd-词向量】表格直接依次计算余弦相似度q×dq×d，然后取相似度最高的前K个作为返回结果。但是这样太暴力了，也太慢了。</p><p>机智的人类发现，q是一个01向量， q×dq×d 也就是对于q中那些为1的词项，计算在文档d中这些词的权重值和。</p><p>因此我们利用倒排索引优化查询。步骤为：</p><ol><li>在词典中定位【中国，招聘】这两个词，返回其倒排记录表。【中国 –&gt; [1,0.2] , [3,0.7] , [4,0.4]】，【招聘 –&gt; [4,0.6]】</li><li>文档4中，中国和招聘两个词的权重值和为1；而文档1的权重为0.2；文档3的权重为0.7</li></ol><h3 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h3><ol><li><strong>索引构建/更新流程图</strong></li></ol><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-02-23-00-07.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-02-23-00-07.png" alt="img"></a></p><ol><li><strong>倒排索引数据库设计</strong></li></ol><p>将爬好的数据进行实时权重向量计算，填入下表，即是倒排表</p><div class="table-container"><table><thead><tr><th>词</th><th>文档频率</th><th>倒排记录表</th></tr></thead><tbody><tr><td>中国</td><td>3</td><td>[1,0.2] , [3,0.7] , [4,0.4]</td></tr><tr><td>招聘</td><td>1</td><td>[4,0.6]</td></tr><tr><td>蜜蜂</td><td>2</td><td>[1,0.1], [2,0.8]</td></tr></tbody></table></div><p>当时这个结构直接存储在了内存当中。但讲道理应该存储在MongoDB这一类KV数据库中。</p><h2 id="4-旧数据删除"><a href="#4-旧数据删除" class="headerlink" title="4. 旧数据删除"></a>4. 旧数据删除</h2><p>​    后续如果数据量不断增大，可以考虑将一些陈旧的帖子删除，比如保留最近半年有过更新的帖子，不过这还要考虑机器的容量。</p><p>本系统定义每天的凌晨4点进行旧数据清除工作。</p><p>​    每个帖子是有有效期的。当某个帖子过了某个时间后信息量就会变得很少，不再有检索需求。因此需要将旧帖子删掉。由于机器硬盘限制，本系统设定当帖子的最后更新时刻与当前时刻超过10天时，此贴应该被从数据库与索引中删除。</p><p>​    本系统定义每天的凌晨4点进行旧数据清除工作。</p><h2 id="5-优化"><a href="#5-优化" class="headerlink" title="5. 优化"></a>5. 优化</h2><p>回头重新看这个问题时，我们发现如果有高并发等类似的请求时，系统还有很多地方需要优化：</p><h3 id="5-1-检索模型角度"><a href="#5-1-检索模型角度" class="headerlink" title="5.1 检索模型角度"></a>5.1 检索模型角度</h3><p>可以结合其他模型，比如概率模型、语言模型等，如果有一定的用户量之后可以结合learn to rank模型</p><h3 id="5-2-字典优化角度"><a href="#5-2-字典优化角度" class="headerlink" title="5.2 字典优化角度"></a>5.2 字典优化角度</h3><p>在实现字典时，通常会使用哈希表、树（二查查找树、字典树）等数据结构。</p><p><strong>用二叉查找树实现字典</strong></p><p>使用二叉查找树实现词典时， 要先将数据对（的列表） <strong>按照单词词典顺序排列</strong>。</p><p>数据对 = [单词 + 该单词的倒排列表的引用（地址）]</p><p>若用内存上的二叉查找树实现之前例子中的词典， 就会得到如下图所示的树形结构。 树中的各个结点是通过地址引用（指针） 连接起来的</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-12-27.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-12-27.png" alt="img"></a></p><p>一般倒排列表都会很长，字典很大。因此会考虑将倒排列表存储到二级存储的连续区域中。</p><p>在二级存储上实现词典时，也要先将数据对按照单词的词典顺序排列， 然后一个接一个地存储到存储器上。 但是， 如果只是单纯地一个接一个地存储， 就无法知道各数据对应该在哪里结束了， 因此在此之上还要维护一个列表， 用于存储从开头算起每个数据对的偏移量。 对应的数据结构如图所示。 在进行检索时， 可以对该偏移量的列表进行二分查找。</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-14-28.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-14-28.png" alt="img"></a></p><p>如果词典能够完整地加载到内存， 那么所形成的二叉树的搜索效率将会非常高。 特别是当二叉树处于平衡状态时， 平均进行log2Nlog2N 次查找就能找到单词。<br>但是， 如果词典无法完整地加载到内存， 而必须存储到二级存储器上时， 二叉树就未必是高效的数据结构了。 HDD 或 SSD 等二级存储器一般被称作“块设备”， 由于它们是以块为单位进行输入输出的 ， 所以即使只是读取块中 1 个字节的数据， 也不得不对整个块进行输入输出操作。 例如， 假设我们用二叉查找树实现了含有 100 万个单词的词典， 那么进行二分查找的话， 平均需要 20 次查找， 因此在最坏的情况下就需要加载 20 个块。 也就是说， 假设二级存储的加载性能为 5ms/ 块， 那么在 1 次检索中， 仅花费在二级存储输入输出上的时间就高达100ms。<br>因此， 当要存储大型词典时， 往往要使用适合块设备的 B+ 树等树形数据结构。</p><p><strong>用B+树实现字典</strong></p><p>B+ 树是一种平衡的多叉树， 属于从 B 树派生出来的树形结构。 在 B+ 树中， 所有的记录都存储在树中的叶结点（Leaf Node） 上， 内部结点（Internal Node） 上只以关键字的顺序存储关键字</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-43-00.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-43-00.png" alt="img"></a></p><p><strong>B+树通常以文件系统中页尺寸的常数倍为单位管理各节点。这样有助于减少检索时对二级存储的输入输出次数。</strong></p><h3 id="5-2-倒排索引构建-更新角度"><a href="#5-2-倒排索引构建-更新角度" class="headerlink" title="5.2 倒排索引构建/更新角度"></a>5.2 倒排索引构建/更新角度</h3><p>简单的文档列表直接存储在内存中。比如我们的项目搜索引擎的倒排索引就是放在内存中的，但是大多数情况倒排索引都是非常稀疏的表，因此用链表实现倒排索引非常好。</p><p>而<strong>文档链表一般都很大，因此很多都存储在二级存储中</strong>。这样就有两种构建方法：基于排序的构建方法和基于合并的构建方法。</p><p><strong>基于排序的索引构建法</strong></p><ol><li>对各文档中构成该文档的每个单词都建立一条【单词、文档编号、TF】的记录。然后将该记录写入二级存储上的文件末尾</li><li>将文件各条记录按照字典顺序排列；单词字段相同的再按照文档编号顺序排列</li><li>逐行读取排序后的文件，取出每个单词的文档编号列表；并用这些列表构建每个单词的倒排索引（这一步可以压缩倒排列表，此处省略）</li></ol><p><strong>基于合并的索引构建法</strong></p><p>基于合并的索引构建法是一种先在内存上构建出倒排索引的片段，然后将这些片段导出到二级存储，最后将导出的多个倒排索引合并在一起。</p><ol><li>在内存上构建【单词-倒排】的kv映射表Map。</li><li>如果某单词不在Map里，就要将该单词加入到Map中</li><li>当Map过大，就将Map导入文件里</li><li>重复1-3步骤，直到处理完所有文档。最后利用多路归并将将导出的各文件合并在一起。（这一步也可以压缩倒排，此处省略）</li></ol><p><strong>动态索引构建</strong></p><p>之前说的索引构建方法都是只有构建完成后才可用于检索。这叫静态构建方法（Offline Index Construction）。</p><p>还有一种动态构建方法（Online Index Construction / Dynamic Indexing）。这种方法可以<strong>一边更新索引，一边检索</strong>。其基本策略如下所示：</p><ul><li>将索引分成内存上的索引和磁盘上的索引分别管理</li><li>添加文档后，优先更新内存上的索引</li><li>当内存索引满时，将其整合到磁盘上的索引中</li></ul><h3 id="5-3-倒排索引压缩"><a href="#5-3-倒排索引压缩" class="headerlink" title="5.3 倒排索引压缩"></a>5.3 倒排索引压缩</h3><p>为什么要进行压缩？</p><p>如果数据量很大，倒排索引庞大，在使用倒排索引进行检索的过程中，总检索时间中的大部分时间往往花费在了<strong>从二级存储读取倒排索引</strong>上。于是，就经常可以看到在存储倒排索引前，对其进行压缩以减少从二级存储读取的时间，进而使检索处理得以高速运转的对策。</p><p>也就是说，我们可以根据如下原理，通过压缩倒排索引来加快检索处理的速度。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">从二级存储中读取（部分）经过压缩的倒排索引的时间＋还原倒排索引的时间</div><div class="line">＜从二级存储中读取（部分）尚未经过压缩的倒排索引的时间</div></pre></td></tr></table></figure><p>倒排索引的压缩分为针对词典的压缩和针对倒排文件的压缩两种。<br>我们可以通过使用更少的信息量表示单词的集合来实现词典的压缩。例如，对于按照词典顺序排列的单词列表而言，通过避免重复存储相同的前缀，就可以减少存储词典时所需的必要存储空间。但是，在大多数情况下，由于词典的大小远远小于倒排文件的大小，所以一般认为压缩词典对于加快检索处理的速度并没有太大的贡献。</p><p>而倒排文件的压缩，可以通过使用更少的信息量表示其构成要素来实现。构成要素就是指文档编号、单词在文档内的出现次数（TF，Term Frequency，词频）以及由单词在文档内的偏移量构成的整数数组。</p><p><strong>使用可变长度的编码确实可以带来大幅度的压缩</strong>。</p><p>待填坑==</p><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ol><li><a href="https://jiayi797.github.io/2018/03/02/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%9B%9E%E9%A1%BE/" target="_blank" rel="external">自制搜索引擎</a></li><li><a href="http://blog.csdn.net/guoziqing506/article/details/64122287" target="_blank" rel="external">B树与B+树</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/03/tf-idf.html" target="_blank" rel="external">TF-IDF与余弦相似性的应用（一）：自动提取关键词</a></li><li><a href="http://blog.csdn.net/starzhou/article/details/51438140" target="_blank" rel="external">机器学习排序之Learning to Rank简单介绍</a></li><li><a href="http://blog.csdn.net/hguisu/article/details/7981145" target="_blank" rel="external"> 搜索引擎的检索模型-查询与文档的相关度计算</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要回顾和总结2017编程之美决赛中校园聊天机器人后端搜索引擎的实现。&lt;/p&gt;
&lt;h2 id=&quot;1-项目简介&quot;&gt;&lt;a href=&quot;#1-项目简介&quot; class=&quot;headerlink&quot; title=&quot;1. 项目简介&quot;&gt;&lt;/a&gt;1. 项目简介&lt;/h2&gt;&lt;p&gt;校园聊天机器人
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】动态规划</title>
    <link href="http://yoursite.com/2018/03/08/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2018/03/08/【九章算法强化班】动态规划/</id>
    <published>2018-03-08T01:37:45.000Z</published>
    <updated>2018-03-12T12:35:15.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><p>滚动数组</p><ul><li>house robber I/II</li><li>Maximal Square</li></ul><p>记忆化搜索</p><ul><li>longest increasing subsequence</li><li>coins in a line</li></ul><h2 id="动态规划四要素"><a href="#动态规划四要素" class="headerlink" title="动态规划四要素"></a>动态规划四要素</h2><ol><li>状态</li><li>转移方程</li><li>初始化</li><li>答案</li></ol><h2 id="滚动数组优化"><a href="#滚动数组优化" class="headerlink" title="滚动数组优化"></a>滚动数组优化</h2><p>f[i] = max(f[i-1],f[i-2]+A[i]);</p><p>转化为：</p><p>f[i%2] = max(f[(i-1)%2],f[(i-2)%2])</p><p>滚动数组优化不会对时间复杂度进行优化，而只是对空间进行优化</p><h3 id="例题1-House-Robber"><a href="#例题1-House-Robber" class="headerlink" title="例题1. House Robber"></a>例题1. <a href="https://leetcode.com/problems/house-robber" target="_blank" rel="external">House Robber</a></h3><p>给定一个数组，代表抢劫商店可以获得的价值，不可以抢劫相邻的商店，计算能够获得的最大价值</p><p>思路：</p><p><strong>序列型dp</strong></p><p><code>f[i]</code>代表抢劫前i个商店能够获得的最大值</p><p>对于店铺i可以有抢和不抢两种情况：</p><ol><li>如果抢，则不能抢f[i-1]，则前i个商店的最大值为前i-2个商店的最大值加上第i个商店的价值</li><li>如果不抢，则前i个商店的最大值=前i-1个商店的最大值</li></ol><p>取两种情况的最大值</p><p>转移方程:f[i] = max(f[i-1],f[i-2]+nums[i])</p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; nums.length;i++)&#123;</div><div class="line">        dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>] + nums[i]);</div><div class="line">        System.out.println(dp[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>用滚动数组优化</strong></p><p>转移方程：<code>f[i] = max(f[i-1],f[i-2]+nums[i])</code></p><p>根据前面的分析，对于每一个商店i，我们只需要考虑商店i-1和i-2，也就是状态i只与它的前两个状态有关，所以我们只需要维护一个长度为2的数组来记录状态即可。</p><p>状态转移方程转化为<code>f[i%2] = max(f[(i-1)%2],f[(i-2)%2]+nums[i])</code></p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; nums.length;i++)&#123;</div><div class="line">        dp[i%<span class="number">2</span>] = Math.max(dp[(i-<span class="number">1</span>)%<span class="number">2</span>],dp[(i-<span class="number">2</span>)%<span class="number">2</span>] + nums[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[(nums.length-<span class="number">1</span>)%<span class="number">2</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这道题是状态只与前两个状态有关，如果推广到一般，如果状态i与前k个状态有关，则有：</p><p><code>f[i%k] = max(f[(i-1)%k],f[(i-2)%k]+nums[i])</code></p><h3 id="例题2-House-Robber-II"><a href="#例题2-House-Robber-II" class="headerlink" title="例题2. House Robber II"></a>例题2. <a href="https://leetcode.com/problems/house-robber-ii" target="_blank" rel="external">House Robber II</a></h3><p>首尾商店算相邻的商店，也就是商店是一个环。</p><p>思路：</p><p>对于成环的问题有两个小技巧：</p><ol><li>拆分数组的方式，将计算一个数组的问题转化成计算两个数组：<ol><li>去掉最后一个元素</li><li>去掉第一个元素</li></ol></li><li>将原数组copy一份，首尾相接，本题不适用</li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len = nums.length;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[] dp1 = <span class="keyword">new</span> <span class="keyword">int</span> [len-<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span>[] dp2 = <span class="keyword">new</span> <span class="keyword">int</span> [len-<span class="number">1</span>];</div><div class="line">    dp1[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">    dp1[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    dp2[<span class="number">0</span>] = nums[<span class="number">1</span>];</div><div class="line">    dp2[<span class="number">1</span>] = Math.max(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len-<span class="number">1</span>;i++)&#123;</div><div class="line">        dp1[i] = Math.max(dp1[i-<span class="number">1</span>],dp1[i-<span class="number">2</span>] + nums[i]);</div><div class="line">        dp2[i] = Math.max(dp2[i-<span class="number">1</span>],dp2[i-<span class="number">2</span>] + nums[i+<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Math.max(dp1[nums.length-<span class="number">2</span>],dp2[nums.length-<span class="number">2</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>滚动数组优化：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len = nums.length;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[] dp1 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span>[] dp2 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];</div><div class="line">    dp1[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">    dp1[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    dp2[<span class="number">0</span>] = nums[<span class="number">1</span>];</div><div class="line">    dp2[<span class="number">1</span>] = Math.max(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len-<span class="number">1</span>;i++)&#123;</div><div class="line">        dp1[i%<span class="number">2</span>] = Math.max(dp1[(i-<span class="number">1</span>)%<span class="number">2</span>],dp1[(i-<span class="number">2</span>)%<span class="number">2</span>] + nums[i]);</div><div class="line">        dp2[i%<span class="number">2</span>] = Math.max(dp2[(i-<span class="number">1</span>)%<span class="number">2</span>],dp2[(i-<span class="number">2</span>)%<span class="number">2</span>] + nums[i+<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Math.max(dp1[(nums.length-<span class="number">2</span>)%<span class="number">2</span>],dp2[(nums.length-<span class="number">2</span>)%<span class="number">2</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题3-Maximal-Square"><a href="#例题3-Maximal-Square" class="headerlink" title="例题3. Maximal Square"></a>例题3. <a href="https://leetcode.com/problems/maximal-square" target="_blank" rel="external">Maximal Square</a></h3><blockquote><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p>For example, given the following matrix:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 0 1 0 0</div><div class="line">&gt; 1 0 1 1 1</div><div class="line">&gt; 1 1 1 1 1</div><div class="line">&gt; 1 0 0 1 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Return 4.</p></blockquote><p>找到全为1的正方形的最大面积</p><p>思路：</p><p>定位正方形，需要一个三维数组[x,y,a]</p><p>其中xy为正方形顶点坐标，a为边长</p><p><strong>baseline：</strong></p><p>x,y,a三层循环从0到n，然后x，y从1到a一共5层循环，复杂度<script type="math/tex">O(n^5)</script></p><p><strong>dp</strong></p><p>对于一个点<code>(i,j)</code> (nums[i,j] = 1)，如要计算以其为右下角的最大正方形边长，需要考虑三个点：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-21-14-20-12.png" alt=""> </p><ol><li>以(i-1,j-1)为右下角的最大正方形边长</li><li>以(i,j-1)为最右点的矩形长度</li><li>以(i-1,j)为最下点的矩形长度</li></ol><p>取三个值中最小的+1就是以(i,j)为右下角的矩形最大边长</p><p>因此：</p><ol><li><p>状态：</p><p><code>f[i][j]</code>表示以以(i,j)为右下角的矩形最大边长</p></li><li><p>转移方程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if(matrix[i][j] == 1)&#123;</div><div class="line">  f[i][j] = max(f[i-1],[j-1],up[i-1][j],left[i][j-1])+1</div><div class="line">&#125;</div><div class="line">if(matrix[i][j] == 0)&#123;</div><div class="line">  f[i][j] = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>改进：</p><p>上面的方法除了维护f之外，还需要维护up和left数组，其实可以直接用f来代替up和left。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>)&#123;</div><div class="line">  f[i][j] = max(f[i-<span class="number">1</span>],[j-<span class="number">1</span>],f[i-<span class="number">1</span>][j],f[i][j-<span class="number">1</span>])+<span class="number">1</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</div><div class="line">  f[i][j] = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>初始化</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">f[i][0] = matrix[i][0]</div><div class="line">f[0][j] = matrix[0][j]</div></pre></td></tr></table></figure></li><li><p>答案</p><p><code>max(f[i][j])</code></p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxSquare = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;rows;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="string">'1'</span>)&#123;</div><div class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">                maxSquare = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;cols;j++) &#123;</div><div class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j] == <span class="string">'1'</span>)&#123;</div><div class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</div><div class="line">                maxSquare = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; cols;j++) &#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</div><div class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]))+<span class="number">1</span>;</div><div class="line">                    maxSquare = Math.max(maxSquare, dp[i][j]);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    dp[i][j] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxSquare*maxSquare;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>滚动数组优化：</strong></p><p>对于每一个元素(i,j)，只与它前一行和前一列的元素有关，与其前两行的元素无关，因此可以对其行进行滚动数组优化</p><p>转移方程变为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if(matrix[i][j] == 1)&#123;</div><div class="line">  f[i%2][j] = max(f[(i-1)%2],[j-1],f[(i-1)%2][j],f[i%2][j-1])+1</div><div class="line">&#125;</div><div class="line">if(matrix[i][j] == 0)&#123;</div><div class="line">  f[i%2][j] = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxSquare = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;cols;j++) &#123;</div><div class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j] == <span class="string">'1'</span>)&#123;</div><div class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</div><div class="line">                maxSquare = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++) &#123;</div><div class="line">                <span class="comment">//每行第一个元素</span></div><div class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</div><div class="line">                    <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</div><div class="line">                        dp[i%<span class="number">2</span>][j] = <span class="number">1</span>;</div><div class="line">                        maxSquare = Math.max(maxSquare, dp[i%<span class="number">2</span>][j]);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span>&#123;</div><div class="line">                        dp[i%<span class="number">2</span>][j] = <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</div><div class="line">                    dp[i%<span class="number">2</span>][j] = Math.min(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][j-<span class="number">1</span>],Math.min(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][j],dp[i%<span class="number">2</span>][j-<span class="number">1</span>]))+<span class="number">1</span>;</div><div class="line">                    maxSquare = Math.max(maxSquare, dp[i%<span class="number">2</span>][j]);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    dp[i%<span class="number">2</span>][j] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxSquare*maxSquare;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>follow up：</strong></p><p>01矩阵里面找一个，对角线全为1， 其他为0的正方形</p><p>转移方程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if(matrix[i][j] == 1)&#123;</div><div class="line">  f[i][j] = max(f[i-1],[j-1],up[i-1][j],left[i][j-1])+1</div><div class="line">&#125;</div><div class="line">if(matrix[i][j] == 0)&#123;</div><div class="line">  f[i][j] = 0;</div><div class="line">&#125;</div><div class="line">其中up和left表示前面连续0的个数</div></pre></td></tr></table></figure><h3 id="二维动态规划空间优化（二维滚动数组）总结"><a href="#二维动态规划空间优化（二维滚动数组）总结" class="headerlink" title="二维动态规划空间优化（二维滚动数组）总结"></a>二维动态规划空间优化（二维滚动数组）总结</h3><p>这类题目特点：</p><p><code>f[i][j]</code> = 由f[i-1]行 来决定状态， 第i行跟 i-1行之前毫无关系， 所以状态转变为：</p><p><code>f[i%2][j]</code> = 由f[(i-1)%2]行来决定状态</p><p>还有一些题目可以用滚动数组进行优化：</p><h3 id="习题1-Unique-Paths"><a href="#习题1-Unique-Paths" class="headerlink" title="习题1. Unique Paths"></a>习题1. <a href="https://leetcode.com/problems/unique-paths" target="_blank" rel="external">Unique Paths</a></h3><h3 id="习题2-Minimum-Path-Sum"><a href="#习题2-Minimum-Path-Sum" class="headerlink" title="习题2. Minimum Path Sum"></a>习题2. <a href="https://leetcode.com/problems/minimum-path-sum" target="_blank" rel="external">Minimum Path Sum</a></h3><h3 id="习题3-Edit-Distance"><a href="#习题3-Edit-Distance" class="headerlink" title="习题3. Edit Distance"></a>习题3. <a href="https://leetcode.com/problems/edit-distance" target="_blank" rel="external">Edit Distance</a></h3><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><ul><li>本质上是动态规划</li><li>动态规划就是解决了重复计算的搜索</li><li>动态规划的实现方式：<ul><li>循环（从小到大递推）</li><li>记忆化搜索（从大到小）<ul><li>画搜索树</li><li>滚动数组优化，万金油</li></ul></li></ul></li></ul><h3 id="例题1-Longest-Increasing-Subsequence"><a href="#例题1-Longest-Increasing-Subsequence" class="headerlink" title="例题1. Longest Increasing Subsequence"></a>例题1. <a href="https://leetcode.com/problems/longest-increasing-subsequence" target="_blank" rel="external">Longest Increasing Subsequence</a></h3><p>见<a href="https://siyaozhang.github.io/2017/11/18/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92(%E4%B8%8A" target="_blank" rel="external">【九章算法基础班】动态规划</a>/)</p><h3 id="例题2-Longest-Increasing-Path-in-a-Matrix"><a href="#例题2-Longest-Increasing-Path-in-a-Matrix" class="headerlink" title="例题2. Longest Increasing Path in a Matrix"></a>例题2. <a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix" target="_blank" rel="external">Longest Increasing Path in a Matrix</a></h3><blockquote><p>Given an integer matrix, find the length of the longest increasing path.</p><p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums = [</div><div class="line">&gt;   [9,9,4],</div><div class="line">&gt;   [6,6,8],</div><div class="line">&gt;   [2,1,1]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Return <code>4</code><br>The longest increasing path is <code>[1, 2, 6, 9]</code>.</p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums = [</div><div class="line">&gt;   [3,4,5],</div><div class="line">&gt;   [3,2,6],</div><div class="line">&gt;   [2,2,1]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Return <code>4</code><br>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.</p></blockquote><p>分析：</p><p>用for循环解决这道题不知道起点在哪，即初始状态找不到</p><p>用搜索：</p><p>用搜索的方式，<code>f[i][j]</code> 为以点(i,j)为结尾的最长递增子序列长度，则需要看其上下左右四个点中没有被访问过的点，计算以这些点为结尾的最长递增子序列长度，这样就会有很多重复计算的点，因此可以用记忆化搜索，把计算过的点的信息存储下来，后面用到的时候直接查找即可。</p><p>记忆化搜索：</p><ul><li>状态： <code>f[i][j]</code> 为以点(i,j)为结尾的最长递增子序列长度</li><li>转移方程：<ul><li>a = +-1;b = 0;</li><li>b = +-1;a = 0;</li><li><code>f[i][j] =f[x+a][x+b]+1,if(a[x][y]&gt;a[x+a][x+b])</code></li></ul></li><li>初始化<ul><li><code>f[i][j] = 1</code> </li></ul></li><li>答案<ul><li><code>max f[i][j]</code> </li></ul></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestIncreasingPathinaMatrix</span> </span>&#123;</div><div class="line">    <span class="comment">//计算矩阵中ij点的最长递增子序列的长度</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] dp)</span></span>&#123;</div><div class="line">        <span class="comment">//如果已经计算过了</span></div><div class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> dp[i][j];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> rows= matrix.length;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[] x_delta =&#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta =&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span> maxlen = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>;k++)&#123;</div><div class="line">            <span class="keyword">int</span> x = i + x_delta[k];</div><div class="line">            <span class="keyword">int</span> y = j + y_delta[k];</div><div class="line">            <span class="comment">//如果上下左右的节点都没有越界,而且当前点的值大于其相邻点的值</span></div><div class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols &amp;&amp; matrix[i][j] &gt; matrix[x][y])&#123;</div><div class="line">                maxlen = Math.max(maxlen,search(matrix,x,y,dp)+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        dp[i][j] = maxlen;</div><div class="line">        <span class="keyword">return</span> dp[i][j];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line"><span class="comment">//        //初始化每个点最长递增子序列长度为1</span></div><div class="line"><span class="comment">//        for(int i = 0;i &lt; dp.length;i++)&#123;</span></div><div class="line"><span class="comment">//            for(int j = 0 ; j &lt; dp[0].length;j++)&#123;</span></div><div class="line"><span class="comment">//                dp[i][j] = 1;</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; dp.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; dp[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                res = Math.max(res,search(matrix,i,j,dp));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        LongestIncreasingPathinaMatrix test = <span class="keyword">new</span> LongestIncreasingPathinaMatrix();</div><div class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">9</span>,<span class="number">9</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</div><div class="line">        <span class="keyword">int</span> res = test.longestIncreasingPath(matrix);</div><div class="line">        System.out.print(res);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结：什么时候用记忆化搜索"><a href="#总结：什么时候用记忆化搜索" class="headerlink" title="总结：什么时候用记忆化搜索"></a>总结：什么时候用记忆化搜索</h3><ol><li>状态转移特别麻烦，不是顺序性。</li><li>初始化状态不是很容易找到。</li><li>从大到小</li></ol><h2 id="博弈类DP"><a href="#博弈类DP" class="headerlink" title="博弈类DP"></a>博弈类DP</h2><p>连两个人做游戏</p><p>解决博弈类DP通常用记忆化搜索的方法</p><h3 id="例题1-coins-in-a-line"><a href="#例题1-coins-in-a-line" class="headerlink" title="例题1.coins in a line"></a>例题1.<a href="http://www.lintcode.com/en/problem/coins-in-a-line/" target="_blank" rel="external">coins in a line</a></h3><blockquote><p>There are n coins in a line. Two players take turns to take one or two coins from right side until there are no more coins left. The player who take the last coin wins.</p><p>Could you please decide the <strong>first</strong> play will win or lose?</p><p>Example</p><p>n = <code>1</code>, return <code>true</code>.</p><p>n = <code>2</code>, return <code>true</code>.</p><p>n = <code>3</code>, return <code>false</code>.</p><p>n = <code>4</code>, return <code>true</code>.</p><p>n = <code>5</code>, return <code>true</code>.</p></blockquote><p>两个人轮流选取硬币，每次只能选1个或者2个，取到最后一个石子的人获胜，给定石子数量，返回第一个选的人（先手）能否获胜。</p><p>分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">画搜索树，以<span class="number">4</span>个coin为例</div><div class="line">先手层： <span class="number">4</span>T</div><div class="line">   <span class="number">1</span>↙      ↘<span class="number">2</span></div><div class="line">后手层：<span class="number">3F</span>    <span class="number">2</span>T</div><div class="line"> <span class="number">1</span>↙   ↘<span class="number">2</span>     <span class="number">1</span>↙   ↘<span class="number">2</span></div><div class="line">先手层：     <span class="number">2</span>T     <span class="number">1</span>T   <span class="number">1</span>T      <span class="number">0F</span></div><div class="line">  </div><div class="line">搜索树中的TorF表示当前选择coin的选手的输赢</div><div class="line">因为两个选手都会选择对自己最为有利的方式选取硬币，因此假设两个选手在开始的时候就已经绘制了这样的搜索树，以<span class="number">4</span>枚硬币的情况为例，先手可以选择<span class="number">1</span>个或者<span class="number">2</span>个:</div><div class="line"><span class="number">1</span>. 选<span class="number">1</span>个，还剩<span class="number">3</span>个，此时后手无论选择<span class="number">1</span>个还是<span class="number">2</span>个，先手都可以赢</div><div class="line"><span class="number">2</span>. 选<span class="number">2</span>个，还剩<span class="number">2</span>个，此时后手选<span class="number">2</span>个先手就会输掉比赛</div><div class="line">所以先手选择对自己最为有利的方式，选择<span class="number">1</span>个，赢得比赛。</div><div class="line">由此可见，当前有n个coin的情况下， 该选手是否能够赢得比赛与在剩余n-<span class="number">1</span>和n-<span class="number">2</span>枚硬币的情况下对手是否能够赢得比赛有关。</div><div class="line">以f(i)表示在剩余i枚硬币情况下当前选手是否能够获胜，</div><div class="line">则当下层节点中至少有一个为<span class="keyword">false</span>时，本层即可获胜</div><div class="line">状态转移方程为: f(i) = !f(i-<span class="number">1</span>)||!f(i-<span class="number">2</span>)</div><div class="line">初始化：f(<span class="number">1</span>)=f(<span class="number">2</span>)=<span class="keyword">true</span></div><div class="line">答案：f(i)</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</div><div class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">    dp[<span class="number">1</span>] = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</div><div class="line">        dp[i] = !dp[i-<span class="number">1</span>] || !dp[i-<span class="number">2</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题2-coins-in-a-line-II"><a href="#例题2-coins-in-a-line-II" class="headerlink" title="例题2. coins in a line II"></a>例题2. <a href="http://www.lintcode.com/en/problem/coins-in-a-line-ii/" target="_blank" rel="external">coins in a line II</a></h3><blockquote><p>There are n coins with different value in a line. Two players take turns to take one or two coins from left side until there are no more coins left. The player who take the coins with the most value wins.</p><p>Could you please decide the <strong>first</strong> player will win or lose?</p><p>Example</p><p>Given values array A = <code>[1,2,2]</code>, return <code>true</code>.</p><p>Given A = <code>[1,2,4]</code>, return <code>false</code>.</p></blockquote><p>给定硬币序列，硬币具有价值，两个人轮流选取硬币，每次可以选1个或者2个获得相应的价值，最终获得价值多的人获胜，问先手能够获胜</p><p>分析：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">f[i]:表示还剩i个硬币，当前取硬币的人最后最多取硬币的价值</div><div class="line">如果f[i]&gt;所有硬币价值的一半则可以获胜</div><div class="line"></div><div class="line">以[5,1,2,10]为例</div><div class="line">先手层：     [5,1,2,10]</div><div class="line">       1↙    ↘2</div><div class="line">后手层：     [1,2,10]     [2,10]</div><div class="line">   1↙ ↘2     1↙   ↘2</div><div class="line">先手层：  [2,10]   [10] [10]    []</div><div class="line"></div><div class="line">两个人在选取硬币的时候，会选择给对方留下尽可能少的价值</div><div class="line">转移方程为：f[i] = sum[i]- min(f[i-1],f[i-2])</div><div class="line">初始化：</div><div class="line">f[1] = coins[i-1]</div><div class="line">f[2] = coins[i-1]+coins[i-2]</div><div class="line">答案：</div><div class="line">if dp[n] &gt; sum[coins]/2</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">if</span>(values.length &lt;= <span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[values.length];</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = values.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">        sum += values[i];</div><div class="line">        sums[i] = sum;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[values.length];</div><div class="line">    dp[<span class="number">0</span>] = sums[sums.length-<span class="number">1</span>];</div><div class="line">    dp[<span class="number">1</span>] = sums[sums.length-<span class="number">2</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; values.length;i++)&#123;</div><div class="line">        dp[i] = sums[values.length-i-<span class="number">1</span>] - Math.min(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[values.length-<span class="number">1</span>] &gt; sums[<span class="number">0</span>]/<span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题3-Coins-in-a-Line-III"><a href="#例题3-Coins-in-a-Line-III" class="headerlink" title="例题3. Coins in a Line III"></a>例题3. Coins in a Line III</h3><blockquote><p>There are n coins in a line. Two players take turns to take a coin from one of the ends of the line until there are no more coins left. The player with the larger amount of money wins.</p><p>Could you please decide the first player will win or lose?</p><p><strong>Example</strong></p><p>Given array A = [3,2,2], return true.</p><p>Given array A = [1,2,4], return true.</p><p>Given array A = [1,20,4], return false.</p></blockquote><p>和II一样coin带有价值，选取时可以从头部或者尾部选取一个coin。</p><p>分析：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">初始：[3, 2, 2]</div><div class="line"></div><div class="line">                  [3, 2, 2]</div><div class="line">                   dp[0][2]</div><div class="line">                /           \</div><div class="line">        取左3  /              \ 取右2</div><div class="line">             /                 \</div><div class="line">         [2, 2]                [3, 2]</div><div class="line">        dp[1][2]              dp[0][1]</div><div class="line">          /    \                  /  \</div><div class="line">   取左2 /       \ 取右2    取左3 /    \ 取右2</div><div class="line">        /         \             /      \</div><div class="line">    [2]            [2]        [2]      [3]</div><div class="line">  dp[2][2]     dp[1][1]     dp[1][1]   dp[0][0]</div><div class="line"> </div><div class="line">这道题目属于区间型dp</div><div class="line">dp[i][j] 现在还第i到第j的硬币，现在当前取硬币的人（先手）最后最多取硬币价值；这里是区间型DP，下标表示区间范围</div><div class="line">转移方程：</div><div class="line">sum[i][j]第i到第j的硬币价值总和</div><div class="line">dp[i][j] = sum[i][j] - min(dp[i+1][j], dp[i][j-1]);</div><div class="line">初始化：</div><div class="line">dp[i][i] = coin[i]</div><div class="line">答案：</div><div class="line">dp[0][n-1] &gt; sum[coins]/2</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//记忆化搜索    </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] values,<span class="keyword">int</span>[][] sums,<span class="keyword">int</span>[][] dp,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> dp[i][j];</div><div class="line">        &#125;</div><div class="line">        dp[i][j] = sums[i][j] - Math.min(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</div><div class="line">        <span class="keyword">return</span> dp[i][j];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] sums = <span class="keyword">new</span> <span class="keyword">int</span>[values.length][values.length];</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[values.length][values.length];</div><div class="line">        <span class="comment">//sums[i][j]为从i到j的coins价值和</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length;i++)&#123;</div><div class="line">            sums[i][i] = values[i];</div><div class="line">            dp[i][i] = values[i];</div><div class="line">            <span class="keyword">int</span> sum = sums[i][i];</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; values.length;j++)&#123;</div><div class="line">                sum += values[j];</div><div class="line">                sums[i][j] = sum;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> search(values,sums,dp,<span class="number">0</span>,values.length-<span class="number">1</span>) &gt; sums[<span class="number">0</span>][values.length-<span class="number">1</span>]/<span class="number">2</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h2 id="区间型DP"><a href="#区间型DP" class="headerlink" title="区间型DP"></a>区间型DP</h2><p>特点：</p><ol><li>求一段区间的解max/min/count</li><li>转移方程通过区间更新</li><li>从大到小更新，用记忆化搜索</li></ol><h3 id="例题1-Stone-Game"><a href="#例题1-Stone-Game" class="headerlink" title="例题1. Stone Game"></a>例题1. Stone Game</h3><blockquote><p>There is a stone game.At the beginning of the game the player picks <code>n</code> piles of stones in a line.</p><p>The goal is to merge the stones in one pile observing the following rules:</p><ol><li>At each step of the game, the player can merge two adjacent piles to a new pile.</li><li>The score is the number of stones in the new pile.</li></ol><p>You are to determine the <strong>minimum</strong> of the total score.</p><p><strong>Example</strong></p><p>For <code>[4, 1, 1, 4]</code>, in the best solution, the total score is <code>18</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1. Merge second and third piles =&gt; [4, 2, 4], score +2</div><div class="line">&gt; 2. Merge the first two piles =&gt; [6, 4]，score +6</div><div class="line">&gt; 3. Merge the last two piles =&gt; [10], score +10</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Other two examples:</p><p><code>[1, 1, 1, 1]</code> return <code>8</code> <code>[4, 4, 5, 9]</code> return <code>43</code></p></blockquote><p>给定数组，每次合并相邻元素直至全部合并，每次合并需要花费两个元素价值之和，返回最小的花费</p><p>分析：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">以[3,4,5,6]为例：</div><div class="line">死胡同:容易想到的一个思路从小往大，枚举第一次合并是在哪? 转而用记忆化搜索的思路，从大到小，先考虑最后的0 ~ n-1合并的总花费。</div><div class="line">正确的打开方式：</div><div class="line"></div><div class="line">将区间拆分，看成是两个区间的合并</div><div class="line">                        [3,4,5,6]</div><div class="line">                          (0,3)</div><div class="line">               ↙   ↓    ↘</div><div class="line">      [3]+[4,5,6]   [3,4]+[5,6]   [3,4,5]+[6]   </div><div class="line">      (0,0)+(1,3)   (0,1)+(2,3)   (0,2)+(3,3)</div><div class="line">            ↙   ↘</div><div class="line">   (1,1)+(2,3) (1,2)+(3,3) .....</div></pre></td></tr></table></figure><ul><li>State:<ul><li><code>dp[i][j]</code>表示把第i到第j个石子合并到一起的最小花费</li></ul></li><li>Function:<ul><li>预处理<code>sum[i,j]</code>表示i到j所有石子价值和</li><li><code>dp[i][j] = min(dp[i][k]+dp[k+1][j]+sum[i,j])</code> 对于所有<code>k</code>属于<code>{i,j}</code></li></ul></li><li>Intialize:<ul><li>for each i<ul><li><code>dp[i][i] = 0</code></li></ul></li></ul></li><li>Answer:<ul><li><code>dp[0][n-1]</code></li></ul></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] stones,<span class="keyword">int</span>[][] dp,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(i &gt; j)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(dp[i][j]!= <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> dp[i][j];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> minCost = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx = i;idx &lt;= j;idx++)&#123;</div><div class="line">        minCost = Math.min(minCost,Math.min(search(stones,dp,i,idx),search(stones,dp,idx+<span class="number">1</span>,j)));</div><div class="line">    &#125;</div><div class="line">    dp[i][j] = minCost;</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StoneGame</span><span class="params">(<span class="keyword">int</span>[] stones)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[stones.length][stones.length];</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; stones.length;i++)&#123;</div><div class="line">        dp[i][i] = stones[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> search(stones,dp,<span class="number">0</span>,stones.length-<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题2-Burst-Balloons"><a href="#例题2-Burst-Balloons" class="headerlink" title="例题2. Burst Balloons"></a>例题2. <a href="https://leetcode.com/problems/burst-balloons" target="_blank" rel="external">Burst Balloons</a></h3><blockquote><p>Given <code>n</code> balloons, indexed from <code>0</code> to <code>n-1</code>. Each balloon is painted with a number on it represented by array <code>nums</code>. You are asked to burst all the balloons. If the you burst balloon <code>i</code> you will get <code>nums[left] * nums[i] * nums[right]</code> coins. Here <code>left</code> and <code>right</code> are adjacent indices of <code>i</code>. After the burst, the <code>left</code> and <code>right</code> then becomes adjacent.</p><p>Find the maximum coins you can collect by bursting the balloons wisely.</p><p><strong>Note:</strong><br>(1) You may imagine <code>nums[-1] = nums[n] = 1</code>. They are not real therefore you can not burst them.<br>(2) 0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</p><p><strong>Example:</strong></p><p>Given <code>[3, 1, 5, 8]</code></p><p>Return <code>167</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</div><div class="line">&gt;    coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>戳气球，每次戳破气球i可以获得价值nums[i-1]*nums[i]&amp;nums[i+1]，返回可以获得的最大利润。</p><p>分析：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[3, 1, 5, 8]</div><div class="line">↙↙↘   ↘</div><div class="line">最后一次打爆的气球:3  15      8</div><div class="line">获得价值：                               1*5*1</div><div class="line">[1,5,8]   [3,5,8]    [3,1](5)[8]   [3,1,5]</div><div class="line">  ↙    ↘    ↓    </div><div class="line">最后一次打爆的气球:           3   1   8</div><div class="line">获得价值1*3*5  1*1*5  5*8*1</div><div class="line">    (3)[1](5) [3](1)(5)</div><div class="line">    ↓         ↓ </div><div class="line">最后一次打爆的气球:          1          3</div><div class="line">获得价值      3*1*5       1*3*1</div></pre></td></tr></table></figure><ul><li><p>State:</p><ul><li><code>dp[i][j]</code>表示把第i到第j个气球打爆获得的最大价值</li></ul></li><li><p>Function:</p><p>计算<code>dp[i][j]</code> 需要遍历ij区间内所有的点，看做最后一个从ij区间中删除的点，删除该点时获得的价值为<code>nums[i-1]*nums[k]*nums[j+1]</code>，然后再删除该点之前，其左边和右边的节点已经全部被删除，所以转移方程为：</p><ul><li><code>dp[i][j] = max(nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j])</code> 对于所有<code>k</code>属于<code>{i,j}</code></li></ul></li><li><p>Intialize:</p><ul><li>for each i<ul><li><code>dp[i][i] = 0</code></li></ul></li></ul></li><li><p>Answer:</p><ul><li><code>dp[0][n-1]</code></li></ul></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">//计算戳破从i到j所有气球获得的coins</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span>[][] max,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(i &gt; j)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果已经计算过了</span></div><div class="line">        <span class="keyword">if</span>(max[i][j] != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> max[i][j];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> maxVal = <span class="number">0</span>;</div><div class="line">        <span class="comment">//假设idx是ij区间中最后一个被戳破的气球</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx = i;idx &lt;= j;idx++)&#123;</div><div class="line">            <span class="keyword">int</span> left = i-<span class="number">1</span> &lt; <span class="number">0</span>?<span class="number">1</span>:nums[i-<span class="number">1</span>];</div><div class="line">            <span class="keyword">int</span> right = j+<span class="number">1</span> &gt;= nums.length ?<span class="number">1</span>:nums[j+<span class="number">1</span>];</div><div class="line">            <span class="keyword">int</span> temp = left * right * nums[idx];</div><div class="line">            maxVal = Math.max(maxVal,temp + solve(nums,max,i,idx-<span class="number">1</span>) + solve(nums,max,idx+<span class="number">1</span>,j));</div><div class="line">        &#125;</div><div class="line">        max[i][j] = maxVal;</div><div class="line">        <span class="keyword">return</span> maxVal;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][nums.length];<span class="comment">//打爆ij所有气球的最大值</span></div><div class="line">        <span class="comment">//Arrays.fill(max,-1);</span></div><div class="line">        <span class="keyword">return</span> solve(nums,max,<span class="number">0</span>,nums.length-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题3-Scramble-String"><a href="#例题3-Scramble-String" class="headerlink" title="例题3. Scramble String"></a>例题3. <a href="https://leetcode.com/problems/scramble-string" target="_blank" rel="external">Scramble String</a></h3><blockquote><p>Given a string <em>s1</em>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p><p>Below is one possible representation of <em>s1</em> = <code>&quot;great&quot;</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     great</div><div class="line">&gt;    /    \</div><div class="line">&gt;   gr    eat</div><div class="line">&gt;  / \    /  \</div><div class="line">&gt; g   r  e   at</div><div class="line">&gt;            / \</div><div class="line">&gt;           a   t</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>To scramble the string, we may choose any non-leaf node and swap its two children.</p><p>For example, if we choose the node <code>&quot;gr&quot;</code> and swap its two children, it produces a scrambled string <code>&quot;rgeat&quot;</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     rgeat</div><div class="line">&gt;    /    \</div><div class="line">&gt;   rg    eat</div><div class="line">&gt;  / \    /  \</div><div class="line">&gt; r   g  e   at</div><div class="line">&gt;            / \</div><div class="line">&gt;           a   t</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>We say that <code>&quot;rgeat&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p><p>Similarly, if we continue to swap the children of nodes <code>&quot;eat&quot;</code> and <code>&quot;at&quot;</code>, it produces a scrambled string <code>&quot;rgtae&quot;</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     rgtae</div><div class="line">&gt;    /    \</div><div class="line">&gt;   rg    tae</div><div class="line">&gt;  / \    /  \</div><div class="line">&gt; r   g  ta  e</div><div class="line">&gt;        / \</div><div class="line">&gt;       t   a</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>We say that <code>&quot;rgtae&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p><p>Given two strings <em>s1</em> and <em>s2</em> of the same length, determine if <em>s2</em> is a scrambled string of <em>s1</em></p></blockquote><p>分析：</p><p>对于s1和s2，找不同的分割点k，将其分别分为两个子数组。若s1的两个子数组和对应的s2的两个子数组都是scramble的，则s1和s2就是scramble的。例如，s1[0…i]被分为0…k，k+1…i，其对应的s2子数组为0…k，k+1…i或者0…i-k-1, i-k…i（即s2的前k个元素或者后k个元素对应于s1的前k个元素，比如s1=abc，s2=acb，第一层递归时比较的是s1左边的子数组和s2左边的子数组以及s1右边的子数组和s2右边的子数组，第二层递归比较右边两个子数组时，就要比较s1右边子数组的左边子数组”b”和s2右边子数组的右边子数组”b”），只要两种情况里面有一种满足，则s1和s2就是scramble的。</p><p>( isScramble(s2[0…k], s1[0…k]) &amp;&amp; isScramble(s2[k+1…j], s1[k+1…i]) ) || ( isScramble(s2[0…k], s1[i-k…i]) &amp;&amp; isScramble(s2[k+1…j], s1[0…i-k-1]) )，（k = 0,1,2 … i-1，k相当于字符串的分割点)</p><p>因此可以用记忆化搜索来保存子问题，设dp[i][j][k]表示s2从j开始长度为k的子串是否可以由s1从i开始长度为k的子串转换而成:</p><p>状态：</p><p><code>dp[i][j][k]</code> 表示s1从第i个开始s2从第j个开始的k个字母是否是scramble string</p><p>因此状态转移方程为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">对于所有的i属于[1,k]:</div><div class="line">s11 = s1.substring(0, i);  </div><div class="line">s12 = s1.substring(i, i+k-1); </div><div class="line">s21 = s2.substring(0, i);  </div><div class="line">s22 = s2.substring(i, i+k-1)</div><div class="line">s23 = s2.substring(j, j+k-i-1);  </div><div class="line">s24 = s2.substring(j+k-i, j+k-1); </div><div class="line">for i = x -&gt; x+k ：</div><div class="line">  dpx[k] = (dpx[i] &amp;&amp; dpx+i[k-i]) || dpx[i] &amp;&amp; dpx+i[k-i])</div></pre></td></tr></table></figure><p>初始化：</p><p><code>dp[i][j][1] = s1[i]==s[j].</code></p><p>答案：</p><p><code>dp[0][0][len]</code></p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">boolean</span>[][][] dp,<span class="keyword">boolean</span>[][][] visited,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">        <span class="comment">//如果计算过了，直接返回</span></div><div class="line">        <span class="keyword">if</span>(visited[i][j][k])&#123;</div><div class="line">            <span class="keyword">return</span> dp[i][j][k];</div><div class="line">        &#125;</div><div class="line">        dp[i][j][k] = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">1</span>;idx &lt; k;idx++)&#123;</div><div class="line">            <span class="keyword">if</span>((search(dp,visited,i,j,idx) &amp;&amp; search(dp,visited,i+idx,j+idx,k-idx) )||</div><div class="line">                    (search(dp,visited,i,j+k-idx,idx) &amp;&amp; search(dp,visited,i+idx,j,k-idx)))&#123;</div><div class="line">                dp[i][j][k] = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        visited[i][j][k] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> dp[i][j][k];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s1.length() != s2.length())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> len = s1.length();</div><div class="line">        <span class="keyword">boolean</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len][len+<span class="number">1</span>];</div><div class="line">        <span class="keyword">boolean</span>[][][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len][len+<span class="number">1</span>];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len;j++)&#123;</div><div class="line">                dp[i][j][<span class="number">1</span>] = s1.charAt(i)== s2.charAt(j);</div><div class="line">                visited[i][j][<span class="number">1</span>] = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> search(dp,visited,<span class="number">0</span>,<span class="number">0</span>,len);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>递归也可以做</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s1.equals(s2)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s1.length();i++) &#123;</div><div class="line">            count[s1.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">            count[s2.charAt(i) - <span class="string">'a'</span>]--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count.length;i++) &#123;</div><div class="line">            <span class="keyword">if</span>(count[i] != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s1.length();i++) &#123;</div><div class="line">            <span class="keyword">if</span>(isScramble(s1.substring(<span class="number">0</span>, i), s2.substring(<span class="number">0</span>, i)) </div><div class="line">               &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(isScramble(s1.substring(<span class="number">0</span>, i), s2.substring(s2.length()-i)) </div><div class="line">               &amp;&amp; isScramble(s1.substring(i), s2.substring(<span class="number">0</span>, s2.length()-i))) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="背包类DP"><a href="#背包类DP" class="headerlink" title="背包类DP"></a>背包类DP</h2><p>特点：</p><ol><li>用值作为DP维度</li><li>DP过程就是填写矩阵</li><li>可以用滚动数组优化</li></ol><h3 id="例题1-Backpack"><a href="#例题1-Backpack" class="headerlink" title="例题1. Backpack"></a>例题1. <a href="http://www.lintcode.com/en/problem/backpack/" target="_blank" rel="external">Backpack</a></h3><blockquote><p>Given <em>n</em> items with size Ai, an integer <em>m</em> denotes the size of a backpack. How full you can fill this backpack?</p><p>Example</p><p>If we have <code>4</code> items with size <code>[2, 3, 5, 7]</code>, the backpack size is 11, we can select <code>[2, 3, 5]</code>, so that the max size we can fill this backpack is <code>10</code>. If the backpack size is <code>12</code>. we can select <code>[2, 3, 7]</code> so that we can fulfill the backpack.</p><p>You function should return the max size we can fill in the given backpack.</p></blockquote><p>给定背包容量和物品数组，返回最大的</p><p>分析：</p><p>不可以用贪心，比如[8,7,5]，容量为12</p><p>如果用贪心法放了8就放不下其他的了，但是放7和5得到的总容量更大，所以不能用贪心法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">以items = [2,3,4,5]，size=11为例分析：</div><div class="line"></div><div class="line">定以一个矩阵，行数为items.length，列数为size</div><div class="line"></div><div class="line">idx 01234567...</div><div class="line"> 0TFFFFFFF...</div><div class="line"> 1TFTFFFFF...</div><div class="line"> 2TFTTFTFF...</div><div class="line"> 3T...</div><div class="line"> 4T...</div><div class="line"></div><div class="line">state:</div><div class="line">f[i][S]表示在前i个物品中取出一些能否组成和为S</div><div class="line"></div><div class="line">function：</div><div class="line">在前i个物品中是否有选择方式使得取出的物品和为S，可以分两种情况讨论：</div><div class="line">1. 选择第i个物品：需要考虑在前i-1和物品中是否可以选取一些物品组成s-a[i]</div><div class="line">2. 不选第i个物品：需要考虑在前i-1和物品中是否可以选取一些物品组成s</div><div class="line">因此状态转移方程为:</div><div class="line">f[i][S] = f[i-1][s-a[i]] or f[i-1][s]</div><div class="line"></div><div class="line">initial:</div><div class="line">f[i][0] = true;</div><div class="line">f[0][j] = false;j!=0</div><div class="line"></div><div class="line">answer:</div><div class="line">max j,f[i][j] = true;</div><div class="line"></div><div class="line">滚动数组优化：</div><div class="line">可以看出来f[i][S]只与前一行有关，所以可以进行二位滚动数组优化</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[A.length+<span class="number">1</span>][m+<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m+<span class="number">1</span>;i++)&#123;</div><div class="line">        dp[<span class="number">0</span>][i] = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m+<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; A.length+<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(i-A[j-<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</div><div class="line">                dp[j][i] = dp[j-<span class="number">1</span>][i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                dp[j][i] = dp[j-<span class="number">1</span>][i-A[j-<span class="number">1</span>]] || dp[j-<span class="number">1</span>][i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(dp[j][i])&#123;</div><div class="line">                res =i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题2-BackPack马甲变换1，硬币凑整"><a href="#例题2-BackPack马甲变换1，硬币凑整" class="headerlink" title="例题2. BackPack马甲变换1，硬币凑整"></a>例题2. BackPack马甲变换1，硬币凑整</h3><p>给定面值1,2,5,10的硬币无穷多个，请问能够凑成80元的方案总数。</p><p>分析：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">states：</div><div class="line">dp[i][j]表示用前i种硬币凑成j元钱的方案总数</div><div class="line"></div><div class="line">以[1,2,5,10] total = 80 为例：</div><div class="line">依然采用填写矩阵的方式</div><div class="line">idx012345678910...</div><div class="line">010000000000...</div><div class="line">111111111111...</div><div class="line">2112233...</div><div class="line">31...</div><div class="line">41</div><div class="line"></div><div class="line">动态转移方程：</div><div class="line">用前i种硬币凑成j元，考虑第i种硬币取的个数k</div><div class="line">dp[i][j] = dp[i-1][j-val[i]] +....+dp[i-1][j-val[i]*k]</div><div class="line"></div><div class="line">初始化：</div><div class="line">dp[i][0] = 1;</div><div class="line">dp[0][j] = 0;(j!=0)</div><div class="line"></div><div class="line">答案：</div><div class="line">dp[val.length][total]</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length+<span class="number">1</span>][m+<span class="number">1</span>];</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m+<span class="number">1</span>;i++)&#123;</div><div class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; m+<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span>(k * A[i-<span class="number">1</span>] &lt;= m)&#123;</div><div class="line">                dp[i][j] += dp[i-<span class="number">1</span>][j-k*A[i-<span class="number">1</span>]];</div><div class="line">                k++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[A.length][m];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题3-Coin-Change"><a href="#例题3-Coin-Change" class="headerlink" title="例题3. Coin Change"></a>例题3. <a href="https://leetcode.com/problems/coin-change/description/" target="_blank" rel="external">Coin Change</a></h3><blockquote><p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p><p><strong>Example 1:</strong><br>coins = <code>[1, 2, 5]</code>, amount = <code>11</code><br>return <code>3</code> (11 = 5 + 5 + 1)</p><p><strong>Example 2:</strong><br>coins = <code>[2]</code>, amount = <code>3</code><br>return <code>-1</code>.</p></blockquote><p>给定硬币面值，和总价值，返回能凑成总价值所用硬币数的最小值</p><p>思路：</p><p>和上一题思路类似</p><p>state:</p><p><code>dp[i][j]</code> 表示用i种硬币凑成j元所需要的最少硬币数量</p><p>function：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dp[i][j] = min&#123;dp[i-1][j-k*A[i-1]]+k&#125;</div><div class="line">for each k*A[i-1]] &lt;= amout &amp;&amp; dp[i-1][j-k*A[i-1]] != 0</div></pre></td></tr></table></figure><p>initial：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dp[i][0] = 1;</div><div class="line">dp[0][j] = 0;(j!=0)</div></pre></td></tr></table></figure><p>answer：</p><p><code>dp[coins.length][amount]</code></p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[coins.length+<span class="number">1</span>][amount+<span class="number">1</span>];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;coins.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; amount+<span class="number">1</span>;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</div><div class="line">                    dp[i][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    dp[i][j] = -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; coins.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; amount+<span class="number">1</span>;j++)&#123;</div><div class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">                <span class="keyword">int</span> minCount = Integer.MAX_VALUE;</div><div class="line">                <span class="keyword">while</span>(k * coins[i-<span class="number">1</span>] &lt;= j)&#123;</div><div class="line">                    <span class="keyword">if</span>(dp[i-<span class="number">1</span>][j-k*coins[i-<span class="number">1</span>]] != -<span class="number">1</span>)&#123;</div><div class="line">                        minCount = Math.min(minCount,dp[i-<span class="number">1</span>][j-k*coins[i-<span class="number">1</span>]]+k);</div><div class="line">                    &#125;</div><div class="line">                    k++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(minCount != Integer.MAX_VALUE)&#123;</div><div class="line">                    dp[i][j] = minCount;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(dp[coins.length][amount] == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> dp[coins.length][amount];</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>优化：</p><h3 id="例题4-BackPack-马甲变换2"><a href="#例题4-BackPack-马甲变换2" class="headerlink" title="例题4. BackPack 马甲变换2"></a>例题4. BackPack 马甲变换2</h3><p>把一个数组[1,24,5,6]尽量平分</p><p>可以转化为背包问题：</p><p>数组总和为36，一半为18</p><p>背包容量为18，用数组中的数字尽量将背包装满</p><h3 id="Partition-Equal-Subset-Sum"><a href="#Partition-Equal-Subset-Sum" class="headerlink" title="Partition Equal Subset Sum"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum" target="_blank" rel="external">Partition Equal Subset Sum</a></h3><blockquote><p>Given a <strong>non-empty</strong> array containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p><p><strong>Note:</strong></p><ol><li>Each of the array element will not exceed 100.</li><li>The array size will not exceed 200.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1, 5, 11, 5]</div><div class="line">&gt;</div><div class="line">&gt; Output: true</div><div class="line">&gt;</div><div class="line">&gt; Explanation: The array can be partitioned as [1, 5, 5] and [11].</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1, 2, 3, 5]</div><div class="line">&gt;</div><div class="line">&gt; Output: false</div><div class="line">&gt;</div><div class="line">&gt; Explanation: The array cannot be partitioned into equal sum subsets.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>返回是否能够取到整个数组的一半。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionEqualSubsetSum</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span> != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        sum = sum/<span class="number">2</span>;</div><div class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length+<span class="number">1</span>][sum+<span class="number">1</span>];</div><div class="line">        <span class="comment">//chushihua</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; sum+<span class="number">1</span>;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(j &lt; nums[i-<span class="number">1</span>])&#123;</div><div class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] || dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[nums.length][sum];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题5-Backpack-II"><a href="#例题5-Backpack-II" class="headerlink" title="例题5.  Backpack II"></a>例题5.  <a href="http://www.lintcode.com/en/problem/backpack-ii/" target="_blank" rel="external">Backpack II</a></h3><p>给定物品占空间和物品价值数组，背包容量，如何装能够使得背物品价值最高</p><p>不可以用贪心算法</p><p>分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">依然采用补全矩阵的方法</div><div class="line">体积数组为A，价值数组为val,容量为S</div><div class="line">state：</div><div class="line">f[i][j]表示在前i个物品中选取一些物品，构成总体积为j，所获得的最高价值是多少</div><div class="line">function：</div><div class="line">考虑第i个物品，有选和不选两种情况：</div><div class="line"><span class="number">1</span>. 选：总价值为f[i-<span class="number">1</span>][j-A[i-<span class="number">1</span>]] + val[i-<span class="number">1</span>]</div><div class="line"><span class="number">2</span>. 不选：总价值为f[i-<span class="number">1</span>][j]</div><div class="line">取两者之中较大的，因此状态转移方程为：</div><div class="line">f[i][j] = max(f[i-<span class="number">1</span>][j],f[i-<span class="number">1</span>][j-A[i-<span class="number">1</span>]] + val[i-<span class="number">1</span>])</div><div class="line">initial:</div><div class="line">f[<span class="number">0</span>][i] = <span class="number">0</span></div><div class="line">f[i][<span class="number">0</span>] = <span class="number">0</span></div><div class="line">answer：</div><div class="line">f[A.length][S]</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackII</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length+<span class="number">1</span>][m+<span class="number">1</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m+<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(j &gt;= A[i-<span class="number">1</span>])&#123;</div><div class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-A[i-<span class="number">1</span>]]+V[i-<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[A.length][m];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题6-K-Sum"><a href="#例题6-K-Sum" class="headerlink" title="例题6. K Sum"></a>例题6. K Sum</h3><p>给定数组A=[1,2,3,4],k=2,target=5</p><p>在A中选2个元素，和为5，返回方案个数</p><p>思路：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">state:</div><div class="line">f[i][j][k]表示在前i个元素中选取j个出来和为t个方案个数</div><div class="line">function:</div><div class="line">考虑第i个元素，有选和不选两种方案，两种方案数求和</div><div class="line">f[i][j][k] = f[i-<span class="number">1</span>][j-<span class="number">1</span>][t-A[i-<span class="number">1</span>]] + f[i-<span class="number">1</span>][j][t]</div><div class="line">initial:</div><div class="line">f[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">answer:</div><div class="line">f[A.length][k][target]</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> A: An integer array</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> k: A positive integer (k &lt;= length(A))</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> target: An integer</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span>: An integer</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kSum</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length+<span class="number">1</span>][k+<span class="number">1</span>][target+<span class="number">1</span>];</div><div class="line">        <span class="comment">//Chushihua</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; k+<span class="number">1</span>;j++)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>;l &lt; target+<span class="number">1</span>;l++)&#123;</div><div class="line">                    <span class="keyword">if</span>(l &gt;= A[i-<span class="number">1</span>])&#123;</div><div class="line">                        dp[i][j][l] = dp[i-<span class="number">1</span>][j][l] + dp[i-<span class="number">1</span>][j-<span class="number">1</span>][l-A[i-<span class="number">1</span>]];</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span>&#123;</div><div class="line">                        dp[i][j][l] = dp[i-<span class="number">1</span>][j][l];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[A.length][k][target];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>优化：</p><h3 id="例题7-Minnimum-Adjus"><a href="#例题7-Minnimum-Adjus" class="headerlink" title="例题7. Minnimum Adjus"></a>例题7. Minnimum Adjus</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>区间类DP<ul><li>从大到小去思考，将区间划分成小区间</li><li>主要通过记忆化搜索来解决</li></ul></li><li>背包类DP<ul><li>用值座位DP维度</li><li>用for循环填写矩阵数值</li><li>可以用滚动数组做优化</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h2&gt;&lt;p&gt;滚动数组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;house robber I/II&lt;/li&gt;
&lt;li&gt;Maxim
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>【面经】算法相关</title>
    <link href="http://yoursite.com/2018/03/07/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2018/03/07/【面经】算法相关/</id>
    <published>2018-03-07T11:33:12.000Z</published>
    <updated>2018-03-12T12:35:15.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-海量数据选取TOPK"><a href="#1-海量数据选取TOPK" class="headerlink" title="1. 海量数据选取TOPK"></a>1. 海量数据选取TOPK</h3><p>baseline：</p><p>用堆，如果取最大的K个，就用最小堆，遍历数组，遇到比堆顶元素大的元素就入堆，同时堆中元素超过k个需要poll操作，保证堆中只有K个元素，最终的topk元素在堆中。</p><p>时间复杂度分析:</p><script type="math/tex; mode=display">O(n*logk)$$ ，元素入堆复杂度$$O(logk)</script><p><strong><script type="math/tex">O(n)</script>算法：</strong></p><p>先用quick select方法找到第K大的元素，复杂度<script type="math/tex">O(n)</script></p><p>然后再遍历一遍，将大于K的元素取出，复杂度<script type="math/tex">O(n)</script></p><p>总复杂度<script type="math/tex">O(n)</script></p><p>！！！！！卧槽！神奇！！！！</p><p><strong>follow up：海量数据选取第K大</strong></p><p>Quick Select，详见<a href="/2018/02/02/【九章算法强化班】两指针/" title="【九章算法强化班】两指针">【九章算法强化班】两指针</a> </p><p>时间复杂度<script type="math/tex">O(n)</script></p><h3 id="2-大数排序问题"><a href="#2-大数排序问题" class="headerlink" title="2. 大数排序问题"></a>2. 大数排序问题</h3><p>海量数据排序怎么做？</p><p>baseline：快排，问题：数据量很大，内存根本存不下，不可行</p><p><strong>桶排序：</strong></p><p>将数据分桶，每个桶存入一个文件，然后文件内部有序，取出合并的时候可以用K路归并，优化：k路可以建个堆</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-海量数据选取TOPK&quot;&gt;&lt;a href=&quot;#1-海量数据选取TOPK&quot; class=&quot;headerlink&quot; title=&quot;1. 海量数据选取TOPK&quot;&gt;&lt;/a&gt;1. 海量数据选取TOPK&lt;/h3&gt;&lt;p&gt;baseline：&lt;/p&gt;
&lt;p&gt;用堆，如果取最大的K个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【实习项目总结】</title>
    <link href="http://yoursite.com/2018/03/07/%E3%80%90%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91/"/>
    <id>http://yoursite.com/2018/03/07/【实习项目总结】/</id>
    <published>2018-03-07T10:35:03.000Z</published>
    <updated>2018-03-12T12:35:15.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h2><p>无线短视频推荐项目，负责无线端用户的短视频推荐，也就是给手机端用户推荐短视频。主要用到了item-based协同过滤的思想，为用户提供候选短视频推荐集合，然后再利用预训练的LR模型返回候选推荐集合的最终排序，推给用户。</p><h2 id="2-推荐系统分类"><a href="#2-推荐系统分类" class="headerlink" title="2. 推荐系统分类"></a>2. 推荐系统分类</h2><p>感谢@<a href="https://www.zhihu.com/question/20326697/answer/58148605" target="_blank" rel="external">奔波的梦想</a> 的总结。推荐算法大致可以分为三类：基于内容的推荐算法、协同过滤推荐算法和基于知识的推荐算法。<br>​         <strong>基于内容的推荐算法</strong>，原理是用户喜欢和自己关注过的Item在内容上类似的Item，比如你看了哈利波特I，基于内容的推荐算法发现哈利波特II-VI，与你以前观看的在内容上面（共有很多关键词）有很大关联性，就把后者推荐给你，这种方法可以避免Item的冷启动问题（冷启动：如果一个Item从没有被关注过，其他推荐算法则很少会去推荐，但是基于内容的推荐算法可以分析Item之间的关系，实现推荐），弊端在于推荐的Item可能会重复，典型的就是新闻推荐，如果你看了一则关于MH370的新闻，很可能推荐的新闻和你浏览过的，内容一致；另外一个弊端则是对于一些多媒体的推荐（比如音乐、电影、图片等)由于很难提内容特征，则很难进行推荐，一种解决方式则是人工给这些Item打标签。<br>​        <strong>协同过滤算法</strong>，原理是用户喜欢那些具有相似兴趣的用户喜欢过的商品，比如你的朋友喜欢电影哈利波特I，那么就会推荐给你，这是最简单的基于用户的协同过滤算法（user-based collaboratIve filtering），还有一种是基于Item的协同过滤算法（item-based collaborative filtering），这两种方法都是将用户的所有数据读入到内存中进行运算的，因此成为Memory-based Collaborative Filtering，另一种则是Model-based collaborative filtering，包括Aspect Model，pLSA，LDA，聚类，SVD，Matrix Factorization等，这种方法训练过程比较长，但是训练完成后，推荐过程比较快。<br>​       最后一种方法是基于知识的推荐算法，也有人将这种方法归为基于内容的推荐，这种方法比较典型的是构建领域本体，或者是建立一定的规则，进行推荐。</p><p><strong>item-based 和 user-based 协同过滤的比较：</strong></p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-08-09-51-55.png" alt=""> </p><p>我们再来回顾一下<strong>item-base CF算法的特点</strong>：</p><ul><li>物品数明显小于用户数的场合，否则物品相似度矩阵计算代价很大</li><li>适合长尾物品丰富，用户个性化需求强的领域</li><li>对新用户友好，对新物品不友好，因为物品相似度矩阵不需要很强的实时性</li><li>利用用户历史行为做推荐解释，比较令用户信服</li></ul><p>所以item-base挺适合做电影的推荐。当用户浏览某个电影的时候，我们可以推荐给他类似的电影，或者根据用户以前的观影记录，推荐他感兴趣的电影。</p><h2 id="3-项目流程"><a href="#3-项目流程" class="headerlink" title="3. 项目流程"></a>3. 项目流程</h2><ol><li>根据集群中7天用户-视频score数据，计算视频两两之间的余弦相似度</li><li>为每个视频选取与之相似度&gt;0.5且最接近的top40个视频</li><li>根据用户7天之内看过的视频，将相似视频merge进来，根据看过视频的score和相似视频的余弦相似度乘积，对看过的所有视频的所有相似视频打分，取top50作为用户的推荐视频候选集（去掉已经看过的视频）</li><li>根据线上抽取的特征和用户、视频15天线下特征输入预训练的LR得到候选集合的点击率排序，作为最终的推荐顺序。</li></ol><h2 id="4-CF核心思路"><a href="#4-CF核心思路" class="headerlink" title="4. CF核心思路"></a>4. CF核心思路</h2><pre><code>* user1     user2* item1  score11   score21 (X)* item2  score12   score22 (Y)* --------------------------------* sim(item1,item2) = XY / math.sqrt(XX) * math.sqrt(YY)* XY= score11 * score12 + score21 * score22* XX = score11 * score11 + score21 * score21* YY = score12 * score12 + score22 * score22</code></pre><p>已知一周内，用户观看视频的数据，形式为RDD[(uid,(aid,score))]</p><p>按照uid做一次join操作，就可以得到RDD[((aid1,aid2),(score11,score22))]，即用户对以及同时看过两者的用户对其的score</p><p>接下来就可以计算出aid对的余弦相似度了</p><p>然后根据余弦相似度为每个aid选出最相近的top40相似ad</p><h2 id="5-优化方向"><a href="#5-优化方向" class="headerlink" title="5. 优化方向"></a>5. 优化方向</h2><p>暂时就想到了一个：</p><p>将用户对电影的score做时间衰减</p><p>之后继续补充</p><h2 id="6-核心代码"><a href="#6-核心代码" class="headerlink" title="6. 核心代码"></a>6. 核心代码</h2><figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> model</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.spark.broadcast.<span class="type">Broadcast</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</div><div class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;<span class="type">DataFrame</span>&#125;</div><div class="line"><span class="keyword">import</span> org.apache.spark.sql.hive.<span class="type">HiveContext</span></div><div class="line"><span class="keyword">import</span> util.<span class="type">MqManager</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">  * Created by dengxing on 2017/7/18.</span></div><div class="line"><span class="comment">  */</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">CF</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/** 基于dt时间获取原始数据源</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @param sc    SparkContext</span></div><div class="line"><span class="comment">    * @param table 转换的hive表</span></div><div class="line"><span class="comment">    * @param day   获取当前日期的数据</span></div><div class="line"><span class="comment">    * @return 原始数据的dataFrame</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getResource</span></span>(sc: <span class="type">SparkContext</span>, table: <span class="type">String</span>, day: <span class="type">String</span>) = &#123;</div><div class="line">    <span class="keyword">val</span> hiveContext = <span class="keyword">new</span> <span class="type">HiveContext</span>(sc)</div><div class="line">    <span class="keyword">import</span> hiveContext.sql</div><div class="line">    <span class="keyword">val</span> resource = sql(<span class="string">"select "</span></div><div class="line">      + <span class="string">"uid,"</span></div><div class="line">      + <span class="string">"aid,"</span></div><div class="line">      + <span class="string">"cnt"</span></div><div class="line">      + <span class="string">" from "</span> + table + <span class="string">" where dt ='"</span> + day + <span class="string">"'"</span>)</div><div class="line">    resource</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">    * 分布式计算余弦相似度</span></div><div class="line"><span class="comment">    * --------------------------------</span></div><div class="line"><span class="comment">    * user1     user2</span></div><div class="line"><span class="comment">    * item1  score11   score21 (X)</span></div><div class="line"><span class="comment">    * item2  score12   score22 (Y)</span></div><div class="line"><span class="comment">    * --------------------------------</span></div><div class="line"><span class="comment">    * sim(item1,item2) = XY / math.sqrt(XX) * math.sqrt(YY)</span></div><div class="line"><span class="comment">    * XY= score11 * score12 + score21 * score22</span></div><div class="line"><span class="comment">    * XX = score11 * score11 + score21 * score21</span></div><div class="line"><span class="comment">    * YY = score12 * score12 + score22 * score22</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @param resource</span></div><div class="line"><span class="comment">    * @return RDD[(item1,item2,sim)]</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getCosineSimilarity</span></span>(resource: <span class="type">DataFrame</span>): <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">String</span>, <span class="type">Double</span>))] = &#123;</div><div class="line">    <span class="keyword">val</span> rating = resource.map &#123;</div><div class="line">      row =&gt; &#123;</div><div class="line">        <span class="keyword">val</span> uid = row.getString(<span class="number">0</span>)</div><div class="line">        <span class="keyword">val</span> aid = row.getString(<span class="number">1</span>)</div><div class="line">        <span class="keyword">val</span> score = row.getString(<span class="number">2</span>).toDouble</div><div class="line">        (uid, aid, score)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//RDD[(uid,(aid,score))]</span></div><div class="line">    <span class="keyword">val</span> user_item_score = rating.map(f =&gt; (f._1, (f._2, f._3)))</div><div class="line">    </div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取每个用户有过行为的item键值对,即</span></div><div class="line"><span class="comment">     * RDD[((aid1,aid2),(score11,score22))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_score_pair = user_item_score.join(user_item_score)</div><div class="line">      .map(f =&gt; ((f._2._1._1, f._2._2._1), (f._2._1._2, f._2._2._2)))</div><div class="line">    </div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取同一对item，所有的用户评分向量的点积，即XY 及 XX 及 YY</span></div><div class="line"><span class="comment">     * RDD[((aid1,aid2),score11 * score12 + score21 * score22)]</span></div><div class="line"><span class="comment">     * 及 RDD[((aid1,aid1),score11 * score11 + score21 * score21)]</span></div><div class="line"><span class="comment">     * 及 RDD[((aid2,aid2),score12 * score12 + score22 * score22)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_pair_ALL = item_score_pair.map(f =&gt; (f._1, f._2._1 * f._2._2)).reduceByKey(_ + _)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取每个item，所有用户的自向量的点积，即XX或YY</span></div><div class="line"><span class="comment">     * RDD[((aid1,aid1),score11 * score11 + score21 * score21)]</span></div><div class="line"><span class="comment">     * 或 RDD[((aid2,aid2),score12 * score12 + score22 * score22)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_pair_XX_YY = item_pair_ALL.filter(f =&gt; f._1._1 == f._1._2)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取每个item，所有用户的非自向量的点积，即XY</span></div><div class="line"><span class="comment">     * RDD[((aid1,aid2),score11 * score12 + score21 * score22)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_pair_XY = item_pair_ALL.filter(f =&gt; f._1._1 != f._1._2)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取item_pair_XX_YY中的item及XX或YY</span></div><div class="line"><span class="comment">     * RDD[(aid1,score11 * score11 + score21 * score21)]</span></div><div class="line"><span class="comment">     * 或 RDD[(aid2,score12 * score12 + score22 * score22)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_XX_YY = item_pair_XX_YY.map(f =&gt; (f._1._1, f._2))</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     *  转化item_pair_XY为(aid1,((aid1,aid2,XY),XX)))</span></div><div class="line"><span class="comment">     *  RDD[(aid1,((aid1,aid2,score11 * score12 + score21 * score22),score11 * score11 + score21 * score21)))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="keyword">val</span> item_XY_XX = item_pair_XY.map(f =&gt; (f._1._1, (f._1._1, f._1._2, f._2))).join(item_XX_YY)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     *  转为item_XY_XX为(aid2,((aid1,aid2,XY,XX),YY))</span></div><div class="line"><span class="comment">     *  RDD[(aid2,((aid1,aid2,score11 * score12 + score21 * score22,score11 * score11 + score21 * score21),score12 * score12 + score22 * score22))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_XY_XX_YY = item_XY_XX.map(f =&gt; (f._2._1._2, (f._2._1._1, f._2._1._2, f._2._1._3, f._2._2))).join(item_XX_YY)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     *  提取item_XY_XX_YY中的(aid1,aid2,XY,XX,YY))</span></div><div class="line"><span class="comment">     *  RDD[(aid1,aid2,score11 * score12 + score21 * score22,score11 * score11 + score21 * score21,score12 * score12 + score22 * score22)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_pair_XY_XX_YY = item_XY_XX_YY.map(f =&gt; (f._2._1._1, f._2._1._2, f._2._1._3, f._2._1._4, f._2._2))</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     *  转化item_pair_XY_XX_YY为(aid1,aid2,XY / math.sqrt(XX * YY))</span></div><div class="line"><span class="comment">     *  RDD[(aid1,aid2,score11 * score12 + score21 * score22 / math.sqrt((score11 * score11 + score21 * score21)*(score12 * score12 + score22 * score22))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_pair_sim = item_pair_XY_XX_YY.map(f =&gt; (f._1, (f._2, f._3 / math.sqrt(f._4 * f._5))))</div><div class="line">    item_pair_sim</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">    * 基于item相似度矩阵为user生成topN推荐列表</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @param resource</span></div><div class="line"><span class="comment">    * @param item_sim_bd</span></div><div class="line"><span class="comment">    * @param topN</span></div><div class="line"><span class="comment">    * @return RDD[(user,List[(item,score)])]</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">recommend</span></span>(resource: <span class="type">DataFrame</span>, item_sim_bd: <span class="type">Broadcast</span>[scala.collection.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Double</span>)]]], topN: <span class="type">Int</span> = <span class="number">50</span>) = &#123;</div><div class="line">    <span class="keyword">val</span> user_item_score = resource.map(</div><div class="line">      row =&gt; &#123;</div><div class="line">        <span class="keyword">val</span> uid = row.getString(<span class="number">0</span>)</div><div class="line">        <span class="keyword">val</span> aid = row.getString(<span class="number">1</span>)</div><div class="line">        <span class="keyword">val</span> score = row.getString(<span class="number">2</span>).toDouble</div><div class="line">        ((uid, aid), score)</div><div class="line">      &#125;</div><div class="line">    )</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取item_sim_user_score为((user,item2),sim * score)</span></div><div class="line"><span class="comment">     * RDD[(user,item2),sim * score]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> user_item_simscore = user_item_score.flatMap(</div><div class="line">      f =&gt; &#123;</div><div class="line">        <span class="keyword">val</span> items_sim = item_sim_bd.value.getOrElse(f._1._2, <span class="type">List</span>((<span class="string">"0"</span>, <span class="number">0.0</span>)))</div><div class="line">        <span class="keyword">for</span> (w &lt;- items_sim) <span class="keyword">yield</span> ((f._1._1, w._1), w._2 * f._2)</div><div class="line">      &#125;).filter(_._2 &gt; <span class="number">0.03</span>)</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 聚合user_item_simscore为 (user,（item2,sim1 * score1 + sim2 * score2）)</span></div><div class="line"><span class="comment">     * 假设user观看过两个item,评分分别为score1和score2，item2是与user观看过的两个item相似的item,相似度分别为sim1，sim2</span></div><div class="line"><span class="comment">     * RDD[(user,item2),sim1 * score1 + sim2 * score2）)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> user_item_rank = user_item_simscore.reduceByKey(_ + _, <span class="number">1000</span>)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 过滤用户已看过的item,并对user_item_rank基于user聚合</span></div><div class="line"><span class="comment">     * RDD[(user,CompactBuffer((item2,rank2）,(item3,rank3)...))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> user_items_ranks = user_item_rank.subtractByKey(user_item_score).map(f =&gt; (f._1._1, (f._1._2, f._2))).groupByKey(<span class="number">1000</span>)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 对user_items_ranks基于rank降序排序，并提取topN,其中包括用户已观看过的item</span></div><div class="line"><span class="comment">     * RDD[(user,ArrayBuffer((item2,rank2）,...,(itemN,rankN)))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> user_items_ranks_desc = user_items_ranks.map(f =&gt; &#123;</div><div class="line">      <span class="keyword">val</span> item_rank_list = f._2.toList</div><div class="line">      <span class="keyword">val</span> item_rank_desc = item_rank_list.sortWith((x, y) =&gt; x._2 &gt; y._2)</div><div class="line">      (f._1, item_rank_desc.take(topN))</div><div class="line">    &#125;)</div><div class="line">    user_items_ranks_desc</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">    * json 编码格式1：用于CF离线推荐结果</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @param recTopN 离线推荐结果</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">encodeToJson1</span></span>(recTopN: (<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Double</span>)])) = &#123;</div><div class="line">    <span class="keyword">val</span> mtype = <span class="string">"lxfs"</span></div><div class="line">    <span class="keyword">val</span> mtype_ = <span class="string">"\""</span> + <span class="string">"mtype"</span> + <span class="string">"\""</span> + <span class="string">":"</span> + <span class="string">"\""</span> + mtype + <span class="string">"\""</span></div><div class="line">    <span class="keyword">val</span> uid = recTopN._1</div><div class="line">    <span class="keyword">val</span> uid_ = <span class="string">"\""</span> + <span class="string">"uid"</span> + <span class="string">"\""</span> + <span class="string">":"</span> + <span class="string">"\""</span> + uid + <span class="string">"\""</span></div><div class="line">    <span class="keyword">val</span> aid_score = recTopN._2</div><div class="line">    <span class="keyword">val</span> aids_ = <span class="keyword">new</span> <span class="type">StringBuilder</span>().append(<span class="string">"\""</span> + <span class="string">"list"</span> + <span class="string">"\""</span> + <span class="string">":["</span>)</div><div class="line">    <span class="keyword">for</span> (v &lt;- aid_score) &#123;</div><div class="line">      <span class="keyword">val</span> aid = v._1.split(<span class="string">"_"</span>)(<span class="number">0</span>)</div><div class="line">      <span class="keyword">val</span> type_ = v._1.split(<span class="string">"_"</span>)(<span class="number">1</span>)</div><div class="line">      <span class="keyword">val</span> score = v._2</div><div class="line">      aids_.append(<span class="string">"&#123;"</span> + <span class="string">"\"aid\""</span> + <span class="string">":"</span> + aid + <span class="string">","</span>)</div><div class="line">      aids_.append(<span class="string">"\"type\""</span> + <span class="string">":"</span> + type_ + <span class="string">","</span>)</div><div class="line">      aids_.append(<span class="string">"\"score\""</span> + <span class="string">":"</span> + score + <span class="string">"&#125;,"</span>)</div><div class="line">    &#125;</div><div class="line">    aids_.deleteCharAt(aids_.length - <span class="number">1</span>).append(<span class="string">"]"</span>)</div><div class="line">    <span class="keyword">val</span> result = <span class="string">"&#123;"</span> + mtype_ + <span class="string">","</span> + uid_ + <span class="string">","</span> + aids_.toString() + <span class="string">"&#125;"</span></div><div class="line">    result</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">    * json 编码格式2：用于CF相似度矩阵</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @param cf_sim CF截断的相似度矩阵</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">encodeToJson2</span></span>(cf_sim: (<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Double</span>)])) = &#123;</div><div class="line">    <span class="keyword">val</span> mtype = <span class="string">"cf"</span></div><div class="line">    <span class="keyword">val</span> mtype_ = <span class="string">"\""</span> + <span class="string">"mtype"</span> + <span class="string">"\""</span> + <span class="string">":"</span> + <span class="string">"\""</span> + mtype + <span class="string">"\""</span></div><div class="line">    <span class="keyword">val</span> aid1 = cf_sim._1.split(<span class="string">"_"</span>)(<span class="number">0</span>)</div><div class="line">    <span class="keyword">val</span> aid_ = <span class="string">"\""</span> + <span class="string">"aid"</span> + <span class="string">"\""</span> + <span class="string">":"</span> + <span class="string">"\""</span> + aid1 + <span class="string">"\""</span></div><div class="line">    <span class="keyword">val</span> aid_score = cf_sim._2</div><div class="line">    <span class="keyword">val</span> aids_ = <span class="keyword">new</span> <span class="type">StringBuilder</span>().append(<span class="string">"\""</span> + <span class="string">"similar"</span> + <span class="string">"\""</span> + <span class="string">":["</span>)</div><div class="line">    <span class="keyword">for</span> (v &lt;- aid_score) &#123;</div><div class="line">      <span class="keyword">val</span> aid2 = v._1.split(<span class="string">"_"</span>)(<span class="number">0</span>)</div><div class="line">      <span class="keyword">val</span> type_ = v._1.split(<span class="string">"_"</span>)(<span class="number">1</span>)</div><div class="line">      <span class="keyword">val</span> score = v._2</div><div class="line">      aids_.append(<span class="string">"&#123;"</span> + <span class="string">"\"aid\""</span> + <span class="string">":"</span> + aid2 + <span class="string">","</span>)</div><div class="line">      aids_.append(<span class="string">"\"type\""</span> + <span class="string">":"</span> + type_ + <span class="string">","</span>)</div><div class="line">      aids_.append(<span class="string">"\"score\""</span> + <span class="string">":"</span> + score + <span class="string">"&#125;,"</span>)</div><div class="line">    &#125;</div><div class="line">    aids_.deleteCharAt(aids_.length - <span class="number">1</span>).append(<span class="string">"]"</span>)</div><div class="line">    <span class="keyword">val</span> result = <span class="string">"&#123;"</span> + mtype_ + <span class="string">","</span> + aid_ + <span class="string">","</span> + aids_.toString() + <span class="string">"&#125;"</span></div><div class="line">    result</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> table = args(<span class="number">0</span>) <span class="comment">//要处理的表</span></div><div class="line">    <span class="keyword">val</span> day = args(<span class="number">1</span>) <span class="comment">//当前日期</span></div><div class="line"></div><div class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"Wireless ItemBased Collaborative Filtering"</span>)</div><div class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</div><div class="line"></div><div class="line">    <span class="keyword">val</span> resource = getResource(sc, table, day).repartition(<span class="number">1000</span>)</div><div class="line">    resource.cache()</div><div class="line"></div><div class="line">    <span class="comment">// 1.计算item相似度矩阵</span></div><div class="line">    <span class="keyword">val</span> item_sim: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">String</span>, <span class="type">Double</span>))] = getCosineSimilarity(resource)</div><div class="line">    item_sim.cache()</div><div class="line"></div><div class="line">    <span class="comment">// 2.每个item提取最相近的40个item</span></div><div class="line">    <span class="keyword">val</span> item_sim_rdd = item_sim.filter(f =&gt; f._2._2 &gt; <span class="number">0.05</span>).groupByKey().map(</div><div class="line">      f =&gt; &#123;</div><div class="line">        <span class="keyword">val</span> item = f._1</div><div class="line">        <span class="keyword">val</span> items_score = f._2.toList</div><div class="line">        <span class="keyword">val</span> items_score_desc = items_score.sortWith((x, y) =&gt; x._2 &gt; y._2)</div><div class="line">        (item, items_score_desc.take(<span class="number">40</span>))</div><div class="line">      &#125;).cache()</div><div class="line"></div><div class="line">    <span class="comment">// 3.保存cf相似度矩阵到HDFS</span></div><div class="line">    item_sim_rdd.map(encodeToJson2(_)).foreachPartition(</div><div class="line">      f =&gt; &#123;</div><div class="line">        <span class="keyword">for</span> (m &lt;- f) <span class="type">MqManager</span>.sendMessage(m)</div><div class="line">      &#125;</div><div class="line">    )</div><div class="line"></div><div class="line">    <span class="comment">// 4.广播相似度矩阵</span></div><div class="line">    <span class="keyword">val</span> item_sim_map = item_sim_rdd.collectAsMap()</div><div class="line">    <span class="keyword">val</span> item_sim_bd: <span class="type">Broadcast</span>[scala.collection.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Double</span>)]]] = sc.broadcast(item_sim_map)</div><div class="line"></div><div class="line">    <span class="comment">// 5.为用户生成推荐列表</span></div><div class="line">    <span class="keyword">val</span> recTopN = recommend(resource, item_sim_bd, <span class="number">50</span>)</div><div class="line"></div><div class="line">    <span class="comment">/* 6.发送RabbitMQ</span></div><div class="line"><span class="comment">     * 1&gt; CF相似度矩阵Json 编码并发送</span></div><div class="line"><span class="comment">     * 2&gt; 用户推荐列表Json 编码并发送</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    recTopN.map(encodeToJson1(_)).foreachPartition(</div><div class="line">      f =&gt; &#123;</div><div class="line">        <span class="keyword">for</span> (m &lt;- f) <span class="type">MqManager</span>.sendMessage(m)</div><div class="line">      &#125;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-项目简介&quot;&gt;&lt;a href=&quot;#1-项目简介&quot; class=&quot;headerlink&quot; title=&quot;1. 项目简介&quot;&gt;&lt;/a&gt;1. 项目简介&lt;/h2&gt;&lt;p&gt;无线短视频推荐项目，负责无线端用户的短视频推荐，也就是给手机端用户推荐短视频。主要用到了item-bas
      
    
    </summary>
    
    
  </entry>
  
</feed>
