<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/小鸡.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/小鸡.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/小鸡.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="1. 应用场景AVL树：平衡二叉树之一，应用相对其他数据结构比较少，windows对进程地址空间的管理用到了AVL 红黑树：平衡二叉树，广泛应用在C++STL中，比如map和set，Java的TreeMap B和B+树：主要用在文件系统以及数据库中做索引等 Trie 树：用在统计和排序大量字符串中，一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示。还有比如IP选路">
<meta property="og:type" content="article">
<meta property="og:title" content="B树、B+树、AVL树、Trie树及其应用场景">
<meta property="og:url" content="http://yoursite.com/2018/03/09/B树、B-树、AVL树、Trie树及其应用场景/index.html">
<meta property="og:site_name" content="Siyao&#39;s Blog">
<meta property="og:description" content="1. 应用场景AVL树：平衡二叉树之一，应用相对其他数据结构比较少，windows对进程地址空间的管理用到了AVL 红黑树：平衡二叉树，广泛应用在C++STL中，比如map和set，Java的TreeMap B和B+树：主要用在文件系统以及数据库中做索引等 Trie 树：用在统计和排序大量字符串中，一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示。还有比如IP选路">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://img.blog.csdn.net/20180307121339361">
<meta property="og:image" content="https://github.com/julycoding/The-Art-Of-Programming-By-July/raw/master/ebook/images/rbtree/1.png">
<meta property="og:image" content="http://img.blog.csdn.net/20161117122843822">
<meta property="og:image" content="http://om1bxijvl.bkt.clouddn.com/2018-03-03-14-53-26.png">
<meta property="og:image" content="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-28.png">
<meta property="og:image" content="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-42.png">
<meta property="og:image" content="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-55.png">
<meta property="og:image" content="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-12.png">
<meta property="og:image" content="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-26.png">
<meta property="og:image" content="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-03-33.png">
<meta property="og:image" content="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-27.png">
<meta property="og:image" content="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-41.png">
<meta property="og:image" content="http://img.blog.csdn.net/20160915145726227">
<meta property="og:image" content="http://img.blog.csdn.net/20160915150104895">
<meta property="og:image" content="http://img.blog.csdn.net/20160915150446557">
<meta property="og:image" content="http://img.blog.csdn.net/20160915150946108">
<meta property="og:image" content="http://img.blog.csdn.net/20160915152043269">
<meta property="og:image" content="http://img.blog.csdn.net/20160915152349100">
<meta property="og:image" content="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-31-31.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/1051369/201704/1051369-20170404131434878-399064987.jpg">
<meta property="og:updated_time" content="2018-03-12T12:35:15.834Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="B树、B+树、AVL树、Trie树及其应用场景">
<meta name="twitter:description" content="1. 应用场景AVL树：平衡二叉树之一，应用相对其他数据结构比较少，windows对进程地址空间的管理用到了AVL 红黑树：平衡二叉树，广泛应用在C++STL中，比如map和set，Java的TreeMap B和B+树：主要用在文件系统以及数据库中做索引等 Trie 树：用在统计和排序大量字符串中，一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示。还有比如IP选路">
<meta name="twitter:image" content="http://img.blog.csdn.net/20180307121339361">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Siyao'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/09/B树、B-树、AVL树、Trie树及其应用场景/"/>





  <title>B树、B+树、AVL树、Trie树及其应用场景 | Siyao's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?22ca9e711cab30a2d33c6a2c25780e5f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Siyao's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/B树、B-树、AVL树、Trie树及其应用场景/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Siyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/小鸡.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Siyao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">B树、B+树、AVL树、Trie树及其应用场景</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-09T11:10:57+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,703
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h2><p>AVL树：平衡二叉树之一，应用相对其他数据结构比较少，windows对进程地址空间的管理用到了AVL</p>
<p>红黑树：平衡二叉树，广泛应用在C++STL中，比如map和set，Java的TreeMap</p>
<p>B和B+树：主要用在文件系统以及数据库中做索引等</p>
<p>Trie 树：用在统计和排序大量字符串中，一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示。还有比如IP选路，也是前缀匹配</p>
<p>R树：空间数据库索引</p>
<h2 id="2-二叉搜索树"><a href="#2-二叉搜索树" class="headerlink" title="2. 二叉搜索树"></a>2. 二叉搜索树</h2><p>不必多说了，可以参考 <a href="https://siyaozhang.github.io/2017/11/29/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95/" target="_blank" rel="external">【九章算法基础班】二叉树与分治法</a></p>
<p><strong>时间复杂度</strong>最好情况是<script type="math/tex">O(logn)</script> ，最坏情况下时间复杂度<script type="math/tex">O(n)</script>，恰好选择了最小或者最大的节点做root，节点排在了一条直线上。</p>
<h2 id="3-AVL树"><a href="#3-AVL树" class="headerlink" title="3. AVL树"></a>3. AVL树</h2><p>AVL树是二叉搜索树的改进</p>
<p><strong>AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡</strong>，左右子树树高不超过1，和红黑树相比，它是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而<strong>旋转是非常耗时</strong>的，由此我们可以知道<strong>AVL树适合用于插入删除次数比较少，但查找多的情况。</strong></p>
<p><strong><img src="http://img.blog.csdn.net/20180307121339361" alt="img"></strong></p>
<p>上图是一个普通的平衡二叉树，这张图我们可以看出，<strong>任意节点的左右子树的平衡因子差值都不会大于1</strong>。</p>
<p>局限性：</p>
<p>由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。</p>
<h2 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4. 红黑树"></a>4. 红黑树</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><p><strong>一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是red或black（非红即黑）</strong>。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，<strong>红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树</strong>(由于是弱平衡，可以推出，相同的节点情况下，AVL树的高度低于红黑树)，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索、插入、删除操作较多的情况下，我们就用红黑树。</p>
<h3 id="4-2-性质"><a href="#4-2-性质" class="headerlink" title="4.2 性质"></a>4.2 性质</h3><p>1、每个节点非红即黑；</p>
<p>2、根节点是黑的；</p>
<p>3、每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的；</p>
<p>4、如果一个节点是红的,那么它的两儿子都是黑的；</p>
<p>5、对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点；</p>
<p>6、高度始终保持在h = logn</p>
<p>7、<strong>红黑树的查找、插入、删除的时间复杂度最坏为O(log n)</strong></p>
<p>如下图所示，即是一颗红黑树(下图引自wikipedia：<a href="http://t.cn/hgvH1l" target="_blank" rel="external">http://t.cn/hgvH1l</a>)：</p>
<p><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/images/rbtree/1.png" target="_blank" rel="external"><img src="https://github.com/julycoding/The-Art-Of-Programming-By-July/raw/master/ebook/images/rbtree/1.png" alt="img"></a></p>
<p>上文中我们所说的 “叶结点” 或”NULL结点”，它不包含数据而只充当树在此结束的指示，这些结点以及它们的父结点，在绘图中都会经常被省略。</p>
<h3 id="4-3-应用"><a href="#4-3-应用" class="headerlink" title="4.3 应用"></a>4.3 应用</h3><p>1、广泛用于C++的STL中，Map和Set都是用红黑树实现的；</p>
<p>2、著名的<strong>Linux进程调度Completely Fair Scheduler</strong>，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间；</p>
<p>3、IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查；</p>
<p>4、Nginx中用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器；</p>
<p>5、<strong>Java中TreeMap的实现</strong>；</p>
<p>详细的插入、删除、旋转等操作可以参考：</p>
<p><a href="https://juejin.im/entry/58371f13a22b9d006882902d" target="_blank" rel="external">面试旧敌之红黑树（直白介绍深入理解）</a></p>
<h2 id="5-B树"><a href="#5-B树" class="headerlink" title="5. B树"></a>5. B树</h2><h3 id="5-1-B-树简介"><a href="#5-1-B-树简介" class="headerlink" title="5.1 B-树简介"></a>5.1 B-树简介</h3><p>B树是为实现<strong>高效的磁盘存取</strong>而设计的多叉平衡搜索树。这个概念在文件系统，数据库系统中非常重要。</p>
<p>​    B树是一种查找树，我们知道，这一类树（比如二叉查找树，红黑树等等）最初生成的目的都是为了解决某种系统中，查找效率低的问题。B树也是如此，它最初启发于二叉查找树，二叉查找树的特点是每个非叶节点都只有两个孩子节点。然而这种做法会导致当数据量非常大时，二叉查找树的深度过深，搜索算法自根节点向下搜索时，需要访问的节点也就变的相当多。如果这些节点存储在外存储器中，每访问一个节点，相当于就是进行了一次I/O操作，随着树高度的增加，频繁的I/O操作一定会降低查询的效率。</p>
<p>​    这里有一个基本的概念，就是说我们从外存储器中读取信息的步骤，简单来分，大致有两步：</p>
<ol>
<li>找到存储这个数据所对应的磁盘页面，这个过程是机械化的过程，需要依靠磁臂的转动，找到对应磁道，所以耗时长。</li>
<li>读取数据进内存，并实施运算，这是电子化的过程，相当快。</li>
</ol>
<p>总的来说，<strong>B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树</strong>(相对于二叉，B树每个内节点有多个分支)，<strong>与红黑树相比，在相同的的节点的情况下，一颗B/B+树的高度远远小于红黑树的高度</strong>(在下面B/B+树的性能分析中会提到)。<strong>B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成</strong>，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，<strong>在关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少</strong>。而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。</p>
<h3 id="5-2-B-树结构"><a href="#5-2-B-树结构" class="headerlink" title="5.2 B-树结构"></a>5.2 B-树结构</h3><p>B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p>
<p>B树的结构要求：<br><strong>1）根节点至少有两个子节点</strong><br><strong>2）每个节点有M-1个key，并且以升序排列</strong><br><strong>3）位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</strong><br><strong>4）其它节点至少有M/2个子节点</strong> [M/2,M-1]<br><strong>5）所有叶子节点都在同一层</strong><br><img src="http://img.blog.csdn.net/20161117122843822" alt="这里写图片描述"> </p>
<p><strong>B树高度</strong></p>
<p>对于一个包含n个关键字，最小度数t≥2t≥2 的B树，其高度hh 一定满足：</p>
<script type="math/tex; mode=display">h \leq \log_{t}{\frac{n + 1}{2}}</script><p>在搜索B树时，很明显，访问节点（即读取磁盘）的次数与树的高度呈正比，而B树与红黑树和普通的二叉查找树相比，虽然高度都是对数数量级，但是显然B树中log函数的底可以比2更大，因此，和二叉树相比，极大地减少了磁盘读取的次数。</p>
<h3 id="5-3-B-树操作"><a href="#5-3-B-树操作" class="headerlink" title="5.3 B-树操作"></a>5.3 B-树操作</h3><ol>
<li><p><strong>查找</strong></p>
<p>一棵已经建立好的B树如下图所示，我们的目的是查找关键字为29的文件：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-14-53-26.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-14-53-26.png" alt="img"></a></p>
<p>先简单说明一下上图：</p>
<ul>
<li>图中小红方块表示对应关键字锁代表的文件存储位置。实际上可以看做一个地址。比如根节点17旁边的小红块表示关键字17所对应的文件在硬盘中的存储地址。</li>
<li>P是指针。需要注意的是：指针 + 关键字 + 小红块 这三个东西合起来构成了一个B树的节点。这个节点存储在一个磁盘块上。</li>
</ul>
<p>下面看看搜索关键字29的文件的过程：</p>
<ol>
<li>从根节点开始，读取根节点信息，根节点有2个关键字：17和35。因为17 &lt; 29 &lt; 35，所以找到指针P2指向的子树，也就是磁盘块3（1次I/0操作）</li>
<li>读取当前节点信息，当前节点有2个关键字：26和30。26 &lt; 29 &lt; 30，找到指针P2指向的子树，也就是磁盘块8（2次I/0操作）</li>
<li>读取当前节点信息，当前节点有2个关键字：28和29。找到了！（3次I/0操作）</li>
</ol>
<p>由上面的过程可见，同样的操作，如果使用平衡二叉树，那么需要至少4次I/O操作，B树比之二叉树的这种优势，还会随着节点数的增加而增加。另外，因为B树节点中的关键字都是排序好的，所以，在节点中的信息被读入内存之后，可以采用二分查找这种快速的查找方式，更进一步减少了读入内存之后的计算时间，由此更能说明对于外存数据结构来说，I/O次数是其查找信息中最大的时间消耗，而我们要做的所有努力就是尽量在搜索过程中减少I/O操作的次数。</p>
</li>
<li><p><strong>插入</strong></p>
<p>​    向B树种插入关键字的过程与向二叉查找树中插入关键字的过程类似，但是要稍微复杂一点，因为根据上面B树的定义，我们可以看出，B树每个节点中关键字的个数是有范围要求的，同时，B树是平衡的，所以，如果像二叉查找树那样，直接找到相关的叶子，插入关键字，有可能会导致B树的结构发生变化而这种变化会使得B树不再是B树。</p>
<p>​    所以，我们这样来设计B树种对新关键字的插入：首先找到要插入的关键字应该插入的叶子节点（为方便描述，设这个叶子节点为u），如果u是满的（恰好有2t−1个关键字），那么由于不能将一个关键字插入满的节点，我们需要对u按其当前<strong>排在中间关键字</strong><script type="math/tex">u.key_t</script>进行分裂，<strong>分裂</strong>成两个节点u1,u2；同时，作为分裂标准的关键字<script type="math/tex">u.key_t</script>被<strong>上移到u的父节点中</strong>，在<script type="math/tex">u.key_t</script>插入前，如果u的父节点未满，则直接插入即可；如果u的父节点已满，则按照上面的方法对u的父节点分裂，这个过程如果一直不停止的话，最终会导致B树的根节点分裂，B树的高度增加一层。</p>
<p>​    下面用《算法导论》中的一个题目展示一下这种插入关键字的过程。</p>
<p>现在我们要将关键字序列：F, S, Q, K, C, L, H, T, V, W, M, R, N, P, A, B, X, Y依次插入一棵最小度为2的B树中。也就是说，这棵树的节点中，最多有3个关键字，最少有1个关键字。</p>
<p><strong>第1步</strong>，F, S, Q可以被插入一个节点（也就是根节点）</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-28.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-28.png" alt="img"></a></p>
<p><strong>第2步</strong>，插入关键字K，因为节点已满，所以在插入前，发生分裂，中间关键字Q上移，建立了一个新的根节点：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-42.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-42.png" alt="img"></a></p>
<p><strong>第3步</strong>，插入关键字C:</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-55.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-55.png" alt="img"></a></p>
<p><strong>第4步</strong>，插入关键字L，L应该被插入到根节点的左侧的孩子中，因为此时该节点已满，所以在插入前，发生分裂：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-12.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-12.png" alt="img"></a></p>
<p><strong>第5步</strong>，插入关键字H, T, V，这个过程没有发生节点的分裂：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-26.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-26.png" alt="img"></a></p>
<p><strong>第6步</strong>，插入关键字W，W应该被插入到根节点的最右侧的孩子中，因为此时该节点已满，所以在插入前，关键字T上移，最右端的叶子节点发生分裂：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-03-33.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-03-33.png" alt="img"></a></p>
<p><strong>第7步</strong>，插入关键字M，M应该被插入到根节点的左起第2个孩子中，因为此时该节点已满，所以在插入前，发生分裂，分裂之后，中间关键字K上移，导致根节点发生分裂，树高增加1：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-27.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-27.png" alt="img"></a></p>
<p>第8步，同样的道理，插入关键字R, N, P, A, B, X, Y：最终得到的B树如下：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-41.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-41.png" alt="img"></a></p>
</li>
<li><p><strong>删除</strong></p>
<p>​    删除操作的基本思想和插入操作是一样的，都是不能因为关键字的改变而改变B树的结构。<strong>插入操作主要防止的是某个节点中关键字的个数太多，所以采用了分裂；删除则是要防止某个节点中，因删除了关键字而导致这个节点的关键字个数太少，所以采用了合并操作。</strong></p>
<p>下面分三种情况来讨论下删除操作是如何工作的，这个过程的顺序是自根节点起向下遍历B树</p>
<p><strong>Case - 1：</strong>如果要删除的关键字k在节点u中，而且u是<strong>叶子节点</strong>，那么直接删除k</p>
<p><strong>Case - 2：</strong>如果要删除的关键字k在节点u中，而且u是<strong>内部节点</strong>。由于关键字影响着子树的范围，因此不能随意删除。必须<strong>从子树中找到一个合适的数字来替代k</strong>才可以。需要分以下3种情况讨论：</p>
<p>(1) 如果u中前于k的子节点u1中至少含有t个关键字，则找出k在以u1为根的子树中的前驱k′（前驱的意思是u1中比k小的关键字中最大的），然后在以u1为根的子树中删除k′，并在u中以k′替代k</p>
<p>(2) 如果上面的条件(1)不成立，也就是说，前于k的子节点中关键字的个数小于t了，那么就去找后于k的子节点，记为u2。若u2中至少含有t个关键字，则找出k在以u2为根的子树中的后继k′(大于k的关键字中最小的)，然后在以u2为根的子树中删除k′，并在u中以k′替代k。可以看出（2）是（1）的一个对称过程</p>
<p>(3) 如果u1,u2中的关键字个数都是t−1，则将k和u2合并后并入u1，这样u就失去了k和指向u2的指针，最后递归地从u1中删除k</p>
<p><strong>Case - 3：</strong>如果要删除的关键字k不在当前节点u中，而且u是内部节点（如果自上而下扫描到叶子都没有这个关键字的话，那就说明要删除的关键字根本就不存在，所以此处只考虑u是内部节点的情况），则首先确定包含k的u的子树，我们这里设为u.pi。如果u.pi中至少含有t个关键字，那么继续扫描，寻找下一个要被扫描的子树；如果u.pi中只含有t−1个关键字，则需要分下面两种情况进行操作：</p>
<p>(1) 如果u.pi至少有一个相邻的兄弟比较“丰满”（即这个兄弟至少有t个关键字）。则将u中的一个关键字降至u.pi，同时令u.pi的最“丰满”的兄弟中升一个关键至u。然后继续扫描B树，寻找k</p>
<p>(2) 如果u.pi的两个相邻的兄弟都不“丰满”（都只有t−1个关键字）。则令u.pi和其一个兄弟合并，再将u的一个关键字降至新合并的节点。使之成为该节点的中间关键字。</p>
<p>举个例子</p>
<p>1、初始状态<br><img src="http://img.blog.csdn.net/20160915145726227" alt="这里写图片描述"></p>
<p>2、删除元素H<br>首先查找H，H在一个叶子结点中，且该叶子结点元素数目3 &gt; 2<br>移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）<br><img src="http://img.blog.csdn.net/20160915150104895" alt="这里写图片描述"></p>
<p>3、删除T<br>在中间结点中找到T，此时删了T后该节点关键字个数 1 &lt; 2<br>将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该叶子结点中元素个数 &gt; 2，无需进行合并操作<br><img src="http://img.blog.csdn.net/20160915150446557" alt="这里写图片描述"></p>
<p>4、删除R<br>R所在叶子结点中元素数目为2，删除导致只有1个元素</p>
<blockquote>
<p>如果其某个相邻兄弟结点中比较丰满（元素个数 &gt; [M/2] - 1），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中</p>
</blockquote>
<p>在这个实例中，右相邻兄弟结点中比较丰满（3 &gt; 2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。<br><img src="http://img.blog.csdn.net/20160915150946108" alt="这里写图片描述"></p>
<p>5、删除E<br>删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（[M/2] - 1），而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件<br>所以需要该节点与某相邻兄弟结点进行合并操作：</p>
<blockquote>
<p>首先，移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中；<br>然后将这两个结点进行合并成一个结点。</p>
</blockquote>
<p>即，将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点。<br><img src="http://img.blog.csdn.net/20160915152043269" alt="这里写图片描述"><br>此时G所在节点只有一个元素，不行。<br>此时该结点的相邻兄弟又不丰满，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，这样，树的高度减少一层。<br><img src="http://img.blog.csdn.net/20160915152349100" alt="这里写图片描述"></p>
</li>
</ol>
<h2 id="6-B-树"><a href="#6-B-树" class="headerlink" title="6. B+树"></a>6. B+树</h2><p>​    B+树是B树的一种变形，<strong>它更适合实际应用中操作系统的文件索引和数据库索引</strong>。定义如下：（为和大多资料保持一致，这里使用阶数m来定义B+树，而不像之前的B树中，使用的是最小度t来定义）</p>
<ol>
<li>每个内部节点的关键字个数为[m/2,m] 个。其中每个关键字对应一个子树；</li>
<li>根节点要么没有子树，要么至少有2颗子树</li>
<li>叶子节点包含了全部的关键字以及关键字指向文件的指针，且：<ol>
<li>所有叶子节点中的关键字按大小顺序排列</li>
<li>相邻的叶子节点顺序链接（相当于是构成了一个顺序链表）</li>
<li>所有叶子节点在同一层</li>
</ol>
</li>
<li>所有分支节点的关键字都是对应子树中关键字的最大值</li>
</ol>
<p>比如，下图就是一个非常典型的B+树的例子。</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-31-31.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-31-31.png" alt="img"></a></p>
<p>B+树和B树相比，主要的不同点在以下3项：</p>
<ul>
<li>内部节点中，关键字的个数与其子树的个数相同，不像B树中，子树的个数总比关键字个数多1个</li>
<li>所有指向文件的关键字及其指针都在叶子节点中，不像B树，有的指向文件的关键字是在内部节点中。换句话说，B+树中，内部节点仅仅起到索引的作用</li>
<li>在搜索过程中，如果查询和内部节点的关键字一致，那么搜索过程不停止，而是继续向下搜索这个分支</li>
</ul>
<h2 id="6-R树"><a href="#6-R树" class="headerlink" title="6. R树"></a>6. R树</h2><h3 id="6-1-R树的结构"><a href="#6-1-R树的结构" class="headerlink" title="6.1 R树的结构"></a>6.1 R树的结构</h3><p>​    R树是B树在<strong>高维</strong>空间的扩展，是一棵<strong>平衡树</strong>。每个R树的叶子结点包含了多个指向不同数据的指针，这些数据可以是存放在硬盘中的，也可以是存在内存中。根据R树的这种数据结构，当我们需要进行一个高维空间查询时，我们只需要遍历少数几个叶子结点所包含的指针，查看这些指针指向的数据是否满足要求即可。这种方式使我们不必遍历所有数据即可获得答案，效率显著提高。下图1是R树的一个简单实例：</p>
<p><img src="https://images2015.cnblogs.com/blog/1051369/201704/1051369-20170404131434878-399064987.jpg" alt="img"></p>
<p>在R树中存放的数据并不是原始数据，而是这些数据的<strong>最小边界矩形（MBR</strong>），空间对象的MBR被包含于R树的叶结点中。</p>
<p>R树满足如下的性质：</p>
<p>1)       根结点至少有两个子结点，除非它同时是叶子结点</p>
<p>2)       每一个叶子结点包含 m至M个索引项记录，通常， m=M/2。</p>
<p>3)       每一个非叶子节点拥有m至M个子节点，除非它是跟节点。</p>
<p>4)       所有叶子节点都位于同一层。</p>
<p>支持搜索、增加、删除等操作，可以自定义矩形的最大子节点数。</p>
<p>更详细的内容可以参考<a href="http://www.cnblogs.com/cmi-sh-love/p/kong-jian-shud-ju-suo-yinRTree-wan-quan-jie-xi-jiJa.html" target="_blank" rel="external">空间数据索引RTree（R树）完全解析及Java实现</a></p>
<h2 id="7-对比"><a href="#7-对比" class="headerlink" title="7. 对比"></a>7. 对比</h2><h3 id="7-1-B树和B-树的区别"><a href="#7-1-B树和B-树的区别" class="headerlink" title="7.1 B树和B+树的区别"></a>7.1 B树和B+树的区别</h3><p>​    B/B+树用在磁盘文件组织、数据索引和数据库索引中。其中B+树比B 树更适合实际应用中操作系统的文件索引和数据库索引，因为：<br><strong>1、B+树的磁盘读写代价更低</strong><br>B+树的内部结点并没有指向关键字具体信息的指针。因此其<strong>内部结点</strong>相对B 树<strong>更小</strong>。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
<blockquote>
<p>举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。</p>
</blockquote>
<p><strong>2、B+-tree的查询效率更加稳定</strong><br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的<strong>路径长度相同</strong>，导致每一个数据的查询效率相当。</p>
<p>3、<strong>B树在元素遍历的时候效率较低</strong> </p>
<p>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库<strong>，只需要扫一遍叶子结点即可</strong>，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。在数据库中基于范围的查询相对频繁，所以此时B+树优于B树。</p>
<h3 id="7-2-红黑树与B树区别"><a href="#7-2-红黑树与B树区别" class="headerlink" title="7.2 红黑树与B树区别"></a>7.2 红黑树与B树区别</h3><p>  一言而知就是树的深度较高，在磁盘I/O方面的表现不如B树。<br>  要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定。<br>  所以，在大规模数据存储的时候，<strong>红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁</strong>，进而导致效率低下。在这方面，B树表现相对优异，B树可以有多个子女，从几十到上千，可以降低树的高度。</p>
<h3 id="7-3-AVL树和红黑树"><a href="#7-3-AVL树和红黑树" class="headerlink" title="7.3 AVL树和红黑树"></a>7.3 AVL树和红黑树</h3><p>红黑树的算法时间复杂度和AVL相同，但<strong>统计性能</strong>比AVL树更高。</p>
<blockquote>
<p>1、红黑树和AVL树都能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。<br>2、由于设计，红黑树的任何不平衡都会在三次旋转之内解决。AVL树增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>
</blockquote>
<p>在<strong>查找</strong>方面：<br>  红黑树的性质(最长路径长度不超过最短路径长度的2倍)，其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点。<br>  AVL是严格平衡的二叉查找树（平衡因子不超过1）。查找过程中不会出现最差情况的单支树。因此查找效率最好，最坏情况都是O(logN)数量级的。</p>
<p>所以，综上：<br>  AVL比RBtree更加平衡，但是AVL的插入和删除会带来大量的旋转。 所以如果<strong>插入和删除比较多</strong>的情况，应该使用<strong>RBtree</strong>, 如果<strong>查询操作比较多</strong>，应该使用<strong>AVL</strong>。</p>
<blockquote>
<p>AVL是一种高度平衡的二叉树，维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果场景中对插入删除不频繁，只是对查找特别有要求，AVL还是优于红黑的。</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://blog.csdn.net/u010899985/article/details/79468080" target="_blank" rel="external">为什么MySQL数据库索引选择使用B+树</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/08/【机器学习】过拟合、欠拟合及其解决办法/" rel="next" title="过拟合、欠拟合及其解决办法">
                <i class="fa fa-chevron-left"></i> 过拟合、欠拟合及其解决办法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/09/【机器学习】生成模型vs判别模型、有监督vs无监督/" rel="prev" title="生成模型vs判别模型、有监督vs无监督">
                生成模型vs判别模型、有监督vs无监督 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/小鸡.png"
                alt="Siyao" />
            
              <p class="site-author-name" itemprop="name">Siyao</p>
              <p class="site-description motion-element" itemprop="description">siyao小朋友画圈圈的地方</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">120</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-应用场景"><span class="nav-number">1.</span> <span class="nav-text">1. 应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-二叉搜索树"><span class="nav-number">2.</span> <span class="nav-text">2. 二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-AVL树"><span class="nav-number">3.</span> <span class="nav-text">3. AVL树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-红黑树"><span class="nav-number">4.</span> <span class="nav-text">4. 红黑树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-简介"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-性质"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-应用"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-B树"><span class="nav-number">5.</span> <span class="nav-text">5. B树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-B-树简介"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 B-树简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-B-树结构"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 B-树结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-B-树操作"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 B-树操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-B-树"><span class="nav-number">6.</span> <span class="nav-text">6. B+树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-R树"><span class="nav-number">7.</span> <span class="nav-text">6. R树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-R树的结构"><span class="nav-number">7.1.</span> <span class="nav-text">6.1 R树的结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-对比"><span class="nav-number">8.</span> <span class="nav-text">7. 对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-B树和B-树的区别"><span class="nav-number">8.1.</span> <span class="nav-text">7.1 B树和B+树的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-红黑树与B树区别"><span class="nav-number">8.2.</span> <span class="nav-text">7.2 红黑树与B树区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-AVL树和红黑树"><span class="nav-number">8.3.</span> <span class="nav-text">7.3 AVL树和红黑树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">9.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Siyao</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div>





 
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">222.8k</span>
  
        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人次
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->





  

  

  
  

  
  


  

  

</body>
</html>
