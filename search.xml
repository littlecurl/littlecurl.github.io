<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[【机器学习】朴素贝叶斯]]></title>
      <url>/2018/03/19/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【机器学习】k近邻]]></title>
      <url>/2018/03/19/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91k%E8%BF%91%E9%82%BB/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【机器学习】CART算法、决策树总结]]></title>
      <url>/2018/03/19/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91CART%E7%AE%97%E6%B3%95%E3%80%81%E5%86%B3%E7%AD%96%E6%A0%91%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p><strong>决策树</strong>学习的本质是从训练数据集中归纳出一组分类规则，从另一个角度看，决策树学习是由训练数据集估计条件概率模型，我们选择的模型应该不仅对训练数据拟合的好，还应具有很好的泛化能力。</p>
<p><strong>决策树学习的三个步骤：</strong></p>
<ol>
<li>特征选择</li>
<li>决策树的生成</li>
<li>决策树的剪枝</li>
</ol>
<h1 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h1><p>​    特征选择在于选取对训练数据具有分类能力的特征，如果一个特征的分类效果不优于随机分类，那么这个这个特征是没有分类能力的，应当放弃。特征选择决定用哪个特征来划分空间，特征选择的准则通常是<strong>信息增益</strong> 、<strong>信息增益比</strong> 、<strong>基尼指数</strong>。</p>
<h2 id="使用信息增益计算"><a href="#使用信息增益计算" class="headerlink" title="使用信息增益计算"></a>使用信息增益计算</h2><p> 特征A对训练数据集D的信息增益<script type="math/tex">g(D,A)</script> ，定义为集合D的经验熵<script type="math/tex">H(D)</script>与特征更A给定条件下D的经验条件熵<script type="math/tex">H(D|A)</script> 之差，即：</p>
<script type="math/tex; mode=display">g(D,A) = H(D)-H(D|A)</script><p><strong>熵越大，说明系统越混乱，携带的信息就越少。熵越小，说明系统越有序，携带的信息就越多</strong>。信息的作用就是在于消除不确定性。</p>
<p>ID3划分特征使用的就是信息增益IG。<strong>一个属性的信息增益越大，表明属性对样本的熵减少的能力就更强，该属性使得数据所属类别的不确定性变为确定性的能力越强</strong>。</p>
<p><strong>信息增益计算</strong></p>
<p>首先计算特征A对数据集D的经验<strong>条件熵</strong><script type="math/tex">H(D|A)</script>,在数学上就是条件概率分布（Condition Probability）.</p>
<script type="math/tex; mode=display">H(D|A)=\sum_j\dfrac{|D_j|}{|D|}\times H(D_j) =\sum_j\dfrac{|D_j|}{|D|} \sum_k\dfrac{|D_{jk}|}{|D_j|}log\dfrac{|D_{jk}|}{|D_j|}</script><p>其中项<script type="math/tex">\dfrac{|D_i|}{|D|}</script>充当第j个分区的权重</p>
<h2 id="信息增益比："><a href="#信息增益比：" class="headerlink" title="信息增益比："></a>信息增益比：</h2><p>在决策树中，<strong>ID3属性划分标准使用的是信息增益，C4.5使用的是信息增益率。</strong></p>
<p>C4.5算法继承了ID3算法的优点，并在以下几方面对ID3算法进行了改进：</p>
<ul>
<li>用信息增益率来选择属性，克<strong>服了用信息增益选择属性时偏向选择取值多的属性的不足</strong>；</li>
<li>在树构造过程中进行剪枝；</li>
<li>能够完成对连续属性的离散化处理；</li>
<li>能够对不完整数据进行处理。</li>
</ul>
<p>C4.5算法有如下优点：<strong>产生的分类规则易于理解，准确率较高</strong>。其缺点是：<strong>在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效</strong>。另外，C4.5只适合于能够驻留于内存的数据集，当训练集大得无法在内存容纳时程序无法运行。</p>
<p>另外，无论是ID3还是C4.5最好在小数据集上使用，决策树分类一般只试用于小数据。当属性取值很多时最好选择C4.5算法，ID3得出的效果会非常差，因为使用信息增益划分时它倾向于取值多的属性。</p>
<p>计算信息增益率时，用到了<strong>分裂信息计算公式：</strong></p>
<script type="math/tex; mode=display">Split_H(D|A)=-∑\dfrac{|D_j|}{|D|}\times log_2(\dfrac{|D_j|}{|D|})</script><script type="math/tex; mode=display">Gain_Rate(A)=\dfrac{g(D,A)}{Split_H(D|A)}</script><h2 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h2><p>基尼指数主要在CART算法中用到，随机森林中用到的属性划分标准也是它。Gini index划分是二元的，<strong>它度量的是数据分区或训练元组集D的不纯度，表示的是一个随机选中的样本在子集中被分错的可能性</strong>。计算方式如下：</p>
<script type="math/tex; mode=display">Gini(D)=1-\sum p^{2}_i ，其中，p_i 是D中元组数以C_i 类的概率，对m个类计算和。</script><p>Gini指数越大，不纯度越大，越不容易区分。假设A有v个不同的值出现在特征D中，它的二元划分有<script type="math/tex">2^v−2</script>种（除去自己和空集）。当考虑二元划分裂时，计算每个结果分区的不纯度加权和。比如A有两个值，则特征D被划分成D1和D2,这时Gini指数为：</p>
<p><a href="http://latex.codecogs.com/gif.latex?Gini_A%28D%29%20%3D%20%5Cfrac%7BD_1%7D%7BD%7D%20Gini%28D_1%29%20+%20%5Cfrac%7BD_2%7D%7BD%7D%20Gini%28D_2%29" target="_blank" rel="external"><img src="http://latex.codecogs.com/gif.latex?Gini_A%28D%29%20%3D%20%5Cfrac%7BD_1%7D%7BD%7D%20Gini%28D_1%29%20+%20%5Cfrac%7BD_2%7D%7BD%7D%20Gini%28D_2%29" alt="$$Gini_A(D) = \frac{D_1}{D} Gini(D_1) + \frac{D_2}{D} Gini(D_2)$$"></a></p>
<p>上面的式子表示的是不确定性的大小。对于每个属性，考虑每种可能的二元划分，对于离散值属性，<strong>选择该属性产生最小Gini指数的自己作为它的分裂信息</strong>。</p>
<h1 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h1><h2 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h2><h2 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h2><h1 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h1><h1 id="CART树"><a href="#CART树" class="headerlink" title="CART树"></a>CART树</h1>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【机器学习】感知机]]></title>
      <url>/2018/03/15/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
      <content type="html"><![CDATA[<p><strong>感知机（perceptron）是二分类的线性分类模型，属于监督学习算法。输入为实例的特征向量</strong>，输出为实例的类别（取+1和-1）。感知机对应于输入空间中将实例划分为两类的<strong>分离超平面</strong>。感知机旨在求出该超平面，为求得超平面导入了基于误分类的损失函数，利用梯度下降法 对损失函数进行最优化（最优化）。感知机的学习算法具有简单而易于实现的优点，分为原始形式和对偶形式。感知机预测是用学习得到的感知机模型对新的实例进行预测的，因此属于<strong>判别模型</strong>。感知机由<strong>Rosenblatt</strong>于1957年提出的，是<strong>神经网络</strong>和<strong>支持向量机</strong>的基础。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h2><p>假设输入空间(特征向量)为<script type="math/tex">X⊆Rn</script>，输出空间为Y={-1, +1}。输入<script type="math/tex">x∈X</script>表示实例的特征向量，对应于输入空间的点；输出y∈Y表示示例的类别。由输入空间到输出空间的函数为</p>
<script type="math/tex; mode=display">f(x)=sign(w⋅x+b)</script><p>称为感知机。其中，参数w叫做权值向量<strong>weight</strong>，b称为偏置<strong>bias</strong>。<script type="math/tex">w⋅x</script>表示w和x的<strong>点积</strong></p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-05-10.png" alt=""> </p>
<p>sign为符号函数，即</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-04-57.png" alt=""> </p>
<p>在二分类问题中，<script type="math/tex">f(x)</script>的值（+1或-1）用于分类xx为正样本（+1）还是负样本（-1）。感知机是一种线性分类模型，属于判别模型。我们需要做的就是找到一个最佳的满足<script type="math/tex">w⋅x+b=0</script>的w和b值，即分离超平面（<em>separating hyperplane</em>）。如下图，一个线性可分的感知机模型</p>
<p><img src="http://img.blog.csdn.net/20151005162258500" alt="这里写图片描述"> </p>
<p>中间的直线即<script type="math/tex">w⋅x+b=0</script>这条直线。</p>
<p>线性分类器的几何表示有：直线、平面、超平面。</p>
<h2 id="学习策略"><a href="#学习策略" class="headerlink" title="学习策略"></a><strong>学习策略</strong></h2><p><strong>核心：极小化损失函数。</strong></p>
<p>如果训练集是可分的，感知机的学习目的是求得一个能将训练集正实例点和负实例点完全分开的分离超平面。为了找到这样一个平面（或超平面），即确定感知机模型参数w和b，我们采用的是损失函数，同时并将损失函数极小化。</p>
<p>对于损失函数的选择，我们采用的是<strong>误分类点到超平面的距离</strong>（可以自己推算一下，这里采用的是几何间距，就是点到直线的距离）：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-06-55.png" alt=""> </p>
<p>其中<script type="math/tex">||w||</script>是<script type="math/tex">L2</script>范数。</p>
<p>对于误分类点<script type="math/tex">(x_i,y_i)</script>来说：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-07-38.png" alt=""> </p>
<p>误分类点到超平面的距离为：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-07-48.png" alt=""> </p>
<p>那么，所有点到超平面的总距离为：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-08-14.png" alt=""> </p>
<p>不考虑<script type="math/tex">1/||w||</script>,就得到感知机的损失函数了。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-08-21.png" alt=""> </p>
<p>其中M为误分类的集合。这个损失函数就是感知机学习的<strong>经验风险函数</strong>。</p>
<p>可以看出，损失函数<script type="math/tex">L(w,b)</script>是非负的。<strong>如果没有误分类点，则损失函数的值为0，而且误分类点越少，误分类点距离超平面就越近，损失函数值就越小</strong>。同时，损失函数<script type="math/tex">L(w,b)</script>是连续可导函数。</p>
<h2 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a><strong>学习算法</strong></h2><p>感知机学习转变成求解损失函数<script type="math/tex">L(w,b)</script>的最优化问题。最优化的方法是随机梯度下降法（stochastic gradient descent），这里采用的就是该方法。关于梯度下降的详细内容，参考<a href="https://en.wikipedia.org/wiki/Gradient_descent" target="_blank" rel="external">wikipedia Gradient descent</a>。下面给出一个简单的梯度下降的可视化图：</p>
<p><img src="http://img.blog.csdn.net/20151005203334645" alt="这里写图片描述"> </p>
<p>上图就是<strong>随机梯度下降</strong>法一步一步达到最优值的过程，说明一下，梯度下降其实是局部最优。感知机学习算法本身是误分类驱动的，因此我们采用随机梯度下降法。首先，任选一个超平面<script type="math/tex">w_0</script>和<script type="math/tex">b_0</script>，然后使用梯度下降法不断地<strong>极小化目标函数</strong></p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-09-32.png" alt=""> </p>
<p>极小化过程不是一次使M中所有误分类点的梯度下降，而是一次随机的选取一个误分类点使其梯度下降。<script type="math/tex">L(w,b)</script>的梯度通过偏导计算：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-10-07.png" alt=""> </p>
<p>然后，随机选取一个误分类点，根据上面的规则，计算新的<script type="math/tex">w,b</script>，然后进行更新：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-10-42.png" alt=""> </p>
<p>其中<script type="math/tex">η</script>是步长，大于0小于1，在统计学习中称之为学习率（<em>learning rate</em>）。这样，通过迭代可以期待损失函数<script type="math/tex">L(w,b)</script>不断减小，直至为0.</p>
<p>算法描述如下：</p>
<p><strong>算法：感知机学习算法原始形式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：T=&#123;(x1,y1),(x2,y2)...(xN,yN)&#125;（其中xi∈X=Rn，yi∈Y=&#123;-1, +1&#125;，i=1,2...N，学习速率为η）</div><div class="line">输出：w, b;感知机模型f(x)=sign(w·x+b)</div><div class="line">(1) 初始化w0,b0，权值可以初始化为0或一个很小的随机数</div><div class="line">(2) 在训练数据集中选取（x_i, y_i）</div><div class="line">(3) 如果yi(w xi+b)≤0</div><div class="line">           w = w + ηy_ix_i</div><div class="line">           b = b + ηy_i</div><div class="line">(4) 转至（2）,直至训练集中没有误分类点12345678</div></pre></td></tr></table></figure>
<p>解释：当一个实例点被误分类时，调整w,b，使分离超平面向该误分类点的一侧移动，以减少该误分类点与超平面的距离，直至超越该点被正确分类。</p>
<p>伪代码描述：</p>
<p><img src="http://img.blog.csdn.net/20151005181037259" alt="这里写图片描述"></p>
<p>对于每个w⋅xw⋅x其实是这样子的（假设x表示的是七维）：</p>
<p><img src="http://img.blog.csdn.net/20151005154220192" alt="这里写图片描述"> </p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-15-16-12-13.png" alt=""> </p>
<p>对于输入的每个特征都附加一个权值，然后将相加得到一个和函数f，最后该函数的输出即为输出的y值。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/dream_angel_z/article/details/48915561" target="_blank" rel="external">机器学习-感知机perceptron</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【机器学习】gbdt/xgboost/lightGBM比较]]></title>
      <url>/2018/03/12/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91gbdt-xgboost-lightGBM%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>RF、GBDT和XGBoost都属于集成学习（Ensemble Learning），集成学习的目的是通过结合多个基学习器的预测结果来改善单个学习器的泛化能力和鲁棒性。<br>　　根据个体学习器的生成方式，目前的集成学习方法大致分为两大类：即个体学习器之间存在强依赖关系、必须串行生成的序列化方法，以及个体学习器间不存在强依赖关系、可同时生成的并行化方法；前者的代表就是Boosting，后者的代表是Bagging和“随机森林”（Random Forest）。</p>
<h1 id="2-随机森林RF"><a href="#2-随机森林RF" class="headerlink" title="2. 随机森林RF"></a>2. 随机森林RF</h1><p>提到随机森林，就不得不提Bagging，Bagging可以简单的理解为：放回抽样，多数表决（分类）或简单平均（回归）,同时Bagging的基学习器之间属于并列生成，不存在强依赖关系。<br>　　Random Forest（随机森林）是Bagging的扩展变体，它在以决策树 为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机特征选择，因此可以概括RF包括四个部分：</p>
<ol>
<li>随机选择样本（放回抽样）</li>
<li><strong>随机选择特征</strong></li>
<li>构建决策树</li>
<li>随机森林投票（平均）。</li>
</ol>
<p>随机选择样本和Bagging相同，随机选择特征是指在树的构建中，会从样本集的特征集合中<strong>随机选择部分特征</strong>，然后再从这个子集中选择最优的属性用于划分，这种随机性导致随机森林的偏差会有稍微的增加（相比于单棵不随机树），但是由于随机森林的‘平均’特性，会使得它的方差减小，而且方差的减小补偿了偏差的增大，因此总体而言是更好的模型。 </p>
<p>​    在构建决策树的时候，<strong>RF的每棵决策树都最大可能的进行生长而不进行剪枝</strong>；在对预测输出进行结合时，RF通常对分类问题使用简单投票法，回归任务使用简单平均法。<br>　　RF的重要特性是<strong>不用对其进行交叉验证</strong>或者使用一个独立的测试集获得无偏估计，它可以在内部进行评估，也就是说在生成的过程中可以对误差进行无偏估计，由于每个基学习器只使用了训练集中约<strong>63.2%</strong>的样本，剩下约<strong>36.8%</strong>的样本可用做验证集来对其泛化性能进行“包外估计”。<br>　　RF和Bagging对比：RF的起始性能较差，特别当只有一个基学习器时，随着学习器数目增多，随机森林通常会收敛到更低的泛化误差。随机森林的训练效率也会高于Bagging，因为在单个决策树的构建中，Bagging使用的是‘确定性’决策树，在选择特征划分结点时，要对所有的特征进行考虑，而随机森林使用的是‘随机性’特征数，只需考虑特征的子集。</p>
<p> <strong>优缺点：</strong></p>
<p>　　随机森林的优点较多，简单总结：</p>
<ol>
<li>在数据集上表现良好，训练速度快、预测准确度较高；</li>
<li>能够处理很高维的数据，并且不用特征选择，而且在训练完后，给出特征的重要性；</li>
<li>容易做成<strong>并行化</strong>方法。 </li>
</ol>
<p>　　RF的缺点：在噪声较大的分类或者回归问题上回过拟合。</p>
<h1 id="3-GBDT"><a href="#3-GBDT" class="headerlink" title="3. GBDT"></a>3. GBDT</h1><p>​    提GBDT之前，谈一下Boosting，Boosting是一种与Bagging很类似的技术。不论是Boosting还是Bagging，所使用的多个分类器类型都是一致的。但是在前者当中，不同的分类器是通过串行训练而获得的，每个新分类器都根据已训练的分类器的性能来进行训练。Boosting是通过关注被已有分类器错分的那些数据来获得新的分类器。<br>　　由于Boosting分类的结果是基于所有分类器的加权求和结果的，因此Boosting与Bagging不太一样，Bagging中的分类器权值是一样的，而Boosting中的分类器权重并不相等，每个权重代表对应的分类器在上一轮迭代中的成功度。</p>
<h2 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h2><p>​    原始的Boost算法是在算法开始的时候，为<strong>每一个样本赋上一个权重值</strong>，初始的时候，大家都是一样重要的。在每一步训练中得到的模型，会使得数据点的估计有对有错，我们就在每一步结束后，<strong>增加分错的点的权重</strong>，减少分对的点的权重，这样使得某些点如果老是被分错，那么就会被“严重关注”，也就被赋上一个很高的权重。然后等进行了N次迭代（由用户指定），将会得到N个简单的分类器（basic learner），然后我们将它们组合起来（比如说可以对它们进行加权、或者让它们进行投票等），得到一个最终的模型。</p>
<p>​    GBDT与传统的Boosting区别较大，它的每一次计算都是为了减少上一次的残差，而为了消除残差，我们可以在残差减小的梯度方向上建立模型,所以说，在GradientBoost中，每个新的模型的建立是为了使得之前的模型的残差往梯度下降的方法，与传统的Boosting中关注正确错误的样本加权有着很大的区别。<br>　　在GradientBoosting算法中，关键就是利用损失函数的负梯度方向在当前模型的值作为残差的近似值，进而<strong>拟合一棵CART回归树</strong>。 </p>
<p>​    GBDT的会累加所有树的结果，而这种累加是无法通过分类完成的，因此GBDT的树都是CART回归树，而<strong>不是分类树</strong>（尽管GBDT调整后也可以用于分类但不代表GBDT的树为分类树）。</p>
<p><strong>一些特性</strong></p>
<ol>
<li>每次迭代获得的决策树模型都要<strong>乘以一个缩减系数</strong>，从而降低每棵树的作用，提升可学习空间。</li>
<li>每次迭代拟合的是<strong>一阶梯度</strong>。</li>
</ol>
<h2 id="3-2-优缺点"><a href="#3-2-优缺点" class="headerlink" title="3.2 优缺点"></a>3.2 优缺点</h2><p>GBDT的性能在RF的基础上又有一步提升，因此其优点也很明显，</p>
<ol>
<li>它能灵活的处理各种类型的数据；</li>
<li>在相对较少的调参时间下，预测的准确度较高。 </li>
</ol>
<p>缺点：当然由于它是Boosting，因此基学习器之前存在串行关系，<strong>难以并行</strong>训练数据。</p>
<h1 id="4-XGBoost"><a href="#4-XGBoost" class="headerlink" title="4. XGBoost"></a>4. XGBoost</h1><h2 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h2><p>​    XGBoost 是GBDT的一个变种，最大的区别是xgboost通过对目标函数做<strong>二阶泰勒展开</strong>，从而求出下一步要拟合的树的叶子节点权重（需要先确定树的结构），从而根据损失函数求出每一次分裂节点的损失减小的大小，从而根据分裂损失选择合适的属性进行分裂。</p>
<p>​    这个利用二阶展开的到的损失函数公式与分裂节点的过程是息息相关的。先遍历所有节点的所有属性进行分裂，假设选择了这个a属性的一个取值作为分裂节点，根据泰勒展开求得的公式可计算该树结构各个叶子节点的权重，从而计算损失减小的程度，从而综合各个属性选择使得损失减小最大的那个特征作为当前节点的分裂属性。依次类推，直到满足终止条件。</p>
<h2 id="4-2-XGBoost与GBDT区别"><a href="#4-2-XGBoost与GBDT区别" class="headerlink" title="4.2 XGBoost与GBDT区别"></a>4.2 XGBoost与GBDT区别</h2><ol>
<li>传统GBDT以CART作为基分类器，xgboost<strong>还支持线性分类器</strong>，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。</li>
<li>传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了<strong>二阶泰勒展开</strong>，同时用到了一阶和二阶导数。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。</li>
<li><strong>xgboost在代价函数里加入了正则项</strong>，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和。从Bias-variance tradeoff角度来讲，正则项降低了模型的variance，使学习出来的模型更加简单，防止过拟合，这也是xgboost优于传统GBDT的一个特性。</li>
<li>Shrinkage（缩减），相当于<strong>学习速率</strong>（xgboost中的eta）。xgboost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间。<strong>实际应用中，一般把eta设置得小一点</strong>，然后迭代次数设置得大一点。（传统GBDT的实现也有学习速率）</li>
<li><strong>列抽样</strong>（column subsampling）。<strong>xgboost借鉴了随机森林的做法，支持列抽样</strong>，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。</li>
<li>对缺失值的处理。<strong>对于特征的值有缺失的样本，xgboost可以自动学习出它的分裂方向</strong>。对于在训练过程中遇到的缺失值，xgboost将其分别归到左子树和右子树分别计算损失，选取较优的哪一个。如果在训练中没有缺失值，在预测时遇到缺失值，就默认分到右子树。</li>
<li><strong>xgboost工具支持并行</strong>。注意xgboost的并行<strong>不是tree粒度的并行</strong>，xgboost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。<strong>xgboost的并行是在特征粒度上的</strong>。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，<strong>那么各个特征的增益计算就可以开多线程进行</strong>。</li>
<li><strong>可并行的近似直方图算法</strong>。树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率就会变得很低，所以xgboost还提出了一种可并行的近似直方图算法，用于高效地生成候选的分割点。</li>
</ol>
<h2 id="4-3-xgboost正则化（预剪枝）"><a href="#4-3-xgboost正则化（预剪枝）" class="headerlink" title="4.3 xgboost正则化（预剪枝）"></a>4.3 xgboost正则化（预剪枝）</h2><p>xgboost的目标函数如下：<img src="http://img.blog.csdn.net/20170331173239339" alt="img"></p>
<p>xgboost中树节点分裂时所采用的公式：<img src="http://img.blog.csdn.net/20170331173223980" alt="img"></p>
<p>这个公式形式上跟ID3算法、CART算法是一致的，都是用分裂后的某种值减去分裂前的某种值，从而得到增益。为了限制树的生长，我们可以加入阈值，<strong>当增益大于阈值时才让节点分裂，上式中的gamma即阈值</strong>，它是正则项里叶子节点数T的系数，所以<strong>xgboost在优化目标函数的同时相当于做了预剪枝</strong>。另外，上式中还有一个系数lambda，是正则项里leaf score的L2模平方的系数，对leaf score做了平滑，也起到了防止过拟合的作用，这个是传统GBDT里不具备的特性。</p>
<h1 id="5-lightGBM与XGBoost区别"><a href="#5-lightGBM与XGBoost区别" class="headerlink" title="5. lightGBM与XGBoost区别"></a>5. lightGBM与XGBoost区别</h1><h2 id="5-1-决策树算法"><a href="#5-1-决策树算法" class="headerlink" title="5.1 决策树算法"></a>5.1 决策树算法</h2><p>由于在决策树在每一次选择节点特征的过程中，要遍历所有的属性的所有取值并选择一个较好的。</p>
<p>XGBoost使用的是pre-sorted算法（对所有特征都按照特征的数值进行预排序，在遍历分割点的时候用O(data)的代价找到一个特征上的最好分割点），能够更精确的找到数据分隔点；（xgboost的分布式实现也是基于直方图的，利于并行）</p>
<p><a href="https://www.msra.cn/zh-cn/news/features/lightgbm-20170105" target="_blank" rel="external">LightGBM</a>使用的是histogram算法（X发给类似一种分桶算法），占用的内存更低，数据分隔的复杂度更低。</p>
<p>直方图优化参考：<a href="https://www.msra.cn/zh-cn/news/features/lightgbm-20170105" target="_blank" rel="external">开源 | LightGBM：三天内收获GitHub 1000  星</a></p>
<p>而这两个算法的比较见参考文献<a href="https://www.zhihu.com/question/51644470/answer/130946285" target="_blank" rel="external">如何看待微软新开源的LightGBM?</a></p>
<h2 id="5-2-决策树生长策略"><a href="#5-2-决策树生长策略" class="headerlink" title="5.2 决策树生长策略"></a>5.2 决策树生长策略</h2><p>XGBoost采用的是level-wise生长策略，如Figure 1所示，能够同时分裂同一层的叶子，从而进行多线程优化，也好控制模型复杂度，不容易过拟合；但实际上Level-wise是一种低效的算法，它不加区分的对待同一层的叶子，带来了很多没必要的开销，因为实际上很多叶子的分裂增益较低，没必要进行搜索和分裂。</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-06-15-39-52.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-06-15-39-52.png" alt="img"></a></p>
<p>LightGBM采用leaf-wise生长策略，如Figure 2所示，每次从当前所有叶子中找到分裂增益最大（一般也是数据量最大）的一个叶子，然后分裂，如此循环；但会生长出比较深的决策树，产生过拟合。因此 LightGBM 在leaf-wise之上增加了一个最大深度的限制，在保证高效率的同时防止过拟合。</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-06-15-41-19.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-06-15-41-19.png" alt="img"></a></p>
<h2 id="5-3-其他"><a href="#5-3-其他" class="headerlink" title="5.3 其他"></a>5.3 其他</h2><ol>
<li><p>直方图做差加速 </p>
<p>一个<strong>子节点的直方图可以通过父节点的直方图减去兄弟节点的直方图</strong>得到，从而加速计算。 </p>
<ol>
<li><p>lightgbm支持直接输入categorical 的feature </p>
<p>在对离散特征分裂时，每个取值都当作一个桶，分裂时的增益算的是”是否属于某个category“的gain。类似于one-hot编码。 </p>
</li>
<li><p>多线程优化</p>
</li>
</ol>
</li>
</ol>
<h1 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/24498293" target="_blank" rel="external">XGBoost, LightGBM性能大对比</a></li>
<li><a href="https://www.msra.cn/zh-cn/news/features/lightgbm-20170105" target="_blank" rel="external">LightGBM微软官方中文介绍</a></li>
<li><a href="http://blog.csdn.net/xwd18280820053/article/details/68927422" target="_blank" rel="external">关于树的几个ensemble模型的比较（GBDT、xgBoost、lightGBM、RF）</a></li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【腾讯转化率预估】SVD分解提取用户-APP特征]]></title>
      <url>/2018/03/12/%E3%80%90%E8%85%BE%E8%AE%AF%E8%BD%AC%E5%8C%96%E7%8E%87%E9%A2%84%E4%BC%B0%E3%80%91SVD%E5%88%86%E8%A7%A3%E6%8F%90%E5%8F%96%E7%94%A8%E6%88%B7-APP%E7%89%B9%E5%BE%81/</url>
      <content type="html"><![CDATA[<p>用SVD可以很容易得到任意矩阵的满秩分解，用满秩分解可以对数据做压缩。可以用SVD来证明对任意M*N的矩阵均存在如下分解：</p>
<p><img src="http://img.blog.csdn.net/20150123160014873?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhvbmdrZWppbmd3YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>这个可以应用在数据降维压缩上！在数据相关性特别大的情况下存储X和Y矩阵比存储A矩阵占用空间更小！其中k为矩阵A的秩的个数。</p>
<p>在推荐系统中，我们通常可以根据历史数据，得到用户和商品打分矩阵：</p>
<p><a href="https://ooo.0o0.ooo/2017/03/13/58c6aa26b83c6.png" target="_blank" rel="external"><img src="https://ooo.0o0.ooo/2017/03/13/58c6aa26b83c6.png" alt="img"></a> </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【面经】海量数据处理相关]]></title>
      <url>/2018/03/12/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h2 id="第一部分-分而治之-Hash映射-Hash-map统计-堆-快速-归并排序"><a href="#第一部分-分而治之-Hash映射-Hash-map统计-堆-快速-归并排序" class="headerlink" title="第一部分 分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序"></a>第一部分 分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序</h2><h3 id="1-海量数据选取TOPK"><a href="#1-海量数据选取TOPK" class="headerlink" title="1. 海量数据选取TOPK"></a>1. 海量数据选取TOPK</h3><p>baseline：</p>
<p>用堆，如果取最大的K个，就用最小堆，遍历数组，遇到比堆顶元素大的元素就入堆，同时堆中元素超过k个需要poll操作，保证堆中只有K个元素，最终的topk元素在堆中。</p>
<p>时间复杂度分析:</p>
<script type="math/tex; mode=display">O(n*logk)$$ ，元素入堆复杂度$$O(logk)</script><p><strong><script type="math/tex">O(n)</script>算法：</strong></p>
<p>先用quick select方法找到第K大的元素，复杂度<script type="math/tex">O(n)</script></p>
<p>然后再遍历一遍，将大于K的元素取出，复杂度<script type="math/tex">O(n)</script></p>
<p>总复杂度<script type="math/tex">O(n)</script></p>
<p>！！！！！卧槽！神奇！！！！</p>
<h3 id="2-海量数据选取第K大"><a href="#2-海量数据选取第K大" class="headerlink" title="2. 海量数据选取第K大"></a>2. 海量数据选取第K大</h3><p>Quick Select，详见<a href="/2018/02/02/【九章算法强化班】两指针/" title="【九章算法强化班】两指针">【九章算法强化班】两指针</a> </p>
<p>时间复杂度<script type="math/tex">O(n)</script></p>
<h3 id="3-大数排序问题"><a href="#3-大数排序问题" class="headerlink" title="3. 大数排序问题"></a>3. 大数排序问题</h3><p>海量数据排序怎么做？</p>
<p>baseline：快排，问题：数据量很大，内存根本存不下，不可行</p>
<p><strong>桶排序：</strong></p>
<p>将数据分桶，每个桶存入一个文件，然后文件内部有序，取出合并的时候可以用K路归并，优化：k路可以建个堆</p>
<h3 id="4-海量日志数据，提取出某日访问百度次数最多的那个IP"><a href="#4-海量日志数据，提取出某日访问百度次数最多的那个IP" class="headerlink" title="4. 海量日志数据，提取出某日访问百度次数最多的那个IP"></a>4. 海量日志数据，提取出某日访问百度次数最多的那个IP</h3><ol>
<li>首先将这一天的访问百度的日志IP取出来，写到一个大文件中，IP是32位的，因此最多有<script type="math/tex">2^{32}</script>个IP。</li>
<li>将整个文件的所有IP映射为10000个小文件，再找出每个小文件中出现次数最多的IP，此时可以用HashMap统计一下</li>
<li>在10000个小文件的top1中寻找整体top1</li>
</ol>
<h3 id="5-300万个查询字符串中统计最热门的10个查询"><a href="#5-300万个查询字符串中统计最热门的10个查询" class="headerlink" title="5. 300万个查询字符串中统计最热门的10个查询"></a>5. 300万个查询字符串中统计最热门的10个查询</h3><p>原题：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p>​    解答：由上面第1题，我们知道，数据大则划为小的，如如一亿个Ip求Top 10，可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hashmap计数统计并按数量排序，最后归并或者最小堆依次处理每个小文件的top10以得到最后的结。</p>
<p>​    但如果数据规模比较小，能一次性装入内存呢?比如这道题，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把他们都放进内存中去（300万个字符串假设没有重复，都是最大长度，那么最多占用内存3M*1K/4=0.75G。所以可以将所有字符串都存放在内存中进行处理），而现在只是需要一个合适的数据结构，在这里，HashTable绝对是我们优先的选择。<script type="math/tex">O(1)</script></p>
<p>解法：</p>
<ol>
<li>Hash_map统计字符串出现次数</li>
<li>借助堆找出出现次数最多的topK个query <script type="math/tex">O(logk)</script></li>
</ol>
<h3 id="6-有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"><a href="#6-有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。" class="headerlink" title="6. 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"></a>6. 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</h3><ol>
<li>分而治之/hash映射：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。</li>
<li>hash_map统计：对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。</li>
<li>堆/归并排序：对于每个小文件，利用堆取出top100的单词，存入新文件，这样又得到了5000个新文件，然后对5000个文件做归并排序，取出全局top100，依然可以用堆优化</li>
</ol>
<h3 id="7-海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"><a href="#7-海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。" class="headerlink" title="7. 海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"></a>7. 海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</h3><p>分两种情况：</p>
<ol>
<li>如果每个数据元素只出现在一台机器上：可以直接分机器统计，得到top10，然后再100台机器的top10中求全局top10，k路归并，用堆优化</li>
<li>每个元素不一定只出现在一台机器上，可能同时出现在多台机器上：<ol>
<li>遍历一遍所有数据，重新hash取摸，如此使得同一个元素只出现在单独的一台电脑中，然后采用上面所说的方法，统计每台电脑中各个元素的出现次数找出TOP10，继而组合100台电脑上的TOP10，找出最终的TOP10。</li>
<li>暴力求解：直接统计统计每台电脑中各个元素的出现次数，然后把同一个元素在不同机器中的出现次数相加，最终从所有数据中找出TOP10。</li>
</ol>
</li>
</ol>
<h3 id="8-有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"><a href="#8-有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。" class="headerlink" title="8. 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"></a>8. 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</h3><h3 id="有海量个文件，知道每个文件的大小，给定100个桶，把这些文件塞到桶里，尽量使得每个桶里装的东西大小差不多"><a href="#有海量个文件，知道每个文件的大小，给定100个桶，把这些文件塞到桶里，尽量使得每个桶里装的东西大小差不多" class="headerlink" title="有海量个文件，知道每个文件的大小，给定100个桶，把这些文件塞到桶里，尽量使得每个桶里装的东西大小差不多"></a>有海量个文件，知道每个文件的大小，给定100个桶，把这些文件塞到桶里，尽量使得每个桶里装的东西大小差不多</h3><ol>
<li>先对文件按照文件大小<strong>从大到小排序</strong> </li>
<li>将文件顺序放入桶中，每次都选取当前容量最小的桶，这里就需要用一个堆来维护当前这100个桶里面的文件大小了，每次需要选出当前容量最小的桶，加了数据之后，更新这个桶的容量，再放回堆中。</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【Java】HashMap原理探究]]></title>
      <url>/2018/03/11/%E3%80%90Java%E3%80%91HashMap%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-HashMap概述"><a href="#1-HashMap概述" class="headerlink" title="1. HashMap概述"></a>1. HashMap概述</h1><p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是不保证该顺序恒久不变。</p>
<p>此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get和put）提供稳定的性能。</p>
<p>迭代colletction视图所需要的时间与HashMap实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以如果迭代性能很重要，则不能将初始容量设置得太高，或者将加载因子设置的太低。</p>
<p>需要注意的是，HashMap是不同步的。如果多个线程同时访问一个HashMap，若其中某个线程修改了HashMap的结构（即删除或者添加映射关系），那么必须要保持外部同步。</p>
<h1 id="2-HashMap的数据结构"><a href="#2-HashMap的数据结构" class="headerlink" title="2. HashMap的数据结构"></a>2. HashMap的数据结构</h1><p>在Java中，最基本的结构就是数组和指针（引用）。HashMap就是结合了这两种结构进行实现。</p>
<p><strong>HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体</strong></p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-14-21-36-42.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-14-21-36-42.png" alt="img"></a></p>
<p>从上图中可以看出，HashMap 底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个 HashMap 的时候，就会初始化一个数组。</p>
<p>我们通过 JDK 中的 HashMap 源码进行一些学习，首先看一下构造函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</div><div class="line">        if (initialCapacity &lt; 0)</div><div class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</div><div class="line">                                               initialCapacity);</div><div class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</div><div class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</div><div class="line">                                               loadFactor);</div><div class="line"></div><div class="line">        // Find a power of 2 &gt;= initialCapacity</div><div class="line">        int capacity = 1;</div><div class="line">        while (capacity &lt; initialCapacity)</div><div class="line">            capacity &lt;&lt;= 1;</div><div class="line"></div><div class="line">        this.loadFactor = loadFactor;</div><div class="line">        threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</div><div class="line">        table = new Entry[capacity]; // 新建数组</div><div class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</div><div class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">        init();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到第18行<code>table = new Entry[capacity];</code> 其实是创建了一个<code>Entry</code> 的数组，其大小为<code>capacity</code> 。那么<code>Entry</code> 又是什么呢？看一下源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">    final K key; //键</div><div class="line">    V value;     //值</div><div class="line">    Entry&lt;K,V&gt; next; //指向下一个元素的引用 --&gt; 构成了链表</div><div class="line">    final int hash;</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们目前还是只着重核心的部分，Entry 是一个 static class，其中包含了 key 和 value，也就是键值对，另外还包含了一个 next 的 Entry 指针。我们可以总结出：Entry 就是数组中的元素，每个 Entry 其实就是一个 key-value 对，它持有一个指向下一个元素的引用，这就构成了链表。</p>
<h1 id="3-HashMap核心方法解读"><a href="#3-HashMap核心方法解读" class="headerlink" title="3. HashMap核心方法解读"></a>3. HashMap核心方法解读</h1><h2 id="3-1-put-方法"><a href="#3-1-put-方法" class="headerlink" title="3.1. put()方法"></a>3.1. put()方法</h2><p><strong>流程图</strong></p>
<p>下面这个流程图很好地说明了总过程，接下来我们会一步步分析这个步骤。</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-14-21-57-57.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-14-21-57-57.png" alt="img"></a></p>
<p><strong>put()主方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">     * Associates the specified value with the specified key in this map.</div><div class="line">     * If the map previously contained a mapping for the key, the old</div><div class="line">     * value is replaced.</div><div class="line">     *</div><div class="line">     * @param key key with which the specified value is to be associated</div><div class="line">     * @param value value to be associated with the specified key</div><div class="line">     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</div><div class="line">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</div><div class="line">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</div><div class="line">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</div><div class="line">     */</div><div class="line">public V put(K key, V value) &#123;</div><div class="line">        //其允许存放null的key和null的value，当其key为null时，调用putForNullKey方法，放入到table[0]的这个位置</div><div class="line">        if (key == null)</div><div class="line">            return putForNullKey(value);</div><div class="line">        </div><div class="line">		//1. 通过调用hash方法对key进行哈希，得到哈希之后的数值。</div><div class="line">        int hash = hash(key);</div><div class="line">  </div><div class="line">        //2. 根据上一步骤中求出的hash得到在数组中是索引i</div><div class="line">        int i = indexFor(hash, table.length);</div><div class="line">  </div><div class="line">        //3.1 如果i处的Entry不为null，则寻找是否存在过key</div><div class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">             // 3.1.1若曾经有过key值，则直接覆盖</div><div class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(this);</div><div class="line">                return oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">		// 3.2、3.1.2 : 如果i处Entry为空，或者不曾存在过key，则添加key</div><div class="line">        modCount++;</div><div class="line">        addEntry(hash, key, value, i); //根据计算出的 hash 值，将 key-value 对放在数组 table 的 i 索引处</div><div class="line">        return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看一下方法的标准注释：在注释中首先提到了，当我们 put 的时候，如果 key 存在了，那么新的 value 会代替旧的 value，并且如果 key 存在的情况下，该方法返回的是旧的 value，如果 key 不存在，那么返回 null。</p>
<p>从上面的源代码中可以看出：当我们往 HashMap 中 put 元素的时候，先根据 key 的 hashCode 重新计算 hash 值，根据 hash 值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p>
<p>也就是说，put方法主要做了以下几个步骤：</p>
<ol>
<li>计算key的hashCode值。其目的是为了尽可能的让键值对可以分不到不同的桶中</li>
<li>根据hashCode得到在table中的索引i</li>
<li>将value插入到table中：<ol>
<li>如果table[i]不为空，则表示两个key的hash值重叠了。那就根据key将值插入table[i]指向的链表中：<ol>
<li>要么覆盖原来的值（曾经有过这个key）</li>
<li>要么插入链表末尾（曾经没有过这个key） –&gt; 调用<code>addEntry()</code></li>
</ol>
</li>
<li>如果table[i]为空，就直接插入 –&gt; 调用<code>addEntry()</code></li>
</ol>
</li>
</ol>
<p><strong>addEntry()方法</strong></p>
<p>addEntry(hash, key, value, i)方法根据计算出的 hash 值，将 key-value 对放在数组 table 的 i 索引处。addEntry 是 HashMap 提供的一个包访问权限的方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">     * Adds a new entry with the specified key, value and hash code to</div><div class="line">     * the specified bucket.  It is the responsibility of this</div><div class="line">     * method to resize the table if appropriate.</div><div class="line">     *</div><div class="line">     * Subclass overrides this to alter the behavior of put method.</div><div class="line">     */</div><div class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</div><div class="line">        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</div><div class="line">            resize(2 * table.length);</div><div class="line">            hash = (null != key) ? hash(key) : 0;</div><div class="line">            bucketIndex = indexFor(hash, table.length);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        createEntry(hash, key, value, bucketIndex);</div><div class="line">&#125;</div><div class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</div><div class="line">        // 获取指定 bucketIndex 索引处的 Entry</div><div class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">        // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entr</div><div class="line">        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</div><div class="line">        size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当系统决定存储 HashMap 中的 key-value 对时，完全没有考虑 Entry 中的 value，仅仅只是根据 key 来计算并决定每个 Entry 的存储位置。我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。</p>
<p><strong>hash()方法</strong></p>
<p>hash(int h)方法根据 key 的 hashCode 重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的 hash 冲突。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">final int hash(Object k) &#123;</div><div class="line">        int h = 0;</div><div class="line">        if (useAltHashing) &#123;</div><div class="line">            if (k instanceof String) &#123;</div><div class="line">                return sun.misc.Hashing.stringHash32((String) k);</div><div class="line">            &#125;</div><div class="line">            h = hashSeed;</div><div class="line">        &#125;</div><div class="line">        //得到k的hashcode值</div><div class="line">        h ^= k.hashCode();</div><div class="line">        //进行计算</div><div class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</div><div class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到在 HashMap 中要找到某个元素，需要根据 key 的 hash 值来求得对应数组中的位置。如何计算这个位置就是 hash 算法。前面说过 HashMap 的数据结构是数组和链表的结合，所以我们当然希望这个 HashMap 里面的 元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用 hash 算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。</p>
<p>对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(int h) 方法所计算得到的 hash 码值总是相同的。我们首先想到的就是把 hash 值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在 HashMap 中是这样做的：调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">     * Returns index for hash code h.</div><div class="line">     */</div><div class="line">static int indexFor(int h, int length) &#123;  </div><div class="line">    return h &amp; (length-1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而 HashMap 底层数组的长度总是 2 的 n 次方，这是 HashMap 在速度上的优化。在 HashMap 构造器中有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// Find a power of 2 &gt;= initialCapacity</div><div class="line">int capacity = 1;</div><div class="line">    while (capacity &lt; initialCapacity)  </div><div class="line">        capacity &lt;&lt;= 1;</div></pre></td></tr></table></figure>
<p><strong>这段代码保证初始化时 HashMap 的容量总是 2 的 n 次方</strong>，即底层数组的长度总是为 2 的 n 次方。</p>
<p>当 length 总是 2 的 n 次方时，h&amp; (length-1)运算等价于对 length 取模，也就是 h%length，但是 &amp; 比 % 具有更高的效率。这看上去很简单，其实比较有玄机的，我们举个例子来说明：</p>
<p>假设数组长度分别为 15 和 16，优化后的 hash 码分别为 8 和 9，那么 &amp; 运算后的结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>h &amp; (table.length-1)</th>
<th>hash</th>
<th></th>
<th>table.length-1</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>8 &amp; (15-1)：</td>
<td>0100</td>
<td>&amp;</td>
<td>1110</td>
<td>= 0100</td>
</tr>
<tr>
<td>9 &amp; (15-1)：</td>
<td>0101</td>
<td>&amp;</td>
<td>1110</td>
<td>= 0100</td>
</tr>
<tr>
<td>8 &amp; (16-1)：</td>
<td>0100</td>
<td>&amp;</td>
<td>1111</td>
<td>= 0100</td>
</tr>
<tr>
<td>9 &amp; (16-1)：</td>
<td>0101</td>
<td>&amp;</td>
<td>1111</td>
<td>= 0101</td>
</tr>
</tbody>
</table>
</div>
<p>从上面的例子中可以看出：当它们和 15-1（1110）“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8 和 9 会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链 表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为 15 的时候，hash 值会与 15-1（1110）进行“与”，那么最后一位永远是 0，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！而当数组长度为16时，即为2的n次方时，2n-1 得到的二进制数的每个位上的值都为 1，这使得在低位上&amp;时，得到的和原 hash 的低位相同，加之 hash(int h)方法对 key 的 hashCode 的进一步优化，加入了高位计算，就使得只有相同的 hash 值的两个值才会被放到数组中的同一个位置上形成链表。</p>
<p>所以说，<strong>当数组长度为 2 的 n 次幂的时候，不同的 key 算得得 index 相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</strong></p>
<p><strong>总结</strong></p>
<p>根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p>
<h2 id="3-2-get-方法"><a href="#3-2-get-方法" class="headerlink" title="3.2. get()方法"></a>3.2. get()方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">     * Returns the value to which the specified key is mapped,</div><div class="line">     * or &#123;@code null&#125; if this map contains no mapping for the key.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;More formally, if this map contains a mapping from a key</div><div class="line">     * &#123;@code k&#125; to a value &#123;@code v&#125; such that &#123;@code (key==null ? k==null :</div><div class="line">     * key.equals(k))&#125;, then this method returns &#123;@code v&#125;; otherwise</div><div class="line">     * it returns &#123;@code null&#125;.  (There can be at most one such mapping.)</div><div class="line">     *</div><div class="line">     * &lt;p&gt;A return value of &#123;@code null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</div><div class="line">     * indicate that the map contains no mapping for the key; it&apos;s also</div><div class="line">     * possible that the map explicitly maps the key to &#123;@code null&#125;.</div><div class="line">     * The &#123;@link #containsKey containsKey&#125; operation may be used to</div><div class="line">     * distinguish these two cases.</div><div class="line">     *</div><div class="line">     * @see #put(Object, Object)</div><div class="line">     */</div><div class="line">    public V get(Object key) &#123;</div><div class="line">        if (key == null)</div><div class="line">            return getForNullKey();</div><div class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line"></div><div class="line">        return null == entry ? null : entry.getValue();</div><div class="line">    &#125;</div><div class="line">    final Entry&lt;K,V&gt; getEntry(Object key) &#123;</div><div class="line">        int hash = (key == null) ? 0 : hash(key);</div><div class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">             e != null;</div><div class="line">             e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            if (e.hash == hash &amp;&amp;</div><div class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                return e;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>有了上面存储时的 hash 算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从 HashMap 中 get 元素时，首先计算 key 的 hashCode，找到数组中对应位置的某一元素，然后通过 key 的 equals 方法在对应位置的链表中找到需要的元素。</p>
<h2 id="3-3-归纳"><a href="#3-3-归纳" class="headerlink" title="3.3. 归纳"></a>3.3. 归纳</h2><p>简单地说，HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。</p>
<ul>
<li>HashMap底层采用一个<code>Entry[]</code> 数组来保存所有的key-value对。</li>
<li>当需要存储一个Entry对象时，会根据hash算法来决定其在数组中的存储位置，再根据equals方法决定其在该数组位置上的链表中的存储位置。</li>
<li>当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置的链表中取出该Entry。</li>
</ul>
<h1 id="4-HashMap相关机制"><a href="#4-HashMap相关机制" class="headerlink" title="4. HashMap相关机制"></a>4. HashMap相关机制</h1><h2 id="4-1-resize机制（rehash）"><a href="#4-1-resize机制（rehash）" class="headerlink" title="4.1. resize机制（rehash）"></a>4.1. resize机制（rehash）</h2><p>当HashMap中的元素越来越多的时候，hash冲突的几率也越来越高，因为数组的长度时固定的。所以为了提高查询的效率，就需要对HashMap的数组进行扩容。那么此时最消耗性能的点就出现了：原数组中的每一个数据必须重新计算其在新数组中的位置，并放进去，这就是resize操作。</p>
<p>那么HashMap是什么时候进行扩容的呢？当HashMap中的元素超过<code>threshold = (int)(capacity * loadFactor)</code> 时，就会进行数组扩容。<strong>loadFactor的默认值为0.75。</strong>其中threshold是HashMap的一个字段。</p>
<p><strong>每次扩容时，都新建一个2倍的数组，</strong>然后重新计算每一个元素在数组中的位置。这是一个非常耗时的操作。所以我们<strong>如果预知HashMap中的元素个数，那么预设元素的个数就能有效地提高HashMap的性能</strong>。</p>
<p>而负载因子loadFactor 衡量的是一个散列表的空间使用程度。负载因子越大表示散列的装填程度越高。对于使用链表法的散列表来说，查找元素的平均时间是<script type="math/tex">O(1+a)</script> 。a是链表平均长度。因此如果负载因子越大，对空间的利用更充分，但查找效率就会更低。如果负载因子太小，散列表的数据又过于稀疏，对空间造成严重浪费。</p>
<h2 id="4-2-HashMap的构造器"><a href="#4-2-HashMap的构造器" class="headerlink" title="4.2. HashMap的构造器"></a>4.2. HashMap的构造器</h2><p>HashMap包含以下几个构造器：</p>
<ul>
<li><code>HashMap()</code> : 构建一个初始容量为16，负载因子为0.75的HashMap。</li>
<li><code>HashMap(int initialCapcity)</code> : 构建一个初始容量为initialCapcity, 负载因子为0.75的HashMap。</li>
<li><code>HashMap(int initialCapacity, float loadFactor)</code>: 以指定初始容量、指定的负载因子创建一个HashMap。<ul>
<li>initialCapcity * loadFactor过大时，会造成空间的严重浪费</li>
<li>initialCapcity * loadFactor过小时，会造成查找效率很低</li>
</ul>
</li>
</ul>
<h2 id="4-3-Fail-Fast机制"><a href="#4-3-Fail-Fast机制" class="headerlink" title="4.3. Fail-Fast机制"></a>4.3. Fail-Fast机制</h2><p>​    <strong>我们知道 java.util.HashMap 不是线程安全的</strong>，因此如果在使用迭代器的过程中有其他线程修改了 map，那么将抛出 ConcurrentModificationException，这就是所谓 fail-fast 策略。</p>
<p>ail-fast 机制是 java 集合(Collection)中的一种错误机制。 当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。</p>
<p>例如：当某一个线程 A 通过 iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程 A 访问集合时，就会抛出 ConcurrentModificationException 异常，产生 fail-fast 事件。</p>
<p>这一策略在源码中的实现是通过 modCount 域，modCount 顾名思义就是修改次数，对 HashMap 内容（当然不仅仅是 HashMap 才会有，其他例如 ArrayList 也会）的修改都将增加这个值（大家可以再回头看一下其源码，在很多操作中都有 modCount++ 这句），那么在迭代器初始化过程中会将这个值赋给迭代器的 expectedModCount。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">HashIterator() &#123;</div><div class="line">    expectedModCount = modCount;</div><div class="line">    if (size &gt; 0) &#123; // advance to first entry</div><div class="line">    Entry[] t = table;</div><div class="line">    while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)  </div><div class="line">        ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在迭代过程中，判断 modCount 跟 expectedModCount 是否相等，如果不相等就表示已经有其他线程修改了 Map：</p>
<p>注意到 modCount 声明为 volatile，保证线程之间修改的可见性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">final Entry&lt;K,V&gt; nextEntry() &#123;</div><div class="line">    if (modCount != expectedModCount)</div><div class="line">        throw new ConcurrentModificationException();</div></pre></td></tr></table></figure>
<p>在 HashMap 的 API 中指出：</p>
<p>由所有 HashMap 类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。</p>
<p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p>
<p><strong>解决方案</strong></p>
<p>在上文中也提到，f<strong>ail-fast 机制，是一种错误检测机制</strong>。它只能被用来检测错误，因为 JDK 并不保证 fail-fast 机制一定会发生。若在多线程环境下使用 fail-fast 机制的集合，建议使用“java.util.concurrent 包下的类”去取代“java.util 包下的类”。</p>
<h2 id="4-4-HashMap的两种遍历方式"><a href="#4-4-HashMap的两种遍历方式" class="headerlink" title="4.4. HashMap的两种遍历方式"></a>4.4. HashMap的两种遍历方式</h2><h2 id="4-5-第一种"><a href="#4-5-第一种" class="headerlink" title="4.5. 第一种"></a>4.5. 第一种</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">　　Map map = new HashMap();</div><div class="line">　　Iterator iter = map.entrySet().iterator();</div><div class="line">　　while (iter.hasNext()) &#123;</div><div class="line">Map.Entry entry = (Map.Entry) iter.next();</div><div class="line">Object key = entry.getKey();</div><div class="line">Object val = entry.getValue();</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<p>效率高,以后一定要使用此种方式！</p>
<h2 id="4-6-第二种"><a href="#4-6-第二种" class="headerlink" title="4.6. 第二种"></a>4.6. 第二种</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">　　Map map = new HashMap();</div><div class="line">　　Iterator iter = map.keySet().iterator();</div><div class="line">　　while (iter.hasNext()) &#123;</div><div class="line">Object key = iter.next();</div><div class="line">Object val = map.get(key);</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<p>效率低,以后尽量少使用！</p>
<h1 id="5-为什么HashMap线程不安全？"><a href="#5-为什么HashMap线程不安全？" class="headerlink" title="5. 为什么HashMap线程不安全？"></a>5. 为什么HashMap线程不安全？</h1><h2 id="5-1-put的时候导致的多线程数据不一致。"><a href="#5-1-put的时候导致的多线程数据不一致。" class="headerlink" title="5.1 put的时候导致的多线程数据不一致。"></a>5.1 put的时候导致的多线程数据不一致。</h2><p>​    这个问题比较好想象，比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</p>
<h2 id="5-2-get操作可能因为resize而引起死循环（cpu100-）"><a href="#5-2-get操作可能因为resize而引起死循环（cpu100-）" class="headerlink" title="5.2 get操作可能因为resize而引起死循环（cpu100%）"></a>5.2 get操作可能因为resize而引起死循环（cpu100%）</h2><p>下面的代码是resize的核心内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void transfer(Entry[] newTable, boolean rehash) &#123;  </div><div class="line">        int newCapacity = newTable.length;  </div><div class="line">        for (Entry&lt;K,V&gt; e : table) &#123;  </div><div class="line">  </div><div class="line">            while(null != e) &#123;  </div><div class="line">                Entry&lt;K,V&gt; next = e.next;           </div><div class="line">                if (rehash) &#123;  </div><div class="line">                    e.hash = null == e.key ? 0 : hash(e.key);  </div><div class="line">                &#125;  </div><div class="line">                int i = indexFor(e.hash, newCapacity);   </div><div class="line">                e.next = newTable[i];  </div><div class="line">                newTable[i] = e;  </div><div class="line">                e = next;  </div><div class="line">            &#125; </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法的功能是将原来的记录重新计算在新桶的位置，然后迁移过去。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7853175-ab75cd3738471507.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>​    我们假设有两个线程同时需要执行resize操作，我们原来的桶数量为2，记录数为3，需要resize桶到4，原来的记录分别为：[3,A],[7,B],[5,C]，在原来的map里面，我们发现这三个entry都落到了第二个桶里面。<br>​    假设线程thread1执行到了transfer方法的Entry next = e.next这一句，然后时间片用完了，此时的e = [3,A], next = [7,B]。线程thread2被调度执行并且顺利完成了resize操作，需要注意的是，此时的[7,B]的next为[3,A]。此时线程thread1重新被调度运行，此时的thread1持有的引用是已经被thread2 resize之后的结果。线程thread1首先将[3,A]迁移到新的数组上，然后再处理[7,B]，而[7,B]被链接到了[3,A]的后面，处理完[7,B]之后，就需要处理[7,B]的next了啊，而通过thread2的resize之后，[7,B]的next变为了[3,A]，此时，[3,A]和[7,B]形成了环形链表，在get的时候，如果get的key的桶索引和[3,A]和[7,B]一样，那么就会陷入死循环。</p>
<p>参考：<a href="https://www.jianshu.com/p/e2f75c8cce01" target="_blank" rel="external">一字马胡链接</a></p>
<h1 id="6-HashSet-HashTable-currentHashMap-LinkedHashMap"><a href="#6-HashSet-HashTable-currentHashMap-LinkedHashMap" class="headerlink" title="6. HashSet\HashTable\currentHashMap\LinkedHashMap"></a>6. HashSet\HashTable\currentHashMap\LinkedHashMap</h1><h2 id="6-1-HashSet"><a href="#6-1-HashSet" class="headerlink" title="6.1 HashSet"></a>6.1 HashSet</h2><p>在Java里，其实<strong>HashSet</strong>内部是一个HashMap。此处不再过多阐述。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-11-13-17-37.png" alt=""> </p>
<h2 id="6-2-HashSet"><a href="#6-2-HashSet" class="headerlink" title="6.2 HashSet"></a>6.2 HashSet</h2><p><strong>Hashtable</strong>和 HashMap 一样， 也是一个散列表，它存储的内容是键值对，继承于 Dictionary 类</p>
<p><strong>Hashtable 与 HashMap 的简单比较</strong></p>
<ol>
<li>HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap。Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。</li>
<li>HashMap 的 key 和 value 都允许为 null，而 Hashtable 的 key 和 value 都不允许为 null。HashMap 遇到 key 为 null 的时候，调用 putForNullKey 方法进行处理，而对 value 没有处理；Hashtable遇到 null，直接返回 NullPointerException。</li>
<li><strong>Hashtable 方法是同步的，而HashMap则不是，也就是说Hashtable是线程安全的</strong>。我们可以看一下源码，Hashtable 中的几乎所有的 public 的方法都是 synchronized 的，而有些方法也是在内部通过 synchronized 代码块来实现。所以有人一般都建议如果是涉及到多线程同步时采用 HashTable，没有涉及就采用 HashMap，但是在 Collections 类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的 Map 对象，并把它作为一个封装的对象来返回。</li>
</ol>
<h2 id="6-3-currentHashMap"><a href="#6-3-currentHashMap" class="headerlink" title="6.3 currentHashMap"></a>6.3 currentHashMap</h2><p>​    我们在之前的博文中了解到关于 HashMap 和 Hashtable 这两种集合。其中 HashMap 是非线程安全的，当我们只有一个线程在使用 HashMap 的时候，自然不会有问题，但如果涉及到多个线程，并且有读有写的过程中，HashMap 就不能满足我们的需要了(fail-fast)。在不考虑性能问题的时候，我们的解决方案有 Hashtable 或者Collections.synchronizedMap(hashMap)，这两种方式基本都是对整个 hash 表结构做锁定操作的，这样在锁表的期间，别的线程就需要等待了，无疑性能不高。</p>
<p>​    <strong>currentHashMap的加锁操作是针对的 hash 值对应的某个 Segment</strong>，而不是整个 ConcurrentHashMap。因为 put 操作只是在这个 Segment 中完成，所以并不需要对整个 ConcurrentHashMap 加锁。所以，此时，其他的线程也可以对另外的 Segment 进行 put 操作，因为虽然该 Segment 被锁住了，但其他的 Segment 并没有加锁。同时，读线程并不会因为本线程的加锁而阻塞。</p>
<p>​    正是因为其内部的结构以及机制，所以 ConcurrentHashMap 在并发访问的性能上要比Hashtable和同步包装之后的HashMap的性能提高很多。在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。</p>
<p>​    ConcurrentHashMap 针对读操作做了大量的优化。通过 HashEntry 对象的不变性和用 volatile 型变量协调线程间的内存可见性，使得 大多数时候，读操作不需要加锁就可以正确获得值。这个特性使得 ConcurrentHashMap 的并发性能在分离锁的基础上又有了近一步的提高。</p>
<p><strong>总结一下：</strong>ConcurrentHashMap 的高并发性主要来自于三个方面：</p>
<ul>
<li>用分离锁实现多个线程间的更深层次的共享访问。</li>
<li>用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。</li>
<li>通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。</li>
</ul>
<p><a href="http://wiki.jikexueyuan.com/project/java-collection/concurrenthashmap.html" target="_blank" rel="external">极客学院Java集合学习指南</a></p>
<h2 id="6-4-LinkedHashMap"><a href="#6-4-LinkedHashMap" class="headerlink" title="6.4 LinkedHashMap"></a>6.4 LinkedHashMap</h2><p>HashMap 是无序的，HashMap 在 put 的时候是根据 key 的 hashcode 进行 hash 然后放入对应的地方。所以在按照一定顺序 put 进 HashMap 中，然后遍历出 HashMap 的顺序跟 put 的顺序不同（除非在 put 的时候 key 已经按照 hashcode 排序号了，这种几率非常小）</p>
<p>JAVA 在 JDK1.4 以后提供了 <strong>LinkedHashMap 来帮助我们实现了有序的 HashMap</strong>！</p>
<p><strong>LinkedHashMap 实现与 HashMap 的不同之处在于，LinkedHashMap 维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</strong></p>
<p>根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用 get 方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。</p>
<h1 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h1><ol>
<li><a href="http://wiki.jikexueyuan.com/project/java-collection/hashmap.html" target="_blank" rel="external">极客学院，HashMap 的实现原理</a></li>
<li><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">美团点评技术团队，Java 8系列之重新认识HashMap</a></li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章系统设计】爬虫系统与搜索建议系统]]></title>
      <url>/2018/03/10/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%BB%BA%E8%AE%AE%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<h1 id="1-outline"><a href="#1-outline" class="headerlink" title="1. outline"></a>1. outline</h1><ul>
<li>Design a web crawler 爬虫</li>
<li>Design thread-safe producer and  consumer 线程安全的生产者-消费者</li>
<li>Design a Typeahead 搜索建议</li>
</ul>
<h1 id="2-爬虫"><a href="#2-爬虫" class="headerlink" title="2. 爬虫"></a>2. 爬虫</h1><h2 id="2-1-Scenario"><a href="#2-1-Scenario" class="headerlink" title="2.1 Scenario"></a>2.1 Scenario</h2><p>思考：搜索引擎是如爬取网页的？我们需要获取什么样的表格？</p>
<p>URL-网页内容</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-21-08-16.png" alt=""> </p>
<p>爬到了这些数据怎么用呢？</p>
<p>用户搜索关键词，google去数据表中的网页内容字段寻找包含用户query的数据，返回对应的url给用户，之后进行排序等优化操作。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-21-09-32.png" alt=""> </p>
<p>那么想要用程序完成爬取互联网上所有网页及其内容这个目标，我们首先要知道一个事实，也就是互联网上的内容其实是互相索引的，也就是就像如下的大网一样：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-21-11-23.png" alt=""> </p>
<p><strong>总结分析爬虫的工作量：</strong></p>
<p><strong>假设我们需要在一周内爬取互联网中所有的网页，之后至少一周更新一次。</strong></p>
<ol>
<li>互联网上共有1trillion个网页，则每秒需要爬取1.6m个网页</li>
<li><strong>每个网页大概10K</strong>，那么将这些网页存下来需要<strong>10P</strong>的存储空间</li>
</ol>
<p>把互联网上的网页看成是一张图，爬虫相当于遍历这个图，有DFS和BFS两种实现方式，<strong>一般采用BFS进行爬取</strong>，因为DFS不好并行爬取。</p>
<h3 id="2-1-1单线程爬取"><a href="#2-1-1单线程爬取" class="headerlink" title="2.1.1单线程爬取"></a>2.1.1单线程爬取</h3><p>对于单线程的爬虫来说，就是搞一个队列，用BFS爬取集合：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-21-25-03.png" alt=""> </p>
<h3 id="2-1-2-生产者消费者模型"><a href="#2-1-2-生产者消费者模型" class="headerlink" title="2.1.2 生产者消费者模型"></a>2.1.2 生产者消费者模型</h3><p>producer-consumer pattern生产者消费者模型</p>
<p>由于存取速度不一样，所以二者中间有一个buffer</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-11-21-16-37.png" alt="img"></p>
<p>但是单线程有一个问题，就是慢的很。解决——多线程爬虫</p>
<h3 id="2-1-3-多线程爬取"><a href="#2-1-3-多线程爬取" class="headerlink" title="2.1.3 多线程爬取"></a>2.1.3 多线程爬取</h3><p> 不同线程之间共享同一个队列</p>
<p>为什么多线程会比单线程快呢？</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-21-37-28.png" alt=""> </p>
<p>多线程存在的问题：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-21-38-56.png" alt=""> </p>
<p>多个线程都会从队列里向外拿URL，相当于对队列的一次写操作，这时候就会发生冲突，也就是互斥</p>
<p>需要注意的是，争取共享资源，就要<strong>考虑以下三个机制</strong>：</p>
<ul>
<li>sleep —— 就是睡一会，设置一定的时间，然后回来看看资源能用了不。但问题是：在道资源可以使用的第一时间知道，效率很低</li>
<li>condition variable 信号量（实现互斥）—— 相当于所有的线程都在等着，然后信号量通知他们能用的时候，就都立马去抢占用资源，谁抢到算谁的</li>
<li>semaphore —— 就像门上挂上五把钥匙一样，每次可以进去5个人，出来的时候还钥匙，也就是允许同一时间有多个线程访问用一个资源。</li>
</ul>
<p>单线程 –&gt; 多线程：</p>
<p>思考一个问题，既然多线程这么快，是否可以尽量多的开线程，比如开一万个？</p>
<p>不行，原因如下：</p>
<ul>
<li>线程之间来回切换(context switch)还是有花费（需要保存线程执行状态，还需要切换二级缓存等）的，因此线程不能太多，线程过多效率会很低</li>
<li>一个CPU在同一时间只能处理一个线程，如果机器只有一个CPU线程依然在排队</li>
<li>线程端口数目是有限的（TCP/IP协议中，端口只有2个字节，也就是65536个端口，操作系统还会预留一些端口给其他服务）</li>
<li>网络带宽有限制，线程很多，单台的带宽是不能够满足的</li>
</ul>
<p>因此我们可以改进一下：</p>
<h3 id="2-1-4-分布式爬取"><a href="#2-1-4-分布式爬取" class="headerlink" title="2.1.4 分布式爬取"></a>2.1.4 分布式爬取</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-22-02-00.png" alt=""> </p>
<p>分多台机器爬取，就可以突破单台机器的限制了！此时分布式爬虫依然共享一个内存中的URL queue.</p>
<p>分布式爬虫虽然解决了线程不能太多的问题，但是又带来了一个问题：URL队列在内存中放不下了（假设1trillion，差不多要40T的内存）！这是不行的。那么我们考虑一下把URL queue存在硬盘里，也就是数据库里。</p>
<p>但是放到数据库里之后，又有一个很要命的限制是：没有办法控制网页抓取的顺序和优先级啊！</p>
<p>解决：给数据库加入一个优先级的列，再加一个频率的列</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-22-08-58.png" alt=""> </p>
<p>每一行是一个任务：</p>
<ul>
<li>ID,URL</li>
<li>state：是否正在运行的状态（即能去重，也能防止重复运算）</li>
<li>priority：优先级</li>
<li>available_time：控制抓取频率，也就是这个时刻之后再进行抓取。如果本次有更新，那么就把时间设置地更近一些；如果本次没有更新，那么就把时间设置地更远一些</li>
</ul>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-22-09-49.png" alt=""> </p>
<ul>
<li>webPage Storage : 分布式存储系统，存储爬取的东西</li>
<li>分布式爬虫</li>
<li>Task table : 就是上面的任务表</li>
</ul>
<h2 id="2-4-Scale-优化"><a href="#2-4-Scale-优化" class="headerlink" title="2.4 Scale 优化"></a>2.4 Scale 优化</h2><h3 id="2-4-1-Task-Table-拆分"><a href="#2-4-1-Task-Table-拆分" class="headerlink" title="2.4.1 Task Table 拆分"></a>2.4.1 Task Table 拆分</h3><p><strong>task table 最终会非常大！1 trillion 个task，而且会越来越大</strong></p>
<p>解决——拆表sharding，加速访问</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-22-26-40.png" alt=""> </p>
<p>那么拆表就有一个细节需要注意，需要一个scheduler，用来安排去哪里要数据。</p>
<h3 id="2-4-2-抓取频率问题"><a href="#2-4-2-抓取频率问题" class="headerlink" title="2.4.2 抓取频率问题"></a>2.4.2 抓取频率问题</h3><p>如何控制抓取频率呢？有一个暴力的方法：</p>
<ul>
<li>如果本次抓了有更新（更新频繁），那就把下次抓取的时间提前一半</li>
<li>如果本次抓了没更新（更新不频繁），就把下次抓取的时间往后移2倍</li>
</ul>
<p>调整合适的抓频率可以优化计算资源</p>
<h3 id="2-4-3-死循环问题"><a href="#2-4-3-死循环问题" class="headerlink" title="2.4.3 死循环问题"></a>2.4.3 死循环问题</h3><p>比如爬取新浪新闻，基本上连接也都是新浪新闻，</p>
<p>有些网站是互相指向的，比如sina.com。而且所有的URL都是与sina.com差不多的。这样就会使用大量的资源去抓取这种巨型网站，太耗费资源了。对于那些小博客就不公平。</p>
<p>解决办法：单位时间对同一个网站，不要分配过多的计算资源给巨型网站就好啦。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-23-51-10.png" alt=""> </p>
<h3 id="2-4-4-分区域问题"><a href="#2-4-4-分区域问题" class="headerlink" title="2.4.4 分区域问题"></a>2.4.4 分区域问题</h3><p>中国的爬虫爬美国的网站，或者网站在美国爬中国的网站就会很慢</p>
<p>解决：分区域爬取，分区域简历task table，然后定期和全世界的数据库进行同步</p>
<h1 id="3-Typeahead-搜索建议"><a href="#3-Typeahead-搜索建议" class="headerlink" title="3. Typeahead 搜索建议"></a>3. Typeahead 搜索建议</h1><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-23-54-59.png" alt=""> </p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-23-55-53.png" alt=""> </p>
<h2 id="3-1-scenario-场景分析"><a href="#3-1-scenario-场景分析" class="headerlink" title="3.1 scenario 场景分析"></a>3.1 scenario 场景分析</h2><p>我们以google Suggesion为例分析</p>
<ul>
<li>DAU日活跃用户：500m</li>
<li>搜索量：4 x 6 x 500m = 12b （每人搜索6次，输入4个单词 = 使用了typeahead四次）</li>
<li>QPS : 12b / 86400 = 138k</li>
<li>Peak QPS = QPS X 2 = 276k</li>
</ul>
<p>typeahead的最关键问题是快！一定要在用户敲字母的同时给出建议</p>
<h2 id="3-2-service-需求"><a href="#3-2-service-需求" class="headerlink" title="3.2 service 需求"></a>3.2 service 需求</h2><ol>
<li>query survice 处理检索，在极短的时间内返回以输入为前缀的建议热门词</li>
<li>data collection service 收集某段时间内用户搜索的热门词</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-13-00-24-11.png" alt=""></h3><h2 id="3-3-Storage"><a href="#3-3-Storage" class="headerlink" title="3.3 Storage"></a>3.3 Storage</h2>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[排序算法终极大总结]]></title>
      <url>/2018/03/10/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%BB%88%E6%9E%81%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>常见的排序算法有以下几种：</p>
<ul>
<li>递归性排序<ul>
<li><a href="/2017/07/23/【排序】归并排序/" title="归并排序">归并排序</a>：归并排序的主要思想是分治，也就是先把数组分成两部分，当两部分都有序时，然后再将两部分进行二路归并。需要注意的是归并排序的时间复杂度分析方法，就是画出$T(n) = 2T(n/2) + cn$ 的递归树，并计算最终时间复杂度。但是要注意的是，归并排序在进行二路归并时，可能会产生额外的空间复杂度。</li>
<li>：快速排序的思路也是分治，但分治之前需要选择一个主元作为基准，将主元放在应该在的位置，并且数组左边比主元小，右边比主元大。这样如果当左边有序和右边有序时，整个数组就有序了。假设主元位置为i，快速排序复杂度为$T(n) = T(i) + T(n - i - 1) + cn$ 。由于i的不确定性导致快速排序的最坏情况下时间复杂度为$T(n) = T(n-1) + T(0) +  cn = O(n^2)$ ，而平均情况下是$T(n) = 2T(\frac{n-1}{2}) +cn = nlogn$。 快速排序不需要额外的空间。</li>
</ul>
</li>
<li>非递归型排序<ul>
<li><a href="/2017/07/20/【排序】插入排序/" title="插入排序">插入排序</a>：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。</li>
<li><a href="/2017/07/22/【排序】选择排序/" title="选择排序">选择排序</a>：每次从无序区选择一个最小的放大有序区的最后</li>
<li><a href="/2017/07/20/【排序】冒泡排序/" title="冒泡排序">冒泡排序</a>：依次比较相邻的两个数据，如果前面的比后面的大，就将其交换；这样交换一轮之后，整个序列中最大的就“沉”到了最后面的位置；重复上述过程，依次把第二大、第三大…的数字放到后面的位置。</li>
<li><a href="/2017/07/22/【排序】希尔排序/" title="希尔排序">希尔排序</a>：分组插入排序</li>
</ul>
</li>
<li>非比较排序：非比较排序的时间复杂度可以达到$O(n)$ 。<ul>
<li><a href="/2018/02/08/【排序】计数排序、基数排序、桶排序/" title="计数排序、基数排序、桶排序">计数排序、基数排序、桶排序</a>
<ul>
<li>计数排序：已知最大值K。利用数组<code>int[K]</code> 统计每个数字的小于等于它的个数，将这个个数作为这个数字的idx</li>
<li>基数排序：分别对数字的个位、十位、…、d位依次进行计数排序</li>
<li>桶排序：将数字分别放入桶里。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因此我们做出如下总结：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>排序方法</th>
<th>平均时间复杂度</th>
<th>最坏时间复杂度</th>
<th>空间复杂度</th>
<th>其它要点</th>
</tr>
</thead>
<tbody>
<tr>
<td>归并</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(n)$</td>
<td>递归树</td>
</tr>
<tr>
<td>快排</td>
<td>$O(nlogn)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>快速选择<a href="/2018/02/02/【九章算法强化班】两指针/" title="【九章算法强化班】两指针">【九章算法强化班】两指针</a> <br>快排优化算法：随机选择pivot<br></td>
</tr>
<tr>
<td>插入、<br>选择、<br>冒泡、<br>希尔</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td>计数排序</td>
<td>$O(n)$</td>
<td>$O(n)$</td>
<td>$O(K)$</td>
<td>已知数组最大值K</td>
</tr>
<tr>
<td>基数排序</td>
<td>$O(d(n+10))$</td>
<td>$O(d(n+10))$</td>
<td>$O(10)$</td>
<td></td>
</tr>
<tr>
<td>桶排序</td>
<td>$O(n)$</td>
<td></td>
<td>$O(n)$</td>
<td>大数排序<br></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【面经】开发相关基础知识]]></title>
      <url>/2018/03/09/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h2 id="1-JDK和JRE、JVM的区别是什么"><a href="#1-JDK和JRE、JVM的区别是什么" class="headerlink" title="1. JDK和JRE、JVM的区别是什么"></a>1. JDK和JRE、JVM的区别是什么</h2><p><strong>JRE（Java运行时环境）： Java Runtime Environment</strong></p>
<p>JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。</p>
<p><strong>JDK（Java 开发工具包）：Java Development Kit</strong></p>
<p>JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。</p>
<p><strong>JVM（Java 虚拟机）：Java Virtual Machine</strong></p>
<p>JVM是Java编程语言的核心。当我们运行一个程序时，JVM负责将字节码转换为特定机器代码。JVM也是<strong>平台特定</strong>的，并提供核心的Java方法，例如内存管理、垃圾回收和安全机制等。JVM 是可定制化的，我们可以通过Java 选项(java options)定制它，比如配置JVM 内存的上下界。JVM之所以被称为虚拟的是因为它提供了一个不依赖于底层操作系统和机器硬件的接口。这种独立于硬件和操作系统的特性正是Java程序可以一次编写多处执行的原因。</p>
<p><strong>JDK, JRE 和JVM的区别</strong></p>
<ul>
<li>JDK是用于开发的而JRE是用于运行Java程序的。</li>
<li>JDK和JRE都包含了JVM，从而使得我们可以运行Java程序。</li>
<li>JVM是Java编程语言的核心并且具有平台独立性。</li>
</ul>
<h2 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2. 进程和线程"></a>2. 进程和线程</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong>程序</strong></p>
<p>​    程序是指令和数据的有序集合，其本身没有任何运动的含义，是一个静态的概念，而进程则是在处理机上的一次执行过程，它是一个动态的概念。进程是包含程序的，进程的执行离不开程序，进程中的文本区域就是代码区，也就是程序。</p>
<p><strong>进程(process)</strong></p>
<p>狭义的定义：进程就是一段程序的执行过程。</p>
<p>广义定义：进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元。</p>
<p>​    简单来讲进程的概念主要有两点：第一，进程是一个实体。<strong>每一个进程都有它自己的地址空间</strong>，一般情况下，包括<strong>文本区域（text region）、数据区域（data region）和堆栈（stack region）</strong>。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程中调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。</p>
<p>​    进程状态：进程有三个状态，就绪，运行和阻塞。就绪状态其实就是获取了除cpu外的所有资源，只要处理器分配资源马上就可以运行。运行态就是获取了处理器分配的资源，程序开始执行，阻塞态，当程序条件不够时，需要等待条件满足时候才能执行，如等待I/O操作的时候，此刻的状态就叫阻塞态。</p>
<p><strong>线程(thread)</strong></p>
<p>​    通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p>
<h3 id="2-2进程与线程的区别"><a href="#2-2进程与线程的区别" class="headerlink" title="2.2进程与线程的区别"></a>2.2进程与线程的区别</h3><p>​    进程和线程的主要差别在于它们是不同的操作系统资源管理方式。<strong>进程有独立的地址空间</strong>，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。<strong>线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间</strong>，<strong>一个线程死掉就等于整个进程死掉</strong>，<strong>所以多进程的程序要比多线程的程序健壮</strong>，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<p>1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</p>
<p>2) 线程的划分尺度小于进程，使得多线程程序的并发性高。</p>
<p>3) 另外，<strong>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</strong>。</p>
<p>4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
<h3 id="2-3-优缺点"><a href="#2-3-优缺点" class="headerlink" title="2.3 优缺点"></a>2.3 优缺点</h3><p>​    线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP(多核处理机)机器上运行，而进程则可以跨机器迁移。</p>
<p><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="external">用一个工厂的形象的解释进程和线程</a></p>
<p><a href="https://www.jianshu.com/p/7ce30a806c51" target="_blank" rel="external">简书的王布斯</a></p>
<h2 id="3-如何预防死锁"><a href="#3-如何预防死锁" class="headerlink" title="3. 如何预防死锁"></a>3. 如何预防死锁</h2><h3 id="3-1-死锁"><a href="#3-1-死锁" class="headerlink" title="3.1 死锁"></a>3.1 死锁</h3><p>​    当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<h3 id="3-2-造成死锁必须达成的4个条件（原因）"><a href="#3-2-造成死锁必须达成的4个条件（原因）" class="headerlink" title="3.2 造成死锁必须达成的4个条件（原因）"></a>3.2 造成死锁必须达成的4个条件（原因）</h3><ul>
<li>互斥：指进程对所分配到的资源进行排他性使用，即一段时间内某资源只能由一个进程占用</li>
<li>请求和保持：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺：指进程已获得的资源在未使用完之前不能被剥夺，只能在使用完时自己释放</li>
<li>循环等待：若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<h3 id="3-3死锁的预防"><a href="#3-3死锁的预防" class="headerlink" title="3.3死锁的预防"></a>3.3<strong>死锁的预防</strong></h3><blockquote>
<p>破坏互斥条件</p>
</blockquote>
<ul>
<li>一般来说在所列的四个条件中，“互斥”条件是无法破坏的</li>
</ul>
<blockquote>
<p>破坏请求和保持条件</p>
</blockquote>
<ul>
<li>一次性分配方案</li>
<li>要求每个进程提出新的资源申请前，释放它所占有的资源</li>
</ul>
<blockquote>
<p>破坏不剥夺条件</p>
</blockquote>
<ul>
<li>如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源</li>
<li>进程划分优先级，高优先级进程可以剥夺低优先级进程的资源</li>
</ul>
<blockquote>
<p>破坏循环等待条件</p>
</blockquote>
<ul>
<li>将系统中的所有资源统一编号，进程提出的所有资源申请必须按照资源的编号顺序提出</li>
</ul>
<h2 id="4-tcp-udp-区别"><a href="#4-tcp-udp-区别" class="headerlink" title="4. tcp udp 区别"></a>4. tcp udp 区别</h2><p><strong>TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</strong></p>
<p>1)提供IP环境下的数据可靠传输(一台计算机发出的字节流会无差错的发往网络上的其他计算机，而且计算机A接收数据包的时候，也会向计算机B回发数据包，这也会产生部分通信量)，有效流控，全双工操作(数据在两个方向上能同时传递)，多路复用服务，是面向连接，端到端的传输;</p>
<p>2)面向连接：正式通信前必须要与对方建立连接。事先为所发送的数据开辟出连接好的通道，然后再进行数据发送，像打电话。</p>
<p>3)TCP支持的应用协议：Telnet(远程登录)、FTP(文件传输协议)、SMTP(简单邮件传输协议)。TCP用于传输数据量大，可靠性要求高的应用。</p>
<p><strong>UDP(用户数据报协议）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</strong></p>
<p>1)面向非连接的(正式通信前不必与对方建立连接，不管对方状态就直接发送，像短信，QQ)，不能提供可靠性、流控、差错恢复功能。UDP用于一次只传送少量数据，可靠性要求低、传输经济等应用。</p>
<ol>
<li>UDP支持的应用协议：NFS(网络文件系统)、SNMP(简单网络管理系统)、DNS(主域名称系统)、TFTP(通用文件传输协议)等。</li>
</ol>
<p><strong>总结：</strong></p>
<p><strong>TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。</strong></p>
<p><strong>UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。</strong></p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-11-01-23-00.png" alt=""> </p>
<h3 id="5-TCP-IP-协议族常用协议"><a href="#5-TCP-IP-协议族常用协议" class="headerlink" title="5. TCP/IP 协议族常用协议"></a>5. TCP/IP 协议族常用协议</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-11-01-26-11.png" alt=""> </p>
<h2 id="6-三次握手四次挥手"><a href="#6-三次握手四次挥手" class="headerlink" title="6. 三次握手四次挥手"></a>6. 三次握手四次挥手</h2><h3 id="6-1-TCP特性"><a href="#6-1-TCP特性" class="headerlink" title="6.1 TCP特性"></a>6.1 TCP特性</h3><ul>
<li>TCP 提供一种<strong>面向连接的、可靠的</strong>字节流服务</li>
<li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li>
<li>TCP 使用校验和，确认和重传机制来保证可靠传输</li>
<li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li>
<li>TCP 使用<strong>滑动窗口机制</strong>来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>
</ul>
<p><strong>那为什么需要三次握手呢？</strong>请看如下的过程：</p>
<ol>
<li>A向B发起建立连接请求：A——&gt;B；</li>
<li>B收到A的发送信号，并且向A发送确认信息：B——&gt;A；</li>
<li>A收到B的确认信号，并向B发送确认信号：A——&gt;B。</li>
</ol>
<p>三次握手大概就是这么个过程。<br>通过第一次握手，B知道A能够发送数据。通过第二次握手，A知道B能发送数据。结合第一次握手和第二次握手，A知道B能接收数据。结合第三次握手，B知道A能够接收数据。</p>
<p>至此，完成了握手过程，A知道B能收能发，B知道A能收能发，通信连接至此建立。三次连接是保证可靠的最小握手次数，再多次握手也不能提高通信成功的概率，反而浪费资源。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-11-12-21-02.png" alt=""> </p>
<p><strong>那为什么需要四次挥手呢？</strong>请看如下过程：</p>
<ol>
<li>A向B发起请求，表示A没有数据要发送了：A——&gt;B；</li>
<li>B向A发送信号，确认A的断开请求请求：B——&gt;A；</li>
<li>B向A发送信号，请求断开连接，表示B没有数据要发送了：B——&gt;A；</li>
<li>A向B发送确认信号，同意断开：A——&gt;B。</li>
</ol>
<p>B收到确认信号，断开连接，而A在一段时间内没收到B的信号，表明B已经断开了，于是A也断开了连接。至此，完成挥手过程。</p>
<p>可能有捧油会问，为什么2、3次挥手不能合在一次挥手中？那是因为此时A虽然不再发送数据了，但是还可以接收数据，B可能还有数据要发送给A，所以两次挥手不能合并为一次。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-11-12-21-13.png" alt=""> </p>
<p>挥手次数比握手多一次，是因为握手过程，通信只需要处理<strong>连接</strong>。而挥手过程，通信需要处理<strong>数据+连接</strong>。</p>
<h2 id="7-局部变量和函数参数为什么要放在栈中"><a href="#7-局部变量和函数参数为什么要放在栈中" class="headerlink" title="7.  局部变量和函数参数为什么要放在栈中"></a>7.  局部变量和函数参数为什么要放在栈中</h2><p>​    局部变量，顾名思义其作用域属于局部。全局的变量，意味着谁都随时随地可以访问，所以其放在数据段中。而局部变量只是自己在用，放在数据段中纯属浪费空间，没有必要，<strong>故将其放在自己的栈中，随时可以清理，真正体现了局部的意义</strong>。</p>
<p>​    函数参数为什么放在栈区呢？第一也是其局限性导致，只有这个函数用这个参数，何必将其放在数据段呢？二是因为函数是在程序执行过程中调用的，属于动态的调用，编译时无法预测何时调用及被调用的次数，函数的参数及返回值都需要内存来存储，如果是递归调用的话，参数及返回值需要的内存空间也就不确定了，这取决于递归的次数。有些体系结构的计算机也把函数参数放到寄存器里面去。</p>
<p>参考：<a href="https://www.jianshu.com/p/ac325bd601f8" target="_blank" rel="external">无敌大灰狼me链接</a></p>
<h2 id="2-常见设计原则和设计模式"><a href="#2-常见设计原则和设计模式" class="headerlink" title="2. 常见设计原则和设计模式"></a>2. 常见设计原则和设计模式</h2><p>6大设计原则：</p>
<ol>
<li><strong>单一职责原则</strong>：就是开发人员经常说的”高内聚，低耦合”。也就是说，每个类应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个。在设计模式中，所有的设计模式都遵循这一原则。</li>
<li><strong>开闭原则</strong>：一个对象对扩展开放，对修改关闭。也就是说，对类的改动是通过增加代码进行的，而不是修改现有代码。软件开发人员一旦写出了可以运行的代码，就不应该去改动它，而是要保证它能一直运行下去，如何能够做到这一点呢?这就需要借助于抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现则是可以改变和扩展的。</li>
<li><strong>里氏替换原则</strong>：在任何父类出现的地方都可以用它的子类来替代。也就是说，同一个继承体系中的对象应该有共同的行为特征。</li>
<li><strong>依赖注入原则</strong>：要依赖于抽象，不要依赖于具体实现。也就是说，在应用程序中，所有的类如果使用或依赖于其他的类，则应该依赖这些其他类的抽象类，而不是这些其他类的具体类。为了实现这一原则，就要求我们在编程的时候针对抽象类或者接口编程，而不是针对具体实现编程。</li>
<li><strong>接口分离原则</strong>：不应该强迫程序依赖它们不需要使用的方法。也就是说，一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中。</li>
<li><strong>迪米特原则：</strong>一个对象应当对其他对象尽可能少的了解。也就是说，降低各个对象之间的耦合，提高系统的可维护性。在模块之间应该只通过接口编程，而不理会模块的内部工作原理，它可以使各个模块耦合度降到最低，促进软件的复用</li>
</ol>
<p>常见设计模式:</p>
<ol>
<li><p>简单工厂模式</p>
<p> · 工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。</p>
<p>​        · 优点：客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性。</p>
<p>​        · 缺点：需要额外的编写代码，增加了工作量。</p>
</li>
<li><p>单例设计模式</p>
<p> 单例模式就是要确保类在内存中只有一个对象，该实例必须自动创建，并且对外提供。</p>
<p>​        · 优点：在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</p>
<p>​        · 缺点：没有抽象层，因此扩展很难。职责过重，在一定程序上违背了单一职责</p>
</li>
<li><p>模板设计模式</p>
<p>· 模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现</p>
<p>​        · 优点：使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求</p>
<p>​        · 缺点：如果算法骨架有修改的话，则需要修改抽象类</p>
</li>
</ol>
<h3 id="2-volatile关键字作用是什么"><a href="#2-volatile关键字作用是什么" class="headerlink" title="2. volatile关键字作用是什么"></a>2. volatile关键字作用是什么</h3><p>英文翻译：不稳定的</p>
<p>弱同步机制</p>
<p>在多线程的化境下，Volatile 修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>
<p>数据量过大内存存不下了怎么办</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【本科毕设】pub/sub框架]]></title>
      <url>/2018/03/09/%E3%80%90%E6%9C%AC%E7%A7%91%E6%AF%95%E8%AE%BE%E3%80%91pub-sub%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-09-21-59-34.png" alt=""> </p>
<p>本文中研究的问题为位置感知的发布/订阅框架设计与实现。订阅者以订阅（subscription）的形式向发布/订阅系统注册，表达对特定事件的兴趣；发布者发布消息到发布/订阅系统；发布/订阅系统充当订阅者和发布者的中介，负责订阅的管理，并以通知的形式发送消息到感兴趣的订阅者。</p>
<p>与传统的基于文本的发布订阅问题不同，在我们所研究的问题中，发布者发布的消息和订阅者的订阅都是同时包含了空间位置和文本描述两种信息。</p>
<p>​    订阅者对于空间位置和文本描述的相似性有着不同的偏好，比如一些订阅者更希望得到与自己的订阅文本相似程度更高的消息，而另一些订阅者则更关注获得的消息与自己所在的空间位置的相近程度，因此我们允许用户进行参数化订阅，研究基于参数化的空间文本订阅的位置感知发布/订阅框架，力求实现高效、有针对性的发布/订阅过程。</p>
<h2 id="2-前缀过滤技术"><a href="#2-前缀过滤技术" class="headerlink" title="2. 前缀过滤技术"></a>2. 前缀过滤技术</h2><p>​    文本过滤即为利用数据的文本信息进行剪枝。旨在通过执行较快捷的基于文本的算法来减少记录点之间文本相似度的直接计算，从而提高计算效率。常用的文本过滤有长度过滤，前缀过滤，索引前缀过滤，位置过滤和后缀过滤五种过滤机，我们采用其中的前缀过滤机制，结合空间文本订阅的文本信息对不符合条件的订阅进行剪枝。</p>
<p>​    前缀过滤技术中，我们需要结合倒排文件列表构建前缀索引，前缀索引即根据计算出的前缀长度，只在倒排文件中存储前缀词。当且仅当两个记录点的文件中前缀有一个以上相同时，两个记录点才有可能成为匹配对</p>
<h2 id="3-方案"><a href="#3-方案" class="headerlink" title="3. 方案"></a>3. 方案</h2><h3 id="3-1-baseline"><a href="#3-1-baseline" class="headerlink" title="3.1 baseline"></a>3.1 baseline</h3><p>通过计算订阅和消息的相似度，如果超过阈值则可以推送。</p>
<p>问题：计算量大，效率低。</p>
<h3 id="3-2-空间感知前缀"><a href="#3-2-空间感知前缀" class="headerlink" title="3.2 空间感知前缀"></a>3.2 空间感知前缀</h3><p>根据阈值和文本权重，可以计算出每个subscription的前缀长度，因此倒排索引简化为只对前缀词做倒排</p>
<p>根据每个subscription中所有词的权重，可以估算出其文本相似度下界，从而可以得到空间相似度下界。</p>
<p>接下来利用过滤-验证机制，对m中的关键词访问倒排表，找到包含关键词的subscription，计算这些subscription和m的距离，根据之前存储的空间相似度下界进行过滤，得到候选集。最后再用相似度公式验证得到最终结果。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-09-23-02-13.png" alt=""> </p>
<h3 id="3-3-区域感知前缀"><a href="#3-3-区域感知前缀" class="headerlink" title="3.3 区域感知前缀"></a>3.3 区域感知前缀</h3><p> 利用R树对subscriptions做空间索引，在R树的节点中存储倒排索引，空间相似度下界等，当消息过来时，可以一次性过滤掉不符合条件的整个区域。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-09-23-03-19.png" alt=""> </p>
<h3 id="3-4-进一步优化"><a href="#3-4-进一步优化" class="headerlink" title="3. 4 进一步优化"></a>3. 4 进一步优化</h3><p>对消息流按时间段进行R树空间索引，匹配消息和订阅两个R树，进行过滤</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[生成模型vs判别模型、有监督vs无监督]]></title>
      <url>/2018/03/09/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8Bvs%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B%E3%80%81%E6%9C%89%E7%9B%91%E7%9D%A3vs%E6%97%A0%E7%9B%91%E7%9D%A3/</url>
      <content type="html"><![CDATA[<h2 id="1-监督学习-vs-无监督学习"><a href="#1-监督学习-vs-无监督学习" class="headerlink" title="1. 监督学习 vs 无监督学习"></a>1. 监督学习 vs 无监督学习</h2><ol>
<li>有监督学习：输入数据有标签，比如分类回归</li>
<li>无监督学习：输入数据没有标签，比如聚类</li>
<li>半监督学习：输入数据部分有标签，部分没有，或者有标签的部分不确定是否正确，让学习器不依赖外界交互、自动地利用未标记样本来提升学习性能，就是半监督学习</li>
</ol>
<h2 id="2-生成模型-vs-判别模型"><a href="#2-生成模型-vs-判别模型" class="headerlink" title="2. 生成模型 vs 判别模型"></a>2. 生成模型 vs 判别模型</h2><p>监督学习方法又可以分为<strong>生成方法</strong>(generative approach)和<strong>判别方法</strong>(discriminative approach)。所学到的模型分别为生成模型(generative model)和判别模型(discriminative model)。</p>
<h3 id="2-1-生成方法和生成模型"><a href="#2-1-生成方法和生成模型" class="headerlink" title="2.1 生成方法和生成模型"></a>2.1 生成方法和生成模型</h3><p>生成模型：无穷样本==》概率密度模型 = 产生模型==》预测</p>
<p>生成方法<strong>由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)=P(X,Y)/P(X)作为预测的模型</strong>。这样的方法之所以成为生成方法，是因为<strong>模型表示了给定输入X产生输出Y的生成关系</strong>。用于随机生成的观察值建模，特别是在给定某些隐藏参数情况下。典型的生成模型有：朴素贝叶斯法、马尔科夫模型、高斯混合模型。这种方法一般建立在统计学和Bayes理论的基础之上。</p>
<p><strong>生成方法的特点：</strong></p>
<ul>
<li>从统计的角度表示数据的分布情况，能够<strong>反映同类数据本身的相似度</strong>;</li>
<li>生成方法还原出联合概率分布，而判别方法不能；</li>
<li>生成方法的学习<strong>收敛速度更快</strong>、即当样本容量增加的时候，学到的模型可以更快地收敛于真实模型；</li>
<li>当存在隐变量时，仍然可以用生成方法学习，此时判别方法不能用</li>
</ul>
<h3 id="2-2-判别方法和判别模型"><a href="#2-2-判别方法和判别模型" class="headerlink" title="2.2 判别方法和判别模型"></a>2.2 判别方法和判别模型</h3><p>判别模型：有限样本==》判别函数 = 预测模型==》预测</p>
<p>判别方法由数据<strong>直接学习决策函数f(X)或者条件概率分布P(Y|X)作为预测的模型</strong>，即判别模型。判别方法关心的是对给定的输入X，应该预测什么样的输出Y。典型的判别模型包括：k近邻法、感知机、决策树、逻辑斯蒂回归模型、最大熵模型、支持向量机、boosting方法和条件随机场等。判别模型利用正负例和分类标签，关注在判别模型的边缘分布。</p>
<p><strong>判别方法的特点：</strong></p>
<blockquote>
<ul>
<li>判别方法寻找不同类别之间的最优分类面，<strong>反映的是异类数据之间的差异</strong>;</li>
<li>判别方法利用了训练数据的类别标识信息，直接学习的是条件概率P(Y|X)或者决策函数f(X)，直接面对预测，<strong>往往学习的准确率更高</strong>；</li>
<li>由于直接学习条件概率P(Y|X)或者决策函数f(X)，<strong>可以对数据进行各种程度上的抽象、定义特征并使用特征</strong>，因此可以简化学习问题。</li>
<li><strong>缺点是不能反映训练数据本身的特性</strong></li>
</ul>
</blockquote>
<h3 id="2-3-生成模型和判别模型对比"><a href="#2-3-生成模型和判别模型对比" class="headerlink" title="2.3 生成模型和判别模型对比"></a>2.3 生成模型和判别模型对比</h3><ul>
<li><p>训练时，二者优化准则不同</p>
<p>生成模型优化训练数据的联合分布概率；</p>
<p>判别模型优化训练数据的条件分布概率，判别模型与序列标记问题有较好的对应性。</p>
</li>
<li><p>对于观察序列的处理不同</p>
<p>生成模型中，观察序列作为模型的一部分；</p>
<p><strong>判别模型中，观察序列只作为条件，因此可以针对观察序列设计灵活的特征。</strong></p>
<p>训练复杂度不同</p>
<p><strong>判别模型训练复杂度较高</strong>。</p>
</li>
<li><p>是否支持无指导训练</p>
<p>生成模型支持无指导训练。</p>
</li>
<li><p>本质区别</p>
<p>判别估计的是条件概率分布(conditional distribution)p(Y|X)</p>
<p>生成模型估计的是联合概率分布（joint probability distribution）p(X,Y)</p>
</li>
</ul>
<p>另外，由生成模型可以得到判别模型，但由判别模型得不到生成模型。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.jianshu.com/p/d195b887a32e" target="_blank" rel="external">【机器学习基础】生成模型和判别模型</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[B树、B+树、AVL树、Trie树及其应用场景]]></title>
      <url>/2018/03/09/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81AVL%E6%A0%91%E3%80%81Trie%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h2><p>AVL树：平衡二叉树之一，应用相对其他数据结构比较少，windows对进程地址空间的管理用到了AVL</p>
<p>红黑树：平衡二叉树，广泛应用在C++STL中，比如map和set，Java的TreeMap</p>
<p>B和B+树：主要用在文件系统以及数据库中做索引等</p>
<p>Trie 树：用在统计和排序大量字符串中，一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示。还有比如IP选路，也是前缀匹配</p>
<p>R树：空间数据库索引</p>
<h2 id="2-二叉搜索树"><a href="#2-二叉搜索树" class="headerlink" title="2. 二叉搜索树"></a>2. 二叉搜索树</h2><p>不必多说了，可以参考 <a href="https://siyaozhang.github.io/2017/11/29/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95/" target="_blank" rel="external">【九章算法基础班】二叉树与分治法</a></p>
<p><strong>时间复杂度</strong>最好情况是<script type="math/tex">O(logn)</script> ，最坏情况下时间复杂度<script type="math/tex">O(n)</script>，恰好选择了最小或者最大的节点做root，节点排在了一条直线上。</p>
<h2 id="3-AVL树"><a href="#3-AVL树" class="headerlink" title="3. AVL树"></a>3. AVL树</h2><p>AVL树是二叉搜索树的改进</p>
<p><strong>AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡</strong>，左右子树树高不超过1，和红黑树相比，它是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而<strong>旋转是非常耗时</strong>的，由此我们可以知道<strong>AVL树适合用于插入删除次数比较少，但查找多的情况。</strong></p>
<p><strong><img src="http://img.blog.csdn.net/20180307121339361" alt="img"></strong></p>
<p>上图是一个普通的平衡二叉树，这张图我们可以看出，<strong>任意节点的左右子树的平衡因子差值都不会大于1</strong>。</p>
<p>局限性：</p>
<p>由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。</p>
<h2 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4. 红黑树"></a>4. 红黑树</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><p><strong>一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是red或black（非红即黑）</strong>。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，<strong>红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树</strong>(由于是弱平衡，可以推出，相同的节点情况下，AVL树的高度低于红黑树)，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索、插入、删除操作较多的情况下，我们就用红黑树。</p>
<h3 id="4-2-性质"><a href="#4-2-性质" class="headerlink" title="4.2 性质"></a>4.2 性质</h3><p>1、每个节点非红即黑；</p>
<p>2、根节点是黑的；</p>
<p>3、每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的；</p>
<p>4、如果一个节点是红的,那么它的两儿子都是黑的；</p>
<p>5、对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点；</p>
<p>6、高度始终保持在h = logn</p>
<p>7、<strong>红黑树的查找、插入、删除的时间复杂度最坏为O(log n)</strong></p>
<p>如下图所示，即是一颗红黑树(下图引自wikipedia：<a href="http://t.cn/hgvH1l" target="_blank" rel="external">http://t.cn/hgvH1l</a>)：</p>
<p><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/images/rbtree/1.png" target="_blank" rel="external"><img src="https://github.com/julycoding/The-Art-Of-Programming-By-July/raw/master/ebook/images/rbtree/1.png" alt="img"></a></p>
<p>上文中我们所说的 “叶结点” 或”NULL结点”，它不包含数据而只充当树在此结束的指示，这些结点以及它们的父结点，在绘图中都会经常被省略。</p>
<h3 id="4-3-应用"><a href="#4-3-应用" class="headerlink" title="4.3 应用"></a>4.3 应用</h3><p>1、广泛用于C++的STL中，Map和Set都是用红黑树实现的；</p>
<p>2、著名的<strong>Linux进程调度Completely Fair Scheduler</strong>，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间；</p>
<p>3、IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查；</p>
<p>4、Nginx中用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器；</p>
<p>5、<strong>Java中TreeMap的实现</strong>；</p>
<p>详细的插入、删除、旋转等操作可以参考：</p>
<p><a href="https://juejin.im/entry/58371f13a22b9d006882902d" target="_blank" rel="external">面试旧敌之红黑树（直白介绍深入理解）</a></p>
<h2 id="5-B树"><a href="#5-B树" class="headerlink" title="5. B树"></a>5. B树</h2><h3 id="5-1-B-树简介"><a href="#5-1-B-树简介" class="headerlink" title="5.1 B-树简介"></a>5.1 B-树简介</h3><p>B树是为实现<strong>高效的磁盘存取</strong>而设计的多叉平衡搜索树。这个概念在文件系统，数据库系统中非常重要。</p>
<p>​    B树是一种查找树，我们知道，这一类树（比如二叉查找树，红黑树等等）最初生成的目的都是为了解决某种系统中，查找效率低的问题。B树也是如此，它最初启发于二叉查找树，二叉查找树的特点是每个非叶节点都只有两个孩子节点。然而这种做法会导致当数据量非常大时，二叉查找树的深度过深，搜索算法自根节点向下搜索时，需要访问的节点也就变的相当多。如果这些节点存储在外存储器中，每访问一个节点，相当于就是进行了一次I/O操作，随着树高度的增加，频繁的I/O操作一定会降低查询的效率。</p>
<p>​    这里有一个基本的概念，就是说我们从外存储器中读取信息的步骤，简单来分，大致有两步：</p>
<ol>
<li>找到存储这个数据所对应的磁盘页面，这个过程是机械化的过程，需要依靠磁臂的转动，找到对应磁道，所以耗时长。</li>
<li>读取数据进内存，并实施运算，这是电子化的过程，相当快。</li>
</ol>
<p>总的来说，<strong>B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树</strong>(相对于二叉，B树每个内节点有多个分支)，<strong>与红黑树相比，在相同的的节点的情况下，一颗B/B+树的高度远远小于红黑树的高度</strong>(在下面B/B+树的性能分析中会提到)。<strong>B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成</strong>，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，<strong>在关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少</strong>。而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。</p>
<h3 id="5-2-B-树结构"><a href="#5-2-B-树结构" class="headerlink" title="5.2 B-树结构"></a>5.2 B-树结构</h3><p>B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p>
<p>B树的结构要求：<br><strong>1）根节点至少有两个子节点</strong><br><strong>2）每个节点有M-1个key，并且以升序排列</strong><br><strong>3）位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</strong><br><strong>4）其它节点至少有M/2个子节点</strong> [M/2,M-1]<br><strong>5）所有叶子节点都在同一层</strong><br><img src="http://img.blog.csdn.net/20161117122843822" alt="这里写图片描述"> </p>
<p><strong>B树高度</strong></p>
<p>对于一个包含n个关键字，最小度数t≥2t≥2 的B树，其高度hh 一定满足：</p>
<script type="math/tex; mode=display">h \leq \log_{t}{\frac{n + 1}{2}}</script><p>在搜索B树时，很明显，访问节点（即读取磁盘）的次数与树的高度呈正比，而B树与红黑树和普通的二叉查找树相比，虽然高度都是对数数量级，但是显然B树中log函数的底可以比2更大，因此，和二叉树相比，极大地减少了磁盘读取的次数。</p>
<h3 id="5-3-B-树操作"><a href="#5-3-B-树操作" class="headerlink" title="5.3 B-树操作"></a>5.3 B-树操作</h3><ol>
<li><p><strong>查找</strong></p>
<p>一棵已经建立好的B树如下图所示，我们的目的是查找关键字为29的文件：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-14-53-26.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-14-53-26.png" alt="img"></a></p>
<p>先简单说明一下上图：</p>
<ul>
<li>图中小红方块表示对应关键字锁代表的文件存储位置。实际上可以看做一个地址。比如根节点17旁边的小红块表示关键字17所对应的文件在硬盘中的存储地址。</li>
<li>P是指针。需要注意的是：指针 + 关键字 + 小红块 这三个东西合起来构成了一个B树的节点。这个节点存储在一个磁盘块上。</li>
</ul>
<p>下面看看搜索关键字29的文件的过程：</p>
<ol>
<li>从根节点开始，读取根节点信息，根节点有2个关键字：17和35。因为17 &lt; 29 &lt; 35，所以找到指针P2指向的子树，也就是磁盘块3（1次I/0操作）</li>
<li>读取当前节点信息，当前节点有2个关键字：26和30。26 &lt; 29 &lt; 30，找到指针P2指向的子树，也就是磁盘块8（2次I/0操作）</li>
<li>读取当前节点信息，当前节点有2个关键字：28和29。找到了！（3次I/0操作）</li>
</ol>
<p>由上面的过程可见，同样的操作，如果使用平衡二叉树，那么需要至少4次I/O操作，B树比之二叉树的这种优势，还会随着节点数的增加而增加。另外，因为B树节点中的关键字都是排序好的，所以，在节点中的信息被读入内存之后，可以采用二分查找这种快速的查找方式，更进一步减少了读入内存之后的计算时间，由此更能说明对于外存数据结构来说，I/O次数是其查找信息中最大的时间消耗，而我们要做的所有努力就是尽量在搜索过程中减少I/O操作的次数。</p>
</li>
<li><p><strong>插入</strong></p>
<p>​    向B树种插入关键字的过程与向二叉查找树中插入关键字的过程类似，但是要稍微复杂一点，因为根据上面B树的定义，我们可以看出，B树每个节点中关键字的个数是有范围要求的，同时，B树是平衡的，所以，如果像二叉查找树那样，直接找到相关的叶子，插入关键字，有可能会导致B树的结构发生变化而这种变化会使得B树不再是B树。</p>
<p>​    所以，我们这样来设计B树种对新关键字的插入：首先找到要插入的关键字应该插入的叶子节点（为方便描述，设这个叶子节点为u），如果u是满的（恰好有2t−1个关键字），那么由于不能将一个关键字插入满的节点，我们需要对u按其当前<strong>排在中间关键字</strong><script type="math/tex">u.key_t</script>进行分裂，<strong>分裂</strong>成两个节点u1,u2；同时，作为分裂标准的关键字<script type="math/tex">u.key_t</script>被<strong>上移到u的父节点中</strong>，在<script type="math/tex">u.key_t</script>插入前，如果u的父节点未满，则直接插入即可；如果u的父节点已满，则按照上面的方法对u的父节点分裂，这个过程如果一直不停止的话，最终会导致B树的根节点分裂，B树的高度增加一层。</p>
<p>​    下面用《算法导论》中的一个题目展示一下这种插入关键字的过程。</p>
<p>现在我们要将关键字序列：F, S, Q, K, C, L, H, T, V, W, M, R, N, P, A, B, X, Y依次插入一棵最小度为2的B树中。也就是说，这棵树的节点中，最多有3个关键字，最少有1个关键字。</p>
<p><strong>第1步</strong>，F, S, Q可以被插入一个节点（也就是根节点）</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-28.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-28.png" alt="img"></a></p>
<p><strong>第2步</strong>，插入关键字K，因为节点已满，所以在插入前，发生分裂，中间关键字Q上移，建立了一个新的根节点：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-42.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-42.png" alt="img"></a></p>
<p><strong>第3步</strong>，插入关键字C:</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-55.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-55.png" alt="img"></a></p>
<p><strong>第4步</strong>，插入关键字L，L应该被插入到根节点的左侧的孩子中，因为此时该节点已满，所以在插入前，发生分裂：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-12.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-12.png" alt="img"></a></p>
<p><strong>第5步</strong>，插入关键字H, T, V，这个过程没有发生节点的分裂：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-26.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-26.png" alt="img"></a></p>
<p><strong>第6步</strong>，插入关键字W，W应该被插入到根节点的最右侧的孩子中，因为此时该节点已满，所以在插入前，关键字T上移，最右端的叶子节点发生分裂：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-03-33.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-03-33.png" alt="img"></a></p>
<p><strong>第7步</strong>，插入关键字M，M应该被插入到根节点的左起第2个孩子中，因为此时该节点已满，所以在插入前，发生分裂，分裂之后，中间关键字K上移，导致根节点发生分裂，树高增加1：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-27.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-27.png" alt="img"></a></p>
<p>第8步，同样的道理，插入关键字R, N, P, A, B, X, Y：最终得到的B树如下：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-41.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-41.png" alt="img"></a></p>
</li>
<li><p><strong>删除</strong></p>
<p>​    删除操作的基本思想和插入操作是一样的，都是不能因为关键字的改变而改变B树的结构。<strong>插入操作主要防止的是某个节点中关键字的个数太多，所以采用了分裂；删除则是要防止某个节点中，因删除了关键字而导致这个节点的关键字个数太少，所以采用了合并操作。</strong></p>
<p>下面分三种情况来讨论下删除操作是如何工作的，这个过程的顺序是自根节点起向下遍历B树</p>
<p><strong>Case - 1：</strong>如果要删除的关键字k在节点u中，而且u是<strong>叶子节点</strong>，那么直接删除k</p>
<p><strong>Case - 2：</strong>如果要删除的关键字k在节点u中，而且u是<strong>内部节点</strong>。由于关键字影响着子树的范围，因此不能随意删除。必须<strong>从子树中找到一个合适的数字来替代k</strong>才可以。需要分以下3种情况讨论：</p>
<p>(1) 如果u中前于k的子节点u1中至少含有t个关键字，则找出k在以u1为根的子树中的前驱k′（前驱的意思是u1中比k小的关键字中最大的），然后在以u1为根的子树中删除k′，并在u中以k′替代k</p>
<p>(2) 如果上面的条件(1)不成立，也就是说，前于k的子节点中关键字的个数小于t了，那么就去找后于k的子节点，记为u2。若u2中至少含有t个关键字，则找出k在以u2为根的子树中的后继k′(大于k的关键字中最小的)，然后在以u2为根的子树中删除k′，并在u中以k′替代k。可以看出（2）是（1）的一个对称过程</p>
<p>(3) 如果u1,u2中的关键字个数都是t−1，则将k和u2合并后并入u1，这样u就失去了k和指向u2的指针，最后递归地从u1中删除k</p>
<p><strong>Case - 3：</strong>如果要删除的关键字k不在当前节点u中，而且u是内部节点（如果自上而下扫描到叶子都没有这个关键字的话，那就说明要删除的关键字根本就不存在，所以此处只考虑u是内部节点的情况），则首先确定包含k的u的子树，我们这里设为u.pi。如果u.pi中至少含有t个关键字，那么继续扫描，寻找下一个要被扫描的子树；如果u.pi中只含有t−1个关键字，则需要分下面两种情况进行操作：</p>
<p>(1) 如果u.pi至少有一个相邻的兄弟比较“丰满”（即这个兄弟至少有t个关键字）。则将u中的一个关键字降至u.pi，同时令u.pi的最“丰满”的兄弟中升一个关键至u。然后继续扫描B树，寻找k</p>
<p>(2) 如果u.pi的两个相邻的兄弟都不“丰满”（都只有t−1个关键字）。则令u.pi和其一个兄弟合并，再将u的一个关键字降至新合并的节点。使之成为该节点的中间关键字。</p>
<p>举个例子</p>
<p>1、初始状态<br><img src="http://img.blog.csdn.net/20160915145726227" alt="这里写图片描述"></p>
<p>2、删除元素H<br>首先查找H，H在一个叶子结点中，且该叶子结点元素数目3 &gt; 2<br>移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）<br><img src="http://img.blog.csdn.net/20160915150104895" alt="这里写图片描述"></p>
<p>3、删除T<br>在中间结点中找到T，此时删了T后该节点关键字个数 1 &lt; 2<br>将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该叶子结点中元素个数 &gt; 2，无需进行合并操作<br><img src="http://img.blog.csdn.net/20160915150446557" alt="这里写图片描述"></p>
<p>4、删除R<br>R所在叶子结点中元素数目为2，删除导致只有1个元素</p>
<blockquote>
<p>如果其某个相邻兄弟结点中比较丰满（元素个数 &gt; [M/2] - 1），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中</p>
</blockquote>
<p>在这个实例中，右相邻兄弟结点中比较丰满（3 &gt; 2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。<br><img src="http://img.blog.csdn.net/20160915150946108" alt="这里写图片描述"></p>
<p>5、删除E<br>删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（[M/2] - 1），而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件<br>所以需要该节点与某相邻兄弟结点进行合并操作：</p>
<blockquote>
<p>首先，移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中；<br>然后将这两个结点进行合并成一个结点。</p>
</blockquote>
<p>即，将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点。<br><img src="http://img.blog.csdn.net/20160915152043269" alt="这里写图片描述"><br>此时G所在节点只有一个元素，不行。<br>此时该结点的相邻兄弟又不丰满，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，这样，树的高度减少一层。<br><img src="http://img.blog.csdn.net/20160915152349100" alt="这里写图片描述"></p>
</li>
</ol>
<h2 id="6-B-树"><a href="#6-B-树" class="headerlink" title="6. B+树"></a>6. B+树</h2><p>​    B+树是B树的一种变形，<strong>它更适合实际应用中操作系统的文件索引和数据库索引</strong>。定义如下：（为和大多资料保持一致，这里使用阶数m来定义B+树，而不像之前的B树中，使用的是最小度t来定义）</p>
<ol>
<li>每个内部节点的关键字个数为[m/2,m] 个。其中每个关键字对应一个子树；</li>
<li>根节点要么没有子树，要么至少有2颗子树</li>
<li>叶子节点包含了全部的关键字以及关键字指向文件的指针，且：<ol>
<li>所有叶子节点中的关键字按大小顺序排列</li>
<li>相邻的叶子节点顺序链接（相当于是构成了一个顺序链表）</li>
<li>所有叶子节点在同一层</li>
</ol>
</li>
<li>所有分支节点的关键字都是对应子树中关键字的最大值</li>
</ol>
<p>比如，下图就是一个非常典型的B+树的例子。</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-31-31.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-31-31.png" alt="img"></a></p>
<p>B+树和B树相比，主要的不同点在以下3项：</p>
<ul>
<li>内部节点中，关键字的个数与其子树的个数相同，不像B树中，子树的个数总比关键字个数多1个</li>
<li>所有指向文件的关键字及其指针都在叶子节点中，不像B树，有的指向文件的关键字是在内部节点中。换句话说，B+树中，内部节点仅仅起到索引的作用</li>
<li>在搜索过程中，如果查询和内部节点的关键字一致，那么搜索过程不停止，而是继续向下搜索这个分支</li>
</ul>
<h2 id="6-R树"><a href="#6-R树" class="headerlink" title="6. R树"></a>6. R树</h2><h3 id="6-1-R树的结构"><a href="#6-1-R树的结构" class="headerlink" title="6.1 R树的结构"></a>6.1 R树的结构</h3><p>​    R树是B树在<strong>高维</strong>空间的扩展，是一棵<strong>平衡树</strong>。每个R树的叶子结点包含了多个指向不同数据的指针，这些数据可以是存放在硬盘中的，也可以是存在内存中。根据R树的这种数据结构，当我们需要进行一个高维空间查询时，我们只需要遍历少数几个叶子结点所包含的指针，查看这些指针指向的数据是否满足要求即可。这种方式使我们不必遍历所有数据即可获得答案，效率显著提高。下图1是R树的一个简单实例：</p>
<p><img src="https://images2015.cnblogs.com/blog/1051369/201704/1051369-20170404131434878-399064987.jpg" alt="img"></p>
<p>在R树中存放的数据并不是原始数据，而是这些数据的<strong>最小边界矩形（MBR</strong>），空间对象的MBR被包含于R树的叶结点中。</p>
<p>R树满足如下的性质：</p>
<p>1)       根结点至少有两个子结点，除非它同时是叶子结点</p>
<p>2)       每一个叶子结点包含 m至M个索引项记录，通常， m=M/2。</p>
<p>3)       每一个非叶子节点拥有m至M个子节点，除非它是跟节点。</p>
<p>4)       所有叶子节点都位于同一层。</p>
<p>支持搜索、增加、删除等操作，可以自定义矩形的最大子节点数。</p>
<p>更详细的内容可以参考<a href="http://www.cnblogs.com/cmi-sh-love/p/kong-jian-shud-ju-suo-yinRTree-wan-quan-jie-xi-jiJa.html" target="_blank" rel="external">空间数据索引RTree（R树）完全解析及Java实现</a></p>
<h2 id="7-对比"><a href="#7-对比" class="headerlink" title="7. 对比"></a>7. 对比</h2><h3 id="7-1-B树和B-树的区别"><a href="#7-1-B树和B-树的区别" class="headerlink" title="7.1 B树和B+树的区别"></a>7.1 B树和B+树的区别</h3><p>​    B/B+树用在磁盘文件组织、数据索引和数据库索引中。其中B+树比B 树更适合实际应用中操作系统的文件索引和数据库索引，因为：<br><strong>1、B+树的磁盘读写代价更低</strong><br>B+树的内部结点并没有指向关键字具体信息的指针。因此其<strong>内部结点</strong>相对B 树<strong>更小</strong>。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
<blockquote>
<p>举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。</p>
</blockquote>
<p><strong>2、B+-tree的查询效率更加稳定</strong><br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的<strong>路径长度相同</strong>，导致每一个数据的查询效率相当。</p>
<p>3、<strong>B树在元素遍历的时候效率较低</strong> </p>
<p>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库<strong>，只需要扫一遍叶子结点即可</strong>，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。在数据库中基于范围的查询相对频繁，所以此时B+树优于B树。</p>
<h3 id="7-2-红黑树与B树区别"><a href="#7-2-红黑树与B树区别" class="headerlink" title="7.2 红黑树与B树区别"></a>7.2 红黑树与B树区别</h3><p>  一言而知就是树的深度较高，在磁盘I/O方面的表现不如B树。<br>  要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定。<br>  所以，在大规模数据存储的时候，<strong>红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁</strong>，进而导致效率低下。在这方面，B树表现相对优异，B树可以有多个子女，从几十到上千，可以降低树的高度。</p>
<h3 id="7-3-AVL树和红黑树"><a href="#7-3-AVL树和红黑树" class="headerlink" title="7.3 AVL树和红黑树"></a>7.3 AVL树和红黑树</h3><p>红黑树的算法时间复杂度和AVL相同，但<strong>统计性能</strong>比AVL树更高。</p>
<blockquote>
<p>1、红黑树和AVL树都能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。<br>2、由于设计，红黑树的任何不平衡都会在三次旋转之内解决。AVL树增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>
</blockquote>
<p>在<strong>查找</strong>方面：<br>  红黑树的性质(最长路径长度不超过最短路径长度的2倍)，其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点。<br>  AVL是严格平衡的二叉查找树（平衡因子不超过1）。查找过程中不会出现最差情况的单支树。因此查找效率最好，最坏情况都是O(logN)数量级的。</p>
<p>所以，综上：<br>  AVL比RBtree更加平衡，但是AVL的插入和删除会带来大量的旋转。 所以如果<strong>插入和删除比较多</strong>的情况，应该使用<strong>RBtree</strong>, 如果<strong>查询操作比较多</strong>，应该使用<strong>AVL</strong>。</p>
<blockquote>
<p>AVL是一种高度平衡的二叉树，维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果场景中对插入删除不频繁，只是对查找特别有要求，AVL还是优于红黑的。</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://blog.csdn.net/u010899985/article/details/79468080" target="_blank" rel="external">为什么MySQL数据库索引选择使用B+树</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[过拟合、欠拟合及其解决办法]]></title>
      <url>/2018/03/08/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E8%BF%87%E6%8B%9F%E5%90%88%E3%80%81%E6%AC%A0%E6%8B%9F%E5%90%88%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="1-过拟合与欠拟合"><a href="#1-过拟合与欠拟合" class="headerlink" title="1. 过拟合与欠拟合"></a>1. 过拟合与欠拟合</h2><p>​    <strong>机器学习中一个重要的话题便是模型的泛化能力，泛化能力强的模型才是好模型</strong>.</p>
<p>​    对于训练好的模型，若在训练集表现差，不必说在测试集表现同样会很差，这可能是欠拟合导致；若模型在训练集表现非常好，却在测试集上差强人意，则这便是过拟合导致的.</p>
<p>​    过拟合与欠拟合也可以用 Bias 与 Variance （偏差和方差）的角度来解释，<strong>欠拟合会导致高 Bias ，过拟合会导致高 Variance ，所以模型需要在 Bias 与 Variance 之间做出一个权衡。</strong></p>
<p>​    使用简单的模型去拟合复杂数据时，会导致模型很难拟合数据的真实分布，这时模型便欠拟合了，或者说有很大的 Bias，<strong>Bias 即为模型的期望输出与其真实输出之间的差异</strong>；有时为了得到比较精确的模型而过度拟合训练数据，或者模型复杂度过高时，可能连训练数据的噪音也拟合了，导致模型在训练集上效果非常好，但泛化性能却很差，这时模型便过拟合了，或者说有很大的 Variance，这时模型在不同训练集上得到的模型波动比较大，<strong>Variance 刻画了不同训练集得到的模型的输出与这些模型期望输出的差异</strong>。</p>
<p><img src="https://pic3.zhimg.com/80/v2-7b5523e2f3ef416698cfecaebc73df36_hd.jpg" alt="img"></p>
<h2 id="2-常用解决办法"><a href="#2-常用解决办法" class="headerlink" title="2. 常用解决办法"></a>2. 常用解决办法</h2><p><strong>(1)解决欠拟合的方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1、增加新特征，可以考虑加入进特征组合、高次特征，来增大假设空间;</div><div class="line">2、尝试非线性模型，比如核SVM 、决策树、DNN等模型;</div><div class="line">3、如果有正则项可以较小正则项参数 $\lambda$;</div><div class="line">4、Boosting ,Boosting 往往会有较小的 Bias，比如 Gradient Boosting 等.</div></pre></td></tr></table></figure>
<p><strong>(2)解决过拟合的方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1、交叉检验，通过交叉检验得到较优的模型参数;</div><div class="line">2、early stop</div><div class="line">3、特征选择，减少特征数或使用较少的特征组合，对于按区间离散化的特征，增大划分的区间;</div><div class="line">4、正则化，常用的有 L1、L2 正则。而且 L1正则还可以自动进行特征选择;</div><div class="line">5、如果有正则项则可以考虑增大正则项参数 lambda;</div><div class="line">6、增加训练数据可以有限的避免过拟合;</div><div class="line">7、Bagging,将多个弱学习器Bagging 一下效果会好很多，比如随机森林等.</div></pre></td></tr></table></figure>
<p><strong>（3）DNN中常见的方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1、早停策略。本质上是交叉验证策略，选择合适的训练次数，避免训练的网络过度拟合训练数据。</div><div class="line">2、集成学习策略。而DNN可以用Bagging的思路来正则化。首先我们要对原始的m个训练样本进行有放回随机采样，构建N组m个样本的数据集，然后分别用这N组数据集去训练我们的DNN。即采用我们的前向传播算法和反向传播算法得到N个DNN模型的W,b参数组合，最后对N个DNN模型的输出用加权平均法或者投票法决定最终输出。不过用集成学习Bagging的方法有一个问题，就是我们的DNN模型本来就比较复杂，参数很多。现在又变成了N个DNN模型，这样参数又增加了N倍，从而导致训练这样的网络要花更加多的时间和空间。因此一般N的个数不能太多，比如5-10个就可以了。</div><div class="line">3、DropOut策略。所谓的Dropout指的是在用前向传播算法和反向传播算法训练DNN模型时，一批数据迭代时，随机的从全连接DNN网络中去掉一部分隐藏层的神经元。　在对训练集中的一批数据进行训练时，我们随机去掉一部分隐藏层的神经元，并用去掉隐藏层的神经元的网络来拟合我们的一批训练数据。使用基于dropout的正则化比基于bagging的正则化简单，这显而易见，当然天下没有免费的午餐，由于dropout会将原始数据分批迭代，因此原始数据集最好较大，否则模型可能会欠拟合。</div></pre></td></tr></table></figure>
<h2 id="3-L1和L2正则化方法"><a href="#3-L1和L2正则化方法" class="headerlink" title="3. L1和L2正则化方法"></a>3. L1和L2正则化方法</h2><p><strong>目的：防止过拟合，提高泛化能力</strong></p>
<p>选择经验误差与结构化风险（模型复杂度）同时小的模型。</p>
<h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>给定数据集<script type="math/tex">D={(x_1,y_1),(x_2,y_2),…(x_m,y_m)}</script>,其中<script type="math/tex">x\in R^d,y\in R</script>.</p>
<p>考虑最简单的线性回归，以平方误差为损失函数，则优化目标为：</p>
<script type="math/tex; mode=display">min_w\sum_{i=1}^m(y_i-w^Tx_i)^2</script><p>当样本特征很多，而样本数较少时，上式很容易陷入过拟合。解决方案，正则化项。</p>
<p><strong><script type="math/tex">L2</script>范数正则化（“岭回归”(redge regression)）：</strong></p>
<script type="math/tex; mode=display">min_w\sum_{i=1}^m(y_i-w^Tx_i)^2+\lambda ||w||_2^2</script><p><strong><script type="math/tex">L1</script>范数正则化：</strong></p>
<script type="math/tex; mode=display">min_w\sum_{i=1}^m(y_i-w^Tx_i)^2+\lambda ||w||_1</script><h3 id="3-2-L1和L2的异同"><a href="#3-2-L1和L2的异同" class="headerlink" title="3.2 L1和L2的异同"></a>3.2 L1和L2的异同</h3><p>相同点：都用于避免过拟合</p>
<p>不同点：</p>
<ol>
<li>L1可以让一部分特征的系数缩小到0，从而间接实现<strong>特征选择</strong>。所以L1适用于特征之间有关联的情况。</li>
<li>L2让所有特征的系数都缩小，但是不会减为0，它会使<strong>优化求解稳定快速</strong>。所以L2适用于特征之间没有关联的情况</li>
</ol>
<p>总结一下就是 <strong>L1正则化产生稀疏的权值, L2正则化产生平滑的权值</strong>。为什么会这样？这里面的本质原因是什么呢？下面我们从两个角度来解释这个问题。</p>
<h4 id="角度1：数学公式"><a href="#角度1：数学公式" class="headerlink" title="角度1：数学公式"></a>角度1：数学公式</h4><p><strong>L1 regularization:</strong></p>
<p>在原始的代价函数后面加上一个L1正则化项，即所有权重w的绝对值的和，乘以λ/n（这里不像L2正则化项那样，需要再乘以1/2，具体原因上面已经说过。）</p>
<p><img src="http://i.imgur.com/6jbxq15.jpg" alt="img"></p>
<p>同样先计算导数：</p>
<p><img src="http://i.imgur.com/kju5RTZ.jpg" alt="img"></p>
<p>上式中sgn(w)表示w的符号。那么权重w的更新规则为：</p>
<p><img src="http://i.imgur.com/HCkJZYl.jpg" alt="img"></p>
<p>比原始的更新规则多出了η <em> λ </em> sgn(w)/n这一项。当w为正时，更新后的w变小。当w为负时，更新后的w变大——因此它的效果就是让w往0靠，使网络中的权重尽可能为0，也就相当于减小了网络复杂度，防止过拟合。</p>
<p>另外，上面没有提到一个问题，当w为0时怎么办？当w等于0时，|W|是不可导的，所以我们只能按照原始的未经正则化的方法去更新w，这就相当于去掉η<em>λ</em>sgn(w)/n这一项，所以我们可以规定sgn(0)=0，这样就把w=0的情况也统一进来了。（在编程的时候，令sgn(0)=0,sgn(w&gt;0)=1,sgn(w&lt;0)=-1）</p>
<p><strong>L2 regularization（权重衰减）</strong>:</p>
<p>L2正则化就是在代价函数后面再加上一个正则化项：</p>
<p><img src="http://i.imgur.com/9WnBBu1.jpg" alt="img"></p>
<p>C0代表原始的代价函数，后面那一项就是L2正则化项，它是这样来的：所有参数w的平方的和，除以训练集的样本大小n。λ就是正则项系数，权衡正则项与C0项的比重。另外还有一个系数1/2，1/2经常会看到，主要是为了后面求导的结果方便，后面那一项求导会产生一个2，与1/2相乘刚好凑整。</p>
<p>L2正则化项是怎么避免overfitting的呢？我们推导一下看看，先求导：</p>
<p><img src="http://i.imgur.com/mebEC90.jpg" alt="img"></p>
<p>可以发现L2正则化项对b的更新没有影响，但是对于w的更新有影响:</p>
<p><img src="http://i.imgur.com/qM83geg.jpg" alt="img"></p>
<p>在不使用L2正则化时，求导结果中w前系数为1，现在w前面系数为 1−ηλ/n ，因为η、λ、n都是正的，所以 1−ηλ/n小于1，它的效果是减小w，这也就是权重衰减（weight decay）的由来。当然考虑到后面的导数项，w最终的值可能增大也可能减小。</p>
<p>另外，需要提一下，对于基于mini-batch的随机梯度下降，w和b更新的公式跟上面给出的有点不同：</p>
<p><img src="http://i.imgur.com/Xs2p2EN.jpg" alt="img"></p>
<p><img src="http://i.imgur.com/yDETU7x.jpg" alt="img"></p>
<p>对比上面w的更新公式，可以发现后面那一项变了，变成所有导数加和，乘以η再除以m，m是一个mini-batch中样本的个数。</p>
<p>到目前为止，我们只是解释了L2正则化项有让w“变小”的效果，但是还没解释为什么w“变小”可以防止overfitting？一个所谓“显而易见”的解释就是：更小的权值w，从某种意义上说，表示网络的复杂度更低，对数据的拟合刚刚好（这个法则也叫做奥卡姆剃刀），而在实际应用中，也验证了这一点，L2正则化的效果往往好于未经正则化的效果。</p>
<h4 id="角度2：几何空间"><a href="#角度2：几何空间" class="headerlink" title="角度2：几何空间"></a>角度2：几何空间</h4><p>（西瓜书-253页的解释） </p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-08-23-02-04.png" alt=""></p>
<p>​    简化到2维的情形，如上图所示。其中，左边是L1图示，右边是L2图示，左边的方形线上是L1中w1/w2取值区间，右边得圆形线上是L2中w1/w2的取值区间，绿色的圆圈表示w1/w2取不同值时整个正则化项的值的等高线（凸函数），从等高线和w1/w2取值区间的交点可以看到，L1中两个权值倾向于一个较大另一个为0，L2中两个权值倾向于均为非零的较小数。这也就是L1稀疏，L2平滑的效果。</p>
<h2 id="4-bagging-and-boosting"><a href="#4-bagging-and-boosting" class="headerlink" title="4. bagging  and boosting"></a>4. bagging  and boosting</h2><h3 id="4-1-bootstrap采样"><a href="#4-1-bootstrap采样" class="headerlink" title="4.1 bootstrap采样"></a>4.1 bootstrap采样</h3><p>​    名字来自成语“pull up by your own bootstraps”，意思是依靠你自己的资源，称为自助法，它是一种有放回的抽样方法，它是非参数统计中一种重要的估计统计量方差进而进行区间估计的统计方法。其核心思想和基本步骤如下：<br>　　（1） 采用重抽样技术从原始样本中抽取一定数量（自己给定）的样本，此过程允许重复抽样。<br>　　（2） 根据抽出的样本计算给定的统计量T。<br>　　（3） 重复上述N次（一般大于1000），得到N个统计量T。<br>　　（4） 计算上述N个统计量T的样本方差，得到统计量的方差。<br>　　应该说Bootstrap是现代统计学较为流行的一种统计方法，在小样本时效果很好。通过方差的估计可以构造置信区间等，其运用范围得到进一步延伸。</p>
<h3 id="4-2-bagging-bootstrap-aggregating"><a href="#4-2-bagging-bootstrap-aggregating" class="headerlink" title="4.2 bagging (bootstrap aggregating)"></a>4.2 bagging (bootstrap aggregating)</h3><p>Bagging即套袋法，其算法过程如下：</p>
<p>A）从原始样本集中抽取训练集。每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）。共进行k轮抽取，得到k个训练集。（k个训练集之间是相互独立的）</p>
<p>B）每次使用一个训练集得到一个模型，k个训练集共得到k个模型。（注：这里并没有具体的分类算法或回归方法，我们可以根据具体问题采用不同的分类或回归方法，如决策树、感知器等）</p>
<p>C）对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果。（所有模型的重要性相同）</p>
<h3 id="4-3-boosting"><a href="#4-3-boosting" class="headerlink" title="4.3 boosting"></a>4.3 boosting</h3><p>其主要思想是将弱分类器组装成一个强分类器。在PAC（概率近似正确）学习框架下，则一定可以将弱分类器组装成一个强分类器。</p>
<p>关于Boosting的两个核心问题：</p>
<p>1）在每一轮如何改变训练数据的权值或概率分布？</p>
<p>通过提高那些在前一轮被弱分类器分错样例的权值，减小前一轮分对样例的权值，来使得分类器对误分的数据有较好的效果。</p>
<p>2）通过什么方式来组合弱分类器？</p>
<p>通过加法模型将弱分类器进行线性组合，比如AdaBoost通过加权多数表决的方式，即增大错误率小的分类器的权值，同时减小错误率较大的分类器的权值。</p>
<p>而提升树通过拟合残差的方式逐步减小残差，将每一步生成的模型叠加得到最终模型。</p>
<h3 id="4-4-Bagging，Boosting二者之间的区别"><a href="#4-4-Bagging，Boosting二者之间的区别" class="headerlink" title="4.4 Bagging，Boosting二者之间的区别"></a>4.4 Bagging，Boosting二者之间的区别</h3><p>Bagging和Boosting的区别：</p>
<p>1）样本选择上：</p>
<p>Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。</p>
<p>Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。</p>
<p>2）样例权重：</p>
<p>Bagging：使用均匀取样，每个样例的权重相等</p>
<p>Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。</p>
<p>3）预测函数：</p>
<p>Bagging：所有预测函数的权重相等。</p>
<p>Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。</p>
<p>4）并行计算：</p>
<p>Bagging：各个预测函数可以并行生成</p>
<p>Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。</p>
<p>3)方差和偏差：</p>
<p>Bagging：偏差不变，方差变小，解决过拟合</p>
<p>Boosting：偏差变小，解决欠拟合</p>
<p>这两种方法都是把若干个分类器整合为一个分类器的方法，只是整合的方式不一样，最终得到不一样的效果，将不同的分类算法套入到此类算法框架中一定程度上会提高了原单一分类器的分类效果，但是也增大了计算量。</p>
<p>下面是将决策树与这些算法框架进行结合所得到的新的算法：</p>
<p>1）Bagging + 决策树 = 随机森林</p>
<p>2）AdaBoost + 决策树 = 提升树</p>
<p>3）Gradient Boosting + 决策树 = GBDT</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/29707029" target="_blank" rel="external">机器学习防止欠拟合、过拟合方法</a></p>
<p><a href="http://blog.csdn.net/u012162613/article/details/44261657" target="_blank" rel="external">正则化方法：L1和L2 regularization、数据集扩增、dropout</a></p>
<p><a href="https://vimsky.com/article/969.html" target="_blank" rel="external">为什么L1稀疏，L2平滑？</a></p>
<p><a href="https://www.jianshu.com/p/cb0ad5939629" target="_blank" rel="external">Bagging和Boosting 概念及区别</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【本站目录】]]></title>
      <url>/2018/03/08/%E3%80%90%E6%9C%AC%E7%AB%99%E7%9B%AE%E5%BD%95%E3%80%91/</url>
      <content type="html"><![CDATA[<p>文章渐渐多了起来，为了方面复习和查找，对本站文章做个目录~</p>
<h1 id="1-算法与数据结构"><a href="#1-算法与数据结构" class="headerlink" title="1. 算法与数据结构"></a>1. 算法与数据结构</h1><h3 id="1-1-排序算法"><a href="#1-1-排序算法" class="headerlink" title="1.1 排序算法"></a>1.1 排序算法</h3><ul>
<li><a href="/2018/02/08/【排序】计数排序、基数排序、桶排序/" title="计数排序、基数排序、桶排序">计数排序、基数排序、桶排序</a>，三种非比较排序，理想情况下时间复杂度可以降到<script type="math/tex">O(n)</script></li>
<li><a href="/2017/07/23/【排序】归并排序/" title="归并排序">归并排序</a></li>
<li><a href="/2017/07/22/【排序】选择排序/" title="选择排序">选择排序</a></li>
<li><a href="/2017/07/20/【排序】冒泡排序/" title="冒泡排序">冒泡排序</a></li>
<li><a href="/2017/07/17/【排序】快速排序/" title="快速排序">快速排序</a></li>
<li><a href="/2018/01/31/【排序】堆排序/" title="堆排序">堆排序</a></li>
<li><a href="/2017/07/22/【排序】希尔排序/" title="希尔排序">希尔排序</a></li>
<li><a href="/2018/03/10/【排序】排序算法终极大总结/" title="排序算法终极大总结">排序算法终极大总结</a> 
</li>
</ul>
<h3 id="1-3-数与数组"><a href="#1-3-数与数组" class="headerlink" title="1.3 数与数组"></a>1.3 数与数组</h3><ul>
<li><a href="/2017/12/07/【九章算法基础班】二分法/" title="【九章算法基础班】二分法">【九章算法基础班】二分法</a></li>
<li><a href="/2017/12/24/【九章算法基础班】数与数组/" title="【九章算法基础班】数与数组">【九章算法基础班】数与数组</a></li>
<li><a href="/2018/02/02/【九章算法强化班】两指针/" title="【九章算法强化班】两指针">【九章算法强化班】两指针</a> 包含<strong>partition、quickSelect</strong></li>
<li><a href="/2017/11/17/【九章算法强化班】扫描线/" title="【九章算法强化班】课程笔记2——扫描线">【九章算法强化班】课程笔记2——扫描线</a>
</li>
</ul>
<h3 id="1-2-动态规划"><a href="#1-2-动态规划" class="headerlink" title="1.2 动态规划"></a>1.2 动态规划</h3><ul>
<li><a href="/2017/11/18/【九章算法基础班】动态规划/" title="【九章算法基础班】动态规划">【九章算法基础班】动态规划</a>动态规划四要素，两类常见的动态规划：坐标型动态规划、序列型动态规划</li>
<li><a href="/2018/03/08/【九章算法强化班】动态规划/" title="【九章算法强化班】动态规划">【九章算法强化班】动态规划</a>包括DP的滚动数组优化、记忆化搜索、博弈类DP、区间型DP、背包DP</li>
<li><a href="/2017/10/31/【算法导论】钢条切割/" title="【算法导论】动态规划（一）钢条切割">【算法导论】动态规划（一）钢条切割</a></li>
<li><a href="/2017/11/01/【算法导论】矩阵链乘法/" title="【算法导论】动态规划（二）矩阵链乘法">【算法导论】动态规划（二）矩阵链乘法</a>
</li>
</ul>
<h3 id="1-3-链表"><a href="#1-3-链表" class="headerlink" title="1.3 链表"></a>1.3 链表</h3><ul>
<li><a href="/2017/12/11/【九章算法基础班】链表/" title="【九章算法基础班】课程笔记——链表">【九章算法基础班】课程笔记——链表</a>
</li>
</ul>
<h3 id="1-4-树模块"><a href="#1-4-树模块" class="headerlink" title="1.4 树模块"></a>1.4 树模块</h3><ul>
<li><a href="/2017/11/29/【九章算法基础班】二叉树与分治法/" title="【九章算法基础班】二叉树与分治法">【九章算法基础班】二叉树与分治法</a></li>
<li><a href="/2018/02/08/【数据结构】线段树/" title="【leetcode】线段树">【leetcode】线段树</a></li>
<li><a href="/2017/11/14/【九章算法强化班】Trie树/" title="【九章算法强化班】课程笔记2——Trie树">【九章算法强化班】课程笔记2——Trie树</a></li>
<li><a href="/2018/03/09/B树、B-树、AVL树、Trie树及其应用场景/" title="B树、B+树、AVL树、Trie树及其应用场景">B树、B+树、AVL树、Trie树及其应用场景</a>
</li>
</ul>
<ul>
<li>​</li>
</ul>
<h3 id="1-5-图模块"><a href="#1-5-图模块" class="headerlink" title="1.5 图模块"></a>1.5 图模块</h3><ul>
<li><a href="/2018/01/23/【九章算法基础班】图与搜索/" title="【九章算法基础班】图与搜索">【九章算法基础班】图与搜索</a>主要是BFS、DFS</li>
<li><a href="/2017/11/04/【算法】回溯法/" title="回溯法、【leetcode】51.52 N-Queens">回溯法、【leetcode】51.52 N-Queens</a></li>
<li><a href="/2017/11/05/【九章算法强化班】并查集/" title="【九章算法强化班】课程笔记2——并查集">【九章算法强化班】课程笔记2——并查集</a>
</li>
</ul>
<h3 id="1-6-hash表、堆、栈、队列、Trie树、并查集"><a href="#1-6-hash表、堆、栈、队列、Trie树、并查集" class="headerlink" title="1.6 hash表、堆、栈、队列、Trie树、并查集"></a>1.6 hash表、堆、栈、队列、Trie树、并查集</h3><ul>
<li><a href="/2018/01/19/【九章算法基础班】数据结构/" title="【九章算法基础班】数据结构">【九章算法基础班】数据结构</a>主要是hash表、堆、栈</li>
<li><a href="/2017/11/18/【九章算法强化班】堆Heap/" title="【九章算法强化班】堆Heap&双端队列Dequeue">【九章算法强化班】堆Heap&双端队列Dequeue</a> 堆&amp;双端队列Deque</li>
<li><a href="/2017/11/04/【九章算法强化班】第k大/" title="【九章算法强化班】第k大">【九章算法强化班】第k大</a></li>
<li>​</li>
</ul>
<h1 id="2-系统设计"><a href="#2-系统设计" class="headerlink" title="2. 系统设计"></a>2. 系统设计</h1><ul>
<li><a href="/2018/01/27/【九章系统设计】新鲜事系统/" title="【九章系统设计】新鲜事系统">【九章系统设计】新鲜事系统</a></li>
<li><a href="/2018/01/30/【九章系统设计】从用户系统理解数据库和缓存/" title="【九章系统设计】从用户系统理解数据库和缓存">【九章系统设计】从用户系统理解数据库和缓存</a></li>
<li><a href="/2018/03/05/【九章系统设计】一致性哈希-短网址系统设计/" title="【九章系统设计】一致性哈希&短网址系统设计">【九章系统设计】一致性哈希&短网址系统设计</a></li>
<li><a href="/2018/03/10/【九章系统设计】爬虫系统与搜索建议系统/" title="【九章系统设计】爬虫系统与搜索建议系统">【九章系统设计】爬虫系统与搜索建议系统</a>
</li>
</ul>
<h1 id="3-机器学习"><a href="#3-机器学习" class="headerlink" title="3. 机器学习"></a>3. 机器学习</h1><h3 id="3-1-线性模型"><a href="#3-1-线性模型" class="headerlink" title="3.1 线性模型"></a>3.1 线性模型</h3><ul>
<li>【机器学习】LR</li>
<li>【机器学习】svm</li>
<li>【机器学习】PLA 线性感知机</li>
</ul>
<h3 id="3-2-树模型"><a href="#3-2-树模型" class="headerlink" title="3.2 树模型"></a>3.2 树模型</h3><ul>
<li><a href="/2017/03/04/【机器学习】决策树（一）：基础/" title="决策树（一）：基础">决策树（一）：基础</a></li>
<li><a href="/2017/03/05/【机器学习】决策树（二）：连续值和缺失处理/" title="决策树（二）：连续值和缺失处理">决策树（二）：连续值和缺失处理</a></li>
<li><a href="/2017/03/05/【机器学习】决策树（三）：多变量决策树/" title="决策树（三）：多变量决策树">决策树（三）：多变量决策树</a>
</li>
</ul>
<ul>
<li>gbdt</li>
<li>RF</li>
<li><a href="/2018/03/12/【机器学习】gbdt-xgboost-lightGBM比较/" title="【机器学习】gbdt/xgboost/lightGBM比较">【机器学习】gbdt/xgboost/lightGBM比较</a>
</li>
</ul>
<h3 id="3-3-评价指标等"><a href="#3-3-评价指标等" class="headerlink" title="3.3 评价指标等"></a>3.3 评价指标等</h3><ul>
<li><a href="/2017/04/04/【机器学习】准确率、召回率、F1、ROC、AUC/" title="准确率、召回率、F1、ROC、AUC">准确率、召回率、F1、ROC、AUC</a></li>
<li><a href="/2017/03/16/【机器学习】熵、交叉熵/" title="交叉熵">交叉熵</a></li>
<li><a href="/2018/03/08/【机器学习】过拟合、欠拟合及其解决办法/" title="过拟合、欠拟合及其解决办法">过拟合、欠拟合及其解决办法</a></li>
<li><a href="/2018/03/09/【机器学习】生成模型vs判别模型、有监督vs无监督/" title="生成模型vs判别模型、有监督vs无监督">生成模型vs判别模型、有监督vs无监督</a>
</li>
</ul>
<h3 id="3-4-其他算法"><a href="#3-4-其他算法" class="headerlink" title="3.4 其他算法"></a>3.4 其他算法</h3><ul>
<li>PCA 主成分分析</li>
<li>SVD 奇异值分解</li>
<li>​</li>
</ul>
<h1 id="4-项目-amp-竞赛总结"><a href="#4-项目-amp-竞赛总结" class="headerlink" title="4. 项目&amp;竞赛总结"></a>4. 项目&amp;竞赛总结</h1><h3 id="4-1-腾讯社交广告算法大赛"><a href="#4-1-腾讯社交广告算法大赛" class="headerlink" title="4.1 腾讯社交广告算法大赛"></a>4.1 腾讯社交广告算法大赛</h3><ul>
<li><a href="/2018/03/06/【腾讯转化率预估】比赛总结/" title="【腾讯转化率预估】总结">【腾讯转化率预估】总结</a></li>
<li><a href="/2018/03/07/【腾讯转化率预估】贝叶斯平滑/" title="【腾讯转化率预估】贝叶斯平滑">【腾讯转化率预估】贝叶斯平滑</a></li>
<li><a href="/2018/03/12/【机器学习】gbdt-xgboost-lightGBM比较/" title="【机器学习】gbdt/xgboost/lightGBM比较">【机器学习】gbdt/xgboost/lightGBM比较</a></li>
<li><a href="/2017/03/14/【机器学习】FM，因子分解机/" title="Factorization Machine（FM，因子分解机）">Factorization Machine（FM，因子分解机）</a></li>
<li><a href="/2017/03/22/【机器学习】FFM（field-aware-Factorization-Machine）——升级版FM/" title="FFM（field-aware Factorization Machine）——升级版FM">FFM（field-aware Factorization Machine）——升级版FM</a>​</li>
<li><a href="https://jiayi797.github.io/2017/06/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E4%B8%8D%E5%B9%B3%E8%A1%A1%E7%B1%BB%E7%9A%84%E5%A4%84%E7%90%86/" target="_blank" rel="external">机器学习实践-不平衡类的处理</a></li>
<li><a href="https://jiayi797.github.io/2017/04/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6-xgboost%E5%8F%82%E6%95%B0%E8%B0%83%E8%8A%82%E6%8C%87%E5%8D%97%EF%BC%88Python%E7%89%88%EF%BC%89/" target="_blank" rel="external">机器学习框架-xgboost参数调节指南（Python版</a></li>
</ul>
<h3 id="4-2-编程之美"><a href="#4-2-编程之美" class="headerlink" title="4.2 编程之美"></a>4.2 编程之美</h3><ul>
<li><a href="/2018/03/08/【2017编程之美】搜索引擎总结/" title="【2017编程之美】搜索引擎总结">【2017编程之美】搜索引擎总结</a></li>
<li>​</li>
</ul>
<h3 id="4-3-实习"><a href="#4-3-实习" class="headerlink" title="4.3 实习"></a>4.3 实习</h3><ul>
<li> item-based 协同过滤</li>
</ul>
<h1 id="5-语言相关"><a href="#5-语言相关" class="headerlink" title="5. 语言相关"></a>5. 语言相关</h1><ul>
<li><a href="/2018/01/27/【Java】Java常用笔记/" title="Java常用笔记">Java常用笔记</a> 写代码的时候总忘记的小东西</li>
<li><a href="/2018/01/24/【Java】Java垃圾回收机制/" title="理解Java垃圾回收机制">理解Java垃圾回收机制</a></li>
<li><a href="/2018/03/11/【Java】HashMap原理探究/" title="【Java】HashMap原理探究">【Java】HashMap原理探究</a>
</li>
</ul>
<h1 id="6-面试必备"><a href="#6-面试必备" class="headerlink" title="6. 面试必备"></a>6. 面试必备</h1><ul>
<li><a href="/2018/03/09/【面经】开发相关基础知识/" title="【面经】开发相关基础知识">【面经】开发相关基础知识</a> </li>
<li><a href="/2018/03/07/【面经】算法相关/" title="【面经】算法相关">【面经】算法相关</a> 
</li>
</ul>
<h1 id="7-计算广告相关"><a href="#7-计算广告相关" class="headerlink" title="7. 计算广告相关"></a>7. 计算广告相关</h1><h3 id="6-1-系统相关"><a href="#6-1-系统相关" class="headerlink" title="6.1 系统相关"></a>6.1 系统相关</h3><ul>
<li><a href="https://siyaozhang.github.io/2018/01/10/%E3%80%90DSP%E7%B3%BB%E7%BB%9F%E3%80%91Java-UDP%E9%80%9A%E4%BF%A1%E6%A8%A1%E6%8B%9F%E7%9B%91%E5%90%AC%E6%A8%A1%E5%9D%97/" target="_blank" rel="external">【DSP系统】Java UDP通信模拟监听模块</a></li>
<li><a href="https://siyaozhang.github.io/2018/01/09/DSP%E7%B3%BB%E7%BB%9Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%90%AD%E5%BB%BA/" target="_blank" rel="external">DSP系统mysql数据库搭建</a></li>
</ul>
<h3 id="6-2-论文相关"><a href="#6-2-论文相关" class="headerlink" title="6.2 论文相关"></a>6.2 论文相关</h3><ul>
<li><a href="https://siyaozhang.github.io/2017/12/10/DeepFM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">DeepFM论文笔记</a></li>
<li><a href="https://siyaozhang.github.io/2017/12/07/WAND%E7%AE%97%E6%B3%95/" target="_blank" rel="external">WAND检索算法</a></li>
<li><a href="https://siyaozhang.github.io/2017/11/27/Bid-Optimizing-and-Inventory-Scoring-in-Targeted-Online%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">Bid Optimizing and Inventory Scoring in Targeted Online论文笔记</a></li>
<li><a href="https://siyaozhang.github.io/2017/07/17/Optimal-Real-Time-Bidding-for-Display-Advertising%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">ptimal Real-Time Bidding for Display Advertising论文笔记</a></li>
<li><a href="https://siyaozhang.github.io/2017/11/22/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8ETop-k%E5%BF%AB%E9%80%9F%E6%A3%80%E7%B4%A2%E9%97%AE%E9%A2%98/" target="_blank" rel="external">搜索引擎Top-k快速检索问题</a></li>
<li><a href="https://siyaozhang.github.io/2017/11/20/%E3%80%90RTB%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%91/" target="_blank" rel="external">RTB论文笔记</a></li>
<li><a href="https://siyaozhang.github.io/2017/11/02/DSP%E5%9B%BD%E5%86%85%E7%A1%95%E5%A3%AB%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/" target="_blank" rel="external">DSP国内硕士论文总结</a></li>
</ul>
<a id="more"></a>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【2017编程之美】搜索引擎总结]]></title>
      <url>/2018/03/08/%E3%80%902017%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E3%80%91%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>本文主要回顾和总结2017编程之美决赛中校园聊天机器人后端搜索引擎的实现。</p>
<h2 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h2><p>校园聊天机器人，针对用户的问题进行回答，当然，问题都是跟校园相关的一些问题。</p>
<p>收集校主页和论坛上的信息，招聘信息、征友信息、失物招领等信息，根据用户的需求返回合适的答案。</p>
<h2 id="2-爬虫"><a href="#2-爬虫" class="headerlink" title="2. 爬虫"></a>2. 爬虫</h2><p>北邮人论坛格式相对工整，并不需要进行DFS爬取。论坛某个页面如下：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-02-19-39-36.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-02-19-39-36.png" alt="img"></a></p>
<p>论坛格式基本如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1  [标题，最新回复时刻]</div><div class="line">2  [标题，最新回复时刻]</div><div class="line">...</div><div class="line">10 [标题，最新回复时刻]</div><div class="line"></div><div class="line"></div><div class="line">              第k页</div></pre></td></tr></table></figure>
<p>因此只需要按页遍历即可。</p>
<h3 id="2-1-数据库设计"><a href="#2-1-数据库设计" class="headerlink" title="2.1 数据库设计"></a>2.1 数据库设计</h3><p>爬取的内容建立一张表放入MySQL。由于每个帖子都有自己的唯一性ID，因此可以将这个ID作为主键。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文章ID（主键）</th>
<th>标题（已分词）</th>
<th>最后更新时刻</th>
<th>内容（已分词）</th>
<th>链接</th>
<th>已索引</th>
</tr>
</thead>
<tbody>
<tr>
<td>758943</td>
<td>社招/神马/搜索/北京/资深/广告/算法/研发/工程师</td>
<td>20180302 165751</td>
<td>基于/大规模/用户/行为/效果/目标/建立/优化/推荐/系统/基础/算法/策略 ….</td>
<td><a href="https://bbs.byr.cn/#!article/JobInfo/758943" target="_blank" rel="external">https://bbs.byr.cn/#!article/JobInfo/758943</a></td>
<td>是/否</td>
</tr>
<tr>
<td></td>
<td>…</td>
<td>…</td>
<td>…</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-2-实时爬虫"><a href="#2-2-实时爬虫" class="headerlink" title="2.2 实时爬虫"></a>2.2 实时爬虫</h3><p>由于北邮人论坛的【缘分天空】、【毕业生找工作】、【兼职实习信息】等板块很热火，几乎每小时都有新帖。因此可以不考虑资源浪费问题，直接采用定时爬虫进行信息更新和维护。</p>
<p>实时爬虫的流程如下：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-02-20-13-35.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-02-20-13-35.png" alt="img"></a></p>
<p>对于每个页面，我们可以从页面目录快速获取【文章ID、标题、发帖时刻、回复量、最新回复时刻、文章链接】信息。因此当获取到本页面的10篇文章的ID和最新回复时刻TimeStamp后：</p>
<ol>
<li><p>看库中是否存在此ID</p>
<ol>
<li><p>如果存在：</p>
<ol>
<li><p>此帖在近期有回复，更新最新回复时刻TimeStamp</p>
</li>
<li><p>此帖在近期无回复，有两种可能：</p>
<ol>
<li>后面的帖子不再有新的回复，因此可以直接停止本版面的爬虫；</li>
<li>爬取第1页时，本帖在第1页；爬取第2页时，本帖被顶到第2页；</li>
</ol>
<p>为了不让情况2误认为是近期无更新的贴，因此我们设置50次阈值。当连续50篇文章都没有新的更新时，停止爬虫。</p>
</li>
</ol>
</li>
<li><p>如果不存在，则爬取本页面并添加进数据库</p>
</li>
</ol>
</li>
</ol>
<p>对于每个版块的每个页面，执行以上循环操作。每个页面包含10篇左右文章。由于每篇文章打开需要约1秒，因此一页需要10多秒。北邮人论坛设置反爬虫机制，每连续访问10次后就要休息10秒才可以继续爬。而【毕业生找工作】等热门版面每日的更新量达300+条。那么完成一次此版面的爬取需要10分钟。三个版面的爬取大约需要20分钟。这个时间太长了，不利于后续的实施构建索引。</p>
<p>为了加速爬取速度，我们采用了多线程爬取技术。为了避免重复写入，因此每个线程只负责一个页面。当爬取完毕时，将数据扔到“待写入队列”里排队写入MySQL。</p>
<h3 id="2-3-分词"><a href="#2-3-分词" class="headerlink" title="2.3 分词"></a>2.3 分词</h3><p>利用jieba分词模块，对爬取的文档进行分词，首先按是否为汉字、数字、英文字符及标点符号对新闻内容进行梳理，去除掉信息缺失的数据，然后用jieba分词对标题及内容进行分词，并去掉停用词、生僻字等，得到文章的分词内容【这一步骤在爬虫模块已完成】。另外对于北邮人常用的找工作模块，需自定义计算机类技术栈关键词，如Python、Java、计算广告、推荐系统等。</p>
<p>分好词之后就可以存入数据库了。</p>
<p>jieba分词用到了哪些算法，文档里面如下介绍：</p>
<p>• 基于Trie树结构实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图（DAG）<br>• 采用了<strong>动态规划查找最大概率路径</strong>, 找出基于词频的最大切分组合<br>• 对于未登录词，采用了基于汉字成词能力的<strong>HMM模型</strong>，使用了Viterbi算法（隐马尔科夫模型）</p>
<p><strong>日后需要补习</strong></p>
<h2 id="3-索引构建-amp-检索"><a href="#3-索引构建-amp-检索" class="headerlink" title="3. 索引构建&amp;检索"></a>3. 索引构建&amp;检索</h2><h3 id="3-1-向量空间模型"><a href="#3-1-向量空间模型" class="headerlink" title="3.1 向量空间模型"></a>3.1 向量空间模型</h3><p><strong>检索结果排序是搜索引擎最核心的部分，</strong>很大程度度上决定了搜索引擎的质量好坏及用户满意度。实际搜索结果排序的因子有很多，但最主要的两个因素是用户查询和网页内容的相关度，以及网页链接情况。这里我们主要总结网页内容和用户查询相关的内容。</p>
<p>​       判断网页内容是否与用户査询相关，这依赖于搜索引擎所来用的检索模型。检索模型是搜索引擎的理论基础，为量化相关性提供了一种数学模型，是对查询词和文档之间进行相似度计算的框架和方法。其本质就是相关度建模。</p>
<p><strong>常见检索模型：布尔模型，向量空间模型，概率模型，语言模型，机器学习排序算法</strong></p>
<ol>
<li><p>布尔模型</p>
<p>苹果 AND 公司：表示搜索既包含“苹果”，又包含“公司”这两个词的文档。<br>苹果 OR 公司：表示搜索包含“苹果”，或包含“公司”这两个词中任意一个的文档。<br>特点：简单粗暴</p>
</li>
<li><p><strong>向量空间模型</strong></p>
<p>苹果 AND 公司：表示搜索既包含“苹果”，又包含“公司”这两个词的文档。<br>苹果 OR 公司：表示搜索包含“苹果”，或包含“公司”这两个词中任意一个的文档。<br>特点：简单粗暴</p>
<p>本文就是采用这样的方式</p>
</li>
<li><p>概率检索模型</p>
<p>概率检索模型基于概率排序原理，是目前效果最好的模型之一，okapi BM25这一经典概率模型计算公式已经在商业搜索引擎的网页排序中广泛应用。</p>
<p>I. 概率排序原理</p>
<p>基本思想：给定一个用户查询，若搜索系统能在搜索结果排序时按照文档和用户查询的相关性由高到低排序，那么这个搜索系统的准确性是最优的。</p>
<p>II. 实际实现</p>
<ol>
<li>根据用户的查询将文档集合划分为两个集合：相关文档子集和不相关文档子集。</li>
<li>将相关性衡量转换为分类问题，对某个文档D来说，若其属于相关文档子集的概率大于属于不相关文档的概率，就认为它与查询相关。</li>
</ol>
<p>另P(R|D)代表给定一个文档D对应的相关性概率，而P(NR|D)代表该文档的不相关概率，若P(R|D)&gt;P(NR|D)我们就认为此文档与查询相关。</p>
<p>根据贝叶斯定理（详见<a href="http://blog.csdn.net/zealfory/article/details/77853128" target="_blank" rel="external">贝叶斯公式推导及意义</a>）,最终等价于计算:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(R|D)/P(NR|D)</div></pre></td></tr></table></figure>
<p>搜索系统无需分类，只需将文档按照上式大小降序排列即可。</p>
<p>III. 估值公式<br>基于二元独立模型（BIM）的二元假设和词汇独立性假设，得到最终的相关性估算公式：</p>
<p><img src="http://img.blog.csdn.net/20170923100608912?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemVhbGZvcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="估算公式"><br>其中pi代表第i个单词在相关文档集合中出现的概率，si代表第i个单词在不相关文档集合中出现的概率。</p>
<p>取log便于计算：<br><img src="http://img.blog.csdn.net/20170923100720285?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemVhbGZvcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>统计语言模型</p>
<p>基本思想：<br>​    其他的检索模型的思考路径是从<strong>查询</strong>到文档，即给定用户<strong>查询</strong>，如何找出相关的文档，该模型的思路正好想法，是由文档到<strong>查询</strong>这个方向，即为每个文档建立不同的语言模型，判断由文档生成用户<strong>查询</strong>的可能性有多大，然后按照这种生成概率由高到低排序，作为搜索结果。语言模型代表了单词或者单词序列在文档中的分布情况；</p>
<p>举个例子：</p>
<p>先引入一个概念：抽取概率<br>把一篇文档进行分词，统计其中每个词的出现频率进行计数，则一个词Word在文档Doc中的抽取概率为“Word词的计数/Doc中所有词的计数之和”。所谓抽取概率，就是在Doc中随机抽取一个词的话，Word被抽取到的概率。<br>假设用户搜索“野鸟装备 跑步”，野鸟装备在文档Doc1中的抽取概率1%，跑步的抽取概率为2%，则该次搜索中，Doc1的相关性得分为1%*2%。依此可以计算出所有文档的相关性得分，并按相关性得分对搜索结果进行排序。 </p>
</li>
<li><p>机器学习模型</p>
<p>机器学习与前面的模型相比，有几个显著的不同：<br>1、这里一般使用有监督的机器学习，因此需要对训练结果有监督反馈，用户对搜索结果的隐性评价（即点击）可以看作是一种监督反馈。<br>2、传统搜索计算搜索结果相关性一般也就考虑关键词匹配、词频等少数几个维度的数据，使用前面提到的模型已经足够，只有当考察的数据维度比较多时，机器学习的优势才会体现出来。比如像百度、Google这种大型的商业搜索引擎，考察的数据维度要多很多，比如链入链出链接数、网站类型、网站权威度、用户地理位置、历史搜索习惯、设备类型等等，据说Google考察的数据维度多达几百个。<br>特点：复杂度高，适合大型商业搜索引擎。</p>
<p><a href="http://blog.csdn.net/starzhou/article/details/51438140" target="_blank" rel="external">机器学习排序之Learning to Rank简单介绍</a></p>
</li>
</ol>
<h3 id="3-2-TF-IDF"><a href="#3-2-TF-IDF" class="headerlink" title="3.2 TF-IDF"></a>3.2 TF-IDF</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-08-13-40-07.png" alt=""></p>
<h3 id="3-3-倒排索引构建"><a href="#3-3-倒排索引构建" class="headerlink" title="3.3 倒排索引构建"></a>3.3 倒排索引构建</h3><p>对每个词来说更新“词-文章序号”的倒排列表。倒排列表的结构如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>ID</th>
<th>词</th>
<th>文档频率</th>
<th>倒排记录表</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>中国</td>
<td>3</td>
<td>1,3,4</td>
</tr>
<tr>
<td>1</td>
<td>招聘</td>
<td>1</td>
<td>4，</td>
</tr>
<tr>
<td>2</td>
<td>蜜蜂</td>
<td>2</td>
<td>1,2</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-4-计算各文档的向量"><a href="#3-4-计算各文档的向量" class="headerlink" title="3.4 计算各文档的向量"></a>3.4 计算各文档的向量</h3><p>假如文档1包含的词有【中国，蜜蜂】，按照上字典序号对应的关系，词向量应该为[1,0,1][1,0,1] 。而用01表示词其实并不科学，这里每个词可以用TF-IDF来优化。那么词向量可能会变成[0.2,0,0.1][0.2,0,0.1]</p>
<p>计算每个文档的词向量（下表不必存储）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文档</th>
<th>词</th>
<th>词向量</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>中国，蜜蜂</td>
<td>[0.2,0,1][0.2,0,1]</td>
</tr>
<tr>
<td>2</td>
<td>蜜蜂</td>
<td>[0,0,0.8][0,0,0.8]</td>
</tr>
<tr>
<td>3</td>
<td>中国</td>
<td>[0.7,0,0][0.7,0,0]</td>
</tr>
<tr>
<td>4</td>
<td>中国，招聘</td>
<td>[0.4,0.6,0][0.4,0.6,0]</td>
</tr>
</tbody>
</table>
</div>
<p>将词向量模型更新添加进倒排索引：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>词</th>
<th>文档频率</th>
<th>倒排记录表[文章ID，权重]</th>
</tr>
</thead>
<tbody>
<tr>
<td>中国</td>
<td>3</td>
<td>[1,0.2] , [3,0.7] , [4,0.4]</td>
</tr>
<tr>
<td>招聘</td>
<td>1</td>
<td>[4,0.6]</td>
</tr>
<tr>
<td>蜜蜂</td>
<td>2</td>
<td>[1,0.1], [2,0.8]</td>
</tr>
</tbody>
</table>
</div>
<p>其中每个文档中某个词的TF值只与该文档有关，但是IDF是与当前倒排表相关的，计算的时候这里需要主要 </p>
<h3 id="3-5-检索"><a href="#3-5-检索" class="headerlink" title="3.5 检索"></a>3.5 检索</h3><p>当用户输入查询词时，例如查询【中国，招聘】这两个关键字时，由于关键字无权重，因此可以直接设查询向量qq为[1,1,0][1,1,0] 。按理来说应该直接对着【文档dd-词向量】表格直接依次计算余弦相似度q×dq×d，然后取相似度最高的前K个作为返回结果。但是这样太暴力了，也太慢了。</p>
<p>机智的人类发现，q是一个01向量， q×dq×d 也就是对于q中那些为1的词项，计算在文档d中这些词的权重值和。</p>
<p>因此我们利用倒排索引优化查询。步骤为：</p>
<ol>
<li>在词典中定位【中国，招聘】这两个词，返回其倒排记录表。【中国 –&gt; [1,0.2] , [3,0.7] , [4,0.4]】，【招聘 –&gt; [4,0.6]】</li>
<li>文档4中，中国和招聘两个词的权重值和为1；而文档1的权重为0.2；文档3的权重为0.7</li>
</ol>
<h3 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h3><ol>
<li><strong>索引构建/更新流程图</strong></li>
</ol>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-02-23-00-07.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-02-23-00-07.png" alt="img"></a></p>
<ol>
<li><strong>倒排索引数据库设计</strong></li>
</ol>
<p>将爬好的数据进行实时权重向量计算，填入下表，即是倒排表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>词</th>
<th>文档频率</th>
<th>倒排记录表</th>
</tr>
</thead>
<tbody>
<tr>
<td>中国</td>
<td>3</td>
<td>[1,0.2] , [3,0.7] , [4,0.4]</td>
</tr>
<tr>
<td>招聘</td>
<td>1</td>
<td>[4,0.6]</td>
</tr>
<tr>
<td>蜜蜂</td>
<td>2</td>
<td>[1,0.1], [2,0.8]</td>
</tr>
</tbody>
</table>
</div>
<p>当时这个结构直接存储在了内存当中。但讲道理应该存储在MongoDB这一类KV数据库中。</p>
<h2 id="4-旧数据删除"><a href="#4-旧数据删除" class="headerlink" title="4. 旧数据删除"></a>4. 旧数据删除</h2><p>​    后续如果数据量不断增大，可以考虑将一些陈旧的帖子删除，比如保留最近半年有过更新的帖子，不过这还要考虑机器的容量。</p>
<p>本系统定义每天的凌晨4点进行旧数据清除工作。</p>
<p>​    每个帖子是有有效期的。当某个帖子过了某个时间后信息量就会变得很少，不再有检索需求。因此需要将旧帖子删掉。由于机器硬盘限制，本系统设定当帖子的最后更新时刻与当前时刻超过10天时，此贴应该被从数据库与索引中删除。</p>
<p>​    本系统定义每天的凌晨4点进行旧数据清除工作。</p>
<h2 id="5-优化"><a href="#5-优化" class="headerlink" title="5. 优化"></a>5. 优化</h2><p>回头重新看这个问题时，我们发现如果有高并发等类似的请求时，系统还有很多地方需要优化：</p>
<h3 id="5-1-检索模型角度"><a href="#5-1-检索模型角度" class="headerlink" title="5.1 检索模型角度"></a>5.1 检索模型角度</h3><p>可以结合其他模型，比如概率模型、语言模型等，如果有一定的用户量之后可以结合learn to rank模型</p>
<h3 id="5-2-字典优化角度"><a href="#5-2-字典优化角度" class="headerlink" title="5.2 字典优化角度"></a>5.2 字典优化角度</h3><p>在实现字典时，通常会使用哈希表、树（二查查找树、字典树）等数据结构。</p>
<p><strong>用二叉查找树实现字典</strong></p>
<p>使用二叉查找树实现词典时， 要先将数据对（的列表） <strong>按照单词词典顺序排列</strong>。</p>
<p>数据对 = [单词 + 该单词的倒排列表的引用（地址）]</p>
<p>若用内存上的二叉查找树实现之前例子中的词典， 就会得到如下图所示的树形结构。 树中的各个结点是通过地址引用（指针） 连接起来的</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-12-27.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-12-27.png" alt="img"></a></p>
<p>一般倒排列表都会很长，字典很大。因此会考虑将倒排列表存储到二级存储的连续区域中。</p>
<p>在二级存储上实现词典时，也要先将数据对按照单词的词典顺序排列， 然后一个接一个地存储到存储器上。 但是， 如果只是单纯地一个接一个地存储， 就无法知道各数据对应该在哪里结束了， 因此在此之上还要维护一个列表， 用于存储从开头算起每个数据对的偏移量。 对应的数据结构如图所示。 在进行检索时， 可以对该偏移量的列表进行二分查找。</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-14-28.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-14-28.png" alt="img"></a></p>
<p>如果词典能够完整地加载到内存， 那么所形成的二叉树的搜索效率将会非常高。 特别是当二叉树处于平衡状态时， 平均进行log2Nlog2N 次查找就能找到单词。<br>但是， 如果词典无法完整地加载到内存， 而必须存储到二级存储器上时， 二叉树就未必是高效的数据结构了。 HDD 或 SSD 等二级存储器一般被称作“块设备”， 由于它们是以块为单位进行输入输出的 ， 所以即使只是读取块中 1 个字节的数据， 也不得不对整个块进行输入输出操作。 例如， 假设我们用二叉查找树实现了含有 100 万个单词的词典， 那么进行二分查找的话， 平均需要 20 次查找， 因此在最坏的情况下就需要加载 20 个块。 也就是说， 假设二级存储的加载性能为 5ms/ 块， 那么在 1 次检索中， 仅花费在二级存储输入输出上的时间就高达100ms。<br>因此， 当要存储大型词典时， 往往要使用适合块设备的 B+ 树等树形数据结构。</p>
<p><strong>用B+树实现字典</strong></p>
<p>B+ 树是一种平衡的多叉树， 属于从 B 树派生出来的树形结构。 在 B+ 树中， 所有的记录都存储在树中的叶结点（Leaf Node） 上， 内部结点（Internal Node） 上只以关键字的顺序存储关键字</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-43-00.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-43-00.png" alt="img"></a></p>
<p><strong>B+树通常以文件系统中页尺寸的常数倍为单位管理各节点。这样有助于减少检索时对二级存储的输入输出次数。</strong></p>
<h3 id="5-2-倒排索引构建-更新角度"><a href="#5-2-倒排索引构建-更新角度" class="headerlink" title="5.2 倒排索引构建/更新角度"></a>5.2 倒排索引构建/更新角度</h3><p>简单的文档列表直接存储在内存中。比如我们的项目搜索引擎的倒排索引就是放在内存中的，但是大多数情况倒排索引都是非常稀疏的表，因此用链表实现倒排索引非常好。</p>
<p>而<strong>文档链表一般都很大，因此很多都存储在二级存储中</strong>。这样就有两种构建方法：基于排序的构建方法和基于合并的构建方法。</p>
<p><strong>基于排序的索引构建法</strong></p>
<ol>
<li>对各文档中构成该文档的每个单词都建立一条【单词、文档编号、TF】的记录。然后将该记录写入二级存储上的文件末尾</li>
<li>将文件各条记录按照字典顺序排列；单词字段相同的再按照文档编号顺序排列</li>
<li>逐行读取排序后的文件，取出每个单词的文档编号列表；并用这些列表构建每个单词的倒排索引（这一步可以压缩倒排列表，此处省略）</li>
</ol>
<p><strong>基于合并的索引构建法</strong></p>
<p>基于合并的索引构建法是一种先在内存上构建出倒排索引的片段，然后将这些片段导出到二级存储，最后将导出的多个倒排索引合并在一起。</p>
<ol>
<li>在内存上构建【单词-倒排】的kv映射表Map。</li>
<li>如果某单词不在Map里，就要将该单词加入到Map中</li>
<li>当Map过大，就将Map导入文件里</li>
<li>重复1-3步骤，直到处理完所有文档。最后利用多路归并将将导出的各文件合并在一起。（这一步也可以压缩倒排，此处省略）</li>
</ol>
<p><strong>动态索引构建</strong></p>
<p>之前说的索引构建方法都是只有构建完成后才可用于检索。这叫静态构建方法（Offline Index Construction）。</p>
<p>还有一种动态构建方法（Online Index Construction / Dynamic Indexing）。这种方法可以<strong>一边更新索引，一边检索</strong>。其基本策略如下所示：</p>
<ul>
<li>将索引分成内存上的索引和磁盘上的索引分别管理</li>
<li>添加文档后，优先更新内存上的索引</li>
<li>当内存索引满时，将其整合到磁盘上的索引中</li>
</ul>
<h3 id="5-3-倒排索引压缩"><a href="#5-3-倒排索引压缩" class="headerlink" title="5.3 倒排索引压缩"></a>5.3 倒排索引压缩</h3><p>为什么要进行压缩？</p>
<p>如果数据量很大，倒排索引庞大，在使用倒排索引进行检索的过程中，总检索时间中的大部分时间往往花费在了<strong>从二级存储读取倒排索引</strong>上。于是，就经常可以看到在存储倒排索引前，对其进行压缩以减少从二级存储读取的时间，进而使检索处理得以高速运转的对策。</p>
<p>也就是说，我们可以根据如下原理，通过压缩倒排索引来加快检索处理的速度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">从二级存储中读取（部分）经过压缩的倒排索引的时间＋还原倒排索引的时间</div><div class="line">＜从二级存储中读取（部分）尚未经过压缩的倒排索引的时间</div></pre></td></tr></table></figure>
<p>倒排索引的压缩分为针对词典的压缩和针对倒排文件的压缩两种。<br>我们可以通过使用更少的信息量表示单词的集合来实现词典的压缩。例如，对于按照词典顺序排列的单词列表而言，通过避免重复存储相同的前缀，就可以减少存储词典时所需的必要存储空间。但是，在大多数情况下，由于词典的大小远远小于倒排文件的大小，所以一般认为压缩词典对于加快检索处理的速度并没有太大的贡献。</p>
<p>而倒排文件的压缩，可以通过使用更少的信息量表示其构成要素来实现。构成要素就是指文档编号、单词在文档内的出现次数（TF，Term Frequency，词频）以及由单词在文档内的偏移量构成的整数数组。</p>
<p><strong>使用可变长度的编码确实可以带来大幅度的压缩</strong>。</p>
<p>待填坑==</p>
<h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ol>
<li><a href="https://jiayi797.github.io/2018/03/02/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%9B%9E%E9%A1%BE/" target="_blank" rel="external">自制搜索引擎</a></li>
<li><a href="http://blog.csdn.net/guoziqing506/article/details/64122287" target="_blank" rel="external">B树与B+树</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/03/tf-idf.html" target="_blank" rel="external">TF-IDF与余弦相似性的应用（一）：自动提取关键词</a></li>
<li><a href="http://blog.csdn.net/starzhou/article/details/51438140" target="_blank" rel="external">机器学习排序之Learning to Rank简单介绍</a></li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7981145" target="_blank" rel="external"> 搜索引擎的检索模型-查询与文档的相关度计算</a></li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班】动态规划]]></title>
      <url>/2018/03/08/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><p>滚动数组</p>
<ul>
<li>house robber I/II</li>
<li>Maximal Square</li>
</ul>
<p>记忆化搜索</p>
<ul>
<li>longest increasing subsequence</li>
<li>coins in a line</li>
</ul>
<h2 id="动态规划四要素"><a href="#动态规划四要素" class="headerlink" title="动态规划四要素"></a>动态规划四要素</h2><ol>
<li>状态</li>
<li>转移方程</li>
<li>初始化</li>
<li>答案</li>
</ol>
<h2 id="滚动数组优化"><a href="#滚动数组优化" class="headerlink" title="滚动数组优化"></a>滚动数组优化</h2><p>f[i] = max(f[i-1],f[i-2]+A[i]);</p>
<p>转化为：</p>
<p>f[i%2] = max(f[(i-1)%2],f[(i-2)%2])</p>
<p>滚动数组优化不会对时间复杂度进行优化，而只是对空间进行优化</p>
<h3 id="例题1-House-Robber"><a href="#例题1-House-Robber" class="headerlink" title="例题1. House Robber"></a>例题1. <a href="https://leetcode.com/problems/house-robber" target="_blank" rel="external">House Robber</a></h3><p>给定一个数组，代表抢劫商店可以获得的价值，不可以抢劫相邻的商店，计算能够获得的最大价值</p>
<p>思路：</p>
<p><strong>序列型dp</strong></p>
<p><code>f[i]</code>代表抢劫前i个商店能够获得的最大值</p>
<p>对于店铺i可以有抢和不抢两种情况：</p>
<ol>
<li>如果抢，则不能抢f[i-1]，则前i个商店的最大值为前i-2个商店的最大值加上第i个商店的价值</li>
<li>如果不抢，则前i个商店的最大值=前i-1个商店的最大值</li>
</ol>
<p>取两种情况的最大值</p>
<p>转移方程:f[i] = max(f[i-1],f[i-2]+nums[i])</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; nums.length;i++)&#123;</div><div class="line">        dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>] + nums[i]);</div><div class="line">        System.out.println(dp[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>用滚动数组优化</strong></p>
<p>转移方程：<code>f[i] = max(f[i-1],f[i-2]+nums[i])</code></p>
<p>根据前面的分析，对于每一个商店i，我们只需要考虑商店i-1和i-2，也就是状态i只与它的前两个状态有关，所以我们只需要维护一个长度为2的数组来记录状态即可。</p>
<p>状态转移方程转化为<code>f[i%2] = max(f[(i-1)%2],f[(i-2)%2]+nums[i])</code></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; nums.length;i++)&#123;</div><div class="line">        dp[i%<span class="number">2</span>] = Math.max(dp[(i-<span class="number">1</span>)%<span class="number">2</span>],dp[(i-<span class="number">2</span>)%<span class="number">2</span>] + nums[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[(nums.length-<span class="number">1</span>)%<span class="number">2</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这道题是状态只与前两个状态有关，如果推广到一般，如果状态i与前k个状态有关，则有：</p>
<p><code>f[i%k] = max(f[(i-1)%k],f[(i-2)%k]+nums[i])</code></p>
<h3 id="例题2-House-Robber-II"><a href="#例题2-House-Robber-II" class="headerlink" title="例题2. House Robber II"></a>例题2. <a href="https://leetcode.com/problems/house-robber-ii" target="_blank" rel="external">House Robber II</a></h3><p>首尾商店算相邻的商店，也就是商店是一个环。</p>
<p>思路：</p>
<p>对于成环的问题有两个小技巧：</p>
<ol>
<li>拆分数组的方式，将计算一个数组的问题转化成计算两个数组：<ol>
<li>去掉最后一个元素</li>
<li>去掉第一个元素</li>
</ol>
</li>
<li>将原数组copy一份，首尾相接，本题不适用</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len = nums.length;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[] dp1 = <span class="keyword">new</span> <span class="keyword">int</span> [len-<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span>[] dp2 = <span class="keyword">new</span> <span class="keyword">int</span> [len-<span class="number">1</span>];</div><div class="line">    dp1[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">    dp1[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    dp2[<span class="number">0</span>] = nums[<span class="number">1</span>];</div><div class="line">    dp2[<span class="number">1</span>] = Math.max(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len-<span class="number">1</span>;i++)&#123;</div><div class="line">        dp1[i] = Math.max(dp1[i-<span class="number">1</span>],dp1[i-<span class="number">2</span>] + nums[i]);</div><div class="line">        dp2[i] = Math.max(dp2[i-<span class="number">1</span>],dp2[i-<span class="number">2</span>] + nums[i+<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Math.max(dp1[nums.length-<span class="number">2</span>],dp2[nums.length-<span class="number">2</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>滚动数组优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len = nums.length;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[] dp1 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span>[] dp2 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];</div><div class="line">    dp1[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">    dp1[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    dp2[<span class="number">0</span>] = nums[<span class="number">1</span>];</div><div class="line">    dp2[<span class="number">1</span>] = Math.max(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len-<span class="number">1</span>;i++)&#123;</div><div class="line">        dp1[i%<span class="number">2</span>] = Math.max(dp1[(i-<span class="number">1</span>)%<span class="number">2</span>],dp1[(i-<span class="number">2</span>)%<span class="number">2</span>] + nums[i]);</div><div class="line">        dp2[i%<span class="number">2</span>] = Math.max(dp2[(i-<span class="number">1</span>)%<span class="number">2</span>],dp2[(i-<span class="number">2</span>)%<span class="number">2</span>] + nums[i+<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Math.max(dp1[(nums.length-<span class="number">2</span>)%<span class="number">2</span>],dp2[(nums.length-<span class="number">2</span>)%<span class="number">2</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="例题3-Maximal-Square"><a href="#例题3-Maximal-Square" class="headerlink" title="例题3. Maximal Square"></a>例题3. <a href="https://leetcode.com/problems/maximal-square" target="_blank" rel="external">Maximal Square</a></h3><blockquote>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p>
<p>For example, given the following matrix:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 0 1 0 0</div><div class="line">&gt; 1 0 1 1 1</div><div class="line">&gt; 1 1 1 1 1</div><div class="line">&gt; 1 0 0 1 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Return 4.</p>
</blockquote>
<p>找到全为1的正方形的最大面积</p>
<p>思路：</p>
<p>定位正方形，需要一个三维数组[x,y,a]</p>
<p>其中xy为正方形顶点坐标，a为边长</p>
<p><strong>baseline：</strong></p>
<p>x,y,a三层循环从0到n，然后x，y从1到a一共5层循环，复杂度<script type="math/tex">O(n^5)</script></p>
<p><strong>dp</strong></p>
<p>对于一个点<code>(i,j)</code> (nums[i,j] = 1)，如要计算以其为右下角的最大正方形边长，需要考虑三个点：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-21-14-20-12.png" alt=""> </p>
<ol>
<li>以(i-1,j-1)为右下角的最大正方形边长</li>
<li>以(i,j-1)为最右点的矩形长度</li>
<li>以(i-1,j)为最下点的矩形长度</li>
</ol>
<p>取三个值中最小的+1就是以(i,j)为右下角的矩形最大边长</p>
<p>因此：</p>
<ol>
<li><p>状态：</p>
<p><code>f[i][j]</code>表示以以(i,j)为右下角的矩形最大边长</p>
</li>
<li><p>转移方程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if(matrix[i][j] == 1)&#123;</div><div class="line">  f[i][j] = max(f[i-1],[j-1],up[i-1][j],left[i][j-1])+1</div><div class="line">&#125;</div><div class="line">if(matrix[i][j] == 0)&#123;</div><div class="line">  f[i][j] = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>改进：</p>
<p>上面的方法除了维护f之外，还需要维护up和left数组，其实可以直接用f来代替up和left。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>)&#123;</div><div class="line">  f[i][j] = max(f[i-<span class="number">1</span>],[j-<span class="number">1</span>],f[i-<span class="number">1</span>][j],f[i][j-<span class="number">1</span>])+<span class="number">1</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</div><div class="line">  f[i][j] = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">f[i][0] = matrix[i][0]</div><div class="line">f[0][j] = matrix[0][j]</div></pre></td></tr></table></figure>
</li>
<li><p>答案</p>
<p><code>max(f[i][j])</code></p>
</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxSquare = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;rows;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="string">'1'</span>)&#123;</div><div class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">                maxSquare = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;cols;j++) &#123;</div><div class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j] == <span class="string">'1'</span>)&#123;</div><div class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</div><div class="line">                maxSquare = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; cols;j++) &#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</div><div class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]))+<span class="number">1</span>;</div><div class="line">                    maxSquare = Math.max(maxSquare, dp[i][j]);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    dp[i][j] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxSquare*maxSquare;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>滚动数组优化：</strong></p>
<p>对于每一个元素(i,j)，只与它前一行和前一列的元素有关，与其前两行的元素无关，因此可以对其行进行滚动数组优化</p>
<p>转移方程变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if(matrix[i][j] == 1)&#123;</div><div class="line">  f[i%2][j] = max(f[(i-1)%2],[j-1],f[(i-1)%2][j],f[i%2][j-1])+1</div><div class="line">&#125;</div><div class="line">if(matrix[i][j] == 0)&#123;</div><div class="line">  f[i%2][j] = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxSquare = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;cols;j++) &#123;</div><div class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j] == <span class="string">'1'</span>)&#123;</div><div class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</div><div class="line">                maxSquare = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++) &#123;</div><div class="line">                <span class="comment">//每行第一个元素</span></div><div class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</div><div class="line">                    <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</div><div class="line">                        dp[i%<span class="number">2</span>][j] = <span class="number">1</span>;</div><div class="line">                        maxSquare = Math.max(maxSquare, dp[i%<span class="number">2</span>][j]);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span>&#123;</div><div class="line">                        dp[i%<span class="number">2</span>][j] = <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</div><div class="line">                    dp[i%<span class="number">2</span>][j] = Math.min(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][j-<span class="number">1</span>],Math.min(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][j],dp[i%<span class="number">2</span>][j-<span class="number">1</span>]))+<span class="number">1</span>;</div><div class="line">                    maxSquare = Math.max(maxSquare, dp[i%<span class="number">2</span>][j]);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    dp[i%<span class="number">2</span>][j] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxSquare*maxSquare;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>follow up：</strong></p>
<p>01矩阵里面找一个，对角线全为1， 其他为0的正方形</p>
<p>转移方程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if(matrix[i][j] == 1)&#123;</div><div class="line">  f[i][j] = max(f[i-1],[j-1],up[i-1][j],left[i][j-1])+1</div><div class="line">&#125;</div><div class="line">if(matrix[i][j] == 0)&#123;</div><div class="line">  f[i][j] = 0;</div><div class="line">&#125;</div><div class="line">其中up和left表示前面连续0的个数</div></pre></td></tr></table></figure>
<h3 id="二维动态规划空间优化（二维滚动数组）总结"><a href="#二维动态规划空间优化（二维滚动数组）总结" class="headerlink" title="二维动态规划空间优化（二维滚动数组）总结"></a>二维动态规划空间优化（二维滚动数组）总结</h3><p>这类题目特点：</p>
<p><code>f[i][j]</code> = 由f[i-1]行 来决定状态， 第i行跟 i-1行之前毫无关系， 所以状态转变为：</p>
<p><code>f[i%2][j]</code> = 由f[(i-1)%2]行来决定状态</p>
<p>还有一些题目可以用滚动数组进行优化：</p>
<h3 id="习题1-Unique-Paths"><a href="#习题1-Unique-Paths" class="headerlink" title="习题1. Unique Paths"></a>习题1. <a href="https://leetcode.com/problems/unique-paths" target="_blank" rel="external">Unique Paths</a></h3><h3 id="习题2-Minimum-Path-Sum"><a href="#习题2-Minimum-Path-Sum" class="headerlink" title="习题2. Minimum Path Sum"></a>习题2. <a href="https://leetcode.com/problems/minimum-path-sum" target="_blank" rel="external">Minimum Path Sum</a></h3><h3 id="习题3-Edit-Distance"><a href="#习题3-Edit-Distance" class="headerlink" title="习题3. Edit Distance"></a>习题3. <a href="https://leetcode.com/problems/edit-distance" target="_blank" rel="external">Edit Distance</a></h3><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><ul>
<li>本质上是动态规划</li>
<li>动态规划就是解决了重复计算的搜索</li>
<li>动态规划的实现方式：<ul>
<li>循环（从小到大递推）</li>
<li>记忆化搜索（从大到小）<ul>
<li>画搜索树</li>
<li>滚动数组优化，万金油</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="例题1-Longest-Increasing-Subsequence"><a href="#例题1-Longest-Increasing-Subsequence" class="headerlink" title="例题1. Longest Increasing Subsequence"></a>例题1. <a href="https://leetcode.com/problems/longest-increasing-subsequence" target="_blank" rel="external">Longest Increasing Subsequence</a></h3><p>见<a href="https://siyaozhang.github.io/2017/11/18/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92(%E4%B8%8A" target="_blank" rel="external">【九章算法基础班】动态规划</a>/)</p>
<h3 id="例题2-Longest-Increasing-Path-in-a-Matrix"><a href="#例题2-Longest-Increasing-Path-in-a-Matrix" class="headerlink" title="例题2. Longest Increasing Path in a Matrix"></a>例题2. <a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix" target="_blank" rel="external">Longest Increasing Path in a Matrix</a></h3><blockquote>
<p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums = [</div><div class="line">&gt;   [9,9,4],</div><div class="line">&gt;   [6,6,8],</div><div class="line">&gt;   [2,1,1]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Return <code>4</code><br>The longest increasing path is <code>[1, 2, 6, 9]</code>.</p>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums = [</div><div class="line">&gt;   [3,4,5],</div><div class="line">&gt;   [3,2,6],</div><div class="line">&gt;   [2,2,1]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Return <code>4</code><br>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.</p>
</blockquote>
<p>分析：</p>
<p>用for循环解决这道题不知道起点在哪，即初始状态找不到</p>
<p>用搜索：</p>
<p>用搜索的方式，<code>f[i][j]</code> 为以点(i,j)为结尾的最长递增子序列长度，则需要看其上下左右四个点中没有被访问过的点，计算以这些点为结尾的最长递增子序列长度，这样就会有很多重复计算的点，因此可以用记忆化搜索，把计算过的点的信息存储下来，后面用到的时候直接查找即可。</p>
<p>记忆化搜索：</p>
<ul>
<li>状态： <code>f[i][j]</code> 为以点(i,j)为结尾的最长递增子序列长度</li>
<li>转移方程：<ul>
<li>a = +-1;b = 0;</li>
<li>b = +-1;a = 0;</li>
<li><code>f[i][j] =f[x+a][x+b]+1,if(a[x][y]&gt;a[x+a][x+b])</code></li>
</ul>
</li>
<li>初始化<ul>
<li><code>f[i][j] = 1</code> </li>
</ul>
</li>
<li>答案<ul>
<li><code>max f[i][j]</code> </li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestIncreasingPathinaMatrix</span> </span>&#123;</div><div class="line">    <span class="comment">//计算矩阵中ij点的最长递增子序列的长度</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] dp)</span></span>&#123;</div><div class="line">        <span class="comment">//如果已经计算过了</span></div><div class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> dp[i][j];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> rows= matrix.length;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[] x_delta =&#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta =&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span> maxlen = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>;k++)&#123;</div><div class="line">            <span class="keyword">int</span> x = i + x_delta[k];</div><div class="line">            <span class="keyword">int</span> y = j + y_delta[k];</div><div class="line">            <span class="comment">//如果上下左右的节点都没有越界,而且当前点的值大于其相邻点的值</span></div><div class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols &amp;&amp; matrix[i][j] &gt; matrix[x][y])&#123;</div><div class="line">                maxlen = Math.max(maxlen,search(matrix,x,y,dp)+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        dp[i][j] = maxlen;</div><div class="line">        <span class="keyword">return</span> dp[i][j];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line"><span class="comment">//        //初始化每个点最长递增子序列长度为1</span></div><div class="line"><span class="comment">//        for(int i = 0;i &lt; dp.length;i++)&#123;</span></div><div class="line"><span class="comment">//            for(int j = 0 ; j &lt; dp[0].length;j++)&#123;</span></div><div class="line"><span class="comment">//                dp[i][j] = 1;</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; dp.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; dp[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                res = Math.max(res,search(matrix,i,j,dp));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        LongestIncreasingPathinaMatrix test = <span class="keyword">new</span> LongestIncreasingPathinaMatrix();</div><div class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">9</span>,<span class="number">9</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</div><div class="line">        <span class="keyword">int</span> res = test.longestIncreasingPath(matrix);</div><div class="line">        System.out.print(res);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结：什么时候用记忆化搜索"><a href="#总结：什么时候用记忆化搜索" class="headerlink" title="总结：什么时候用记忆化搜索"></a>总结：什么时候用记忆化搜索</h3><ol>
<li>状态转移特别麻烦，不是顺序性。</li>
<li>初始化状态不是很容易找到。</li>
<li>从大到小</li>
</ol>
<h2 id="博弈类DP"><a href="#博弈类DP" class="headerlink" title="博弈类DP"></a>博弈类DP</h2><p>连两个人做游戏</p>
<p>解决博弈类DP通常用记忆化搜索的方法</p>
<h3 id="例题1-coins-in-a-line"><a href="#例题1-coins-in-a-line" class="headerlink" title="例题1.coins in a line"></a>例题1.<a href="http://www.lintcode.com/en/problem/coins-in-a-line/" target="_blank" rel="external">coins in a line</a></h3><blockquote>
<p>There are n coins in a line. Two players take turns to take one or two coins from right side until there are no more coins left. The player who take the last coin wins.</p>
<p>Could you please decide the <strong>first</strong> play will win or lose?</p>
<p>Example</p>
<p>n = <code>1</code>, return <code>true</code>.</p>
<p>n = <code>2</code>, return <code>true</code>.</p>
<p>n = <code>3</code>, return <code>false</code>.</p>
<p>n = <code>4</code>, return <code>true</code>.</p>
<p>n = <code>5</code>, return <code>true</code>.</p>
</blockquote>
<p>两个人轮流选取硬币，每次只能选1个或者2个，取到最后一个石子的人获胜，给定石子数量，返回第一个选的人（先手）能否获胜。</p>
<p>分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">画搜索树，以<span class="number">4</span>个coin为例</div><div class="line">先手层：			 <span class="number">4</span>T</div><div class="line">	   			<span class="number">1</span>↙      ↘<span class="number">2</span></div><div class="line">后手层：		<span class="number">3F</span>	 	   <span class="number">2</span>T</div><div class="line"> 			<span class="number">1</span>↙   ↘<span class="number">2</span>     <span class="number">1</span>↙   ↘<span class="number">2</span></div><div class="line">先手层：     <span class="number">2</span>T     <span class="number">1</span>T   <span class="number">1</span>T      <span class="number">0F</span></div><div class="line">  </div><div class="line">搜索树中的TorF表示当前选择coin的选手的输赢</div><div class="line">因为两个选手都会选择对自己最为有利的方式选取硬币，因此假设两个选手在开始的时候就已经绘制了这样的搜索树，以<span class="number">4</span>枚硬币的情况为例，先手可以选择<span class="number">1</span>个或者<span class="number">2</span>个:</div><div class="line"><span class="number">1</span>. 选<span class="number">1</span>个，还剩<span class="number">3</span>个，此时后手无论选择<span class="number">1</span>个还是<span class="number">2</span>个，先手都可以赢</div><div class="line"><span class="number">2</span>. 选<span class="number">2</span>个，还剩<span class="number">2</span>个，此时后手选<span class="number">2</span>个先手就会输掉比赛</div><div class="line">所以先手选择对自己最为有利的方式，选择<span class="number">1</span>个，赢得比赛。</div><div class="line">由此可见，当前有n个coin的情况下， 该选手是否能够赢得比赛与在剩余n-<span class="number">1</span>和n-<span class="number">2</span>枚硬币的情况下对手是否能够赢得比赛有关。</div><div class="line">以f(i)表示在剩余i枚硬币情况下当前选手是否能够获胜，</div><div class="line">则当下层节点中至少有一个为<span class="keyword">false</span>时，本层即可获胜</div><div class="line">状态转移方程为: f(i) = !f(i-<span class="number">1</span>)||!f(i-<span class="number">2</span>)</div><div class="line">初始化：f(<span class="number">1</span>)=f(<span class="number">2</span>)=<span class="keyword">true</span></div><div class="line">答案：f(i)</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</div><div class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">    dp[<span class="number">1</span>] = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</div><div class="line">        dp[i] = !dp[i-<span class="number">1</span>] || !dp[i-<span class="number">2</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="例题2-coins-in-a-line-II"><a href="#例题2-coins-in-a-line-II" class="headerlink" title="例题2. coins in a line II"></a>例题2. <a href="http://www.lintcode.com/en/problem/coins-in-a-line-ii/" target="_blank" rel="external">coins in a line II</a></h3><blockquote>
<p>There are n coins with different value in a line. Two players take turns to take one or two coins from left side until there are no more coins left. The player who take the coins with the most value wins.</p>
<p>Could you please decide the <strong>first</strong> player will win or lose?</p>
<p>Example</p>
<p>Given values array A = <code>[1,2,2]</code>, return <code>true</code>.</p>
<p>Given A = <code>[1,2,4]</code>, return <code>false</code>.</p>
</blockquote>
<p>给定硬币序列，硬币具有价值，两个人轮流选取硬币，每次可以选1个或者2个获得相应的价值，最终获得价值多的人获胜，问先手能够获胜</p>
<p>分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">f[i]:表示还剩i个硬币，当前取硬币的人最后最多取硬币的价值</div><div class="line">如果f[i]&gt;所有硬币价值的一半则可以获胜</div><div class="line"></div><div class="line">以[5,1,2,10]为例</div><div class="line">先手层：    	 [5,1,2,10]</div><div class="line">		       1↙	    ↘2</div><div class="line">后手层：     [1,2,10]     [2,10]</div><div class="line">		   1↙	 ↘2     1↙   ↘2</div><div class="line">先手层：  [2,10]   [10] [10]    []</div><div class="line"></div><div class="line">两个人在选取硬币的时候，会选择给对方留下尽可能少的价值</div><div class="line">转移方程为：f[i] = sum[i]- min(f[i-1],f[i-2])</div><div class="line">初始化：</div><div class="line">f[1] = coins[i-1]</div><div class="line">f[2] = coins[i-1]+coins[i-2]</div><div class="line">答案：</div><div class="line">if dp[n] &gt; sum[coins]/2</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">if</span>(values.length &lt;= <span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[values.length];</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = values.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">        sum += values[i];</div><div class="line">        sums[i] = sum;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[values.length];</div><div class="line">    dp[<span class="number">0</span>] = sums[sums.length-<span class="number">1</span>];</div><div class="line">    dp[<span class="number">1</span>] = sums[sums.length-<span class="number">2</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; values.length;i++)&#123;</div><div class="line">        dp[i] = sums[values.length-i-<span class="number">1</span>] - Math.min(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[values.length-<span class="number">1</span>] &gt; sums[<span class="number">0</span>]/<span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="例题3-Coins-in-a-Line-III"><a href="#例题3-Coins-in-a-Line-III" class="headerlink" title="例题3. Coins in a Line III"></a>例题3. Coins in a Line III</h3><blockquote>
<p>There are n coins in a line. Two players take turns to take a coin from one of the ends of the line until there are no more coins left. The player with the larger amount of money wins.</p>
<p>Could you please decide the first player will win or lose?</p>
<p><strong>Example</strong></p>
<p>Given array A = [3,2,2], return true.</p>
<p>Given array A = [1,2,4], return true.</p>
<p>Given array A = [1,20,4], return false.</p>
</blockquote>
<p>和II一样coin带有价值，选取时可以从头部或者尾部选取一个coin。</p>
<p>分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">初始：[3, 2, 2]</div><div class="line"></div><div class="line">                  [3, 2, 2]</div><div class="line">                   dp[0][2]</div><div class="line">                /           \</div><div class="line">        取左3  /              \ 取右2</div><div class="line">             /                 \</div><div class="line">         [2, 2]                [3, 2]</div><div class="line">        dp[1][2]              dp[0][1]</div><div class="line">          /    \                  /  \</div><div class="line">   取左2 /       \ 取右2    取左3 /    \ 取右2</div><div class="line">        /         \             /      \</div><div class="line">    [2]            [2]        [2]      [3]</div><div class="line">  dp[2][2]     dp[1][1]     dp[1][1]   dp[0][0]</div><div class="line"> </div><div class="line">这道题目属于区间型dp</div><div class="line">dp[i][j] 现在还第i到第j的硬币，现在当前取硬币的人（先手）最后最多取硬币价值；这里是区间型DP，下标表示区间范围</div><div class="line">转移方程：</div><div class="line">sum[i][j]第i到第j的硬币价值总和</div><div class="line">dp[i][j] = sum[i][j] - min(dp[i+1][j], dp[i][j-1]);</div><div class="line">初始化：</div><div class="line">dp[i][i] = coin[i]</div><div class="line">答案：</div><div class="line">dp[0][n-1] &gt; sum[coins]/2</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//记忆化搜索    </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] values,<span class="keyword">int</span>[][] sums,<span class="keyword">int</span>[][] dp,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> dp[i][j];</div><div class="line">        &#125;</div><div class="line">        dp[i][j] = sums[i][j] - Math.min(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</div><div class="line">        <span class="keyword">return</span> dp[i][j];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] sums = <span class="keyword">new</span> <span class="keyword">int</span>[values.length][values.length];</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[values.length][values.length];</div><div class="line">        <span class="comment">//sums[i][j]为从i到j的coins价值和</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length;i++)&#123;</div><div class="line">            sums[i][i] = values[i];</div><div class="line">            dp[i][i] = values[i];</div><div class="line">            <span class="keyword">int</span> sum = sums[i][i];</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; values.length;j++)&#123;</div><div class="line">                sum += values[j];</div><div class="line">                sums[i][j] = sum;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> search(values,sums,dp,<span class="number">0</span>,values.length-<span class="number">1</span>) &gt; sums[<span class="number">0</span>][values.length-<span class="number">1</span>]/<span class="number">2</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="区间型DP"><a href="#区间型DP" class="headerlink" title="区间型DP"></a>区间型DP</h2><p>特点：</p>
<ol>
<li>求一段区间的解max/min/count</li>
<li>转移方程通过区间更新</li>
<li>从大到小更新，用记忆化搜索</li>
</ol>
<h3 id="例题1-Stone-Game"><a href="#例题1-Stone-Game" class="headerlink" title="例题1. Stone Game"></a>例题1. Stone Game</h3><blockquote>
<p>There is a stone game.At the beginning of the game the player picks <code>n</code> piles of stones in a line.</p>
<p>The goal is to merge the stones in one pile observing the following rules:</p>
<ol>
<li>At each step of the game, the player can merge two adjacent piles to a new pile.</li>
<li>The score is the number of stones in the new pile.</li>
</ol>
<p>You are to determine the <strong>minimum</strong> of the total score.</p>
<p><strong>Example</strong></p>
<p>For <code>[4, 1, 1, 4]</code>, in the best solution, the total score is <code>18</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1. Merge second and third piles =&gt; [4, 2, 4], score +2</div><div class="line">&gt; 2. Merge the first two piles =&gt; [6, 4]，score +6</div><div class="line">&gt; 3. Merge the last two piles =&gt; [10], score +10</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Other two examples:</p>
<p><code>[1, 1, 1, 1]</code> return <code>8</code> <code>[4, 4, 5, 9]</code> return <code>43</code></p>
</blockquote>
<p>给定数组，每次合并相邻元素直至全部合并，每次合并需要花费两个元素价值之和，返回最小的花费</p>
<p>分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">以[3,4,5,6]为例：</div><div class="line">死胡同:容易想到的一个思路从小往大，枚举第一次合并是在哪? 转而用记忆化搜索的思路，从大到小，先考虑最后的0 ~ n-1合并的总花费。</div><div class="line">正确的打开方式：</div><div class="line"></div><div class="line">将区间拆分，看成是两个区间的合并</div><div class="line">                        [3,4,5,6]</div><div class="line">                          (0,3)</div><div class="line">               ↙		   ↓   			 ↘</div><div class="line">      [3]+[4,5,6]	   [3,4]+[5,6]	   [3,4,5]+[6]   </div><div class="line">      (0,0)+(1,3)	   (0,1)+(2,3)	   (0,2)+(3,3)</div><div class="line">            ↙   ↘</div><div class="line">   (1,1)+(2,3) (1,2)+(3,3) .....</div></pre></td></tr></table></figure>
<ul>
<li>State:<ul>
<li><code>dp[i][j]</code>表示把第i到第j个石子合并到一起的最小花费</li>
</ul>
</li>
<li>Function:<ul>
<li>预处理<code>sum[i,j]</code>表示i到j所有石子价值和</li>
<li><code>dp[i][j] = min(dp[i][k]+dp[k+1][j]+sum[i,j])</code> 对于所有<code>k</code>属于<code>{i,j}</code></li>
</ul>
</li>
<li>Intialize:<ul>
<li>for each i<ul>
<li><code>dp[i][i] = 0</code></li>
</ul>
</li>
</ul>
</li>
<li>Answer:<ul>
<li><code>dp[0][n-1]</code></li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] stones,<span class="keyword">int</span>[][] dp,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(i &gt; j)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(dp[i][j]!= <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> dp[i][j];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> minCost = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx = i;idx &lt;= j;idx++)&#123;</div><div class="line">        minCost = Math.min(minCost,Math.min(search(stones,dp,i,idx),search(stones,dp,idx+<span class="number">1</span>,j)));</div><div class="line">    &#125;</div><div class="line">    dp[i][j] = minCost;</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StoneGame</span><span class="params">(<span class="keyword">int</span>[] stones)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[stones.length][stones.length];</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; stones.length;i++)&#123;</div><div class="line">        dp[i][i] = stones[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> search(stones,dp,<span class="number">0</span>,stones.length-<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="例题2-Burst-Balloons"><a href="#例题2-Burst-Balloons" class="headerlink" title="例题2. Burst Balloons"></a>例题2. <a href="https://leetcode.com/problems/burst-balloons" target="_blank" rel="external">Burst Balloons</a></h3><blockquote>
<p>Given <code>n</code> balloons, indexed from <code>0</code> to <code>n-1</code>. Each balloon is painted with a number on it represented by array <code>nums</code>. You are asked to burst all the balloons. If the you burst balloon <code>i</code> you will get <code>nums[left] * nums[i] * nums[right]</code> coins. Here <code>left</code> and <code>right</code> are adjacent indices of <code>i</code>. After the burst, the <code>left</code> and <code>right</code> then becomes adjacent.</p>
<p>Find the maximum coins you can collect by bursting the balloons wisely.</p>
<p><strong>Note:</strong><br>(1) You may imagine <code>nums[-1] = nums[n] = 1</code>. They are not real therefore you can not burst them.<br>(2) 0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</p>
<p><strong>Example:</strong></p>
<p>Given <code>[3, 1, 5, 8]</code></p>
<p>Return <code>167</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</div><div class="line">&gt;    coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>戳气球，每次戳破气球i可以获得价值nums[i-1]*nums[i]&amp;nums[i+1]，返回可以获得的最大利润。</p>
<p>分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">							[3, 1, 5, 8]</div><div class="line">					↙		↙		↘		   ↘</div><div class="line">最后一次打爆的气球:	3		  1			5 		     8</div><div class="line">获得价值：                               1*5*1</div><div class="line">				[1,5,8]   [3,5,8]    [3,1](5)[8]   [3,1,5]</div><div class="line">								  ↙    ↘    ↓    </div><div class="line">最后一次打爆的气球:		           3	   1   8</div><div class="line">获得价值						1*3*5  1*1*5  5*8*1</div><div class="line">						    (3)[1](5) [3](1)(5)</div><div class="line">							    ↓         ↓ </div><div class="line">最后一次打爆的气球:		          1          3</div><div class="line">获得价值				      3*1*5       1*3*1</div></pre></td></tr></table></figure>
<ul>
<li><p>State:</p>
<ul>
<li><code>dp[i][j]</code>表示把第i到第j个气球打爆获得的最大价值</li>
</ul>
</li>
<li><p>Function:</p>
<p>计算<code>dp[i][j]</code> 需要遍历ij区间内所有的点，看做最后一个从ij区间中删除的点，删除该点时获得的价值为<code>nums[i-1]*nums[k]*nums[j+1]</code>，然后再删除该点之前，其左边和右边的节点已经全部被删除，所以转移方程为：</p>
<ul>
<li><code>dp[i][j] = max(nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j])</code> 对于所有<code>k</code>属于<code>{i,j}</code></li>
</ul>
</li>
<li><p>Intialize:</p>
<ul>
<li>for each i<ul>
<li><code>dp[i][i] = 0</code></li>
</ul>
</li>
</ul>
</li>
<li><p>Answer:</p>
<ul>
<li><code>dp[0][n-1]</code></li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">//计算戳破从i到j所有气球获得的coins</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span>[][] max,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(i &gt; j)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果已经计算过了</span></div><div class="line">        <span class="keyword">if</span>(max[i][j] != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> max[i][j];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> maxVal = <span class="number">0</span>;</div><div class="line">        <span class="comment">//假设idx是ij区间中最后一个被戳破的气球</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx = i;idx &lt;= j;idx++)&#123;</div><div class="line">            <span class="keyword">int</span> left = i-<span class="number">1</span> &lt; <span class="number">0</span>?<span class="number">1</span>:nums[i-<span class="number">1</span>];</div><div class="line">            <span class="keyword">int</span> right = j+<span class="number">1</span> &gt;= nums.length ?<span class="number">1</span>:nums[j+<span class="number">1</span>];</div><div class="line">            <span class="keyword">int</span> temp = left * right * nums[idx];</div><div class="line">            maxVal = Math.max(maxVal,temp + solve(nums,max,i,idx-<span class="number">1</span>) + solve(nums,max,idx+<span class="number">1</span>,j));</div><div class="line">        &#125;</div><div class="line">        max[i][j] = maxVal;</div><div class="line">        <span class="keyword">return</span> maxVal;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][nums.length];<span class="comment">//打爆ij所有气球的最大值</span></div><div class="line">        <span class="comment">//Arrays.fill(max,-1);</span></div><div class="line">        <span class="keyword">return</span> solve(nums,max,<span class="number">0</span>,nums.length-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="例题3-Scramble-String"><a href="#例题3-Scramble-String" class="headerlink" title="例题3. Scramble String"></a>例题3. <a href="https://leetcode.com/problems/scramble-string" target="_blank" rel="external">Scramble String</a></h3><blockquote>
<p>Given a string <em>s1</em>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p>
<p>Below is one possible representation of <em>s1</em> = <code>&quot;great&quot;</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     great</div><div class="line">&gt;    /    \</div><div class="line">&gt;   gr    eat</div><div class="line">&gt;  / \    /  \</div><div class="line">&gt; g   r  e   at</div><div class="line">&gt;            / \</div><div class="line">&gt;           a   t</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>To scramble the string, we may choose any non-leaf node and swap its two children.</p>
<p>For example, if we choose the node <code>&quot;gr&quot;</code> and swap its two children, it produces a scrambled string <code>&quot;rgeat&quot;</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     rgeat</div><div class="line">&gt;    /    \</div><div class="line">&gt;   rg    eat</div><div class="line">&gt;  / \    /  \</div><div class="line">&gt; r   g  e   at</div><div class="line">&gt;            / \</div><div class="line">&gt;           a   t</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>We say that <code>&quot;rgeat&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p>
<p>Similarly, if we continue to swap the children of nodes <code>&quot;eat&quot;</code> and <code>&quot;at&quot;</code>, it produces a scrambled string <code>&quot;rgtae&quot;</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     rgtae</div><div class="line">&gt;    /    \</div><div class="line">&gt;   rg    tae</div><div class="line">&gt;  / \    /  \</div><div class="line">&gt; r   g  ta  e</div><div class="line">&gt;        / \</div><div class="line">&gt;       t   a</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>We say that <code>&quot;rgtae&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p>
<p>Given two strings <em>s1</em> and <em>s2</em> of the same length, determine if <em>s2</em> is a scrambled string of <em>s1</em></p>
</blockquote>
<p>分析：</p>
<p>对于s1和s2，找不同的分割点k，将其分别分为两个子数组。若s1的两个子数组和对应的s2的两个子数组都是scramble的，则s1和s2就是scramble的。例如，s1[0…i]被分为0…k，k+1…i，其对应的s2子数组为0…k，k+1…i或者0…i-k-1, i-k…i（即s2的前k个元素或者后k个元素对应于s1的前k个元素，比如s1=abc，s2=acb，第一层递归时比较的是s1左边的子数组和s2左边的子数组以及s1右边的子数组和s2右边的子数组，第二层递归比较右边两个子数组时，就要比较s1右边子数组的左边子数组”b”和s2右边子数组的右边子数组”b”），只要两种情况里面有一种满足，则s1和s2就是scramble的。</p>
<p>( isScramble(s2[0…k], s1[0…k]) &amp;&amp; isScramble(s2[k+1…j], s1[k+1…i]) ) || ( isScramble(s2[0…k], s1[i-k…i]) &amp;&amp; isScramble(s2[k+1…j], s1[0…i-k-1]) )，（k = 0,1,2 … i-1，k相当于字符串的分割点)</p>
<p>因此可以用记忆化搜索来保存子问题，设dp[i][j][k]表示s2从j开始长度为k的子串是否可以由s1从i开始长度为k的子串转换而成:</p>
<p>状态：</p>
<p><code>dp[i][j][k]</code> 表示s1从第i个开始s2从第j个开始的k个字母是否是scramble string</p>
<p>因此状态转移方程为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">对于所有的i属于[1,k]:</div><div class="line">s11 = s1.substring(0, i);  </div><div class="line">s12 = s1.substring(i, i+k-1); </div><div class="line">s21 = s2.substring(0, i);  </div><div class="line">s22 = s2.substring(i, i+k-1)</div><div class="line">s23 = s2.substring(j, j+k-i-1);  </div><div class="line">s24 = s2.substring(j+k-i, j+k-1); </div><div class="line">for i = x -&gt; x+k ：</div><div class="line">  dpx[k] = (dpx[i] &amp;&amp; dpx+i[k-i]) || dpx[i] &amp;&amp; dpx+i[k-i])</div></pre></td></tr></table></figure>
<p>初始化：</p>
<p><code>dp[i][j][1] = s1[i]==s[j].</code></p>
<p>答案：</p>
<p><code>dp[0][0][len]</code></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">boolean</span>[][][] dp,<span class="keyword">boolean</span>[][][] visited,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">        <span class="comment">//如果计算过了，直接返回</span></div><div class="line">        <span class="keyword">if</span>(visited[i][j][k])&#123;</div><div class="line">            <span class="keyword">return</span> dp[i][j][k];</div><div class="line">        &#125;</div><div class="line">        dp[i][j][k] = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">1</span>;idx &lt; k;idx++)&#123;</div><div class="line">            <span class="keyword">if</span>((search(dp,visited,i,j,idx) &amp;&amp; search(dp,visited,i+idx,j+idx,k-idx) )||</div><div class="line">                    (search(dp,visited,i,j+k-idx,idx) &amp;&amp; search(dp,visited,i+idx,j,k-idx)))&#123;</div><div class="line">                dp[i][j][k] = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        visited[i][j][k] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> dp[i][j][k];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s1.length() != s2.length())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> len = s1.length();</div><div class="line">        <span class="keyword">boolean</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len][len+<span class="number">1</span>];</div><div class="line">        <span class="keyword">boolean</span>[][][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len][len+<span class="number">1</span>];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len;j++)&#123;</div><div class="line">                dp[i][j][<span class="number">1</span>] = s1.charAt(i)== s2.charAt(j);</div><div class="line">                visited[i][j][<span class="number">1</span>] = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> search(dp,visited,<span class="number">0</span>,<span class="number">0</span>,len);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>递归也可以做</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s1.equals(s2)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s1.length();i++) &#123;</div><div class="line">            count[s1.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">            count[s2.charAt(i) - <span class="string">'a'</span>]--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count.length;i++) &#123;</div><div class="line">            <span class="keyword">if</span>(count[i] != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s1.length();i++) &#123;</div><div class="line">            <span class="keyword">if</span>(isScramble(s1.substring(<span class="number">0</span>, i), s2.substring(<span class="number">0</span>, i)) </div><div class="line">               &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(isScramble(s1.substring(<span class="number">0</span>, i), s2.substring(s2.length()-i)) </div><div class="line">               &amp;&amp; isScramble(s1.substring(i), s2.substring(<span class="number">0</span>, s2.length()-i))) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="背包类DP"><a href="#背包类DP" class="headerlink" title="背包类DP"></a>背包类DP</h2><p>特点：</p>
<ol>
<li>用值作为DP维度</li>
<li>DP过程就是填写矩阵</li>
<li>可以用滚动数组优化</li>
</ol>
<h3 id="例题1-Backpack"><a href="#例题1-Backpack" class="headerlink" title="例题1. Backpack"></a>例题1. <a href="http://www.lintcode.com/en/problem/backpack/" target="_blank" rel="external">Backpack</a></h3><blockquote>
<p>Given <em>n</em> items with size Ai, an integer <em>m</em> denotes the size of a backpack. How full you can fill this backpack?</p>
<p>Example</p>
<p>If we have <code>4</code> items with size <code>[2, 3, 5, 7]</code>, the backpack size is 11, we can select <code>[2, 3, 5]</code>, so that the max size we can fill this backpack is <code>10</code>. If the backpack size is <code>12</code>. we can select <code>[2, 3, 7]</code> so that we can fulfill the backpack.</p>
<p>You function should return the max size we can fill in the given backpack.</p>
</blockquote>
<p>给定背包容量和物品数组，返回最大的</p>
<p>分析：</p>
<p>不可以用贪心，比如[8,7,5]，容量为12</p>
<p>如果用贪心法放了8就放不下其他的了，但是放7和5得到的总容量更大，所以不能用贪心法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">以items = [2,3,4,5]，size=11为例分析：</div><div class="line"></div><div class="line">定以一个矩阵，行数为items.length，列数为size</div><div class="line"></div><div class="line">idx 0	1	2	3	4	5	6	7	...</div><div class="line"> 0	T	F	F	F	F	F	F	F	...</div><div class="line"> 1	T	F	T	F	F	F	F	F	...</div><div class="line"> 2	T	F	T	T	F	T	F	F	...</div><div class="line"> 3	T	...</div><div class="line"> 4	T	...</div><div class="line"></div><div class="line">state:</div><div class="line">f[i][S]表示在前i个物品中取出一些能否组成和为S</div><div class="line"></div><div class="line">function：</div><div class="line">在前i个物品中是否有选择方式使得取出的物品和为S，可以分两种情况讨论：</div><div class="line">1. 选择第i个物品：需要考虑在前i-1和物品中是否可以选取一些物品组成s-a[i]</div><div class="line">2. 不选第i个物品：需要考虑在前i-1和物品中是否可以选取一些物品组成s</div><div class="line">因此状态转移方程为:</div><div class="line">f[i][S] = f[i-1][s-a[i]] or f[i-1][s]</div><div class="line"></div><div class="line">initial:</div><div class="line">f[i][0] = true;</div><div class="line">f[0][j] = false;j!=0</div><div class="line"></div><div class="line">answer:</div><div class="line">max j,f[i][j] = true;</div><div class="line"></div><div class="line">滚动数组优化：</div><div class="line">可以看出来f[i][S]只与前一行有关，所以可以进行二位滚动数组优化</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[A.length+<span class="number">1</span>][m+<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m+<span class="number">1</span>;i++)&#123;</div><div class="line">        dp[<span class="number">0</span>][i] = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m+<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; A.length+<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(i-A[j-<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</div><div class="line">                dp[j][i] = dp[j-<span class="number">1</span>][i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                dp[j][i] = dp[j-<span class="number">1</span>][i-A[j-<span class="number">1</span>]] || dp[j-<span class="number">1</span>][i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(dp[j][i])&#123;</div><div class="line">                res =i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="例题2-BackPack马甲变换1，硬币凑整"><a href="#例题2-BackPack马甲变换1，硬币凑整" class="headerlink" title="例题2. BackPack马甲变换1，硬币凑整"></a>例题2. BackPack马甲变换1，硬币凑整</h3><p>给定面值1,2,5,10的硬币无穷多个，请问能够凑成80元的方案总数。</p>
<p>分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">states：</div><div class="line">dp[i][j]表示用前i种硬币凑成j元钱的方案总数</div><div class="line"></div><div class="line">以[1,2,5,10] total = 80 为例：</div><div class="line">依然采用填写矩阵的方式</div><div class="line">idx	0	1	2	3	4	5	6	7	8	9	10	...</div><div class="line">0	1	0	0	0	0	0	0	0	0	0	0	...</div><div class="line">1	1	1	1	1	1	1	1	1	1	1	1	...</div><div class="line">2	1	1	2	2	3	3	...</div><div class="line">3	1	...</div><div class="line">4	1</div><div class="line"></div><div class="line">动态转移方程：</div><div class="line">用前i种硬币凑成j元，考虑第i种硬币取的个数k</div><div class="line">dp[i][j] = dp[i-1][j-val[i]] +....+dp[i-1][j-val[i]*k]</div><div class="line"></div><div class="line">初始化：</div><div class="line">dp[i][0] = 1;</div><div class="line">dp[0][j] = 0;(j!=0)</div><div class="line"></div><div class="line">答案：</div><div class="line">dp[val.length][total]</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length+<span class="number">1</span>][m+<span class="number">1</span>];</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m+<span class="number">1</span>;i++)&#123;</div><div class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; m+<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span>(k * A[i-<span class="number">1</span>] &lt;= m)&#123;</div><div class="line">                dp[i][j] += dp[i-<span class="number">1</span>][j-k*A[i-<span class="number">1</span>]];</div><div class="line">                k++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[A.length][m];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="例题3-Coin-Change"><a href="#例题3-Coin-Change" class="headerlink" title="例题3. Coin Change"></a>例题3. <a href="https://leetcode.com/problems/coin-change/description/" target="_blank" rel="external">Coin Change</a></h3><blockquote>
<p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p><strong>Example 1:</strong><br>coins = <code>[1, 2, 5]</code>, amount = <code>11</code><br>return <code>3</code> (11 = 5 + 5 + 1)</p>
<p><strong>Example 2:</strong><br>coins = <code>[2]</code>, amount = <code>3</code><br>return <code>-1</code>.</p>
</blockquote>
<p>给定硬币面值，和总价值，返回能凑成总价值所用硬币数的最小值</p>
<p>思路：</p>
<p>和上一题思路类似</p>
<p>state:</p>
<p><code>dp[i][j]</code> 表示用i种硬币凑成j元所需要的最少硬币数量</p>
<p>function：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dp[i][j] = min&#123;dp[i-1][j-k*A[i-1]]+k&#125;</div><div class="line">for each k*A[i-1]] &lt;= amout &amp;&amp; dp[i-1][j-k*A[i-1]] != 0</div></pre></td></tr></table></figure>
<p>initial：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dp[i][0] = 1;</div><div class="line">dp[0][j] = 0;(j!=0)</div></pre></td></tr></table></figure>
<p>answer：</p>
<p><code>dp[coins.length][amount]</code></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[coins.length+<span class="number">1</span>][amount+<span class="number">1</span>];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;coins.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; amount+<span class="number">1</span>;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</div><div class="line">                    dp[i][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    dp[i][j] = -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; coins.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; amount+<span class="number">1</span>;j++)&#123;</div><div class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">                <span class="keyword">int</span> minCount = Integer.MAX_VALUE;</div><div class="line">                <span class="keyword">while</span>(k * coins[i-<span class="number">1</span>] &lt;= j)&#123;</div><div class="line">                    <span class="keyword">if</span>(dp[i-<span class="number">1</span>][j-k*coins[i-<span class="number">1</span>]] != -<span class="number">1</span>)&#123;</div><div class="line">                        minCount = Math.min(minCount,dp[i-<span class="number">1</span>][j-k*coins[i-<span class="number">1</span>]]+k);</div><div class="line">                    &#125;</div><div class="line">                    k++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(minCount != Integer.MAX_VALUE)&#123;</div><div class="line">                    dp[i][j] = minCount;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(dp[coins.length][amount] == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> dp[coins.length][amount];</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>优化：</p>
<h3 id="例题4-BackPack-马甲变换2"><a href="#例题4-BackPack-马甲变换2" class="headerlink" title="例题4. BackPack 马甲变换2"></a>例题4. BackPack 马甲变换2</h3><p>把一个数组[1,24,5,6]尽量平分</p>
<p>可以转化为背包问题：</p>
<p>数组总和为36，一半为18</p>
<p>背包容量为18，用数组中的数字尽量将背包装满</p>
<h3 id="Partition-Equal-Subset-Sum"><a href="#Partition-Equal-Subset-Sum" class="headerlink" title="Partition Equal Subset Sum"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum" target="_blank" rel="external">Partition Equal Subset Sum</a></h3><blockquote>
<p>Given a <strong>non-empty</strong> array containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<p><strong>Note:</strong></p>
<ol>
<li>Each of the array element will not exceed 100.</li>
<li>The array size will not exceed 200.</li>
</ol>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1, 5, 11, 5]</div><div class="line">&gt;</div><div class="line">&gt; Output: true</div><div class="line">&gt;</div><div class="line">&gt; Explanation: The array can be partitioned as [1, 5, 5] and [11].</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1, 2, 3, 5]</div><div class="line">&gt;</div><div class="line">&gt; Output: false</div><div class="line">&gt;</div><div class="line">&gt; Explanation: The array cannot be partitioned into equal sum subsets.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>返回是否能够取到整个数组的一半。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionEqualSubsetSum</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span> != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        sum = sum/<span class="number">2</span>;</div><div class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length+<span class="number">1</span>][sum+<span class="number">1</span>];</div><div class="line">        <span class="comment">//chushihua</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; sum+<span class="number">1</span>;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(j &lt; nums[i-<span class="number">1</span>])&#123;</div><div class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] || dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[nums.length][sum];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="例题5-Backpack-II"><a href="#例题5-Backpack-II" class="headerlink" title="例题5.  Backpack II"></a>例题5.  <a href="http://www.lintcode.com/en/problem/backpack-ii/" target="_blank" rel="external">Backpack II</a></h3><p>给定物品占空间和物品价值数组，背包容量，如何装能够使得背物品价值最高</p>
<p>不可以用贪心算法</p>
<p>分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">依然采用补全矩阵的方法</div><div class="line">体积数组为A，价值数组为val,容量为S</div><div class="line">state：</div><div class="line">f[i][j]表示在前i个物品中选取一些物品，构成总体积为j，所获得的最高价值是多少</div><div class="line">function：</div><div class="line">考虑第i个物品，有选和不选两种情况：</div><div class="line"><span class="number">1</span>. 选：总价值为f[i-<span class="number">1</span>][j-A[i-<span class="number">1</span>]] + val[i-<span class="number">1</span>]</div><div class="line"><span class="number">2</span>. 不选：总价值为f[i-<span class="number">1</span>][j]</div><div class="line">取两者之中较大的，因此状态转移方程为：</div><div class="line">f[i][j] = max(f[i-<span class="number">1</span>][j],f[i-<span class="number">1</span>][j-A[i-<span class="number">1</span>]] + val[i-<span class="number">1</span>])</div><div class="line">initial:</div><div class="line">f[<span class="number">0</span>][i] = <span class="number">0</span></div><div class="line">f[i][<span class="number">0</span>] = <span class="number">0</span></div><div class="line">answer：</div><div class="line">f[A.length][S]</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackII</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length+<span class="number">1</span>][m+<span class="number">1</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m+<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(j &gt;= A[i-<span class="number">1</span>])&#123;</div><div class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-A[i-<span class="number">1</span>]]+V[i-<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[A.length][m];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="例题6-K-Sum"><a href="#例题6-K-Sum" class="headerlink" title="例题6. K Sum"></a>例题6. K Sum</h3><p>给定数组A=[1,2,3,4],k=2,target=5</p>
<p>在A中选2个元素，和为5，返回方案个数</p>
<p>思路：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">state:</div><div class="line">f[i][j][k]表示在前i个元素中选取j个出来和为t个方案个数</div><div class="line">function:</div><div class="line">考虑第i个元素，有选和不选两种方案，两种方案数求和</div><div class="line">f[i][j][k] = f[i-<span class="number">1</span>][j-<span class="number">1</span>][t-A[i-<span class="number">1</span>]] + f[i-<span class="number">1</span>][j][t]</div><div class="line">initial:</div><div class="line">f[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">answer:</div><div class="line">f[A.length][k][target]</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> A: An integer array</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> k: A positive integer (k &lt;= length(A))</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> target: An integer</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span>: An integer</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kSum</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length+<span class="number">1</span>][k+<span class="number">1</span>][target+<span class="number">1</span>];</div><div class="line">        <span class="comment">//Chushihua</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; k+<span class="number">1</span>;j++)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>;l &lt; target+<span class="number">1</span>;l++)&#123;</div><div class="line">                    <span class="keyword">if</span>(l &gt;= A[i-<span class="number">1</span>])&#123;</div><div class="line">                        dp[i][j][l] = dp[i-<span class="number">1</span>][j][l] + dp[i-<span class="number">1</span>][j-<span class="number">1</span>][l-A[i-<span class="number">1</span>]];</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span>&#123;</div><div class="line">                        dp[i][j][l] = dp[i-<span class="number">1</span>][j][l];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[A.length][k][target];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优化：</p>
<h3 id="例题7-Minnimum-Adjus"><a href="#例题7-Minnimum-Adjus" class="headerlink" title="例题7. Minnimum Adjus"></a>例题7. Minnimum Adjus</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>区间类DP<ul>
<li>从大到小去思考，将区间划分成小区间</li>
<li>主要通过记忆化搜索来解决</li>
</ul>
</li>
<li>背包类DP<ul>
<li>用值座位DP维度</li>
<li>用for循环填写矩阵数值</li>
<li>可以用滚动数组做优化</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【面经】算法相关]]></title>
      <url>/2018/03/07/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h3 id="1-海量数据选取TOPK"><a href="#1-海量数据选取TOPK" class="headerlink" title="1. 海量数据选取TOPK"></a>1. 海量数据选取TOPK</h3><p>baseline：</p>
<p>用堆，如果取最大的K个，就用最小堆，遍历数组，遇到比堆顶元素大的元素就入堆，同时堆中元素超过k个需要poll操作，保证堆中只有K个元素，最终的topk元素在堆中。</p>
<p>时间复杂度分析:</p>
<script type="math/tex; mode=display">O(n*logk)$$ ，元素入堆复杂度$$O(logk)</script><p><strong><script type="math/tex">O(n)</script>算法：</strong></p>
<p>先用quick select方法找到第K大的元素，复杂度<script type="math/tex">O(n)</script></p>
<p>然后再遍历一遍，将大于K的元素取出，复杂度<script type="math/tex">O(n)</script></p>
<p>总复杂度<script type="math/tex">O(n)</script></p>
<p>！！！！！卧槽！神奇！！！！</p>
<p><strong>follow up：海量数据选取第K大</strong></p>
<p>Quick Select，详见<a href="/2018/02/02/【九章算法强化班】两指针/" title="【九章算法强化班】两指针">【九章算法强化班】两指针</a> </p>
<p>时间复杂度<script type="math/tex">O(n)</script></p>
<h3 id="2-大数排序问题"><a href="#2-大数排序问题" class="headerlink" title="2. 大数排序问题"></a>2. 大数排序问题</h3><p>海量数据排序怎么做？</p>
<p>baseline：快排，问题：数据量很大，内存根本存不下，不可行</p>
<p><strong>桶排序：</strong></p>
<p>将数据分桶，每个桶存入一个文件，然后文件内部有序，取出合并的时候可以用K路归并，优化：k路可以建个堆</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【实习项目总结】]]></title>
      <url>/2018/03/07/%E3%80%90%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91/</url>
      <content type="html"><![CDATA[<h2 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h2><p>无线短视频推荐项目，负责无线端用户的短视频推荐，也就是给手机端用户推荐短视频。主要用到了item-based协同过滤的思想，为用户提供候选短视频推荐集合，然后再利用预训练的LR模型返回候选推荐集合的最终排序，推给用户。</p>
<h2 id="2-推荐系统分类"><a href="#2-推荐系统分类" class="headerlink" title="2. 推荐系统分类"></a>2. 推荐系统分类</h2><p>感谢@<a href="https://www.zhihu.com/question/20326697/answer/58148605" target="_blank" rel="external">奔波的梦想</a> 的总结。推荐算法大致可以分为三类：基于内容的推荐算法、协同过滤推荐算法和基于知识的推荐算法。<br>​         <strong>基于内容的推荐算法</strong>，原理是用户喜欢和自己关注过的Item在内容上类似的Item，比如你看了哈利波特I，基于内容的推荐算法发现哈利波特II-VI，与你以前观看的在内容上面（共有很多关键词）有很大关联性，就把后者推荐给你，这种方法可以避免Item的冷启动问题（冷启动：如果一个Item从没有被关注过，其他推荐算法则很少会去推荐，但是基于内容的推荐算法可以分析Item之间的关系，实现推荐），弊端在于推荐的Item可能会重复，典型的就是新闻推荐，如果你看了一则关于MH370的新闻，很可能推荐的新闻和你浏览过的，内容一致；另外一个弊端则是对于一些多媒体的推荐（比如音乐、电影、图片等)由于很难提内容特征，则很难进行推荐，一种解决方式则是人工给这些Item打标签。<br>​        <strong>协同过滤算法</strong>，原理是用户喜欢那些具有相似兴趣的用户喜欢过的商品，比如你的朋友喜欢电影哈利波特I，那么就会推荐给你，这是最简单的基于用户的协同过滤算法（user-based collaboratIve filtering），还有一种是基于Item的协同过滤算法（item-based collaborative filtering），这两种方法都是将用户的所有数据读入到内存中进行运算的，因此成为Memory-based Collaborative Filtering，另一种则是Model-based collaborative filtering，包括Aspect Model，pLSA，LDA，聚类，SVD，Matrix Factorization等，这种方法训练过程比较长，但是训练完成后，推荐过程比较快。<br>​       最后一种方法是基于知识的推荐算法，也有人将这种方法归为基于内容的推荐，这种方法比较典型的是构建领域本体，或者是建立一定的规则，进行推荐。</p>
<p><strong>item-based 和 user-based 协同过滤的比较：</strong></p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-08-09-51-55.png" alt=""> </p>
<p>我们再来回顾一下<strong>item-base CF算法的特点</strong>：</p>
<ul>
<li>物品数明显小于用户数的场合，否则物品相似度矩阵计算代价很大</li>
<li>适合长尾物品丰富，用户个性化需求强的领域</li>
<li>对新用户友好，对新物品不友好，因为物品相似度矩阵不需要很强的实时性</li>
<li>利用用户历史行为做推荐解释，比较令用户信服</li>
</ul>
<p>所以item-base挺适合做电影的推荐。当用户浏览某个电影的时候，我们可以推荐给他类似的电影，或者根据用户以前的观影记录，推荐他感兴趣的电影。</p>
<h2 id="3-项目流程"><a href="#3-项目流程" class="headerlink" title="3. 项目流程"></a>3. 项目流程</h2><ol>
<li>根据集群中7天用户-视频score数据，计算视频两两之间的余弦相似度</li>
<li>为每个视频选取与之相似度&gt;0.5且最接近的top40个视频</li>
<li>根据用户7天之内看过的视频，将相似视频merge进来，根据看过视频的score和相似视频的余弦相似度乘积，对看过的所有视频的所有相似视频打分，取top50作为用户的推荐视频候选集（去掉已经看过的视频）</li>
<li>根据线上抽取的特征和用户、视频15天线下特征输入预训练的LR得到候选集合的点击率排序，作为最终的推荐顺序。</li>
</ol>
<h2 id="4-CF核心思路"><a href="#4-CF核心思路" class="headerlink" title="4. CF核心思路"></a>4. CF核心思路</h2><pre><code>* user1     user2
* item1  score11   score21 (X)
* item2  score12   score22 (Y)
* --------------------------------
* sim(item1,item2) = XY / math.sqrt(XX) * math.sqrt(YY)
* XY= score11 * score12 + score21 * score22
* XX = score11 * score11 + score21 * score21
* YY = score12 * score12 + score22 * score22
</code></pre><p>已知一周内，用户观看视频的数据，形式为RDD[(uid,(aid,score))]</p>
<p>按照uid做一次join操作，就可以得到RDD[((aid1,aid2),(score11,score22))]，即用户对以及同时看过两者的用户对其的score</p>
<p>接下来就可以计算出aid对的余弦相似度了</p>
<p>然后根据余弦相似度为每个aid选出最相近的top40相似ad</p>
<h2 id="5-优化方向"><a href="#5-优化方向" class="headerlink" title="5. 优化方向"></a>5. 优化方向</h2><p>暂时就想到了一个：</p>
<p>将用户对电影的score做时间衰减</p>
<p>之后继续补充</p>
<h2 id="6-核心代码"><a href="#6-核心代码" class="headerlink" title="6. 核心代码"></a>6. 核心代码</h2><figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> model</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.spark.broadcast.<span class="type">Broadcast</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</div><div class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;<span class="type">DataFrame</span>&#125;</div><div class="line"><span class="keyword">import</span> org.apache.spark.sql.hive.<span class="type">HiveContext</span></div><div class="line"><span class="keyword">import</span> util.<span class="type">MqManager</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">  * Created by dengxing on 2017/7/18.</span></div><div class="line"><span class="comment">  */</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">CF</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/** 基于dt时间获取原始数据源</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @param sc    SparkContext</span></div><div class="line"><span class="comment">    * @param table 转换的hive表</span></div><div class="line"><span class="comment">    * @param day   获取当前日期的数据</span></div><div class="line"><span class="comment">    * @return 原始数据的dataFrame</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getResource</span></span>(sc: <span class="type">SparkContext</span>, table: <span class="type">String</span>, day: <span class="type">String</span>) = &#123;</div><div class="line">    <span class="keyword">val</span> hiveContext = <span class="keyword">new</span> <span class="type">HiveContext</span>(sc)</div><div class="line">    <span class="keyword">import</span> hiveContext.sql</div><div class="line">    <span class="keyword">val</span> resource = sql(<span class="string">"select "</span></div><div class="line">      + <span class="string">"uid,"</span></div><div class="line">      + <span class="string">"aid,"</span></div><div class="line">      + <span class="string">"cnt"</span></div><div class="line">      + <span class="string">" from "</span> + table + <span class="string">" where dt ='"</span> + day + <span class="string">"'"</span>)</div><div class="line">    resource</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">    * 分布式计算余弦相似度</span></div><div class="line"><span class="comment">    * --------------------------------</span></div><div class="line"><span class="comment">    * user1     user2</span></div><div class="line"><span class="comment">    * item1  score11   score21 (X)</span></div><div class="line"><span class="comment">    * item2  score12   score22 (Y)</span></div><div class="line"><span class="comment">    * --------------------------------</span></div><div class="line"><span class="comment">    * sim(item1,item2) = XY / math.sqrt(XX) * math.sqrt(YY)</span></div><div class="line"><span class="comment">    * XY= score11 * score12 + score21 * score22</span></div><div class="line"><span class="comment">    * XX = score11 * score11 + score21 * score21</span></div><div class="line"><span class="comment">    * YY = score12 * score12 + score22 * score22</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @param resource</span></div><div class="line"><span class="comment">    * @return RDD[(item1,item2,sim)]</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getCosineSimilarity</span></span>(resource: <span class="type">DataFrame</span>): <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">String</span>, <span class="type">Double</span>))] = &#123;</div><div class="line">    <span class="keyword">val</span> rating = resource.map &#123;</div><div class="line">      row =&gt; &#123;</div><div class="line">        <span class="keyword">val</span> uid = row.getString(<span class="number">0</span>)</div><div class="line">        <span class="keyword">val</span> aid = row.getString(<span class="number">1</span>)</div><div class="line">        <span class="keyword">val</span> score = row.getString(<span class="number">2</span>).toDouble</div><div class="line">        (uid, aid, score)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//RDD[(uid,(aid,score))]</span></div><div class="line">    <span class="keyword">val</span> user_item_score = rating.map(f =&gt; (f._1, (f._2, f._3)))</div><div class="line">    </div><div class="line">	<span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取每个用户有过行为的item键值对,即</span></div><div class="line"><span class="comment">     * RDD[((aid1,aid2),(score11,score22))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_score_pair = user_item_score.join(user_item_score)</div><div class="line">      .map(f =&gt; ((f._2._1._1, f._2._2._1), (f._2._1._2, f._2._2._2)))</div><div class="line">    </div><div class="line">	<span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取同一对item，所有的用户评分向量的点积，即XY 及 XX 及 YY</span></div><div class="line"><span class="comment">     * RDD[((aid1,aid2),score11 * score12 + score21 * score22)]</span></div><div class="line"><span class="comment">     * 及 RDD[((aid1,aid1),score11 * score11 + score21 * score21)]</span></div><div class="line"><span class="comment">     * 及 RDD[((aid2,aid2),score12 * score12 + score22 * score22)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_pair_ALL = item_score_pair.map(f =&gt; (f._1, f._2._1 * f._2._2)).reduceByKey(_ + _)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取每个item，所有用户的自向量的点积，即XX或YY</span></div><div class="line"><span class="comment">     * RDD[((aid1,aid1),score11 * score11 + score21 * score21)]</span></div><div class="line"><span class="comment">     * 或 RDD[((aid2,aid2),score12 * score12 + score22 * score22)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_pair_XX_YY = item_pair_ALL.filter(f =&gt; f._1._1 == f._1._2)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取每个item，所有用户的非自向量的点积，即XY</span></div><div class="line"><span class="comment">     * RDD[((aid1,aid2),score11 * score12 + score21 * score22)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_pair_XY = item_pair_ALL.filter(f =&gt; f._1._1 != f._1._2)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取item_pair_XX_YY中的item及XX或YY</span></div><div class="line"><span class="comment">     * RDD[(aid1,score11 * score11 + score21 * score21)]</span></div><div class="line"><span class="comment">     * 或 RDD[(aid2,score12 * score12 + score22 * score22)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_XX_YY = item_pair_XX_YY.map(f =&gt; (f._1._1, f._2))</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     *  转化item_pair_XY为(aid1,((aid1,aid2,XY),XX)))</span></div><div class="line"><span class="comment">     *  RDD[(aid1,((aid1,aid2,score11 * score12 + score21 * score22),score11 * score11 + score21 * score21)))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="keyword">val</span> item_XY_XX = item_pair_XY.map(f =&gt; (f._1._1, (f._1._1, f._1._2, f._2))).join(item_XX_YY)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     *  转为item_XY_XX为(aid2,((aid1,aid2,XY,XX),YY))</span></div><div class="line"><span class="comment">     *  RDD[(aid2,((aid1,aid2,score11 * score12 + score21 * score22,score11 * score11 + score21 * score21),score12 * score12 + score22 * score22))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_XY_XX_YY = item_XY_XX.map(f =&gt; (f._2._1._2, (f._2._1._1, f._2._1._2, f._2._1._3, f._2._2))).join(item_XX_YY)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     *  提取item_XY_XX_YY中的(aid1,aid2,XY,XX,YY))</span></div><div class="line"><span class="comment">     *  RDD[(aid1,aid2,score11 * score12 + score21 * score22,score11 * score11 + score21 * score21,score12 * score12 + score22 * score22)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_pair_XY_XX_YY = item_XY_XX_YY.map(f =&gt; (f._2._1._1, f._2._1._2, f._2._1._3, f._2._1._4, f._2._2))</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     *  转化item_pair_XY_XX_YY为(aid1,aid2,XY / math.sqrt(XX * YY))</span></div><div class="line"><span class="comment">     *  RDD[(aid1,aid2,score11 * score12 + score21 * score22 / math.sqrt((score11 * score11 + score21 * score21)*(score12 * score12 + score22 * score22))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_pair_sim = item_pair_XY_XX_YY.map(f =&gt; (f._1, (f._2, f._3 / math.sqrt(f._4 * f._5))))</div><div class="line">    item_pair_sim</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">    * 基于item相似度矩阵为user生成topN推荐列表</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @param resource</span></div><div class="line"><span class="comment">    * @param item_sim_bd</span></div><div class="line"><span class="comment">    * @param topN</span></div><div class="line"><span class="comment">    * @return RDD[(user,List[(item,score)])]</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">recommend</span></span>(resource: <span class="type">DataFrame</span>, item_sim_bd: <span class="type">Broadcast</span>[scala.collection.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Double</span>)]]], topN: <span class="type">Int</span> = <span class="number">50</span>) = &#123;</div><div class="line">    <span class="keyword">val</span> user_item_score = resource.map(</div><div class="line">      row =&gt; &#123;</div><div class="line">        <span class="keyword">val</span> uid = row.getString(<span class="number">0</span>)</div><div class="line">        <span class="keyword">val</span> aid = row.getString(<span class="number">1</span>)</div><div class="line">        <span class="keyword">val</span> score = row.getString(<span class="number">2</span>).toDouble</div><div class="line">        ((uid, aid), score)</div><div class="line">      &#125;</div><div class="line">    )</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取item_sim_user_score为((user,item2),sim * score)</span></div><div class="line"><span class="comment">     * RDD[(user,item2),sim * score]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> user_item_simscore = user_item_score.flatMap(</div><div class="line">      f =&gt; &#123;</div><div class="line">        <span class="keyword">val</span> items_sim = item_sim_bd.value.getOrElse(f._1._2, <span class="type">List</span>((<span class="string">"0"</span>, <span class="number">0.0</span>)))</div><div class="line">        <span class="keyword">for</span> (w &lt;- items_sim) <span class="keyword">yield</span> ((f._1._1, w._1), w._2 * f._2)</div><div class="line">      &#125;).filter(_._2 &gt; <span class="number">0.03</span>)</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 聚合user_item_simscore为 (user,（item2,sim1 * score1 + sim2 * score2）)</span></div><div class="line"><span class="comment">     * 假设user观看过两个item,评分分别为score1和score2，item2是与user观看过的两个item相似的item,相似度分别为sim1，sim2</span></div><div class="line"><span class="comment">     * RDD[(user,item2),sim1 * score1 + sim2 * score2）)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> user_item_rank = user_item_simscore.reduceByKey(_ + _, <span class="number">1000</span>)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 过滤用户已看过的item,并对user_item_rank基于user聚合</span></div><div class="line"><span class="comment">     * RDD[(user,CompactBuffer((item2,rank2）,(item3,rank3)...))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> user_items_ranks = user_item_rank.subtractByKey(user_item_score).map(f =&gt; (f._1._1, (f._1._2, f._2))).groupByKey(<span class="number">1000</span>)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 对user_items_ranks基于rank降序排序，并提取topN,其中包括用户已观看过的item</span></div><div class="line"><span class="comment">     * RDD[(user,ArrayBuffer((item2,rank2）,...,(itemN,rankN)))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> user_items_ranks_desc = user_items_ranks.map(f =&gt; &#123;</div><div class="line">      <span class="keyword">val</span> item_rank_list = f._2.toList</div><div class="line">      <span class="keyword">val</span> item_rank_desc = item_rank_list.sortWith((x, y) =&gt; x._2 &gt; y._2)</div><div class="line">      (f._1, item_rank_desc.take(topN))</div><div class="line">    &#125;)</div><div class="line">    user_items_ranks_desc</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">    * json 编码格式1：用于CF离线推荐结果</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @param recTopN 离线推荐结果</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">encodeToJson1</span></span>(recTopN: (<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Double</span>)])) = &#123;</div><div class="line">    <span class="keyword">val</span> mtype = <span class="string">"lxfs"</span></div><div class="line">    <span class="keyword">val</span> mtype_ = <span class="string">"\""</span> + <span class="string">"mtype"</span> + <span class="string">"\""</span> + <span class="string">":"</span> + <span class="string">"\""</span> + mtype + <span class="string">"\""</span></div><div class="line">    <span class="keyword">val</span> uid = recTopN._1</div><div class="line">    <span class="keyword">val</span> uid_ = <span class="string">"\""</span> + <span class="string">"uid"</span> + <span class="string">"\""</span> + <span class="string">":"</span> + <span class="string">"\""</span> + uid + <span class="string">"\""</span></div><div class="line">    <span class="keyword">val</span> aid_score = recTopN._2</div><div class="line">    <span class="keyword">val</span> aids_ = <span class="keyword">new</span> <span class="type">StringBuilder</span>().append(<span class="string">"\""</span> + <span class="string">"list"</span> + <span class="string">"\""</span> + <span class="string">":["</span>)</div><div class="line">    <span class="keyword">for</span> (v &lt;- aid_score) &#123;</div><div class="line">      <span class="keyword">val</span> aid = v._1.split(<span class="string">"_"</span>)(<span class="number">0</span>)</div><div class="line">      <span class="keyword">val</span> type_ = v._1.split(<span class="string">"_"</span>)(<span class="number">1</span>)</div><div class="line">      <span class="keyword">val</span> score = v._2</div><div class="line">      aids_.append(<span class="string">"&#123;"</span> + <span class="string">"\"aid\""</span> + <span class="string">":"</span> + aid + <span class="string">","</span>)</div><div class="line">      aids_.append(<span class="string">"\"type\""</span> + <span class="string">":"</span> + type_ + <span class="string">","</span>)</div><div class="line">      aids_.append(<span class="string">"\"score\""</span> + <span class="string">":"</span> + score + <span class="string">"&#125;,"</span>)</div><div class="line">    &#125;</div><div class="line">    aids_.deleteCharAt(aids_.length - <span class="number">1</span>).append(<span class="string">"]"</span>)</div><div class="line">    <span class="keyword">val</span> result = <span class="string">"&#123;"</span> + mtype_ + <span class="string">","</span> + uid_ + <span class="string">","</span> + aids_.toString() + <span class="string">"&#125;"</span></div><div class="line">    result</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">    * json 编码格式2：用于CF相似度矩阵</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @param cf_sim CF截断的相似度矩阵</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">encodeToJson2</span></span>(cf_sim: (<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Double</span>)])) = &#123;</div><div class="line">    <span class="keyword">val</span> mtype = <span class="string">"cf"</span></div><div class="line">    <span class="keyword">val</span> mtype_ = <span class="string">"\""</span> + <span class="string">"mtype"</span> + <span class="string">"\""</span> + <span class="string">":"</span> + <span class="string">"\""</span> + mtype + <span class="string">"\""</span></div><div class="line">    <span class="keyword">val</span> aid1 = cf_sim._1.split(<span class="string">"_"</span>)(<span class="number">0</span>)</div><div class="line">    <span class="keyword">val</span> aid_ = <span class="string">"\""</span> + <span class="string">"aid"</span> + <span class="string">"\""</span> + <span class="string">":"</span> + <span class="string">"\""</span> + aid1 + <span class="string">"\""</span></div><div class="line">    <span class="keyword">val</span> aid_score = cf_sim._2</div><div class="line">    <span class="keyword">val</span> aids_ = <span class="keyword">new</span> <span class="type">StringBuilder</span>().append(<span class="string">"\""</span> + <span class="string">"similar"</span> + <span class="string">"\""</span> + <span class="string">":["</span>)</div><div class="line">    <span class="keyword">for</span> (v &lt;- aid_score) &#123;</div><div class="line">      <span class="keyword">val</span> aid2 = v._1.split(<span class="string">"_"</span>)(<span class="number">0</span>)</div><div class="line">      <span class="keyword">val</span> type_ = v._1.split(<span class="string">"_"</span>)(<span class="number">1</span>)</div><div class="line">      <span class="keyword">val</span> score = v._2</div><div class="line">      aids_.append(<span class="string">"&#123;"</span> + <span class="string">"\"aid\""</span> + <span class="string">":"</span> + aid2 + <span class="string">","</span>)</div><div class="line">      aids_.append(<span class="string">"\"type\""</span> + <span class="string">":"</span> + type_ + <span class="string">","</span>)</div><div class="line">      aids_.append(<span class="string">"\"score\""</span> + <span class="string">":"</span> + score + <span class="string">"&#125;,"</span>)</div><div class="line">    &#125;</div><div class="line">    aids_.deleteCharAt(aids_.length - <span class="number">1</span>).append(<span class="string">"]"</span>)</div><div class="line">    <span class="keyword">val</span> result = <span class="string">"&#123;"</span> + mtype_ + <span class="string">","</span> + aid_ + <span class="string">","</span> + aids_.toString() + <span class="string">"&#125;"</span></div><div class="line">    result</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> table = args(<span class="number">0</span>) <span class="comment">//要处理的表</span></div><div class="line">    <span class="keyword">val</span> day = args(<span class="number">1</span>) <span class="comment">//当前日期</span></div><div class="line"></div><div class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"Wireless ItemBased Collaborative Filtering"</span>)</div><div class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</div><div class="line"></div><div class="line">    <span class="keyword">val</span> resource = getResource(sc, table, day).repartition(<span class="number">1000</span>)</div><div class="line">    resource.cache()</div><div class="line"></div><div class="line">    <span class="comment">// 1.计算item相似度矩阵</span></div><div class="line">    <span class="keyword">val</span> item_sim: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">String</span>, <span class="type">Double</span>))] = getCosineSimilarity(resource)</div><div class="line">    item_sim.cache()</div><div class="line"></div><div class="line">    <span class="comment">// 2.每个item提取最相近的40个item</span></div><div class="line">    <span class="keyword">val</span> item_sim_rdd = item_sim.filter(f =&gt; f._2._2 &gt; <span class="number">0.05</span>).groupByKey().map(</div><div class="line">      f =&gt; &#123;</div><div class="line">        <span class="keyword">val</span> item = f._1</div><div class="line">        <span class="keyword">val</span> items_score = f._2.toList</div><div class="line">        <span class="keyword">val</span> items_score_desc = items_score.sortWith((x, y) =&gt; x._2 &gt; y._2)</div><div class="line">        (item, items_score_desc.take(<span class="number">40</span>))</div><div class="line">      &#125;).cache()</div><div class="line"></div><div class="line">    <span class="comment">// 3.保存cf相似度矩阵到HDFS</span></div><div class="line">    item_sim_rdd.map(encodeToJson2(_)).foreachPartition(</div><div class="line">      f =&gt; &#123;</div><div class="line">        <span class="keyword">for</span> (m &lt;- f) <span class="type">MqManager</span>.sendMessage(m)</div><div class="line">      &#125;</div><div class="line">    )</div><div class="line"></div><div class="line">    <span class="comment">// 4.广播相似度矩阵</span></div><div class="line">    <span class="keyword">val</span> item_sim_map = item_sim_rdd.collectAsMap()</div><div class="line">    <span class="keyword">val</span> item_sim_bd: <span class="type">Broadcast</span>[scala.collection.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Double</span>)]]] = sc.broadcast(item_sim_map)</div><div class="line"></div><div class="line">    <span class="comment">// 5.为用户生成推荐列表</span></div><div class="line">    <span class="keyword">val</span> recTopN = recommend(resource, item_sim_bd, <span class="number">50</span>)</div><div class="line"></div><div class="line">    <span class="comment">/* 6.发送RabbitMQ</span></div><div class="line"><span class="comment">     * 1&gt; CF相似度矩阵Json 编码并发送</span></div><div class="line"><span class="comment">     * 2&gt; 用户推荐列表Json 编码并发送</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    recTopN.map(encodeToJson1(_)).foreachPartition(</div><div class="line">      f =&gt; &#123;</div><div class="line">        <span class="keyword">for</span> (m &lt;- f) <span class="type">MqManager</span>.sendMessage(m)</div><div class="line">      &#125;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【腾讯转化率预估】贝叶斯平滑]]></title>
      <url>/2018/03/07/%E3%80%90%E8%85%BE%E8%AE%AF%E8%BD%AC%E5%8C%96%E7%8E%87%E9%A2%84%E4%BC%B0%E3%80%91%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%B9%B3%E6%BB%91/</url>
      <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>​    电商领域中经常需要计算或预测一些转化率指标，如最典型的CTR（点击率，Click-Through Rate），这些转化率可以是模型的预测值，也可以作为模型的特征（feature）使用。我们在比赛中就以转化率作为特征来使用。</p>
<p>以商品点击率预测为例，CTR的值等于点击量（Click）除以曝光量（Impression或Exposure）。以r表示点击率，</p>
<script type="math/tex; mode=display">r = C/I</script><p>但在实际应用过程中会碰到两个问题：</p>
<ul>
<li><strong>新商品点击率的预测与计算</strong><br>对于新上线的商品，其曝光为0，点击量也为0，此时这件商品的CTR应该设为0还是赋一个初始值？</li>
<li><strong>不同商品点击率之间的比较</strong><br>有两件商品A和B，其点击率分别为<script type="math/tex">r_A=5/10</script>和<script type="math/tex">r_B=50/100</script>，<script type="math/tex">r_A=r_B</script>，但商品A的曝光只有10次，商品B的曝光有100次，这样比较是否合理？</li>
</ul>
<p>第一个问题，初始值设0是可以的，但不太合理。当CTR作为特征使用时，表示这个商品完全没有点击，不太符合日常推断，通常是赋一个大于0的初始值。第二个问题，不合理。</p>
<p><strong>解决以上两个问题可以使用平滑的技术解决。</strong>最简单的方法是在计算CTR的公式中分子分母同时加上一个数，加上之后可避免这两个问题。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-07-14-47-28.png" alt=""> </p>
<p>但(2)式中a和b的值如何确定？若设置得不合理会出现数据被放大的情况。本文介绍如何<strong>使用贝叶斯平滑来确定a和b</strong>的值。</p>
<h1 id="2-贝叶斯平滑思想"><a href="#2-贝叶斯平滑思想" class="headerlink" title="2. 贝叶斯平滑思想"></a>2. 贝叶斯平滑思想</h1><p>​    贝叶斯平滑的思想是给CTR预设一个<strong>经验初始值</strong>，再<strong>通过当前的点击量和曝光量来修正这个初始值</strong>。如果某商品的点击量和曝光量都是0，那么该商品的CTR就是这个经验初始值；如果商品A和商品B的曝光量差别很大，那么可以通过这个经验初始值来修正，使得曝光量大的商品的权重增大。</p>
<p>​    贝叶斯平滑就是确定这个经验值的过程。贝叶斯平滑是基于贝叶斯统计推断的，因此经验值计算的过程依赖于数据的分布情况。</p>
<h1 id="3-点击率贝叶斯平滑的假设"><a href="#3-点击率贝叶斯平滑的假设" class="headerlink" title="3. 点击率贝叶斯平滑的假设"></a>3. 点击率贝叶斯平滑的假设</h1><p>​    对于一件商品或一条广告，对于某次曝光，用户要么点击，要么没点击，这符合二项分布。因此下文中对于点击率类的贝叶斯平滑，都是基于以下假设：<strong>对于某件商品或广告，其是否被点击是一个伯努利分布（Bernoulli）/二项分布</strong>：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-09-41-16.png" alt=""> </p>
<p>​    其中X表示某个广告是否被点击，点击取1，未被点击取0，<script type="math/tex">r</script>是某件商品被点击的概率，即<strong>点击率</strong>。</p>
<p>​     </p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-09-34-18.png" alt=""> </p>
<p>在贝叶斯框架下，我们假设点击率<script type="math/tex">r</script>服从某个分布：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-10-21-22.png" alt=""></p>
<p>因为这是基于经验的，这个分布称为<strong>先验分布</strong>。贝叶斯参数估计可以同时解决最开始提出的两个问题。其过程是<strong>基于经验或历史数据先给出一个r的估计值，然后基于现有的数据在这个估计值上修正，得到最终的点击率估计，</strong>此时的估计值已经是修正过的。更美好的是我们可以分离出修正参数（即(2)式中的a和b）。</p>
<p>既然有先验分布，就有<strong>后验分布</strong>。<script type="math/tex">r</script>的后验分布记作<script type="math/tex">π(r|x)</script>。其中<script type="math/tex">x</script>表示输入数据或特征，对于点击率预测，<script type="math/tex">x</script> 就是点击次数和曝光量。因为已经看到了数据，才确定<script type="math/tex">r</script>的分布，因此叫做『后验』分布。<strong>贝叶斯估计的实质就是求后验分布。</strong>即基于当前的点击次数和曝光量，求点击率的分布；而未看到数据之前点击率的分布是<script type="math/tex">π(r)</script>。</p>
<p>总结一下，贝叶斯估计的过程可以简单认为：</p>
<p><strong>用历史数据根据<script type="math/tex">π(r)</script>估计<script type="math/tex">r</script>，记作<script type="math/tex">r^{history}</script>；用当前数据根据<script type="math/tex">π(r)</script>估计<script type="math/tex">r</script>，记作<script type="math/tex">r^{current}</script>，然后用<script type="math/tex">r^{history}</script>修正<script type="math/tex">r^{current}</script>。</strong></p>
<p>为什么是beta分布？</p>
<p><strong>由于是否点击是服从伯努利分布的，伯努利分布的共轭先验分布是Beta分布，因此我们认为点击率是服从Beta分布的。</strong></p>
<p><strong>共轭先验分布性质：</strong><br><strong>如果找到一个<script type="math/tex">π(r)</script>，它是<script type="math/tex">f(x|r)</script>的共轭先验，那么<script type="math/tex">r</script>的后验分布<script type="math/tex">π(r|x)</script>和先验分布<script type="math/tex">π(r)</script>会有一样的形式。</strong></p>
<p>也就是说</p>
<p><strong>点击率的先验分布<script type="math/tex">r = Beta<a,b>  +  后验知识 = Beta<a',b'> = r'</script></strong></p>
<p>当误差是平方误差的时候，可以解出：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-11-26-55.png" alt=""> </p>
<p>也就是<script type="math/tex">Beta<a',b'> = Beta<a+I,b+I-C></script> 的均值，也就是相当于针对当前数据I和C的“定制化”Beta分布。然后用Beta分布的期望作为点击率的经验值，因为这样的误差最小。</p>
<p>上面的内容给出了为什么很多文章会假设点击率服从Beta分布的理由，因为<strong>最终的平滑的因子是Beta分布（先验分布）中的两个参数</strong>。那么如何计算（估计）这两个参数？</p>
<h1 id="4-贝叶斯平滑因子的计算（矩估计）"><a href="#4-贝叶斯平滑因子的计算（矩估计）" class="headerlink" title="4. 贝叶斯平滑因子的计算（矩估计）"></a>4. 贝叶斯平滑因子的计算（矩估计）</h1><p>综上，贝叶斯平滑的最终落脚点是要估计Beta分布（点击率r服从的分布）中的参数<script type="math/tex">\alpha</script>和<script type="math/tex">\beta</script>。下面给出比较直观的矩估计的方法，我们在比赛中也是采用的这种方法，其优点是计算速度快，但同时也就牺牲了一定的精确程度。</p>
<p>首先，<strong>矩估计的原理：</strong>样本与总体的<strong>原点矩是近似的</strong> ，可以通过让它们<strong>相等</strong>来计算。</p>
<p>beta分布的期望（一阶矩）是：</p>
<script type="math/tex; mode=display">E(x) = \frac{\alpha}{\alpha+\beta}</script><p>beta分布的方差（二阶矩）是：</p>
<script type="math/tex; mode=display">D(x) = \frac{\alpha\beta}{(\alpha+\beta)^2+(\alpha+\beta+1)}</script><p>因此为了估计两个参数<script type="math/tex">\alpha</script>和<script type="math/tex">\beta</script> ，可以采用<strong>二阶矩估计</strong>的方法，</p>
<p>我们可以用样本的均值代替期望，样本的方差代替总体的方差，此时就可以解出α和β的值。<script type="math/tex">\bar X</script>是样本均值，<script type="math/tex">S^2</script>是样本方差，则解为：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-10-53-12.png" alt=""> </p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HyperParam</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, alpha, beta)</span>:</span></div><div class="line">        self.alpha = alpha</div><div class="line">        self.beta = beta</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sample_from_beta</span><span class="params">(self, alpha, beta, num, imp_upperbound)</span>:</span></div><div class="line">        sample = numpy.random.beta(alpha, beta, num)</div><div class="line">        I = []</div><div class="line">        C = []</div><div class="line">        <span class="keyword">for</span> click_ratio <span class="keyword">in</span> sample:</div><div class="line">            imp = random.random() * imp_upperbound</div><div class="line">            <span class="comment">#imp = imp_upperbound</span></div><div class="line">            click = imp * click_ratio</div><div class="line">            I.append(imp)</div><div class="line">            C.append(click)</div><div class="line">        <span class="keyword">return</span> I, C</div><div class="line"></div><div class="line">    <span class="comment"># 矩估计，根据均值和方差</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_from_data_by_moment</span><span class="params">(self, tries, success)</span>:</span></div><div class="line">        <span class="string">'''estimate alpha, beta using moment estimation'''</span></div><div class="line">        mean, var = self.__compute_moment(tries, success)</div><div class="line">        <span class="comment">#print 'mean and variance: ', mean, var</span></div><div class="line">        <span class="comment">#self.alpha = mean*(mean*(1-mean)/(var+0.000001)-1)</span></div><div class="line">        self.alpha = (mean+<span class="number">0.000001</span>) * ((mean+<span class="number">0.000001</span>) * (<span class="number">1.000001</span> - mean) / (var+<span class="number">0.000001</span>) - <span class="number">1</span>)</div><div class="line">        <span class="comment">#self.beta = (1-mean)*(mean*(1-mean)/(var+0.000001)-1)</span></div><div class="line">        self.beta = (<span class="number">1.000001</span> - mean) * ((mean+<span class="number">0.000001</span>) * (<span class="number">1.000001</span> - mean) / (var+<span class="number">0.000001</span>) - <span class="number">1</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 计算均值和方差，也就是一阶和二阶矩</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__compute_moment</span><span class="params">(self, tries, success)</span>:</span></div><div class="line">        <span class="string">'''moment estimation'''</span></div><div class="line">        ctr_list = []</div><div class="line">        <span class="comment"># var = 0.0</span></div><div class="line">        mean = (success/tries).mean()</div><div class="line">        <span class="keyword">if</span> len(tries)==<span class="number">1</span>:</div><div class="line">            var = <span class="number">0</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            var = (success/tries).var()</div><div class="line">      <span class="keyword">return</span> mean, var</div></pre></td></tr></table></figure>
<h1 id="5-分层贝叶斯平滑"><a href="#5-分层贝叶斯平滑" class="headerlink" title="5. 分层贝叶斯平滑"></a>5. 分层贝叶斯平滑</h1><p>由于广告数据是分为：广告主 —&gt;广告 —&gt; 推广计划 —&gt;广告创意 四个层级的，因此在做平滑的时候，可以依照层级关系进行平滑。</p>
<p>核心思想就是认为同一个推广计划的点击率服从一个beta分布，同一个广告的点击率服从一个beta分布，以此类推，同一个广告主也服从一个beta分布。因此我们队不同的推广计划、广告、广告主都求出不同的参数a和b。</p>
<p>当遇到新出现的广告创意时，就用其所属推广计划的a和b来估计（修正）其点击率，同样当出现一个新的推广计划时，就用其所属的广告的a和b来修正其点击率。</p>
<p>这样做的效果要比单纯从单一维度来平滑效果要好一些。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://blog.csdn.net/jinping_shi/article/details/53444100" target="_blank" rel="external">阿拉丁吃米粉-贝叶斯参数估计的理解</a></p>
<p><a href="http://blog.csdn.net/jinping_shi/article/details/78334362" target="_blank" rel="external">阿拉丁吃米粉-http://blog.csdn.net/jinping_shi/article/details/78334362</a></p>
<p><a href="http://www.cnblogs.com/bentuwuying/p/6389222.html" target="_blank" rel="external">笨兔勿应-CTR预估中的贝叶斯平滑方法（一）原理及实验介绍</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【腾讯转化率预估】总结]]></title>
      <url>/2018/03/06/%E3%80%90%E8%85%BE%E8%AE%AF%E8%BD%AC%E5%8C%96%E7%8E%87%E9%A2%84%E4%BC%B0%E3%80%91%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>第一届腾讯社交广告算法大赛复赛成绩0.101941，排名26名，在此总结一下。</p>
<p><a href="https://ooo.0o0.ooo/2017/07/11/59646ce45d3e0.png" target="_blank" rel="external"><img src="https://ooo.0o0.ooo/2017/07/11/59646ce45d3e0.png" alt="img"></a></p>
<h1 id="1-题目简介"><a href="#1-题目简介" class="headerlink" title="1. 题目简介"></a>1. 题目简介</h1><h2 id="1-1-移动App广告转化率预估"><a href="#1-1-移动App广告转化率预估" class="headerlink" title="1.1 移动App广告转化率预估"></a>1.1 移动App广告转化率预估</h2><p>详细赛题见<a href="http://algo.tpai.qq.com/home/information/index.html" target="_blank" rel="external">官方网站</a></p>
<blockquote>
<p>计算广告是互联网最重要的商业模式之一，广告投放效果通常通过曝光、点击和转化各环节来衡量，大多数广告系统受广告效果数据回流的限制只能通过曝光或点击作为投放效果的衡量标准开展优化。腾讯社交广告(<a href="http://ads.tencent.com/" target="_blank" rel="external">http://ads.tencent.com</a>)发挥特有的用户识别和转化跟踪数据能力，帮助广告主跟踪广告投放后的转化效果，基于广告转化数据训练转化率预估模型(pCVR，Predicted Conversion Rate)，在广告排序中引入pCVR因子优化广告投放效果，提升ROI。</p>
<p>本题目以移动App广告为研究对象，预测App广告点击后被激活的概率：pCVR=P(conversion=1 | Ad,User,Context)，即给定广告、用户和上下文情况下广告被点击后发生激活的概率。</p>
</blockquote>
<p>总结起来就是说，在业界，大多数广告系统是通过点击率来投放广告的，因为转化追踪起来是比较困难的，然而腾讯凭借平台优势很好地追踪了广告投放之后的转化情况，以此训练<strong>转化率预估模型</strong>，用转化率来指导广告投放，进而提升ROI。</p>
<p><strong>因此赛题就是给我们17-30号两周（15天）的移动APP广告（投放在移动端的APP广告）数据，让我们训练转化率模型做转化率预估，即预测第31号App广告点击后被激活的概率。</strong></p>
<h2 id="1-2-评估方式："><a href="#1-2-评估方式：" class="headerlink" title="1.2 评估方式："></a>1.2 评估方式：</h2><p>通过Logarithmic Loss评估(越小越好)，公式如下：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-14-36-51.png" alt=""> </p>
<p>其中，</p>
<ul>
<li>N是测试样本总数</li>
<li><script type="math/tex">y_i</script>是二值变量，取值为0或1，表示第i个样本的label</li>
<li><script type="math/tex">p_i</script>是模型预测第i个样本label为1的概率</li>
</ul>
<h1 id="2-数据"><a href="#2-数据" class="headerlink" title="2. 数据"></a>2. 数据</h1><h2 id="2-1-数据量"><a href="#2-1-数据量" class="headerlink" title="2.1 数据量"></a>2.1 数据量</h2><p><strong>数据量：初赛30w/天；决赛300w/天</strong></p>
<h2 id="2-2-数据表"><a href="#2-2-数据表" class="headerlink" title="2.2 数据表"></a>2.2 数据表</h2><p>接下来看看给的数据长啥样。</p>
<p>一共给了8张表：</p>
<p>test+train+下面这些：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户基础特征文件(<em>user.csv</em>)</td>
<td>每行代表一个用户，各字段之间由逗号分隔，顺序依次为：“userID，age，gender，education，marriageStatus，haveBaby，hometown，residence”。</td>
</tr>
<tr>
<td>用户App安装列表文件(<em>user_installedapps.csv</em>)</td>
<td>每行代表一个用户安装的单个App，各字段之间由逗号分隔，顺序依次为：“userID，appID”。特别的，我们提供了截止到第1天0点用户全部的App安装列表。</td>
</tr>
<tr>
<td>用户App安装流水文件(<em>user_app_actions.csv</em>)</td>
<td>每行代表一个用户的单个App操作流水，各字段之间由逗号分隔，顺序依次为：“userID，installTime，appID”。特别的，我们提供了训练数据开始时间之前16天开始连续30天的操作流水，即第1天0点到第31天0点。</td>
</tr>
<tr>
<td>App特征文件(<em>app_categories.csv</em>)</td>
<td>每行代表一个App，各字段之间由逗号分隔，顺序依次为：“appID，appCategory”。</td>
</tr>
<tr>
<td>广告特征文件(<em>ad.csv</em>)</td>
<td>每行描述一条广告素材，各字段之间由逗号分隔，顺序依次为“creativeID，adID，camgaignID，advertiserID，appID，appPlatform”。</td>
</tr>
<tr>
<td>广告位特征文件(<em>position.csv</em>)</td>
<td>每行描述一个广告位，各字段之间由逗号分隔，顺序依次为：“positionID，sitesetID，positionType”。</td>
</tr>
</tbody>
</table>
</div>
<p><code>train.csv</code> 训练数据集 ：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-14-30-00.png" alt=""> </p>
<p>17到30号共14天点击数据。</p>
<p>每一条训练样本即为一条广告<strong>点击日志</strong>(点击时间用clickTime表示)，样本label取值0或1，其中0表示点击后没有发生转化，1表示点击后有发生转化，如果label为1，还会提供转化回流时间。</p>
<p>每一条数据其中label表示是否转化，经统计<strong>转化率大概1/40</strong></p>
<p>数据量：初赛30w/天；决赛300w/天</p>
<p><code>test.csv</code> 线上测试数据</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-14-30-28.png" alt=""> </p>
<p>31号一天数据，字段和test一致，需要预测lable</p>
<p><code>ad.csv</code> 广告基本特征</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-30-44.png" alt="">     <img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-26-24.png" alt=""> </p>
<p>这里广告结构分为四级：广告主——推广计划——广告——素材。<strong>之后会用到这个层级结构做贝叶斯平滑。</strong></p>
<p><code>user.csv</code> 用户信息表</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-31-49.png" alt=""> </p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-28-05.png" alt=""> </p>
<p>就是用户的一些基本特征啦，性别年龄blabla</p>
<p><code>app_category.csv</code> appID对应的类别信息</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-32-49.png" alt="">                      <img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-28-21.png" alt=""> </p>
<p>就是appID和对应的categoryID，其中类目标签有两层，使用3位数字编码，百位数表示一级类目，十位个位数表示二级类目，如“210”表示一级类目编号为2，二级类目编号为10，类目未知或者无法获取时，标记为0。</p>
<p><code>position.csv</code> 广告位信息</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-33-15.png" alt=""> </p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-28-46.png" alt=""> </p>
<p>没啥说的，就是广告位信息，直接merge就行</p>
<p><code>user_app_actions.csv</code> 用户安装app流水，1——30天的，包含安装时间</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-34-00.png" alt="">        <img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-29-01.png" alt=""> </p>
<p>用户近期的app安装行为，这里可以挖掘出用户的偏好类别，时间等等。。。</p>
<p><code>user_installedapps.csv</code>用户历史安装过的app，第一天0点之前的</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-34-31.png" alt="">         <img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-30-00.png" alt=""> </p>
<p>用户自注册以来安装过的appID，有待挖掘。。。</p>
<h2 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h2><p>总结一下，一共有三类特征，用户特征、广告特征、上下文特征，官网也给了个很好的总结表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特征</th>
<th>分类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>广告特征</td>
<td>账户ID(<em>advertiserID</em>)</td>
<td>腾讯社交广告的账户结构分为四级：账户——推广计划——广告——素材，账户对应一家特定的广告主。</td>
</tr>
<tr>
<td></td>
<td>推广计划ID(<em>campaignID</em>)</td>
<td>推广计划是广告的集合，类似电脑文件夹功能。广告主可以将推广平台、预算限额、是否匀速投放等条件相同的广告放在同一个推广计划中，方便管理。</td>
</tr>
<tr>
<td></td>
<td>广告ID(<em>adID</em>)</td>
<td>腾讯社交广告管理平台中的广告是指广告主创建的广告创意(或称广告素材)及广告展示相关设置，包含广告的基本信息(广告名称，投放时间等)，广告的推广目标，投放平台，投放的广告规格，所投放的广告创意，广告的受众(即广告的定向设置)，广告出价等信息。单个推广计划下的广告数不设上限。</td>
</tr>
<tr>
<td></td>
<td>素材ID(<em>creativeID</em>)</td>
<td>展示给用户直接看到的广告内容，一条广告下可以有多组素材。</td>
</tr>
<tr>
<td></td>
<td>AppID(<em>appID</em>)</td>
<td>广告推广的目标页面链接地址，即点击后想要展示给用户的页面，此处页面特指具体的App。多个推广计划或广告可以同时推广同一个App。</td>
</tr>
<tr>
<td></td>
<td>App分类(<em>appCategory</em>)</td>
<td>App开发者设定的App类目标签，类目标签有两层，使用3位数字编码，百位数表示一级类目，十位个位数表示二级类目，如“210”表示一级类目编号为2，二级类目编号为10，类目未知或者无法获取时，标记为0。</td>
</tr>
<tr>
<td></td>
<td>App平台(<em>appPlatform</em>)</td>
<td>App所属操作系统平台，取值为Android，iOS，未知。同一个appID只会属于一个平台。</td>
</tr>
<tr>
<td>用户特征</td>
<td>用户ID(<em>userID</em>)</td>
<td>唯一标识一个用户</td>
</tr>
<tr>
<td></td>
<td>年龄(<em>age</em>)</td>
<td>取值范围[0, 80]，其中0表示未知。</td>
</tr>
<tr>
<td></td>
<td>性别(<em>gender</em>)</td>
<td>取值包括男，女，未知。</td>
</tr>
<tr>
<td></td>
<td>学历(<em>education</em>)</td>
<td>用户当前最高学历，不区分在读生和毕业生，取值包括小学，初中，高中，专科，本科，硕士，博士，未知</td>
</tr>
<tr>
<td></td>
<td>婚恋状态(<em>marriageStatus</em>)</td>
<td>用户当前感情状况，取值包括单身，新婚，已婚，未知。</td>
</tr>
<tr>
<td></td>
<td>育儿状态(<em>haveBaby</em>)</td>
<td>用户当前孕育宝宝状态，取值包括孕育中，宝宝0~6个月，宝宝6~12个月，宝宝1~2岁，宝宝2~3岁，育儿但宝宝年龄未知，未知。</td>
</tr>
<tr>
<td></td>
<td>家乡/籍贯(<em>hometown</em>)</td>
<td>用户出生地，取值具体到市级城市，使用二级编码，千位百位数表示省份，十位个位数表示省内城市，如1806表示省份编号为18，城市编号是省内的6号，编号0表示未知。</td>
</tr>
<tr>
<td></td>
<td>常住地(<em>residence</em>)</td>
<td>最近一段时间用户长期居住的地方，取值具体到市级城市，编码方式与家乡相同。</td>
</tr>
<tr>
<td></td>
<td>App安装列表(<em>appInstallList</em>)</td>
<td>截止到某一时间点用户全部的App安装列表(appID)，已过滤高频和低频App。</td>
</tr>
<tr>
<td></td>
<td>App安装流水</td>
<td>最近一段时间内用户安装App行为流水，包括appID，行为发生时间(installTime)和app类别(appCategory)，已过滤高频和低频App。</td>
</tr>
<tr>
<td></td>
<td>注：2~8基于用户个人注册资料和算法自动修正得到，9~10基于用户行为日志统计得到。</td>
<td></td>
</tr>
<tr>
<td>上下文特征</td>
<td>广告位ID(<em>positionID</em>)</td>
<td>广告曝光的具体位置，如QQ空间Feeds广告位。</td>
</tr>
<tr>
<td></td>
<td>站点集合ID(<em>sitesetID</em>)</td>
<td>多个广告位的聚合，如QQ空间</td>
</tr>
<tr>
<td></td>
<td>广告位类型(<em>positionType</em>)</td>
<td>对于某些站点，人工定义的一套广告位规格分类，如Banner广告位。</td>
</tr>
<tr>
<td></td>
<td>联网方式(<em>connectionType</em>)</td>
<td>移动设备当前使用的联网方式，取值包括2G，3G，4G，WIFI，未知</td>
</tr>
<tr>
<td></td>
<td>运营商(<em>telecomsOperator</em>)</td>
<td>移动设备当前使用的运营商，取值包括中国移动，中国联通，中国电信，未知</td>
</tr>
</tbody>
</table>
</div>
<p>接下来的任务就是从这些给的数据里面挖掘有用的信息去训练模型预测转化率啦。</p>
<h1 id="3-主要流程"><a href="#3-主要流程" class="headerlink" title="3. 主要流程"></a>3. 主要流程</h1><p>这是Kaggle上数据挖掘比赛的黄金流程图：<br><a href="http://om1bxijvl.bkt.clouddn.com/2017-06-07-15-44-01.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-15-44-01.png" alt="img"></a></p>
<p>我们也是采用这个流程来做的~</p>
<h1 id="4-数据分析-amp-清洗"><a href="#4-数据分析-amp-清洗" class="headerlink" title="4. 数据分析&amp;清洗"></a>4. 数据分析&amp;清洗</h1><h2 id="4-1-数据分析"><a href="#4-1-数据分析" class="headerlink" title="4.1 数据分析"></a>4.1 数据分析</h2><p>拿到数据第一件事就是要好好分析数据！！！不仅一开始要分析，训练完也要根据结果分析，所以数据分析是要贯穿整个流程的，只有通过不断的分析统计，才能挖掘到数据背后的价值啊~</p>
<p>上面介绍数据表的时候已经有了一部分简单粗暴的分析了，实际上拿到赛题的时候进行的数据统计和分析远比上面的多，比如还统计了广告主上传回流时间的分布，上传回流时间在5,4,3,2,1天内的百分比，用户转化时间段分布各维度转化率情况（比如各广告主、广告计划、性别、年龄、app的转化率等等)…….</p>
<p>这些都是数据清洗和特征工程的依据。</p>
<h2 id="4-2-数据清洗"><a href="#4-2-数据清洗" class="headerlink" title="4.2 数据清洗"></a>4.2 数据清洗</h2><p>按天对训练集<code>train.csv</code>转化率进行了统计</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-16-37-49.png" alt=""> </p>
<p>其中19号可能由于节日等原因导致转化率有点高，但是考虑到如果去掉这一天的数据就会丢失大一部分信息所以最终没有去掉。</p>
<p>而由于回流时间的存在，最后四天的数据会不准确，也就是说后五天的数据中有一部分实际上是转化了的，但广告主还没有来得及将这条转化汇报给广告系统，导致数据集中的label被误标记为了0（实际上是1）</p>
<p>这里我们尝试了两种方法：</p>
<ol>
<li>根据经验猜测回流数据是广告主网站反馈回来的，所以我们计算了各广告主在最后五天内的最后一次回流反馈时间，将各广告主最后一次回流返回时间之后的数据删除掉这样就在一定程度上减少了不准确的负样本。这样筛去了大概有3万条。这样的做法带来的问题是有一些真正的负样本也被去除掉了。</li>
<li>由于最后两天数据的问题比较大，所以干脆直接把最后两天的数据删掉，不用这两天的数据训练模型，这样带来的问题是有一些在这两天新上线的广告就没有得到充分的训练。</li>
</ol>
<h1 id="5-特征工程"><a href="#5-特征工程" class="headerlink" title="5. 特征工程"></a>5. 特征工程</h1><p>一开始的时候我们采用了很多基本特征，即各种基础的category型特征（AppID, UserID, creativeID, pisitionID等）的onehot编码，又对单特征进行了一定的统计，比如某广告的转化率，某种联网方式的转化率等。后来看了大神“为情所困的少年”的分享，才反应过来其实无论是onehot还是对ID单维度的统计特征，其实都是对于一个特征的一种表达，从一定意义上是重复的。我个人感觉onehot之后的稀疏特征更适合于线性模型，如LR；而统计量的连续特征更适合于树模型，如GBDT。</p>
<p>回头来看，其实特征工程需要根据模型预先选择方向。李沐说过，模型是使用离散特征还是连续特征，其实是一个“海量离散特征+简单模型” 同 “少量连续特征+复杂模型”的权衡。既可以离散化用线性模型，也可以用连续特征加深度学习。就看是喜欢折腾特征还是折腾模型了。通常来说，前者容易，而且可以n个人一起并行做，有成功经验；后者目前看很赞，能走多远还须拭目以待。</p>
<p>后来这两种思路在初赛和决赛中我们的都尝试了：</p>
<h2 id="5-1-海量离散特征-简单模型"><a href="#5-1-海量离散特征-简单模型" class="headerlink" title="5.1 海量离散特征+简单模型"></a>5.1 海量离散特征+简单模型</h2><p>在初赛的开始阶段，我们将各种基础的category型特征进行onehot编码，然后构造了一些单维度的统计特征，比如某广告的转化率，某种联网方式的转化率等，然后构造了一些组合特征，将这些特征onehot之后输入了LR模型就开始训练和预测了。</p>
<p>对于LR这种线性模型来说，它更适合于onehot类型的特征，首先它对于稀疏高维特征处理是无压力的，其次离散化后的特征对异常数据有很强的鲁棒性，这些在参考文献2<a href="http://blog.csdn.net/yang090510118/article/details/39478033" target="_blank" rel="external">逻辑回归LR的特征为什么要先离散化</a>中可以看到。</p>
<p>对于一些onehot之后维度很大的特征，我们通过统计，取高频的一部分，舍弃低频的一部分，进行onehot。但随着构造特征的增多，onehot之后的向量维度剧增，这时就会带来维度灾难问题，见参考文献4<a href="https://zhuanlan.zhihu.com/p/26945814" target="_blank" rel="external">机器学习中的维度灾难</a>。不仅如此，这时基本上也就被设备问题限制死了。</p>
<p>这很烦。于是我们就换模型了。</p>
<h2 id="5-2-少量连续特征-复杂模型"><a href="#5-2-少量连续特征-复杂模型" class="headerlink" title="5.2 少量连续特征+复杂模型"></a>5.2 少量连续特征+复杂模型</h2><p>既然要预测的是转化率，我们不如把特征转化为<strong>转化率特征</strong>，这样特征就变成了连续值，同时我们还抽取了一些<strong>统计特征</strong>，比如某广告在一天之内、n天之内的<strong>点击量，转化量</strong>，某用户历史安装次数、APP历史被安装次数，等等，然后输入树模型中训练。感谢“为情所困”大神的分享，树模型比LR快了不少。</p>
<h2 id="5-3-组合特征构造"><a href="#5-3-组合特征构造" class="headerlink" title="5.3 组合特征构造"></a>5.3 组合特征构造</h2><p>说到特征组合，从统计的角度解释，基本特征仅仅是真实特征分布在低维空间的映射，不足以描述真实分布，加入组合特征是为了在更高维空间拟合真实分布，使得预测更准确。<br>在初赛和决赛阶段，我们共使用过两种组合特征的表达：</p>
<p><strong>1. 对离散ID进行hash生成新特征</strong></p>
<p>在初期用LR的时候，我们采用的方式是hash。即对两个ID做hash运算，得到一个新特征。这是一个很巧妙的方法。例如下面这个表，我们做哈希：</p>
<p>age×10+gendarage×10+gendar</p>
<p>得到第三列：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>age</th>
<th>gendar</th>
<th>hash</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>21</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>32</td>
</tr>
</tbody>
</table>
</div>
<p>第三列的的特征的取值有两位，十位是age,个位是gendar。新特征是一种新的交叉特征的体现。</p>
<p><strong>2. 对组合进行统计生成新特征</strong></p>
<p>像之前“为情所困”大神说过的那样，其实无论onehot还是统计特征，其实都是对于一个特征的一种表达。因为后期我们采用了GBDT，因此我们弃用了之前的hash组合方式，而选用统计量（即点击量、转化量和转化率）。这样就在一个维度上表达了这两个特征的组合，而且非常便于计算。</p>
<p>实现：按字段groupby，获取统计量和转化率特征</p>
<h2 id="5-4-特征选择"><a href="#5-4-特征选择" class="headerlink" title="5.4 特征选择"></a>5.4 特征选择</h2><p>我们用到了两种特征选择的方法：</p>
<ol>
<li>根据方差：方差很小的属性，意味着该属性的识别能力很差。极端情况下，方差为0，意味着该属性在所有样本上都是一个值，所以我们尽量选那些方差比较大，区分度比较好的特征。</li>
<li>根据模型评分+相关系数矩阵：用GBDT训练会得到一个特征打分，可以作为筛选特征的依据，与此同时，我们发现，有一些特征之间有很强的相互作用，比如加入了某个特征之后会使之前排名很靠前的特征下降，因此我们还计算了特征之间的相关系数，对于相关系数较大的特征，我们就多次试验，反复选择</li>
</ol>
<p>特征之间的相关系数：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-21-58-07.png" alt=""> </p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-21-49-00.png" alt=""> </p>
<p>另外，“酱紫”学长对特征筛选还有一种建议就是直接对所有基本特征进行遍历两两组合，然后用卡方检验筛出来一些比较好的特征。这种方式很简单，大多数工作只需要交给模型来完成。<strong>日后学习一下</strong></p>
<h2 id="5-5-用户-APP特征挖掘"><a href="#5-5-用户-APP特征挖掘" class="headerlink" title="5.5 用户-APP特征挖掘"></a>5.5 用户-APP特征挖掘</h2><p>特征说到这里，还有两个表没有充分利用上，<code>user_app_actions.csv</code> 和</p>
<p><code>user_installedapps.csv</code> </p>
<p><code>user_app_actions.csv</code> ：用户安装app流水，1——30天的，包含安装时间，既然包含安装时间，就可以提取出用户的偏好安装时间、类别、app的偏好安装时间、安装量等特征</p>
<p><code>user_installedapps.csv</code> 用户历史安装app</p>
<p>两个表都有用户和APP的安装信息，所以是否可以提取出用户和app之间的一些联系呢。思考一个问题，如果用户已经点击了某个APP的广告，那么是否会转化（下载）取决于什么呢？除了一些客观的因素，比如广告位（是否误点），联网方式等，当然是用户到底感不感兴趣！需不需要！</p>
<p>想到这里就感觉是个推荐系统方面的问题了，所以我们查了一些资料，尝试了用三种方式表达用户和app之间的联系：</p>
<ol>
<li><p>tf-idf向量特征</p>
<ol>
<li>把用户看成文档，app、app所属的类别看成词</li>
<li>把app、app所属的类别看成文档，用户看成词</li>
</ol>
<p>没什么提高</p>
</li>
<li><p>word-embedding特征</p>
<p><code>user_app_actions.csv</code> 中包含用户的近期下载的app，根据时间可以得到app下载的顺序。</p>
<p>把word2vec应用在用户app下载序列上，根据用户下载app的顺序，把app看做单词，也是可以形成这样的序列数据，进而训练处每个app对应的向量，看作是app的一个特征。</p>
</li>
<li><p>SVD分解</p>
<p><code>user_installedapps.csv</code> 表中没有时间信息，也就不合适用word2vec来提取特征了，我们想到了用推荐系统中的常用套路：SVD分解</p>
<p>关于SVD知识的补充日后可以看下面两篇文章：</p>
<p><a href="http://blog.csdn.net/zhongkejingwang/article/details/43053513" target="_blank" rel="external">奇异值分解SVD原理详解及推导</a></p>
<p><a href="http://blog.csdn.net/zhongkejingwang/article/details/43083603" target="_blank" rel="external">SVD在推荐系统中的应用详解以及算法推导</a></p>
</li>
</ol>
<h2 id="5-6-贝叶斯平滑"><a href="#5-6-贝叶斯平滑" class="headerlink" title="5.6 贝叶斯平滑"></a>5.6 贝叶斯平滑</h2><p>这里我们参考了@<a href="https://cloud.tencent.com/developer/user/598572" target="_blank" rel="external">王照彬</a> 大神的平滑方式</p>
<p> 例如对我们数据中存在的 root -&gt; advertiser -&gt; campaign -&gt; ad -&gt; creative 层级关系(root为训练集中全部样本), 这样的层级关系隐喻了在同一个父节点下的子节点, 其来自于同一个Beta分布, 所以我逐层进行了贝叶斯平滑, 且建立层级关系还有一个好处, 即对预测集出现的数据, 若该creativeID 在训练集从未出现过, 则在pandas.merge时该值为空, 则向上寻找其父节点的统计值, 最高一层为root, 是基与全部训练数据的统计, root的值不进行贝叶斯平滑, 且一定存在, 这就保证了当在预测集中遇到了未出现的样本时, 使用最合理的缺省值进行补全.</p>
<p><img src="https://blog-10039692.file.myqcloud.com/1496913643639_4485_1496913644532.png" alt="img"></p>
<p>关于贝叶斯平滑，其核心思想就是说，当某些广告投放量比较少时，或者还未投放时，根据历史数据所统计的转化率特征是不准确的，比如有广告A和B，<script type="math/tex">r_A = 5/10</script>,<script type="math/tex">r_B = 50/100</script>,由于广告A的投放量还比较少，通过历史数据计算而得的<script type="math/tex">r_B</script> 就很有可能不准确，在比如如果某一个广告还未投放过，那么根据历史数据计算其转化率为0，放入模型中训练，也是非常不合理的，所以我们该如何解决呢？</p>
<p>对于贝叶斯平滑参数的估计方法，可以采用矩估计、极大似然估计和EM算法，这里由于速度的限制，我们采用的是矩估计的方式，代码<a href="https://github.com/zsyandjyhouse/TencentAD_contest" target="_blank" rel="external">TencentAD_contest</a></p>
<p>关于贝叶斯平滑，有待补习，参考文章：</p>
<p><a href="http://blog.csdn.net/jinping_shi/article/details/53444100" target="_blank" rel="external">贝叶斯参数估计的理解</a></p>
<p><a href="https://www.bbsmax.com/A/A7zgmjRk54/" target="_blank" rel="external">CTR预估中的贝叶斯平滑方法（二）参数估计和代码实现</a></p>
<p><a href="http://blog.csdn.net/jinping_shi/article/details/78334362" target="_blank" rel="external">转化率（CTR）预测的贝叶斯平滑</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/21724759" target="_blank" rel="external">计算广告的训练与平滑思想（下）</a></p>
<h2 id="5-7-多线程抽取特征"><a href="#5-7-多线程抽取特征" class="headerlink" title="5.7 多线程抽取特征"></a>5.7 多线程抽取特征</h2><p>决赛数据集太大，而我们组合特征非常多。因此我们采用了多线程抽特征的方式。</p>
<p>每个特征一个进程，同时对多个特征进行抽取。</p>
<p>代码见<a href="https://github.com/zsyandjyhouse/TencentAD_contest" target="_blank" rel="external">TencentAD_contest</a>，extra_rate_thread_0623.py</p>
<h2 id="5-8-总结"><a href="#5-8-总结" class="headerlink" title="5.8 总结"></a>5.8 总结</h2><p><a href="https://github.com/z564808896/Tencent_Social_Ads" target="_blank" rel="external">竟然有这种操作队分享</a>总结得非常好，我们的特征主要分为以下几类：</p>
<ul>
<li><p>Trick特征：</p>
<ol>
<li><p><strong>重复点击的数据条目</strong>：通过观察原始数据是不难发现的,有很多只有clickTime和label不一样的重复数据，按时间排序发现重复数据如果转化，label一般标在头或尾，少部分在中间，在训练集上出现的情况在测试集上也会出现，所以把重复点击数据中的第一条和最后一条标记出来，让模型去学习。后来进一步标注，非重复数据0，重复但不是第一条和最后一条1，重复且是第一条2，最后一条3。这里面包含用户的重复点击、creativeID的重复点击等</p>
</li>
<li><p>时间差特征：与重复第一条的时间差和重复最后一条的时间差特征，与前一条和后一条的时间差，甚至包括了重复组合特征的时间差特征</p>
</li>
<li><p>rank特征：重复数据的rank特征，同样包括重复的用户、广告等</p>
<p>这里实现方面用到了pandas的 <code>shift()</code>操作，非常酷炫</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>统计特征（单维+组合）：<br>原始特征主要三大类：广告特征、用户特征、位置特征，通过交叉组合算统计构造特征，由于机器限制，统计特征主要使用了转化率，部分特征还统计了点击次数和转化次数。前面已经说过，就不详细列举。</p>
</li>
<li><p>用户app行为挖掘特征：</p>
<p>word-embedding特征、SVD特征</p>
</li>
</ul>
<p><strong>最后附上当时的特征评分表：</strong></p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-12-14-40-32.png" alt=""> </p>
<h1 id="6-训练集-测试集构造"><a href="#6-训练集-测试集构造" class="headerlink" title="6. 训练集/测试集构造"></a>6. 训练集/测试集构造</h1><p>尝试过两种方法：</p>
<ol>
<li><p><strong>滑动窗口</strong></p>
<p>用每天的前七天的统计（统计指统计转化量、点击量、转化率，下同）来作为本天的特征。</p>
<p>这样就得到了24-30号7天的特征数据，再加上31号的特征，然后用24-29做训练，得到模型，30号作为线下验证集合，验证模型的线下loss，然后将31号的特征输入到该模型，得到最终的线上预测结果，提交。</p>
<p>​<br>如下图所示：<br><a href="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-49-53.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-49-53.png" alt="img"></a><br>经测试我们发现，即使我们去掉了30号的部分负样本，还是有一些问题的，30号的数据还是不够好，线上线下会不一致，因此我们改用28号做验证：<br><a href="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-53-21.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-53-21.png" alt="img"></a><br>这样做出于两种目的：一是尽量做到了线上线下统一，二是不让模型学习30号的样本数据，防止一些错误样本被模型学到。</p>
</li>
<li><p>用第一周统计，第二周做交叉验证并训练模型。如下图所示：<br><a href="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-59-59.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-59-59.png" alt="img"></a></p>
</li>
</ol>
<p>相信很多人都用的是这两种其中的一种。我是一个对自己极度不自信的人，来来回回换了好几次。最终觉得第2种方式很稳定，线上线下较统一。第1种方式特征更新较快，模型更准确，但带来的问题就是线上线下不太统一。</p>
<h1 id="7-模型训练-amp-验证-amp-调参"><a href="#7-模型训练-amp-验证-amp-调参" class="headerlink" title="7. 模型训练&amp;验证&amp;调参"></a>7. 模型训练&amp;验证&amp;调参</h1><h2 id="7-1-模型"><a href="#7-1-模型" class="headerlink" title="7.1 模型"></a>7.1 模型</h2><p>操作系统：ubuntu14.04</p>
<p>机器内存：256G</p>
<p>语言：python</p>
<p>用到的模型：</p>
<ul>
<li><p>LR：L1\L2</p>
</li>
<li><p>gbdt：xgboost,lightGBM</p>
</li>
<li><p>gbdt+lr：Facebook论文中提出的一种方法</p>
</li>
<li><p>特征离散化+ffm：</p>
<p>​    可以参考我的两篇文章</p>
<p>​    <a href="https://siyaozhang.github.io/2017/03/14/Factorization-Machine%EF%BC%88FM%EF%BC%8C%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3%E6%9C%BA%EF%BC%89/" target="_blank" rel="external">Factorization Machine（<strong>FM</strong>，因子分解机）</a></p>
<p>​    <a href="https://siyaozhang.github.io/2017/03/22/FFM%EF%BC%88field-aware-Factorization-Machine%EF%BC%89%E2%80%94%E2%80%94%E5%8D%87%E7%BA%A7%E7%89%88FM/" target="_blank" rel="external">F<strong>FM</strong>（field-aware Factorization Machine）——升级版<strong>FM</strong></a></p>
</li>
</ul>
<h2 id="7-2-调参："><a href="#7-2-调参：" class="headerlink" title="7.2 调参："></a>7.2 调参：</h2><p>决赛LGB参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">params = &#123; </div><div class="line"> <span class="string">'boosting_type'</span>: <span class="string">'gbdt'</span>, </div><div class="line"> <span class="string">'objective'</span>: <span class="string">'binary'</span>, //目标，二分类</div><div class="line"> <span class="string">'metric'</span>: <span class="string">'binary_logloss'</span>, //损失函数</div><div class="line"> <span class="string">'num_leaves'</span>: <span class="number">280</span>, //叶子节点数目</div><div class="line"> <span class="string">'learning_rate'</span>: <span class="number">0.05</span>, //学习率</div><div class="line"> <span class="string">'feature_fraction'</span>: <span class="number">0.90</span>, //随机抽取特征率</div><div class="line"> <span class="string">'bagging_fraction'</span>: <span class="number">1</span>, </div><div class="line"> <span class="string">'bagging_freq'</span>: <span class="number">5</span>, </div><div class="line"> <span class="string">'verbose'</span>: <span class="number">0</span>, </div><div class="line"> <span class="string">'min_gain_to_split'</span>:<span class="number">1</span>, //最小分裂信息增益</div><div class="line"> <span class="string">'lambda_l1'</span>:<span class="number">1</span> //正则化项系数</div><div class="line"> &#125; </div><div class="line"> num_boost_round = <span class="number">1000</span> //训练轮数，树的数目</div><div class="line"> early_stopping_rounds = <span class="number">20</span>//提前停止轮数</div></pre></td></tr></table></figure>
<p>初赛XGB参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">params = &#123;</div><div class="line">        <span class="string">'task'</span>: <span class="string">'train'</span>,</div><div class="line">        <span class="string">'boosting_type'</span>: <span class="string">'gbdt'</span>,</div><div class="line">        <span class="string">'objective'</span>: <span class="string">'regression'</span>,</div><div class="line">        <span class="string">'metric'</span>: <span class="string">'binary_logloss'</span>,</div><div class="line">        <span class="string">'num_leaves'</span>: <span class="number">31</span>,</div><div class="line">        <span class="string">'learning_rate'</span>: <span class="number">0.1</span>,</div><div class="line">        <span class="string">'feature_fraction'</span>: <span class="number">0.9</span>,</div><div class="line">        <span class="string">'bagging_fraction'</span>: <span class="number">0.8</span>,</div><div class="line">        <span class="string">'bagging_freq'</span>: <span class="number">5</span>,</div><div class="line">        <span class="string">'verbose'</span>: <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    num_boost_round = <span class="number">100</span></div></pre></td></tr></table></figure>
<h1 id="8-项目代码"><a href="#8-项目代码" class="headerlink" title="8. 项目代码"></a>8. 项目代码</h1><p><a href="https://github.com/zsyandjyhouse/TencentAD_contest" target="_blank" rel="external">TencentAD_contest</a></p>
<h1 id="9-参考资料"><a href="#9-参考资料" class="headerlink" title="9. 参考资料"></a>9. 参考资料</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/26820998" target="_blank" rel="external">Kaggle 数据挖掘比赛经验分享</a></li>
<li><a href="http://blog.csdn.net/yang090510118/article/details/39478033" target="_blank" rel="external">逻辑回归LR的特征为什么要先离散化</a></li>
<li><a href="http://breezedeus.github.io/2014/11/20/breezedeus-feature-hashing.html" target="_blank" rel="external">特征哈希（Feature Hashing）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26945814" target="_blank" rel="external">机器学习中的维度灾难</a></li>
<li><a href="http://blog.jasonding.top/2015/11/12/Feature%20Engineering/%E3%80%90%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E3%80%91%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%89%B9%E5%BE%81%E5%AD%A6%E4%B9%A0/" target="_blank" rel="external">【特征工程】特征选择与特征学习</a></li>
<li><a href="http://202.197.191.206:8080/30/text/chapter04/4_8.htm" target="_blank" rel="external">描述量选择及特征的组合优化</a></li>
<li><a href="http://www.jianshu.com/p/8f6f94f1d275" target="_blank" rel="external">scikit-learn系列之特征选择</a></li>
<li><a href="http://blog.csdn.net/shine19930820/article/details/71713680" target="_blank" rel="external">GBDT原理及利用GBDT构造新的特征-Python实现</a></li>
<li><a href="http://www.bigbear2017.com/blog/2016/11/02/facebook-ctr-paper/" target="_blank" rel="external">很好的文献资料Facebook CTR Paper</a></li>
<li><a href="https://github.com/z564808896/Tencent_Social_Ads" target="_blank" rel="external">竟然有这种操作队分享</a></li>
<li><a href="https://www.qcloud.com/community/article/895055" target="_blank" rel="external">【SPA大赛】腾讯广告点击大赛：对stacking的一些基本介绍</a></li>
<li><a href="http://blog.csdn.net/ben3ben/article/details/74838338" target="_blank" rel="external">第七名</a></li>
</ol>
<h1 id="10-top3方案"><a href="#10-top3方案" class="headerlink" title="10. top3方案"></a>10. top3方案</h1><h3 id="10-1-top1"><a href="#10-1-top1" class="headerlink" title="10.1 top1"></a>10.1 top1</h3><p>特征工程非常细致，而且有理有据，都是经过仔细的分析统计抽取的特征，效果必然好，而且还做了模型创新，用</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-07-17-03-21.png" alt=""> </p>
<h3 id="10-2-top2"><a href="#10-2-top2" class="headerlink" title="10.2 top2"></a>10.2 top2</h3><p>也是用了17-30号交叉验证，和我们相同的就不说了，说说不同的：</p>
<p>回流数据不准处理方法：删掉30号平均回流时间较长的数据</p>
<p>应该是这里回流的处理方式比较好，特征也比较细致，最后模型也做了stacking，模型大概跟我们差不多，但是我们ffm一直没训练好，最后也没有融合</p>
<h3 id="10-3-top4"><a href="#10-3-top4" class="headerlink" title="10.3 top4"></a>10.3 top4</h3><p>deepFM</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章系统设计】一致性哈希&短网址系统设计]]></title>
      <url>/2018/03/05/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C-%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-05-16-18-40.png" alt=""> </p>
<h1 id="consistent-hashing-一致性哈性"><a href="#consistent-hashing-一致性哈性" class="headerlink" title="consistent hashing 一致性哈性"></a>consistent hashing 一致性哈性</h1><h2 id="复习："><a href="#复习：" class="headerlink" title="复习："></a>复习：</h2><p>数据量过大，需要将数据拆分，有两种拆分方式：</p>
<ol>
<li>纵向：不同表存在不同机器，按常用字段和不常用字段将表拆分存在不同机器</li>
<li>横向：将数据横向切分，存在不同的机器上</li>
</ol>
<h2 id="为什么要做一致性hash？"><a href="#为什么要做一致性hash？" class="headerlink" title="为什么要做一致性hash？"></a>为什么要做一致性hash？</h2><ul>
<li>一种简单的hash算法：将数据存在第%n个机器上</li>
<li>当增加一台机器时（n -&gt; n+1），需要迁移的数据量非常大</li>
<li>因此这个hash算法称为<strong>不一致hash</strong></li>
</ul>
<h2 id="一个简单的一致性hash算法："><a href="#一个简单的一致性hash算法：" class="headerlink" title="一个简单的一致性hash算法："></a>一个简单的一致性hash算法：</h2><ul>
<li><p>将key模一个很大的数，比如360</p>
</li>
<li><p>将360分配给n台机器，每个机器负责一段区间</p>
</li>
<li><p>区间分配信息记录在一张表上，存在web server上</p>
</li>
<li><p>新加一台机器的时候，在表中选择一个位置插入，匀走<strong>相邻</strong>两台机器的一部分数据</p>
</li>
<li><p>比如n从3变化到4：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-05-17-24-32.png" alt=""> </p>
</li>
</ul>
<p>缺陷：</p>
<ol>
<li>数据分布不均匀：分摊数据后，各机器数据分布不均匀</li>
<li>迁移压力大：新机器只能从与之相邻的两台机器上迁移数据，导致这两台老机器负载过大</li>
</ol>
<h2 id="一个更实用的一致性hashing"><a href="#一个更实用的一致性hashing" class="headerlink" title="一个更实用的一致性hashing"></a>一个更实用的一致性hashing</h2><p>将机器（IP或者名字）与数据，都看做环上的一个点！！</p>
<ol>
<li>将机器映射到环上，如下图所示的ABCD是四个机器<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-39-02.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-39-02.png" alt="img"></a></li>
<li>比如有个数据，蓝色的点，散在了蓝色点出。那么就顺时针去找一个机器，把这个数据放在这个机器上，即B<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-40-32.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-40-32.png" alt="img"></a></li>
<li>那么如何让点更均匀呢？<br>四个点可能不会均匀，但是4000个点相对来说一定会更均匀。那就引入Micro shards / Virtual nodes 的概念——一台机器对应了1000个代表。例如将A机器撒在环上（下图红色），将B机器撒在环上（下图蓝色）<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-42-51.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-42-51.png" alt="img"></a><br>来了一个数据时， 例如图中的黑色点Data，那么就找到了机器B<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-44-31.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-44-31.png" alt="img"></a></li>
<li>也就是意味着，每个机器负责了很多个离散的区间。</li>
<li>当需要加入一台新机器时？加入我们现在机器分布是这样：<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-51-51.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-51-51.png" alt="img"></a><br>新来了一个E的机器，丢到环里之后<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-52-19.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-52-19.png" alt="img"></a><br>[D,E]之间的数据必须从A迁移到E上！！！！[A,E]之间的数据必须从B迁移到E上</li>
</ol>
<p>总结：</p>
<ul>
<li><p>将整个hash区间看成一个环，大小从359变成<script type="math/tex">2^{64}-1</script></p>
</li>
<li><p>将机器和数据都看成是环上的点</p>
</li>
<li><p>引入Micro shards/Virtual nodes的概念，每台机器对应1000个Micro shards/Virtual nodes</p>
</li>
<li><p>把每台机器看成1000台机器均匀撒在环上</p>
</li>
<li><p>每加入一条数据</p>
<ul>
<li>计算其id对应的hash值，得到0~<script type="math/tex">2^{64}-1</script> 区间上的一个点，找到环上对应的点</li>
<li>从这个点出发顺时针找到第一个机器的virtual node</li>
<li>该virtual node对应的机器就是本条数据应该存储的数据库服务器</li>
</ul>
</li>
<li><p>每加入一台新机器</p>
<ul>
<li>在环上随机撒1000个点</li>
<li>这1000个virtual node 各自想顺时针相邻的第一个virtual node 索要数据</li>
<li>例子：<a href="http://www.jiuzhang.com/qa/2067/" target="_blank" rel="external">http://www.jiuzhang.com/qa/2067/</a></li>
</ul>
</li>
<li><p>实现用TreeMap 红黑树</p>
<p>​</p>
</li>
</ul>
<p>问题：</p>
<p>问题1：需要存储数据在环的哪里吗？<br>不需要。因为这个数据在哪里与其它数据在哪里没有关系。只需要在环上计算数据所在的点的下一个位置的机器是哪个即可。</p>
<p>问题：那这个1000能变成100万吗？<br>太多也不行。查询效率会变低。就是在比较均匀的情况下选一个比较快的就行。</p>
<p>思考：哪种数据结构能够支持这种“顺时针”寻找下一个机器的功能呢？——链表是不行的，因为链表长度太大，查找很慢。用TreeMap!! 就是一个红黑树，能在LogN的时间内寻找比n大的最小值。</p>
<h1 id="数据备份-Replica"><a href="#数据备份-Replica" class="headerlink" title="数据备份 Replica"></a>数据备份 Replica</h1><h2 id="问题：Backup和Replica有什么区别？"><a href="#问题：Backup和Replica有什么区别？" class="headerlink" title="问题：Backup和Replica有什么区别？"></a>问题：Backup和Replica有什么区别？</h2><p>Backup</p>
<ul>
<li>一般是周期性的，比如每天晚上进行一次备份</li>
<li>当数据丢失的时候，通常只能恢复到之前的某个时间点</li>
<li>Backup 的数据是死数据，是离线的。不用作在线的数据服务，不分摊读</li>
</ul>
<p>Replica</p>
<ul>
<li>是实时的， 在数据写入的时候，就会以复制品的形式存为多份</li>
<li>当数据丢失的时候，可以马上通过其他的复制品恢复</li>
<li>Replica是实时的。 用作在线的数据服务，分摊读</li>
</ul>
<p>思考：既然 Replica 更牛，那么还需要 Backup么？</p>
<p>backup便宜哇~</p>
<h2 id="MySQL类型数据库的Replica"><a href="#MySQL类型数据库的Replica" class="headerlink" title="MySQL类型数据库的Replica"></a>MySQL类型数据库的Replica</h2><p>以MySQL为代表的的SQL型数据库，通常自带Master Slave模式的Replica方法。Master负责写，Slave负责读。Slave从Master中同步对数据的操作。</p>
<p><strong>Master - slave原理</strong>：Write Ahead Log</p>
<p>SQL数据库的任何操作，都会以Log的形式做一份记录。</p>
<p>比如Master上的数据A在B时刻从C改成了D，那么Master会通知Slave来读Log（不是同步值，而是同步操作！）。Slave被激活后，告诉master我可以更新了，之后Master有任何操作就会通知slave来读log然后slave会同步操作</p>
<p>因此Slave上的数据是有延迟的。</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-24-44.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-24-44.png" alt="img"></a></p>
<p>问题：万一Master挂了怎么办？</p>
<ul>
<li>将一台slave升级为master, 接受读 + 写</li>
<li>可能会造成一定程度的数据丢失和不一致</li>
</ul>
<h2 id="NoSQL类型数据库的Replica"><a href="#NoSQL类型数据库的Replica" class="headerlink" title="NoSQL类型数据库的Replica"></a>NoSQL类型数据库的Replica</h2><p>以Cassandra为代表的的NoSQL数据库，通常将数据“顺时针”存储在Consistent hashing环上的三个vitual nodes中。</p>
<h2 id="MySQL和NoSQL型数据库的Replica比较"><a href="#MySQL和NoSQL型数据库的Replica比较" class="headerlink" title="MySQL和NoSQL型数据库的Replica比较"></a>MySQL和NoSQL型数据库的Replica比较</h2><p><strong>SQL</strong></p>
<ul>
<li>“自带” 的 Replica 方式是 Master Slave</li>
<li>“手动” 的 Replica 方式也可以在 Consistent Hashing 环上顺时针存三份</li>
</ul>
<p><strong>NoSQL</strong></p>
<ul>
<li>“自带” 的 Replica 方式就是 Consistent Hashing 环上顺时针存三份</li>
<li>“手动” 的 Replica 方式：就不需要手动了，NoSQL就是在 Sharding 和 Replica 上帮你偷懒用的！</li>
</ul>
<h1 id="设计短网址系统-Design-Tiny-URL"><a href="#设计短网址系统-Design-Tiny-URL" class="headerlink" title="设计短网址系统 Design Tiny URL"></a>设计短网址系统 Design Tiny URL</h1><p>短网址生成网站：</p>
<p><a href="https://bitly.com/" target="_blank" rel="external">https://bitly.com/</a><br><a href="https://goo.gl/" target="_blank" rel="external">https://goo.gl/</a></p>
<h2 id="系统设计的常见误区："><a href="#系统设计的常见误区：" class="headerlink" title="系统设计的常见误区："></a>系统设计的常见误区：</h2><p><strong>以下几个是误区</strong></p>
<ul>
<li>系统一定巨大无比 —— ×</li>
<li>必须用NoSQL —— ×</li>
<li>必须是分布式 —— ×</li>
</ul>
<p>不可以扔关键词，必须一步步分析。</p>
<p><strong>正确打开方式——4S分析法</strong></p>
<ol>
<li>提问：分析功能/需求/QPS/存储容量——Scenario</li>
<li>画图：根据分析结果设计“可行解”—— Service+Storage</li>
<li>进化：研究可能遇到的问题，优化系统 —— Scale</li>
</ol>
<h2 id="1-Scenario-场景-需求分析"><a href="#1-Scenario-场景-需求分析" class="headerlink" title="1. Scenario 场景 需求分析"></a>1. Scenario 场景 需求分析</h2><h4 id="我要设计啥"><a href="#我要设计啥" class="headerlink" title="我要设计啥"></a>我要设计啥</h4><ul>
<li>根据长URL生成短URL<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-35-36.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-35-36.png" alt="img"></a></li>
<li>根据短URL还原长URL<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-36-01.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-36-01.png" alt="img"></a></li>
</ul>
<h4 id="QPS-Storage"><a href="#QPS-Storage" class="headerlink" title="QPS + Storage"></a>QPS + Storage</h4><p>假设这个是用来给微博做短网址的跳转。那么QPS能有多少？</p>
<ol>
<li>询问微博日活用户 —— 约100M</li>
<li>推算产生一条Tiny URL的QPS<ul>
<li>假设每个用户平均每天发0.1条微博，</li>
<li>平均写QPS = 100M * 0.1 / 86400 ~ 100</li>
<li>峰值QPS = 100 * 2 = 200</li>
</ul>
</li>
<li>推算点击一条Tiny URL的QPS<ul>
<li>假设每个用户平均点1个Tiny URL</li>
<li>平均读QPS = 100M * 1 / 86400 ~ 1k</li>
<li>峰值QPS = 2k</li>
</ul>
</li>
<li>推算每天产生的新的 URL 所占存储<ul>
<li>100M * 0.1 ~ 10M 条</li>
<li>每一条 URL 长度平均 100 算，一共1G</li>
<li>1T 的硬盘可以用 3 年</li>
</ul>
</li>
</ol>
<p>前3点：2k QPS ，一台SSD支持的MySQL完全可以搞定！</p>
<h2 id="2-Service-服务"><a href="#2-Service-服务" class="headerlink" title="2. Service 服务"></a>2. Service 服务</h2><h4 id="逻辑块聚类与接口设计"><a href="#逻辑块聚类与接口设计" class="headerlink" title="逻辑块聚类与接口设计"></a>逻辑块聚类与接口设计</h4><ol>
<li><p>TinyUrl只有一个UrlService</p>
<ul>
<li>本身就是一个小Application</li>
<li>无需关心其他的</li>
</ul>
</li>
<li><p>函数设计</p>
<ul>
<li><code>UrlService.encode(long_url)</code></li>
<li><code>`UrlService.decode(short_url)</code></li>
</ul>
</li>
<li><p>访问端口设计</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">GET /&lt;short_url&gt;</div><div class="line">	<span class="keyword">return</span> a Http redirect response</div><div class="line"></div><div class="line">POST /data/shorten/</div><div class="line">	Data = &#123;url: http:<span class="comment">//xxxx &#125;</span></div><div class="line">	Return <span class="keyword">short</span> url</div></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-49-19.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-49-19.png" alt="img"></a></p>
<h2 id="3-Storage-数据存储"><a href="#3-Storage-数据存储" class="headerlink" title="3. Storage 数据存储"></a>3. Storage 数据存储</h2><p>两个步骤：</p>
<ol>
<li>选择存储结构</li>
<li>细化数据表</li>
</ol>
<h4 id="选择存储结构-SQL-vs-NoSQL"><a href="#选择存储结构-SQL-vs-NoSQL" class="headerlink" title="选择存储结构 SQL vs NoSQL"></a>选择存储结构 SQL vs NoSQL</h4><ul>
<li>是否需要支持 Transaction（事务）？<ul>
<li>NoSQL不支持Transaction</li>
<li>是否需要丰富的 SQL Query？</li>
</ul>
</li>
<li>NoSQL的SQL Query不是太丰富<ul>
<li>也有一些NoSQL的数据库提供简单的SQL Query支持</li>
</ul>
</li>
<li>是否想偷懒？<ul>
<li>大多数 Web Framework 与 SQL 数据库兼容得很好</li>
<li>用SQL比用NoSQL少写很多代码</li>
</ul>
</li>
<li>是否需要Sequential ID？<ul>
<li>SQL 为你提供了 auto-increment 的 Sequential ID。也就是1,2,3,4,5 …</li>
<li>NoSQL的ID并不是 Sequential 的</li>
</ul>
</li>
<li>对QPS的要求有多高？<ul>
<li>NoSQL 的性能更高</li>
</ul>
</li>
<li>对Scalability的要求有多高？<ul>
<li>SQL 需要码农自己写代码来 Scale</li>
<li>还记得Db那节课中怎么做 Sharding，Replica 的么？</li>
</ul>
</li>
<li>NoSQL 这些都帮你做了</li>
</ul>
<p><strong>选择</strong></p>
<ul>
<li>是否需要支持 Transaction？——不需要。NoSQL +1</li>
<li>是否需要丰富的 SQL Query？——不需要。NoSQL +1</li>
<li>是否想偷懒？——Tiny URL 需要写的代码并不复杂。NoSQL+1</li>
<li>对QPS的要求有多高？—— 经计算，2k QPS并不高，而且2k读可以用Cache，写很少。SQL +1</li>
<li>对Scalability的要求有多高？—— 存储和QPS要求都不高，单机都可以搞定。SQL+1</li>
<li>是否需要Sequential ID？—— 取决于你的算法是什么 : 如何将Long URL 转化为 Short URL</li>
</ul>
<h2 id="4-算法：-如何将Long-URL-转化为-Short-URL"><a href="#4-算法：-如何将Long-URL-转化为-Short-URL" class="headerlink" title="4. 算法： 如何将Long URL 转化为 Short URL"></a>4. 算法： 如何将Long URL 转化为 Short URL</h2><h3 id="4-1-算法1-使用哈希函数-Hash-Function（不可行）"><a href="#4-1-算法1-使用哈希函数-Hash-Function（不可行）" class="headerlink" title="4.1 算法1 使用哈希函数 Hash Function（不可行）"></a>4.1 算法1 使用哈希函数 Hash Function（不可行）</h3><p>比如取 Long Url 的 MD5 的最后 6 位——这个方法肯定是有问题的</p>
<ul>
<li>优点：快</li>
<li>缺点：难以设计一个没有冲突的哈希算法</li>
</ul>
<h3 id="4-2-算法2：随机生成-数据库去重"><a href="#4-2-算法2：随机生成-数据库去重" class="headerlink" title="4.2 算法2：随机生成 + 数据库去重"></a>4.2 算法2：随机生成 + 数据库去重</h3><p>随机一个 6 位的 ShortURL，如果没有被用过，就绑定到该 LongURL</p>
<p>伪代码如下：<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-03-23-00-12.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-03-23-00-12.png" alt="img"></a></p>
<ul>
<li>优点：实现简单</li>
<li>缺点：生成短网址的长度随着短网址越来越多变得越来越慢</li>
<li>可行性：其实能凑合用。在生活中有很多随机编码的，例如机票码、酒店码，是不可重复的，就是用这种方法弄的。</li>
</ul>
<h3 id="4-3-算法3：进制转换-Base62"><a href="#4-3-算法3：进制转换-Base62" class="headerlink" title="4.3 算法3：进制转换 Base62"></a>4.3 算法3：进制转换 Base62</h3><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-20-55-32.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-20-55-32.png" alt="img"></a></p>
<ul>
<li>Base62<ul>
<li>将6位的short url看成一个62进制的数（0-9,a-z,A-Z）</li>
<li>每个short url对应到一个整数</li>
<li>该整数对应数据库表的主键——Sequential ID</li>
</ul>
</li>
<li>6位可以表示不同的URL有多少？<ul>
<li>5位 = 625625 = 9亿</li>
<li>6位 = 626626 = 570亿</li>
<li>7位 = 627627 = 35000亿</li>
</ul>
</li>
<li>优缺点<ul>
<li>优点：效率高</li>
<li>缺点：依赖于全局的自增ID</li>
</ul>
</li>
</ul>
<h3 id="4-4-算法2与3的比较"><a href="#4-4-算法2与3的比较" class="headerlink" title="4.4 算法2与3的比较"></a>4.4 算法2与3的比较</h3><ul>
<li><p><strong>基于随机生成的方法</strong><br>需要根据 Long 查询 Short，也需要根据 Short 查询 Long。基本上work solution如下图所示：<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-00-54.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-00-54.png" alt="img"></a><br>如果选择用 SQL 型数据库，表结构如下：<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-20-58-03.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-20-58-03.png" alt="img"></a><br>并且需要对shortKey和longURL分别建索引<br>• <a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95" target="_blank" rel="external">什么是索引？</a><br>• <a href="http://www.cnblogs.com/morvenhuang/archive/2009/03/30/1425534.html" target="_blank" rel="external">索引的原理？</a><br>也可以选用 NoSQL 数据库，但是需要建立两张表（大多数NoSQL数据库不支持二级索引）。以 Cassandra 为例子<br>第一张表：根据 Long 查询 Short<br>row_key=longURL, column_key=ShortURL, value=null or timestamp<br>第二张表：根据 Short 查询 Long<br>row_key=shortURL, column_key=LongURL, value=null or timestamp</p>
</li>
<li><p><strong>基于进制转换的方法</strong><br>因为需要用到自增ID（Sequential ID），因此只能选择使用 SQL 型数据库。表单结构如下，shortURL 可以不存储在表单里，因为可以根据 id 来进行换算</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-05-21-36-40.png" alt=""> </p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-02-19.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-02-19.png" alt="img"></a></p>
</li>
</ul>
<h2 id="5-Scale-优化"><a href="#5-Scale-优化" class="headerlink" title="5. Scale 优化"></a>5. Scale 优化</h2><h3 id="5-1-如何提高响应速度？"><a href="#5-1-如何提高响应速度？" class="headerlink" title="5.1 如何提高响应速度？"></a>5.1 如何提高响应速度？</h3><p><strong>读操作的优化</strong></p>
<p>既然读操作比较多，那么可以用cache的方式去提速。</p>
<ul>
<li>cache里存什么？<ul>
<li>long to short(生成新short url时需要)</li>
<li>short to long(查询short url时需要)</li>
</ul>
</li>
<li>查询的流程图：<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-22-22.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-22-22.png" alt="img"></a></li>
</ul>
<h3 id="5-2-如何提速？"><a href="#5-2-如何提速？" class="headerlink" title="5.2 如何提速？"></a>5.2 如何提速？</h3><ul>
<li><p>利用地理位置信息加速</p>
</li>
<li><p>优化服务器速度</p>
<ul>
<li>不同地区，使用不同Web服务器</li>
<li>通过DNS解析不同地区的用户到不同的服务器</li>
</ul>
</li>
<li><p>优化数据访问速度</p>
<ul>
<li><p>使用Centralized MySQL + Distributed Memcached</p>
</li>
<li><p>数据库共享一个，不同地区设置多个缓存</p>
</li>
<li><p>一个MySQL配多个Memcached, Memcached跨地区分布</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-31-37.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-31-37.png" alt="img"></a></p>
</li>
</ul>
</li>
</ul>
<h3 id="5-3-数据量扩展"><a href="#5-3-数据量扩展" class="headerlink" title="5.3 数据量扩展"></a>5.3 数据量扩展</h3><p>如果数据量很大，一台MySQL搞不定了</p>
<ul>
<li>什么时候需要扩展多台服务器？<ul>
<li>Cache资源不够</li>
<li>写操作越来越多</li>
<li>请求太多，无法通过Cache满足</li>
</ul>
</li>
<li>增加多台数据库可以优化什么？<ul>
<li>解决存不下的问题——Storage角度（TinyURL一般遇不到这种问题）</li>
<li>解决忙不过来的问题——QPS角度</li>
<li>TinyURL主要是什么问题？？——忙不过来的问题</li>
</ul>
</li>
</ul>
<ul>
<li><p>如何解决忙不过来的问题？拆分 </p>
<ul>
<li><p>纵向切分？不同列放不同数据库？不可行！</p>
</li>
<li><p>横向拆分？</p>
<ul>
<li><p>用什么做sharding key?</p>
</li>
<li><p>如果用longURL做为sharding key，如何查询ID(short URL) ?</p>
<ul>
<li>已知shortURL查询longURL时，只能广播给N台数据库查询</li>
<li>不能降低每台机器QPS</li>
</ul>
</li>
<li><p>如果用ID(short URL)做为sharding key，如何查询 longURL?</p>
<ul>
<li><p>假设按照ID%N来分配存储</p>
</li>
<li><p>short2long</p>
<ul>
<li>将shortURL转化为ID</li>
<li>根据ID计算找到数据库</li>
<li>在该数据库中查询longURL即可</li>
</ul>
</li>
<li><p>long2short</p>
<ul>
<li>先查询：广播给N台数据库，查询是否存在，似乎有点耗时，但是也是可行的，因为数据库服务器不会太多</li>
<li>再插入如果不存在的话，获得下一个自增ID值，插入对应数据库</li>
<li><strong>其实也不可以不查询直接插入</strong>，因为long2short没有必要意义对应，<strong>一个long可以对应多个short</strong>，也就是说可以把长网址转成多个短网址，但是一旦用户获得一个短网址，相同的短网址只能对应一个长网址。</li>
</ul>
</li>
<li><p>这种方法还有一个问题，如何在多台数据库服务器上获取全局递增的ID？（因为每台机器上都有一个数据表，需要获取所有数据的递增ID就是个问题），解决办法：</p>
<ol>
<li>专门用一台服务器负责自增ID服务，不存储数据，也不负责查询</li>
<li>用Zookeeper</li>
</ol>
<p>但用全局递增ID不是解决TinyURL的好办法</p>
</li>
</ul>
</li>
</ul>
<p><strong>下面是一种更好的sharding办法，不需要全局递增ID：</strong></p>
</li>
<li><p>如果最开始shortkey为6位，那就增加一位前置位：</p>
<ul>
<li>AB1234 –&gt; 0AB1234（该前置位由hash(long_url)%62得到（可以用consistent hash算法），因此是唯一的。这个前置位可以作为机器的ID等）</li>
<li>另一种做法，把第一位单独留出来做sharding key，总共还是6位</li>
</ul>
</li>
<li><p>该前置位为sharding key</p>
</li>
<li><p>这样我们就可以同时通过shortURL和longURL得到sharding key</p>
<ul>
<li>无需广播</li>
<li>无论short2long还是long2short都可直接定位数据所在服务器</li>
</ul>
</li>
<li><p>当新加入一个longURL时，先通过hash(long_url)%62得到机器ID，然后在该机器上，通过该台机器的自增ID通过进制转换得到6位shortkey</p>
</li>
<li><p>用户已知shortURL时，先按第一位获取到机器ID，然后在此机器上查询longURL</p>
<p>那么当前的架构就变成了：</p>
</li>
</ul>
</li>
</ul>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-22-18-36.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-22-18-36.png" alt="img"></a></p>
<h3 id="5-4-Multi-region-的进一步优化"><a href="#5-4-Multi-region-的进一步优化" class="headerlink" title="5.4 Multi region 的进一步优化"></a>5.4 Multi region 的进一步优化</h3><p>上面的架构图还有优化的空间：</p>
<ul>
<li>网站服务器与数据库服务器之间的通信</li>
<li>中心化服务器集群与跨地域的web server之间的通信较慢，比如如果中心数据库放在美国，那么中国的服务器需要访问美国的数据库，通信较慢</li>
</ul>
<p>解决方法1：重写数据库到中国，中国用户访问中国数据库</p>
<p>问题：重写数据库，一致性问题如何解决？很难解决</p>
<p>正确打开方式：</p>
<p>想一想用户习惯：</p>
<ol>
<li>中国的用户一般访问的网站是中国的，美国的用户一般访问的网站是美国的</li>
<li>中国用户访问时，会被DNS分配中国的服务器</li>
</ol>
<p>因此我们可以用<strong>地域信息</strong>进行sharding，也就是说按照网站的地域信息将其数据分开存储在不同地方的数据库中</p>
<p>​    如何获得网站的地域信息？做一张用户经常访问的网站数据表</p>
<p>这样中国用户要访问的网站大多在位于中国的数据库中，响应速度就会比较快，当然也有少量中国用户需要访问美国网站的情况，就直接去访问美国数据库就好，反正不会慢对少，毕竟中国访问中国是主流需求，优化系统就是要优化主要需求。</p>
<p>最终架构图</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-11-17-32.png" alt=""> </p>
<h3 id="5-5-自定义短链接"><a href="#5-5-自定义短链接" class="headerlink" title="5.5 自定义短链接"></a>5.5 自定义短链接</h3><p>用户自定义短网址 -&gt; 长网址映射</p>
<p><a href="http://tiny.url/google/" target="_blank" rel="external">http://tiny.url/google/</a> =&gt; <a href="http://www.google.com" target="_blank" rel="external">http://www.google.com</a><br><a href="http://tiny.url/systemdesign/" target="_blank" rel="external">http://tiny.url/systemdesign/</a> =&gt; <a href="http://www.jiuzhang.com/course/2/" target="_blank" rel="external">http://www.jiuzhang.com/course/2/</a></p>
<p><strong>一个错误的想法是：</strong></p>
<p>在URLtable中增加一个column，存放自定义的URL，因为这一列大部分会是空的，浪费空间。</p>
<p>正确打开方式：</p>
<ul>
<li>新建一张表存储自定义URL<ul>
<li>CustomURL Table</li>
</ul>
</li>
</ul>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-12-05-53.png" alt=""> </p>
<ul>
<li>已知长链接查询短链接的时候：<ul>
<li>先查询customURL table</li>
<li>再查询URL table</li>
</ul>
</li>
<li>用户想要由长链接自定一个新的短链接的时候<ul>
<li>查询是否已经在URLtable中存在了</li>
<li>再在CustomURL table 中查询和插入</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 系统设计 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班】follow up]]></title>
      <url>/2018/02/26/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91follow-up/</url>
      <content type="html"><![CDATA[<h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-26-20-43-25.png" alt=""> </p>
<h2 id="例题1-Find-Peak-Element"><a href="#例题1-Find-Peak-Element" class="headerlink" title="例题1.Find Peak Element"></a>例题1.<a href="https://leetcode.com/problems/find-peak-element" target="_blank" rel="external">Find Peak Element</a></h2><blockquote>
<p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array where <code>num[i] ≠ num[i+1]</code>, find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that <code>num[-1] = num[n] = -∞</code>.</p>
<p>For example, in array <code>[1, 2, 3, 1]</code>, 3 is a peak element and your function should return the index number 2.</p>
</blockquote>
<p>找局部最大值。</p>
<p>思路：</p>
<ol>
<li><p>baseline：</p>
<p>遍历，找到i：nums[i-1]&lt;num[i]&lt;num[i+1]</p>
<p>复杂度<script type="math/tex">O(n)</script></p>
</li>
</ol>
<ol>
<li><p>优化：二分法</p>
<p>首先我们找到中间节点mid，如果大于两边返回当前index就可以了，如果左边的节点比mid大，那么我们可以继续在左半区间查找，这里面一定存在一个peak，为什么这么说呢？假设此时的区间范围为[0, mid - 1]， 因为num[mid - 1]一定大于num[mid]了，如果num[mid - 2] &lt;= num[mid - 1]，那么num[mid - 1]就是一个peak。如果num[mid - 2] &gt; num[mid - 1]，那么我们就继续在[0, mid - 2]区间查找，因为num[-1]为负无穷，所以最终我们绝对能在左半区间找到一个peak。同理右半区间一样。</p>
<p>复杂度<script type="math/tex">O(logn)</script></p>
</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">         <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//遇到这种需要判断元素左右的将start设为1，end设为len-2,放置越界</span></div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">2</span>;</div><div class="line">        <span class="keyword">while</span>(start+<span class="number">1</span>&lt;end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>((nums[mid] &gt; nums[mid+<span class="number">1</span>]) &amp;&amp; (nums[mid] &gt; nums[mid-<span class="number">1</span>]))&#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((nums[mid] &lt; nums[mid+<span class="number">1</span>]) &amp;&amp; (nums[mid] &lt; nums[mid-<span class="number">1</span>]))&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nums[mid] &gt; nums[mid+<span class="number">1</span>]) &amp;&amp; (nums[mid] &lt; nums[mid-<span class="number">1</span>]))&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[start] &lt; nums[end])&#123;</div><div class="line">            <span class="keyword">return</span>  end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="follow-up-Find-Peak-Element-II"><a href="#follow-up-Find-Peak-Element-II" class="headerlink" title="follow up: Find Peak Element II"></a>follow up: Find Peak Element II</h3><p> 由一维拓展到二维，在矩阵上找peak element</p>
<p>peak element：<code>matrix[i][j]</code> 比其上下左右相邻元素大</p>
<p>思路：</p>
<ol>
<li><p>baseline：</p>
<p>遍历</p>
<p>复杂度复杂度<script type="math/tex">O(n^2)</script></p>
</li>
<li><p>优化：二分法</p>
<ul>
<li>找到中间行的最大值<code>matrix[i][j]</code></li>
<li>跟相邻上下元素比较，决定向上/向下走</li>
<li>如果上面的元素比较大，向上走，否则向下走</li>
</ul>
<p>复杂度<script type="math/tex">O(nlogn)</script></p>
</li>
<li><p>优化：行列交替二分</p>
<ul>
<li>找到中间行的最大值<code>matrix[i][j]</code> <script type="math/tex">O(n)</script></li>
<li>跟相邻上下元素比较，决定向上/向下走 剩下一半矩阵</li>
<li>找中间列的最大值<code>matrix[i][j]</code><script type="math/tex">O(n/2)</script></li>
<li>跟相邻左右元素比较，决定向左/向右走 剩下n/4矩阵</li>
</ul>
<p>复杂度<script type="math/tex">O(n)</script></p>
</li>
</ol>
<h2 id="例题2-Subarray-Sum"><a href="#例题2-Subarray-Sum" class="headerlink" title="例题2. Subarray Sum"></a>例题2. <a href="http://www.lintcode.com/en/problem/subarray-sum/" target="_blank" rel="external">Subarray Sum</a></h2><blockquote>
<p>Given an integer array, find a subarray where the sum of numbers is <strong>zero</strong>. Your code should return the index of the first number and the index of the last number.</p>
<p>Example</p>
<p>Given <code>[-3, 1, 2, -3, 4]</code>, return <code>[0, 2]</code> or <code>[1, 3]</code>.</p>
</blockquote>
<p>找子数组，和为0</p>
<p>思路：</p>
<ol>
<li><p>baseline:</p>
<p>两指针遍历</p>
<p>复杂度复杂度<script type="math/tex">O(n^2)</script></p>
</li>
<li><p>prefix sum:</p>
<p>用hash表记录前缀和的取值</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">                result.add(<span class="number">0</span>);</div><div class="line">                result.add(i);</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(map.containsKey(sum))&#123;</div><div class="line">                result.add(map.get(sum)+<span class="number">1</span>);</div><div class="line">                result.add(i);</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            map.put(sum,i);<span class="comment">//key是前缀和，value是idx</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="follow-up-1-Submatrix-Sum"><a href="#follow-up-1-Submatrix-Sum" class="headerlink" title="follow up 1: Submatrix Sum"></a>follow up 1: <a href="http://www.lintcode.com/en/problem/submatrix-sum/" target="_blank" rel="external">Submatrix Sum</a></h3><blockquote>
<p>Given an integer matrix, find a submatrix where the sum of numbers is zero. Your code should return the coordinate of the left-up and right-down number.</p>
<p>Example</p>
<p>Given matrix</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1 ,5 ,7],</div><div class="line">&gt;   [3 ,7 ,-8],</div><div class="line">&gt;   [4 ,-8 ,9],</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return <code>[(1,1), (2,2)]</code></p>
</blockquote>
<p>求元素和为0的子矩阵，返回矩阵的左上角和右下角元素位置</p>
<p>思路：</p>
<ol>
<li><p>先定位子矩阵的首行和尾行（外层循环）</p>
</li>
<li><p>把首行和尾行之间的元素压成一行，变成一个数组</p>
</li>
<li><p>对上面的数组做subarray sum，找到和为0的子数组就可以定位子矩阵的首列和尾列。</p>
<p>​</p>
</li>
</ol>
<p>预计算presum矩阵：</p>
<p><code>presum[i][j] = matrix[0][0]到matrix[i][j]的所有元素和</code></p>
<p>当外层循环固定为l和h时，内层循环j从0开始遍历，矩阵的前缀和为<code>presum[h][j]-presum[l][j]</code></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] submatrixSum(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> rows = matrix.length;</div><div class="line">    <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">    <span class="keyword">if</span>(cols == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[][] presum = <span class="keyword">new</span> <span class="keyword">int</span>[rows+<span class="number">1</span>][cols+<span class="number">1</span>];</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows+<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols+<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</div><div class="line">                presum[i][j] = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                presum[i][j] = matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] + presum[i-<span class="number">1</span>][j] + presum[i][j-<span class="number">1</span>] - presum[i-<span class="number">1</span>][j-<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; rows + <span class="number">1</span>; j++) &#123;</div><div class="line">            HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cols + <span class="number">1</span>; k++) &#123;</div><div class="line">                <span class="keyword">int</span> diff = presum[j][k] - presum[i][k];</div><div class="line">                <span class="keyword">if</span> (map.containsKey(diff)) &#123;</div><div class="line">                    result[<span class="number">0</span>][<span class="number">0</span>] = i;</div><div class="line">                    result[<span class="number">0</span>][<span class="number">1</span>] = map.get(diff);</div><div class="line">                    result[<span class="number">1</span>][<span class="number">0</span>] = j-<span class="number">1</span>;</div><div class="line">                    result[<span class="number">1</span>][<span class="number">1</span>] = k-<span class="number">1</span>;</div><div class="line">                    <span class="keyword">return</span> result;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    map.put(diff, k);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="follow-up-2-Subarray-Sum-II"><a href="#follow-up-2-Subarray-Sum-II" class="headerlink" title="follow up 2: Subarray Sum II"></a>follow up 2: Subarray Sum II</h3><p>给定一个数组nums和一个区间interval，返回nums数组中和在区间interval中的子数组个数，如nums = [1,2,3,4]，interval = [1,3],return 4,the possible answers are:[0,0],[0,1],[1,1],[2,2]</p>
<p>思路：</p>
<p>low &lt; prefix[j] - prefix[i] &lt; high</p>
<p>low + prefix[i] &lt; prefix[j] &lt; high + prefix[i]</p>
<p>prefix[i]  &lt;  prefix[j] - low</p>
<p>prefix[i]  &gt; prefix[j] - high</p>
<p>所以本题就是要找到在[prefix[j] - high , prefix[j] - low]范围内的prefix[i] </p>
<p>由于prefix[i]是递增的，所以可以存在数组中，用二分法查找</p>
<h2 id="例题3-Maximum-Subarray"><a href="#例题3-Maximum-Subarray" class="headerlink" title="例题3. Maximum Subarray"></a>例题3. <a href="https://leetcode.com/problems/maximum-subarray" target="_blank" rel="external">Maximum Subarray</a></h2><blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br>the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.</p>
</blockquote>
<p>找和最大的子数组</p>
<p>思路：</p>
<p>方法1：prefixsum</p>
<p>维护最小的prefixsum和当前最大的子数组和</p>
<p>方法2：dp</p>
<p>dp[i] = max(dp[i-1] + num[i],num[i])</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> maxVal = nums[<span class="number">0</span>];</div><div class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            dp[i] = Math.max(nums[i],dp[i-<span class="number">1</span>]+nums[i]);</div><div class="line">            maxVal = Math.max(maxVal,dp[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxVal;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="follow-up-循环连续子数组"><a href="#follow-up-循环连续子数组" class="headerlink" title="follow up 循环连续子数组"></a>follow up 循环连续子数组</h2><p>上题的数组变成循环数组。</p>
<p>处理循环数组三种方法：</p>
<ol>
<li>拆开</li>
<li>扩展</li>
<li>取反</li>
</ol>
<p>分别看对于这道题是否可行：</p>
<ol>
<li><p>拆开</p>
<p>house robber用到了这个方法，抢第一个就不能抢最后一个，抢最后一个就不能抢第一个</p>
</li>
<li><p>扩展</p>
<p>将数组翻一倍，[-3, 1, 3, -3, 4]变成[-3, 1, 3, -3, 4,-3,1,3,-3]，然后找最大子数组，但是长度不能超过nums的长度。</p>
</li>
<li><p>取反</p>
<p>找循环数组中的最大子数组，有两种情况：</p>
<ol>
<li>在数组的中部，正常找就行了</li>
<li>一半在数组后面，一半在数组头部，因为数组的总和是一定的，因此这种情况可以转化成在数组中部找最小的子数组</li>
</ol>
<p>然后取上面两种情况的最大值。</p>
<p>​</p>
</li>
</ol>
<h2 id="例题4-Wiggle-Sort"><a href="#例题4-Wiggle-Sort" class="headerlink" title="例题4.  Wiggle Sort"></a>例题4.  <a href="https://leetcode.com/problems/wiggle-sort" target="_blank" rel="external">Wiggle Sort</a></h2><blockquote>
<p>Given an unsorted array <code>nums</code>, reorder it <strong>in-place</strong> such that <code>nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]...</code>.</p>
<p>For example, given <code>nums = [3, 5, 2, 1, 6, 4]</code>, one possible answer is <code>[1, 6, 2, 5, 3, 4]</code>.</p>
</blockquote>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</div><div class="line">            <span class="keyword">if</span> (flag == <span class="keyword">false</span>)&#123;</div><div class="line">                copy[idx] = nums[start];</div><div class="line">                start++;</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                copy[idx] = nums[end];</div><div class="line">                end--;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            idx++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            nums[i] = copy[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="follow-up-Wiggle-Sort-II"><a href="#follow-up-Wiggle-Sort-II" class="headerlink" title="follow up Wiggle Sort II"></a>follow up <a href="https://leetcode.com/problems/wiggle-sort-ii" target="_blank" rel="external">Wiggle Sort II</a></h3><blockquote>
<p>Given an unsorted array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p>
<p><strong>Example:</strong><br>(1) Given <code>nums = [1, 5, 1, 1, 6, 4]</code>, one possible answer is <code>[1, 4, 1, 5, 1, 6]</code>.<br>(2) Given <code>nums = [1, 3, 2, 2, 3, 1]</code>, one possible answer is <code>[2, 3, 1, 3, 1, 2]</code>.</p>
</blockquote>
<p>思路：</p>
<ol>
<li><p>baseline：</p>
<p>对数组排序，排序之后将数组分成大小两堆，然后依次选取排序</p>
</li>
<li><p>quick sort思想</p>
<p>利用quick sort 找到中点，然后对左右两边元素一次选取排序</p>
</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> mid = end/<span class="number">2</span>;</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(idx &lt; nums.length)&#123;</div><div class="line">            <span class="keyword">if</span> (flag == <span class="keyword">false</span>)&#123;</div><div class="line">                copy[idx] = nums[mid];</div><div class="line">                mid--;</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                copy[idx] = nums[end];</div><div class="line">                end--;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            idx++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            nums[i] = copy[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="例题5-Building-Post-Office-Best-Meeting-Point"><a href="#例题5-Building-Post-Office-Best-Meeting-Point" class="headerlink" title="例题5. Building Post Office Best Meeting Point"></a>例题5. Building Post Office <a href="https://leetcode.com/problems/best-meeting-point" target="_blank" rel="external">Best Meeting Point</a></h2><blockquote>
<p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="external">Manhattan Distance</a>, where distance(p1, p2) = <code>|p2.x - p1.x| + |p2.y - p1.y|</code>.</p>
<p>For example, given three people living at <code>(0,0)</code>, <code>(0,4)</code>, and <code>(2,2)</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 - 0 - 0 - 0 - 1</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 0 - 0 - 0</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 1 - 0 - 0</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The point <code>(0,2)</code> is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.</p>
</blockquote>
<p>思路：</p>
<ol>
<li><p>baseline：</p>
<p>遍历所有位置，计算每个位置到所有人的距离，取最小的</p>
</li>
<li><p>优化：</p>
<p>看成一维，对于所有人来说，meeting point选在所有人的中位数的位置距离和最近，因此对行和列坐标分别选取中位数，得到meeting point</p>
</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTotalDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; cols = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">//int  num = 0;</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; grid.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;grid[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    rows.add(i);</div><div class="line">                    cols.add(j);</div><div class="line">                    <span class="comment">//num++;</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> num = rows.size()/<span class="number">2</span>;</div><div class="line">        Collections.sort(rows);</div><div class="line">        Collections.sort(cols);</div><div class="line">        <span class="keyword">int</span> x = rows.get(num);</div><div class="line">        <span class="keyword">int</span> y = cols.get(num);</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows.size();i++)&#123;</div><div class="line">            result += Math.abs(x- rows.get(i));</div><div class="line">            result += Math.abs(y- cols.get(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="follow-up1-Shortest-Distance-from-All-Buildings"><a href="#follow-up1-Shortest-Distance-from-All-Buildings" class="headerlink" title="follow up1. Shortest Distance from All Buildings"></a>follow up1. <a href="https://leetcode.com/problems/shortest-distance-from-all-buildings" target="_blank" rel="external">Shortest Distance from All Buildings</a></h3><blockquote>
<p>You want to build a house on an <em>empty</em> land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values <strong>0</strong>, <strong>1</strong> or <strong>2</strong>, where:</p>
<ul>
<li>Each <strong>0</strong> marks an empty land which you can pass by freely.</li>
<li>Each <strong>1</strong> marks a building which you cannot pass through.</li>
<li>Each <strong>2</strong> marks an obstacle which you cannot pass through.</li>
</ul>
<p>For example, given three buildings at <code>(0,0)</code>, <code>(0,4)</code>, <code>(2,2)</code>, and an obstacle at <code>(0,2)</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 - 0 - 2 - 0 - 1</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 0 - 0 - 0</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 1 - 0 - 0</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The point <code>(1,2)</code> is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.</p>
</blockquote>
<p>思路：</p>
<ol>
<li><p>baseline：</p>
<p>bfs，计算每个点到所有人的距离，取距离和最小的</p>
<p>时间复杂度：外层循环<script type="math/tex">O(n^2)</script> 然后内层bfs<script type="math/tex">O(n^2)</script>，因此时间复杂度<script type="math/tex">O(n^4)</script></p>
</li>
<li><p>反向bfs</p>
<p>计算每个人到所有位置的距离<code>dis[k][i][j]</code> ，复杂度<script type="math/tex">O(n^2)</script></p>
<p>然后再遍历矩阵中每一个点，查询距离，取最小值，复杂度<script type="math/tex">O(n^2)</script></p>
<p>因此时间复杂度<script type="math/tex">O(n^2)</script></p>
</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">//计算到所有空地的距离</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> idx,<span class="keyword">int</span>[][][] distance,<span class="keyword">int</span> rows, <span class="keyword">int</span> cols,<span class="keyword">int</span>[][] grid)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(i*cols+j);</div><div class="line">        <span class="keyword">int</span> dis = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> size = queue.size();</div><div class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">int</span> val = queue.poll();</div><div class="line">                <span class="keyword">int</span> x = val/cols;</div><div class="line">                <span class="keyword">int</span> y = val % cols;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">4</span>;ii++)&#123;</div><div class="line">                    <span class="keyword">int</span> x_new = x + x_delta[ii];</div><div class="line">                    <span class="keyword">int</span> y_new = y + y_delta[ii];</div><div class="line">                    <span class="keyword">if</span>(x_new &gt;= <span class="number">0</span> &amp;&amp; x_new &lt; rows &amp;&amp; y_new &gt;= <span class="number">0</span> &amp;&amp; y_new &lt;cols) &#123;</div><div class="line">                        <span class="keyword">if</span>(grid[x_new][y_new] == <span class="number">0</span> &amp;&amp; distance[idx][x_new][y_new] == <span class="number">0</span>)&#123;</div><div class="line">                            distance[idx][x_new][y_new] = dis;</div><div class="line">                            queue.add(x_new * cols + y_new);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">            dis++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = grid.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</div><div class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(cols == <span class="number">0</span>)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</div><div class="line">        <span class="comment">//计算有多少个1</span></div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[count][rows][cols];</div><div class="line">        <span class="comment">//计算（i,j）到所有0点的距离</span></div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    bfs(i,j,idx,distance,rows,cols,grid);</div><div class="line">                    idx++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> minDist = Integer.MAX_VALUE;</div><div class="line">        <span class="comment">//找距离和最短的</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</div><div class="line">                    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">                    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; distance.length;k++)&#123;</div><div class="line">                        <span class="keyword">if</span>(distance[k][i][j] == <span class="number">0</span>)&#123;</div><div class="line">                            flag = <span class="keyword">false</span>;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span>&#123;</div><div class="line">                            sum += distance[k][i][j];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(flag)&#123;</div><div class="line">                        minDist = Math.min(minDist,sum);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(minDist == Integer.MAX_VALUE)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minDist;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="follow-up-2-Bomb-Enemy"><a href="#follow-up-2-Bomb-Enemy" class="headerlink" title="follow up 2. Bomb Enemy"></a>follow up 2. <a href="https://leetcode.com/problems/bomb-enemy" target="_blank" rel="external">Bomb Enemy</a></h3><blockquote>
<p>Given a 2D grid, each cell is either a wall <code>&#39;W&#39;</code>, an enemy <code>&#39;E&#39;</code> or empty <code>&#39;0&#39;</code> (the number zero), return the maximum enemies you can kill using one bomb.<br>The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.<br>Note that you can only put the bomb at an empty cell.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; For the given grid</div><div class="line">&gt;</div><div class="line">&gt; 0 E 0 0</div><div class="line">&gt; E 0 W E</div><div class="line">&gt; 0 E 0 0</div><div class="line">&gt;</div><div class="line">&gt; return 3. (Placing a bomb at (1,1) kills 3 enemies)</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>思路：</p>
<ol>
<li><p>baseline：</p>
<p>bfs，计算每个点能够炸到的到所有人</p>
<p>时间复杂度：外层循环<script type="math/tex">O(n^2)</script> 然后内层<script type="math/tex">O(n)</script>，因此时间复杂度<script type="math/tex">O(n^3)</script></p>
</li>
<li><p>反向bfs</p>
<p>申请四个数组：</p>
<p><code>left[i][j]:在(i,j)放炸弹，向左最多炸人数</code></p>
<p><code>right[i][j]:在(i,j)放炸弹，向右最多炸人数</code></p>
<p><code>up[i][j]:在(i,j)放炸弹，向上最多炸人数</code></p>
<p><code>dowm[i][j]:在(i,j)放炸弹，向下最多炸人数</code></p>
<p>将四个数组相加就得到在(i,j)放炸弹，总共炸人数</p>
<p>因此时间复杂度<script type="math/tex">O(n^2)</script> </p>
</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BombEnemy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxKilledEnemies</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = grid.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(cols == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] left = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">int</span>[][] right = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">int</span>[][] up = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">int</span>[][] down = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">int</span> leftsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> rightsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'0'</span>)&#123; left[i][j] = leftsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'W'</span>)&#123; leftsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'E'</span>)&#123; leftsum++; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][cols-<span class="number">1</span>-j] == <span class="string">'0'</span>)&#123; right[i][cols-<span class="number">1</span>-j] = rightsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][cols-<span class="number">1</span>-j] == <span class="string">'W'</span>)&#123; rightsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][cols-<span class="number">1</span>-j] == <span class="string">'E'</span>)&#123; rightsum++; &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cols;i++)&#123;</div><div class="line">            <span class="keyword">int</span> upsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> downsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; rows;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[j][i] == <span class="string">'0'</span>)&#123; up[j][i] = upsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[j][i] == <span class="string">'W'</span>)&#123; upsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[j][i] == <span class="string">'E'</span>)&#123; upsum++; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[rows-<span class="number">1</span>-j][i] == <span class="string">'0'</span>)&#123; down[rows-<span class="number">1</span>-j][i] = downsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[rows-<span class="number">1</span>-j][i] == <span class="string">'W'</span>)&#123; downsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[rows-<span class="number">1</span>-j][i] == <span class="string">'E'</span>)&#123; downsum++; &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> maxnum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                maxnum = Math.max(maxnum,left[i][j] + right[i][j] + up[i][j] + down[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxnum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="例题6-N个数组的第K大问题"><a href="#例题6-N个数组的第K大问题" class="headerlink" title="例题6. N个数组的第K大问题"></a>例题6. N个数组的第K大问题</h2><p>在N个数组中找到第K大的元素</p>
<p>排序+heap</p>
<p>类似merge K sorted list</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】线段树]]></title>
      <url>/2018/02/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      <content type="html"><![CDATA[<h1 id="1-线段树入门"><a href="#1-线段树入门" class="headerlink" title="1. 线段树入门"></a>1. 线段树入门</h1><p>本文主要参考自<a href="https://jiayi797.github.io/2018/01/23/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/" target="_blank" rel="external">jiayi797的专栏</a> 、 <a href="http://www.cnblogs.com/TenosDoIt/" target="_blank" rel="external">JustDoIT</a> 和 <a href="https://www.jiuzhang.com/article/kSiBNt/" target="_blank" rel="external">线段树知识点总结</a></p>
<p>线段树，类似区间树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为O(logn)。</p>
<p>线段树的每个节点表示一个区间，子节点则分别表示父节点的左右半区间，例如父亲的区间是[a,b]，那么(c=(a+b)/2)左儿子的区间是[a,c]，右儿子的区间是[c+1,b]。线段树形如：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-18-59-58.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-18-59-58.png" alt="img"></a></p>
<p>下面我们从一个经典的例子来了解线段树，问题描述如下:从数组arr[0…n-1]中查找某个数组某个区间内的最大值，其中数组大小固定，但是数组中的元素的值可以随时更新。从这题可以看出：区间(a,b)的最大值和区间(b,c)的最大值中，取较大的就是区间(a,c)的最大值。很明显这个操作具有区间的性质。</p>
<p>我们可以用线段树来解决这个区间最大值问题。根据这个问题我们构造如下的二叉线段树。区间的第三维就是区间的最大值。</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-19-01-44.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-19-01-44.png" alt="img"></a></p>
<p>加入第三维的时候，只需要在构建完左右区间后，根据左右区间的最大值更新当前区间最大值即可。</p>
<p>因为每次将区间长度一分为二，所有构造的节点个数为：</p>
<p>n + 1/2 <em>n + 1/4 </em>n + 1/8 * n + …</p>
<p>= (1 + 1/2 + 1/4 + 1/8 + …) * n</p>
<p>= 2n</p>
<p>所以构造线段树的时空复杂度都为O(n)。</p>
<h2 id="1-1-线段树常见题型"><a href="#1-1-线段树常见题型" class="headerlink" title="1.1. 线段树常见题型"></a>1.1. 线段树常见题型</h2><p>一道题可不可以用线段树来做，基本是看这道题的操作有没有<strong>区间的性质</strong>。也就是在一个区间上的操作是否可以转化为两个子区间上的操作。</p>
<ul>
<li>求区间和，积，最小值，gcd等</li>
<li>以当前节点的值作为节点处理。例如给出N个数字，再给一个数，问比这个数大的有多少个。</li>
<li>区间加减同一个值，或者区间同时赋一个值。</li>
</ul>
<h2 id="1-2-链式线段树"><a href="#1-2-链式线段树" class="headerlink" title="1.2. 链式线段树"></a>1.2. 链式线段树</h2><p>我们常见的二叉树都是链式结构。因此我们先完成链式的线段树。</p>
<h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>复杂度O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> </span>&#123;</div><div class="line">    <span class="comment">//线段树节点定义</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> start;</div><div class="line">        <span class="keyword">int</span> end;</div><div class="line">        <span class="keyword">int</span> max;</div><div class="line">        SegmentTreeNode left = <span class="keyword">null</span>;<span class="comment">//定义左右节点</span></div><div class="line">        SegmentTreeNode right = <span class="keyword">null</span>;</div><div class="line">        SegmentTreeNode(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> max)&#123;</div><div class="line">            <span class="keyword">this</span>.start = start;</div><div class="line">            <span class="keyword">this</span>.end = end;</div><div class="line">            <span class="keyword">this</span>.max = max;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> SegmentTreeNode <span class="title">builder</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,A.length-<span class="number">1</span>,A);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> SegmentTreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span>[] A)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (low &gt; high)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        SegmentTreeNode root = <span class="keyword">new</span> SegmentTreeNode(low,high,A[low]);</div><div class="line">        <span class="keyword">if</span>(low == high)&#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            root.left = helper(low,high/<span class="number">2</span>,A);</div><div class="line">            root.left = helper(high/<span class="number">2</span>+<span class="number">1</span>,high,A);</div><div class="line">            root.max = Math.max(root.left.max,root.right.max);<span class="comment">//更新当前节点max值</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>复杂度 O(log(n))O(log(n))</p>
<p>构造线段树目的是为了更快地查询。例如给定区间，要求区间中的最大值。而线段树的区间查询操作就是将当前区间分解为较小的子区间，然后由子区间的最大值就可以快速得到需要查询区间的最大值。例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">query(1,3) = max(query(1,1), query(2,3)) = max(4,3) = 4</div></pre></td></tr></table></figure>
<p>查询实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//在线段树中查找[low,high]区间的最大值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(SegmentTreeNode root,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root.start == low &amp;&amp; root.end == high)&#123;</div><div class="line">        <span class="keyword">return</span> root.max;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid = (root.start + root.end) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> result = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">if</span>(mid &gt;= low)&#123;<span class="comment">//查询区间与左半区间有交集，最大值有可能在左半区间</span></div><div class="line">        result = Math.max(result,query(root.left,low,mid));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(mid+<span class="number">1</span> &lt;= high)&#123; <span class="comment">//查询区间与右半区间有交集，最大值有可能在右半区间</span></div><div class="line">        result = Math.max(result,query(root.right,mid+<span class="number">1</span>,high));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h3><p>复杂度 O(log(n))O(log(n))</p>
<p>更新序列中的一个节点，那么如何把这种变化体现到线段树中呢？</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-15-07.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-15-07.png" alt="img"></a></p>
<p>例如要将第4个点更新为5.就要变动3个区间的值，分别为[3,3], [2,3], [0,3]</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-16-03.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-16-03.png" alt="img"></a></p>
<p>改动一个节点，与这个节点对应的叶子结点都要变动。并且，这个节点变动后，这个节点的属性值也有可能会变动，那么就有可能影响到这个节点的父亲节点的属性值（例如可能影响到最大值）。所以需要从叶子节点一路走到根节点。</p>
<p>单点更新实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(SegmentTreeNode root,<span class="keyword">int</span> idx,<span class="keyword">int</span> val)</span></span>&#123;</div><div class="line">    <span class="comment">////如果找到相应叶子节点了</span></div><div class="line">    <span class="keyword">if</span>(root.start == root.end &amp;&amp; root.start == idx)&#123;</div><div class="line">        root.max = val;<span class="comment">//修改max值</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid = (root.start + root.end) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(idx &lt;= mid)&#123;<span class="comment">//要修改的在左边</span></div><div class="line">        modify(root.left,idx,val);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        modify(root.right,idx,val);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//跟新root的max</span></div><div class="line">    root.max = Math.max(root.left.max,root.right.max);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[计数排序、基数排序、桶排序]]></title>
      <url>/2018/02/08/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h2><p>插入排序、归并排序、堆排序、快速排序这四种排序算法，他们的运行时间上界不会超过O(nlgn)。这些算法都有一个有趣的性质：在排序的最终结果中，各元素的次序依赖于它们之间的比较。我们把这类排序算法称为比较排序。</p>
<p>可以证明，基于比较的排序算法在最坏情况下的时间下界是Ω(nlgn)。堆排序和归并排序的运行时间上界为O(nlgn)，因此这两种排序算法都是渐进最优的比较排序算法。</p>
<p>而<strong>非基于比较的排序</strong>，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限，达到线性时间复杂度<script type="math/tex">O(n)</script>。但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制，相反，基于比较的排序则没有这种限制(在一定范围内)。但并非因为有条件限制就会使非基于比较的排序算法变得无用，对于特定场合有着特殊的性质数据，非基于比较的排序算法则能够非常巧妙地解决。</p>
<p>基数排序：O(dn) (d次调用桶排序)，空间复杂度 O(k) </p>
<p>桶排序：O(n)时间复杂度，O(n)空间复杂度</p>
<p>计数排序：O(n)时间复杂度，O(k)空间复杂度，每一个元素都是整数，并且位于0到k - 1之间</p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序假设n个输入元素中的每一个都是在0到k区间内的一个整数，其中k为某个整数。当k=O(n)时，排序的运行时间为Θ(n)。</p>
<p>计数排序的思想是，对每一个输入元素，计算小于它的元素个数，如果有10个元素小于它，那么它就应该放在11的位置上，如果有17个元素小于它，它就应该放在18的位置上。当有几个元素相同时，这一方案要略做修改，因为不能把它们放在同一个输出位置上。下图展示了实际的运行过程。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1186132-945c959a74a71c1c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/597" alt="img"></p>
<p>计数排序</p>
<p>构造辅助数组C，C的长度为k。第一次遍历A后，得到[0,k)区间上每个数出现的次数，将这些次数写入C，得到图(a)的结果。然后把C中每个元素变成前面所有元素的累加和，得到图(b)的结果。接下来，再次从后向前遍历数组A，根据取出的元素查找C中对应下标的值，再把这个值作为下标找到B中的位置，即是该元素排序后的位置。例如，图中A的最后一个元素是3，找到C[3]是7，再令B[7]=3即可，然后顺便把C[3]减一，这是防止相同的数被放到同一个位置。</p>
<p>计数排序的时间代价可以这样计算，第一次遍历A并计算C所花时间是Θ(n)，C累加所花时间是Θ(k)，再次遍历A并给B赋值所花时间是Θ(n)，因此，总时间为Θ(k + n)。在实际中，当k=O(n)时，我们一般会采用计数排序，这时的运行时间为Θ(n)。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>对于一组数据，我们可以按照每一位对它们进行排序。比如，考虑下面一组十进制数</p>
<blockquote>
<p>329<br>457<br>839<br>355</p>
</blockquote>
<p>先按最后一位从小到大排序，得到</p>
<blockquote>
<p>35<strong>5</strong><br>45<strong>7</strong><br>32<strong>9</strong><br>83<strong>9</strong></p>
</blockquote>
<p>再按中间一位从小到大排序，得到</p>
<blockquote>
<p>3<strong>2</strong>9<br>8<strong>3</strong>9<br>3<strong>5</strong>5<br>4<strong>5</strong>7</p>
</blockquote>
<p>最后按第一位从小到大排序，得到</p>
<blockquote>
<p><strong>3</strong>29<br><strong>3</strong>55<br><strong>4</strong>57<br><strong>8</strong>39</p>
</blockquote>
<p>其中，对任何一位的排序算法必须是稳定的，即相同数字不能改变它们的前后顺序。</p>
<p>基数排序算法的运行时间很容易计算，对于n个k进制d位数，假如每一位的排序使用计数排序算法，则该位排序用时为Θ(n + k)，总共d位数，总排序用时就是Θ(d(n + k))。当d为常数且k=O(n)时，总排序时间为Θ(n)。</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在[0,1)区间上。</p>
<p>我们将[0,1)区间划分为n个相同大小的子区间，称为桶。然后将输入数据分别放到各个桶中。如果数据分布得很均匀，每个桶中的数据就不会太多，都会维持在常数量级。我们先对每个桶中的元素排序，然后把所有桶中的元素顺序列出来即可。下图为n=10的一个案例。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1186132-1ea2b9a00e9dbeb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/675" alt="img"></p>
<p>桶排序.png</p>
<p>创建一个长度也为10的数组，将A中的元素按照大小找到B中合适的位置，插入链表。之后，分别对B中每个链表中的元素执行插入排序。最后将B中的所有元素依次取出即可。</p>
<p>现在分析桶排序的时间代价。将A中元素放入B用时Θ(n)，B中每个链表执行插入排序的用时，可以证明是O(2 - 1/n)，于是总用时就是Θ(n) + n <em> O(2 - 1/n) = Θ(n)。具体证明过程比较难理解，这里我想给出一个容易理解的解释，虽然不一定对，但还是可以帮助理解为什么总用时是Θ(n)。n个数放入n个桶，平均下来每个桶只有一个数，在实际中，可能有的多有的少，但都不会差得太离谱。因此<em>*我们可以认为每个桶中只有常数个数，那么对常数个数执行插入排序所用的时间当然也就是O(1)了。于是n个桶总用时就是O(n)</em></em>，加上前面的Θ(n)，桶排序总用时就是Θ(n)了。</p>
<p>通常模一个很大的素数。</p>
]]></content>
      
        <categories>
            
            <category> 排序算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2018/02/08/%E3%80%90leetcode%E3%80%91sort/</url>
      <content type="html"><![CDATA[<blockquote>
<hr>
<p>title: 【leetcode】sort<br>date: 2018-02-08 13:38:35<br>tags:</p>
<h2 id="categories"><a href="#categories" class="headerlink" title="categories:"></a>categories:</h2></blockquote>
<p>leetcode 排序相关问题</p>
<h3 id="Largest-Number"><a href="#Largest-Number" class="headerlink" title="Largest Number"></a><a href="https://leetcode.com/problems/largest-number/" target="_blank" rel="external">Largest Number</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a list of non negative integers, arrange them such that they form the largest number.</p>
<p>For example, given <code>[3, 30, 34, 5, 9]</code>, the largest formed number is <code>9534330</code>.</p>
<p>Note: The result may be very large, so you need to return a string instead of an integer.</p>
</blockquote>
<p>给定数组返回由该数组构成的最大数字，返回string类型</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>先把数字转化成字符串，然后按字符串顺序排序，这里有一个小技巧，判断字符串s1和s2谁应该放在前面时，比较s1+s2和s2+s1</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Comparator&lt;String&gt; cmp = <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</div><div class="line">                String s1 = o1+o2;</div><div class="line">                String s2 = o2+o1;</div><div class="line">                <span class="keyword">return</span> s2.compareTo(s1);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            strs[i] = String.valueOf(nums[i]);</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(strs,cmp);</div><div class="line">        <span class="keyword">if</span>(strs[<span class="number">0</span>].equals(<span class="string">"0"</span>))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.length;i++)&#123;</div><div class="line">            sb.append(strs[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Maximum-Gap"><a href="#Maximum-Gap" class="headerlink" title="Maximum Gap"></a><a href="https://leetcode.com/problems/maximum-gap/" target="_blank" rel="external">Maximum Gap</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Try to solve it in linear time/space.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p>
</blockquote>
<p>给定一个无序数组，返回数组中相邻元素（排序后）之差的最大值</p>
<p>复杂度要求：线性时间复杂度</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>baseline：排序，计算相邻元素最大值，时间复杂度<script type="math/tex">O(nlogn)</script></p>
<p>优化：桶排序</p>
<ol>
<li>确定数组中最大和最小元素max和min，数组中元素个数N</li>
<li>这N个数字的平均间隔为：avg = (max-min)/(N-1)，maxGap &gt;= avg，所以我们令桶的大小int <code>bucketSize = Math.max(1,(max - min) / (N-1));</code> 这样每一个桶内，元素的差值不会超过avg了，那么相邻元素之间的最大间隔一定在桶之间。</li>
<li>根据桶的大小，可以计算出桶的个数为<code>int bucketNum = (max - min)/bucketSize + 1;</code> ,</li>
<li>遍历数组中的元素，将元素放入对应的桶中，并维护每个桶的最大值和最小值</li>
<li>计算相邻桶的最小值和最大值的差，遇到桶中没有元素的跳过，取最大的差值即为所求。</li>
</ol>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> N = nums.length;</div><div class="line">        <span class="keyword">if</span>(N &lt;= <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(N == <span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Math.abs(nums[<span class="number">0</span>] - nums[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//查找nums中最大和最小值</span></div><div class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</div><div class="line">            min = Math.min(min,num);</div><div class="line">            max = Math.max(max,num);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//maxGap &gt; avg = (max-min)/(N-1);bucketSize = floor(max-min)/(N-1);</span></div><div class="line">        <span class="keyword">int</span> bucketSize = Math.max(<span class="number">1</span>,(max - min) / (N-<span class="number">1</span>));<span class="comment">//桶大小</span></div><div class="line">        <span class="comment">//bucketNum = ceil (max-min)/bucketSize</span></div><div class="line">        <span class="keyword">int</span> bucketNum = (max - min)/bucketSize + <span class="number">1</span>;<span class="comment">//桶个数</span></div><div class="line"></div><div class="line">        <span class="comment">//用于记录每个bucket中的最大和最小值</span></div><div class="line">        <span class="keyword">int</span>[] bucketMin = <span class="keyword">new</span> <span class="keyword">int</span>[bucketNum];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; bucketNum;i++)&#123;</div><div class="line">            bucketMin[i] = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] bucketMax = <span class="keyword">new</span> <span class="keyword">int</span>[bucketNum];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; bucketNum;i++)&#123;</div><div class="line">            bucketMax[i] = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(bucketMin[(nums[i]-min)/bucketSize] == -<span class="number">1</span>)&#123;</div><div class="line">                bucketMin[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">                bucketMax[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; bucketMin[(nums[i]-min)/bucketSize])&#123;</div><div class="line">                bucketMin[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; bucketMax[(nums[i]-min)/bucketSize])&#123;</div><div class="line">                bucketMax[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> maxGap = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> lastMax =  bucketMax[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; bucketNum;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(bucketMin[i] == -<span class="number">1</span>)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            maxGap = Math.max(maxGap,bucketMin[i] - lastMax);</div><div class="line">            lastMax = bucketMax[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxGap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Best-Meeting-Point"><a href="#Best-Meeting-Point" class="headerlink" title="Best Meeting Point"></a><a href="https://leetcode.com/problems/best-meeting-point/" target="_blank" rel="external">Best Meeting Point</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="external">Manhattan Distance</a>, where distance(p1, p2) = <code>|p2.x - p1.x| + |p2.y - p1.y|</code>.</p>
<p>For example, given three people living at <code>(0,0)</code>, <code>(0,4)</code>, and <code>(2,2)</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 - 0 - 0 - 0 - 1</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 0 - 0 - 0</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 1 - 0 - 0</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The point <code>(0,2)</code> is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.</p>
</blockquote>
<p>给定二维数组，1代表n个人的出发地，0代表其余地点，找到数组中的一个位置，使得大家到这个地点的曼哈顿距离之和最短，返回最短距离</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>只想到了暴力的思路。。。</p>
<p>看了solution，需要从一维的入手：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Case #1: 1-0-0-0-1</div><div class="line">Case #2: 0-1-0-1-0</div><div class="line">Case #3: 1-0-0-0-0-0-0-1-1</div><div class="line">Case #4: 1-1-0-0-1</div></pre></td></tr></table></figure>
<p>给了这么几个例子，说明到所有点最短的距离就是中位数的点。</p>
<p>所以扩展到二维，到所有点距离最短的点就是所有点分别在x轴和y轴中位数的点。</p>
<p>因此可以遍历所有的点，记录是1的点的xy坐标，然后分别对xy坐标排序，取中位数的点，即为要求的点，再计算下距离就好。</p>
<p>优化：</p>
<p>可以把横纵坐标分离计算，按需加入list,这样就不需要排序了,直接取中位数位置的点</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestMeetingPoint</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTotalDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; cols = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; grid.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;grid[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    rows.add(i);</div><div class="line">                    cols.add(j);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> num = rows.size()/<span class="number">2</span>;</div><div class="line">        Collections.sort(rows);</div><div class="line">        Collections.sort(cols);</div><div class="line">        <span class="keyword">int</span> x = rows.get(num);</div><div class="line">        <span class="keyword">int</span> y = cols.get(num);</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows.size();i++)&#123;</div><div class="line">            result += Math.abs(x- rows.get(i));</div><div class="line">            result += Math.abs(y- cols.get(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Insert-Interval"><a href="#Insert-Interval" class="headerlink" title="Insert Interval"></a><a href="https://leetcode.com/problems/insert-interval/" target="_blank" rel="external">Insert Interval</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p><strong>Example 1:</strong><br>Given intervals <code>[1,3],[6,9]</code>, insert and merge <code>[2,5]</code> in as <code>[1,5],[6,9]</code>.</p>
<p><strong>Example 2:</strong><br>Given <code>[1,2],[3,5],[6,7],[8,10],[12,16]</code>, insert and merge <code>[4,9]</code> in as <code>[1,2],[3,10],[12,16]</code>.</p>
<p>This is because the new interval <code>[4,9]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</p>
</blockquote>
<p>给定区间数组，区间之间没有overlap，又给定一个独立区间，将该独立区间加到数组的区间里，如有overlap将区间merge,返回加入独立区间后的数组</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>遍历数组中的区间，当数组中的区间和独立区间还没有交集（intervals.get(i).end &lt; newInterval.start）的时候，将这些区间原封不动放入result中</li>
<li>将区间start和end初始化为newInterval的start和end</li>
<li>继续遍历数组中的区间，直至intervals.get(i).start &gt; newInterval.end,也就是和独立区间不相交了，在此期间，更新数组的上下边界</li>
<li>将更新好的区间加入结果</li>
<li>将剩余区间加入结果</li>
</ol>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertInterval</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">insert</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</div><div class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; intervals.size() &amp;&amp; intervals.get(i).end &lt; newInterval.start)&#123;</div><div class="line">            res.add(intervals.get(i));</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i == intervals.size())&#123;</div><div class="line">            res.add(newInterval);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> start = newInterval.start;</div><div class="line">        <span class="keyword">int</span> end = newInterval.end;</div><div class="line">        <span class="keyword">while</span>(i &lt; intervals.size() &amp;&amp; intervals.get(i).start &lt;= newInterval.end)&#123;</div><div class="line">            start = Math.min(start,intervals.get(i).start);</div><div class="line">            end = Math.max(end,intervals.get(i).end);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        res.add(<span class="keyword">new</span> Interval(start,end));</div><div class="line">        <span class="keyword">while</span>(i &lt; intervals.size())&#123;</div><div class="line">            res.add(intervals.get(i));</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="H-Index"><a href="#H-Index" class="headerlink" title="H-Index"></a><a href="https://leetcode.com/problems/h-index/" target="_blank" rel="external">H-Index</a></h3>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班】两指针]]></title>
      <url>/2018/02/02/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E4%B8%A4%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><ol>
<li>一个数组，从两边往中间移动（对撞型）</li>
<li>一个数组，同时向前移动（前向型）</li>
<li>两个数组两根指针（并行型）</li>
</ol>
<h2 id="1-对撞型或相会型"><a href="#1-对撞型或相会型" class="headerlink" title="1.对撞型或相会型"></a>1.对撞型或相会型</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-12-41-27.png" alt=""> </p>
<h3 id="leetcode-11-Container-With-Most-Water"><a href="#leetcode-11-Container-With-Most-Water" class="headerlink" title="leetcode 11.Container With Most Water"></a><a href="https://leetcode.com/problems/container-with-most-water" target="_blank" rel="external">leetcode 11.Container With Most Water</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and <em>n</em> is at least 2.</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>灌水问题，从两边向内灌水，所以初始两个指针ij一头一尾，此时能够容纳的水量是i和j中比较高度的柱子高度*ij两个柱子之间的距离：</p>
<p>max(height[i] , height[j]) * (j - i)</p>
<p>然后考虑将柱子向内移动，其实我们只需要移动比较矮的柱子，因为如果移动长的一边的柱子，根据上面的公式，j-i会变短，max(height[i] , height[j])可能变小可能不变，所以总的水量不会增加，所以我们只有移动短的柱子，才有可能会遇到更高的柱子，使得水量增大。</p>
<p>这样一来，每次选取较短的柱子向内移动，时间复杂度为<script type="math/tex">O(n)</script></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = height.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">            <span class="keyword">if</span>(height[i] &lt; height[j])&#123;</div><div class="line">                max = Math.max(max,(j-i) *height[i]);</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                max = Math.max(max,(j-i) * height[j]);</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Quick-select-—-Kth-Largest-Element-in-an-Array"><a href="#Quick-select-—-Kth-Largest-Element-in-an-Array" class="headerlink" title="Quick select — Kth Largest Element in an Array"></a>Quick select — <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="external">Kth Largest Element in an Array</a></h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote>
<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>For example,<br>Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.</p>
</blockquote>
<p>在一组数字中找到第K大的数字</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>方法一：可以用堆，维护一个大小为K的堆，将数字依次加入堆，找到第k大，时间复杂度<script type="math/tex">O(nlogk)</script></p>
<p>方法二：quick select，基于quick sort的思想</p>
<ol>
<li>每次在数组中随机选取一个数组作为pivort，这里面随机选取，经过大量的验证，选取中间位置的数字作为pivot比较稳妥。</li>
<li>然后和快排一样，将比它小的放在它左边，比它大的放在右边，找到pivot的位置即是pivot的最终位置。<ol>
<li>如果此时pivot的位置==k-1，找到了</li>
<li>如果此时pivot的位置 &gt;k-1，只需在pivot左边寻找第k大</li>
<li>如果此时pivot的位置 &lt;k-1，只需在pivot右边寻找第k-pivot大</li>
</ol>
</li>
</ol>
<p>这种方法的时间复杂度为<script type="math/tex">O(n)+O(n/2)+O(n/4)+...+O(1) = O(2n) = O(n)</script></p>
<p>两种方法的比较：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-15-34-03.png" alt=""> </p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = nums[i];</div><div class="line">        nums[i] = nums[j];</div><div class="line">        nums[j] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> pivotIdx = start+(end-start)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> pivot = nums[pivotIdx];</div><div class="line">        <span class="keyword">int</span> j = end;</div><div class="line">        <span class="keyword">int</span> i = start;</div><div class="line">        swap(nums,i,pivotIdx);<span class="comment">//把pivot交换至数组头</span></div><div class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &lt;= pivot)&#123;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            nums[i] = nums[j];</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &gt;= pivot)&#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            nums[j] = nums[i];</div><div class="line">        &#125;</div><div class="line">        nums[j] = pivot;</div><div class="line">        <span class="keyword">if</span>((j - start) == k-<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> pivot;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((j - start) &gt; k-<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> partition(nums,start,j-<span class="number">1</span>,k);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> partition(nums,j+<span class="number">1</span>,end,k-j+start-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> partition(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,k);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-16-57-31.png" alt=""> </p>
<h3 id="lintcode-399-Nuts-amp-Bolts-Problem"><a href="#lintcode-399-Nuts-amp-Bolts-Problem" class="headerlink" title="lintcode 399.Nuts &amp; Bolts Problem"></a><a href="https://www.lintcode.com/en/problem/nuts-bolts-problem/" target="_blank" rel="external">lintcode 399.Nuts &amp; Bolts Problem</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>给定一组 n 个不同大小的 nuts 和 n 个不同大小的 bolts。nuts 和 bolts 一一匹配。 不允许将 nut 之间互相比较，也不允许将 bolt 之间互相比较。也就是说，只许将 nut 与 bolt 进行比较， 或将 bolt 与 nut 进行比较。请比较 nut 与 bolt 的大小</p>
<p>样例</p>
<p>给出 nuts = <code>[&#39;ab&#39;,&#39;bc&#39;,&#39;dd&#39;,&#39;gg&#39;]</code>, bolts = <code>[&#39;AB&#39;,&#39;GG&#39;, &#39;DD&#39;, &#39;BC&#39;]</code><br>你的程序应该找出bolts和nuts的匹配。<br>一组可能的返回结果是：<br>nuts = <code>[&#39;ab&#39;,&#39;bc&#39;,&#39;dd&#39;,&#39;gg&#39;]</code>, bolts = <code>[&#39;AB&#39;,&#39;BC&#39;,&#39;DD&#39;,&#39;GG&#39;]</code></p>
</blockquote>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>因为nuts和bolts两个数组在各自的内部不能互相比较，只能在两个数组之间的元素进行比较。所以这就需要利用一个array中的元素对另一个array进行partition，并反过来重复这一个过程，最终让两个array都满足comparator所定义的相同顺序。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * public class NBCompare &#123;</span></div><div class="line"><span class="comment"> *     public int cmp(String a, String b);</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> * You can use compare.cmp(a, b) to compare nuts "a" and bolts "b",</span></div><div class="line"><span class="comment"> * if "a" is bigger than "b", it will return 1, else if they are equal,</span></div><div class="line"><span class="comment"> * it will return 0, else if "a" is smaller than "b", it will return -1.</span></div><div class="line"><span class="comment"> * When "a" is not a nut or "b" is not a bolt, it will return 2, which is not valid.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> nuts: an array of integers</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> bolts: an array of integers</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> compare: a instance of Comparator</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span>: nothing</span></div><div class="line"><span class="comment">     */</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(String[] nuts,String[] bolts,NBComparator compare,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">         <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</div><div class="line">         <span class="comment">//选取bolts中的第一个元素作为pivot，计算在nuts中对应的元素的位置</span></div><div class="line">         <span class="keyword">int</span> nuts_pivotidx = partition(nuts,bolts[start],compare,start,end);</div><div class="line">         <span class="comment">//利用nuts中的pivot对bolts中元素排序</span></div><div class="line">         partition(bolts,nuts[nuts_pivotidx],compare,start,end);</div><div class="line">         <span class="comment">//对picot左边右边分别排序</span></div><div class="line">         quicksort(nuts, bolts, compare, start, nuts_pivotidx - <span class="number">1</span>);</div><div class="line">         quicksort(nuts, bolts, compare, nuts_pivotidx + <span class="number">1</span>, end);</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">//输入nuts和bolts中的pivot,对nuts排序，返回对应元素的位置</span></div><div class="line">     <span class="comment">//输入bolts和nuts中的pivot,对bolts排序，返回对应元素的位置</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String[] str,String pivot,NBComparator compare,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">         <span class="comment">//在另一个数组中找到对应的螺丝或者螺母</span></div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= end;i++)&#123;</div><div class="line">             <span class="keyword">if</span>(compare.cmp(str[i],pivot) == <span class="number">0</span> || </div><div class="line">             compare.cmp(pivot,str[i]) == <span class="number">0</span>)&#123;</div><div class="line">                 swap(str,i,start);</div><div class="line">                 <span class="keyword">break</span>;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">//快速排序</span></div><div class="line">         String pivotTemp = str[start];</div><div class="line">         <span class="keyword">int</span> left = start;</div><div class="line">         <span class="keyword">int</span> right = end;</div><div class="line">         <span class="keyword">while</span>(left &lt; right)&#123;</div><div class="line">             <span class="keyword">while</span>(left &lt; end &amp;&amp; (compare.cmp(str[right], pivot) == -<span class="number">1</span> || </div><div class="line">            compare.cmp(pivot,str[right]) == <span class="number">1</span>))&#123;</div><div class="line">                right--;</div><div class="line">            &#125;</div><div class="line">            str[left] = str[right];</div><div class="line">             <span class="keyword">while</span>(left &lt; end &amp;&amp; (compare.cmp(str[right], pivot) == <span class="number">1</span> || </div><div class="line">            compare.cmp(pivot, str[right]) == -<span class="number">1</span>))&#123;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            str[right] = str[left];</div><div class="line">        &#125;</div><div class="line">        str[left] = pivotTemp;    </div><div class="line">        <span class="keyword">return</span> left;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">//交换元素</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String[] strings,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">         String temp = strings[i];</div><div class="line">         strings[i] = strings[j];</div><div class="line">         strings[j] = temp;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortNutsAndBolts</span><span class="params">(String[] nuts, String[] bolts, NBComparator compare)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">if</span>(nuts == <span class="keyword">null</span> || bolts == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(nuts.length != bolts.length) <span class="keyword">return</span>;</div><div class="line">        quicksort(nuts,bolts,compare,<span class="number">0</span>,nuts.length-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="2-窗口类"><a href="#2-窗口类" class="headerlink" title="2.窗口类"></a>2.窗口类</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-21-47-48.png" alt=""> </p>
<h3 id="Minimum-Size-Subarray-Sum"><a href="#Minimum-Size-Subarray-Sum" class="headerlink" title="Minimum Size Subarray Sum"></a><a href="https://leetcode.com/problems/minimum-size-subarray-sum" target="_blank" rel="external">Minimum Size Subarray Sum</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <strong>contiguous</strong> subarray of which the sum ≥ <strong>s</strong>. If there isn’t one, return 0 instead.</p>
<p>For example, given the array <code>[2,3,1,2,4,3]</code> and <code>s = 7</code>,<br>the subarray <code>[4,3]</code> has the minimal length under the problem constraint.</p>
</blockquote>
<p>返回数组中元素和&gt;=s的最长子数组的长度</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>两指针控制滑动窗口类问题，当窗口内元素和&lt;s时右指针向右滑动，更新最大长度</p>
<p>当窗口内元素和&gt;=s时，左指针向右滑动至&lt;s，无需更新最大长度</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.length;j++)&#123;</div><div class="line">            sum += nums[j];</div><div class="line">            <span class="keyword">while</span>(sum &gt;= s)&#123;</div><div class="line">                minLen = Math.min(minLen,j-i+<span class="number">1</span>);</div><div class="line">                sum -= nums[i];</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE?<span class="number">0</span>:minLen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="external">Longest Substring Without Repeating Characters</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Examples:</strong></p>
<p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p>
<p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p>
<p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code> is a <em>subsequence</em> and not a substring.</p>
</blockquote>
<p>查找字符串中没有重复元素的最长子串</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>记录窗口中出现过哪些字母，当遇到重复字母的时候窗口缩小</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];<span class="comment">//相当于hashmap</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(j &lt; s.length())&#123;</div><div class="line">            <span class="keyword">if</span>(map[s.charAt(j)] == <span class="number">0</span>)&#123;</div><div class="line">                map[s.charAt(j)] = <span class="number">1</span>;</div><div class="line">                maxlen = Math.max(maxlen,j-i+<span class="number">1</span>);</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//map[s.charAt(j)] == 1</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">while</span>(s.charAt(j) != s.charAt(i))&#123;</div><div class="line">                    map[s.charAt(i)] = <span class="number">0</span>;</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxlen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Minimum-Window-Substring"><a href="#Minimum-Window-Substring" class="headerlink" title="Minimum Window Substring"></a><a href="https://leetcode.com/problems/minimum-window-substring" target="_blank" rel="external">Minimum Window Substring</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>For example,<br><strong>S</strong> = <code>&quot;ADOBECODEBANC&quot;</code><br><strong>T</strong> = <code>&quot;ABC&quot;</code></p>
<p>Minimum window is <code>&quot;BANC&quot;</code>.</p>
</blockquote>
<p>返回s中能够包含t的最短子串</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>滑动窗口+hashtable的思想</p>
<p>首先需要两个hash表，一个存储t中的字母，一个存储s中子串的字母，还需要一个能够判别s中的子串是否能够包含t的函数。</p>
<p>然后两指针滑动窗口，右指针向右滑动，当滑窗中的子串能够包含t时，窗口缩小，左指针右移，更新最短窗口，直到窗口内子串不足以包含t中全部字母，此时右指针继续向后移动，重复上述过程。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">//判断s是否包含t</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContain</span><span class="params">(<span class="keyword">int</span>[] mapT,<span class="keyword">int</span>[] mapS)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; mapT.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(mapS[i] &lt; mapT[i])&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] mapT = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="keyword">int</span>[] mapS = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="keyword">int</span> minlen = Integer.MAX_VALUE;</div><div class="line">        StringBuilder minWindow = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : t.toCharArray())&#123;</div><div class="line">            mapT[ch]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; s.length();j++) &#123;</div><div class="line">            mapS[s.charAt(j)]++;</div><div class="line">            <span class="keyword">while</span>(isContain(mapT,mapS))&#123;</div><div class="line">                <span class="keyword">if</span>(minlen &gt; j-i+<span class="number">1</span>)&#123;</div><div class="line">                    minlen = j-i+<span class="number">1</span>;</div><div class="line">                    minWindow = <span class="keyword">new</span> StringBuilder(s.substring(i,j+<span class="number">1</span>));</div><div class="line">                &#125;</div><div class="line">                mapS[s.charAt(i)]--;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(minlen == Integer.MAX_VALUE)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> minWindow.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Longest-Substring-with-At-Most-K-Distinct-Characters"><a href="#Longest-Substring-with-At-Most-K-Distinct-Characters" class="headerlink" title="Longest Substring with At Most K Distinct Characters"></a><a href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/" target="_blank" rel="external">Longest Substring with At Most K Distinct Characters</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a string, find the length of the longest substring T that contains at most <em>k</em> distinct characters.</p>
<p>For example, Given s = <code>“eceba”</code> and k = 2,</p>
<p>T is “ece” which its length is 3.</p>
</blockquote>
<p>在字符串中找到一个子串，最多包含k个不同的字母，返回满足这样条件的子串的最大长度。</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>还是滑窗+hash表</p>
<p>用hash表存储当前子串中字母，用charNum存储子串中的不同字母个数</p>
<ol>
<li>当窗口内字母个数&lt;=k时右指针向右滑动，扩大窗口，更新窗口大小</li>
<li>当窗口内字母个数&gt;k时，左指针右移，缩小窗口，</li>
</ol>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="keyword">int</span> charNum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; s.length();j++)&#123;</div><div class="line">            <span class="comment">//之前已经出现过这个字母了</span></div><div class="line">            <span class="keyword">if</span>(map[s.charAt(j)]&gt;<span class="number">0</span>)&#123;</div><div class="line">                map[s.charAt(j)]++;</div><div class="line">                maxlen = Math.max(maxlen,j-i+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//之前没出现过这个字母,但出现的字母数&lt;k</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (charNum &lt; k)&#123;</div><div class="line">                map[s.charAt(j)]++;</div><div class="line">                charNum++;</div><div class="line">                maxlen = Math.max(maxlen,j-i+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//之前没出现过这个字母,但出现的字母数==k</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                map[s.charAt(j)]++;</div><div class="line">                charNum++;</div><div class="line">                <span class="keyword">while</span>(charNum &gt; k)&#123;</div><div class="line">                    <span class="keyword">if</span>(map[s.charAt(i)] == <span class="number">1</span>)&#123;</div><div class="line">                        map[s.charAt(i)]--;</div><div class="line">                        charNum--;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        map[s.charAt(i)]--;</div><div class="line">                    &#125;</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxlen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="两个数组两个指针"><a href="#两个数组两个指针" class="headerlink" title="两个数组两个指针"></a>两个数组两个指针</h2><h3 id="最小差"><a href="#最小差" class="headerlink" title="最小差"></a><a href="http://www.lintcode.com/zh-cn/problem/the-smallest-difference/" target="_blank" rel="external">最小差</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>给定两个整数数组（第一个是数组 <code>A</code>，第二个是数组 <code>B</code>），在数组 A 中取 A[i]，数组 B 中取 B[j]，A[i] 和 B[j]两者的差越小越好(|A[i] - B[j]|)。返回最小差。</p>
<p>样例</p>
<p>给定数组 A = <code>[3,4,6,7]</code>， B = <code>[2,3,8,9]</code>，返回 <code>0</code>。</p>
</blockquote>
<p>给定两个数组，返回两个数组元素之间的最小差</p>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>baseline:双层for循环，A中循环一遍B中循环一遍，计算每两个元素之间的差值取最小，时间复杂度：<script type="math/tex">O(n^2)</script></p>
<p>优化：</p>
<p>先排序，排序之后遍历A中元素，用二分查找的思路在B中寻找与元素A[i]差值最小的元素，时间复杂度：<script type="math/tex">O(nlogn)</script></p>
<p>骚操作：</p>
<p>两指针ij分别指向AB，更新A[i]和B[j]的差值</p>
<p>当A[i]&lt;B[j]时，i后移，反之j后移</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestDifference</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    Arrays.sort(A);</div><div class="line">    Arrays.sort(B);</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">while</span>(i &lt; A.length &amp;&amp; j &lt; B.length)&#123;</div><div class="line">        min = Math.min(min,Math.abs(A[i]-B[j]));</div><div class="line">        <span class="keyword">if</span>(A[i] &lt; B[j])&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Smallest-Range"><a href="#Smallest-Range" class="headerlink" title="Smallest Range"></a><a href="https://leetcode.com/problems/smallest-range/" target="_blank" rel="external">Smallest Range</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>You have <code>k</code> lists of sorted integers in ascending order. Find the <strong>smallest</strong> range that includes at least one number from each of the <code>k</code> lists.</p>
<p>We define the range [a,b] is smaller than range [c,d] if <code>b-a &lt; d-c</code> or <code>a &lt; c</code> if <code>b-a == d-c</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</div><div class="line">&gt; Output: [20,24]</div><div class="line">&gt; Explanation: </div><div class="line">&gt; List 1: [4, 10, 15, 24,26], 24 is in range [20,24].</div><div class="line">&gt; List 2: [0, 9, 12, 20], 20 is in range [20,24].</div><div class="line">&gt; List 3: [5, 18, 22, 30], 22 is in range [20,24].</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定k个数组，找到最短的区间，该区间需满足包含来自每个数组的至少一个元素</p>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>k个数组k个指针，k个指针中的最大最小即是当前情况下的区间。</p>
<p>每次将值最小的指针向后移动，更新当前情况下的区间长度。</p>
<p>这里就需要找到哪个指针所指的值是最小的了，所以我们需要一个最小堆来维护k个指针中的最小值。</p>
<p>另外，我们还需要计算k个指针中的最大值，这个最大值用一个变量max维护就可以了，每次入堆的元素都跟当前max比较更新一下就好。</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallestRange</span> </span>&#123;</div><div class="line">  <span class="comment">//定义结构Node，存储节所在的数组idx和值</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> idx;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        Node(<span class="keyword">int</span> idx,<span class="keyword">int</span> val)&#123;</div><div class="line">            <span class="keyword">this</span>.idx = idx;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</div><div class="line">        <span class="keyword">int</span>[] idx = <span class="keyword">new</span> <span class="keyword">int</span>[nums.size()];<span class="comment">//代表指针指向每一个数组</span></div><div class="line">        Comparator&lt;Node&gt; cmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o1.val - o2.val;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Node&gt; minheap= <span class="keyword">new</span> PriorityQueue&lt;&gt;(cmp);<span class="comment">//最小堆</span></div><div class="line">        <span class="keyword">int</span> max  = Integer.MIN_VALUE;<span class="comment">//存储当前遇到的最大值</span></div><div class="line">        <span class="keyword">int</span> minRangeLen = Integer.MAX_VALUE;<span class="comment">//存储最小区间的长读</span></div><div class="line">        <span class="keyword">int</span>[] minRange = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];<span class="comment">//存储最小区间</span></div><div class="line">        <span class="comment">//先把所有list第一个元素先入堆，同时记录最大值</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; idx.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> val = nums.get(i).get(idx[i]);</div><div class="line">            minheap.add(<span class="keyword">new</span> Node(i,val));</div><div class="line">            max = Math.max(max,val);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//出堆</span></div><div class="line">        <span class="keyword">while</span> (!minheap.isEmpty())&#123;</div><div class="line">            <span class="comment">//取堆顶元素</span></div><div class="line">            Node temp = minheap.poll();</div><div class="line">            <span class="comment">//更新当前最小区间的长度</span></div><div class="line">            <span class="keyword">if</span>(max-temp.val &lt; minRangeLen)&#123;</div><div class="line">                minRangeLen = max-temp.val;</div><div class="line">                minRange[<span class="number">0</span>] = temp.val;</div><div class="line">                minRange[<span class="number">1</span>] = max;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//堆顶元素所在的区间指针后移一位</span></div><div class="line">            idx[temp.idx]++;</div><div class="line">            <span class="comment">//如果对顶元素所在的区间指针溢出了，跳出</span></div><div class="line">            <span class="keyword">if</span>(idx[temp.idx] == nums.get(temp.idx).size())&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">          <span class="comment">//找到下一个值，更新max，入堆</span></div><div class="line">            <span class="keyword">int</span> nextval = nums.get(temp.idx).get(idx[temp.idx]);</div><div class="line">            max = Math.max(max,nextval);</div><div class="line">            minheap.add(<span class="keyword">new</span> Node(temp.idx,nextval));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minRange;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Partition-Labels"><a href="#Partition-Labels" class="headerlink" title="Partition Labels"></a><a href="https://leetcode.com/problems/partition-labels/" target="_blank" rel="external">Partition Labels</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>A string <code>S</code> of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: S = &quot;ababcbacadefegdehijhklij&quot;</div><div class="line">&gt; Output: [9,7,8]</div><div class="line">&gt; Explanation:</div><div class="line">&gt; The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</div><div class="line">&gt; This is a partition so that each letter appears in at most one part.</div><div class="line">&gt; A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定一个字符串，要求将字符串分割，保证每个字母只出现在一个子串中，最终返回分割的字符串长度</p>
<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">由于每个字母只能出现在一个字符串中，比如第一个字母a，其所在的子串至少要从第一个a到最后一个a。</div><div class="line">S = &quot;ababcbacadefegdehijhklij&quot;</div><div class="line">     ↑       ↑</div><div class="line">     i       maxRight</div><div class="line">但此时并不一定找到第一个合适的分割点了，因为在这两个a中其他字母，有可能出现在后半段中，所以我们还需要遍历这两个指针中间的字母，确定每一个字母在字符串中出现的最后位置，在这个过程中，前后两个指针的距离可能会变得更远，中间的每一个元素都需要遍历到。所以我们用maxRight来存储当前遍历过的字母的最远位置，则i的遍历区间应该是while (i &lt;= maxright)。</div></pre></td></tr></table></figure>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">partition</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = start;</div><div class="line">        <span class="keyword">int</span> j = end;</div><div class="line">        <span class="keyword">int</span> maxright = i;<span class="comment">//初始化maxright</span></div><div class="line">        <span class="keyword">while</span> (i &lt;= maxright)&#123;</div><div class="line">            <span class="keyword">char</span> ch = s.charAt(i);</div><div class="line">            <span class="keyword">while</span> (s.charAt(j) != ch)&#123;</div><div class="line">                j--;</div><div class="line">            &#125;<span class="comment">//找到ch出现的最后一个位置</span></div><div class="line">            maxright = Math.max(maxright,j);<span class="comment">//更新最远距离</span></div><div class="line">            <span class="keyword">if</span>(i == maxright)&#123;<span class="comment">//找到了最后一个，跳出</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            i++;</div><div class="line">            j = end;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//更新结果集，继续分割右边</span></div><div class="line">        result.add(maxright-start+<span class="number">1</span>);</div><div class="line">        partition(s,maxright+<span class="number">1</span>,end);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</div><div class="line">        partition(S,<span class="number">0</span>,S.length()-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[堆排序]]></title>
      <url>/2018/01/31/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章系统设计】从用户系统理解数据库和缓存]]></title>
      <url>/2018/01/30/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E4%BB%8E%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><ul>
<li>Design User System用户系统<ul>
<li>Mencached 优化数据库查询软件</li>
<li>Authentication 用户验证</li>
<li>SQL VS NoSQL 如何选取数据库</li>
<li>Friendship 存储好友关系（不用graph DB用什么）</li>
</ul>
</li>
<li>How to Scale?<ul>
<li>Sharding</li>
<li>Consistent Hashing(第5节)</li>
<li>Replica(第5节)</li>
</ul>
</li>
</ul>
<h1 id="4S分析法"><a href="#4S分析法" class="headerlink" title="4S分析法"></a>4S分析法</h1><ul>
<li><p>Scenario场景</p>
<ul>
<li><p>注册、登录、查询、用户修改信息</p>
<p>哪个需求量最大？查询最大，因为用户登录时给他展示的各种信息邓邓就是通过查询出来的结果</p>
</li>
<li><p>支持100M DAU(每日登录用户数)</p>
</li>
<li><p>注册，登录，信息修改QPS约：</p>
<ul>
<li>100M*0.1/86400 ~ 100</li>
<li>0.1=平均每个用户每天登陆+注册+信息修改</li>
<li>Peak = 100*3 = 300</li>
</ul>
</li>
<li><p>查询的QPS约为：</p>
<ul>
<li>100M*100/86400 ~ 100k</li>
<li>100 = 平均每个用户每天查询与用户信息相关的操作次数（查看好友、发信息，更新消息主页等）</li>
<li>Peak = 100k*3 = 300K</li>
</ul>
</li>
</ul>
</li>
<li><p>Service服务</p>
<ul>
<li>一个AuthService 负责登录注册</li>
<li>一个UserService 负责用户信息与存储</li>
<li>一个FriendshipService存储好友关系</li>
</ul>
</li>
<li><p>Storage:QPS与常用数据存储系统</p>
<ul>
<li>MySQL/PostgreSQL等数据库性能<ul>
<li>约1kQPS</li>
</ul>
</li>
<li>MongoDB/Cassandra等硬盘性NoSQL数据库<ul>
<li>约10QPS</li>
</ul>
</li>
<li>Redis/memcached等内存型NoSQL数据库性能<ul>
<li>100k~1mQPS</li>
</ul>
</li>
</ul>
</li>
<li><p>Scale</p>
<p>根据上面的QPS分析，注册、登录、信息修改300QPS，用mysql应该就够了</p>
<p>用户查询适合什么样的数据存储系统？</p>
</li>
</ul>
<h1 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h1><h2 id="1-1-Cache"><a href="#1-1-Cache" class="headerlink" title="1.1 Cache"></a>1.1 Cache</h2><p><strong>用户系统特点：读非常多，写非常少，一定要用Cache进行优化</strong></p>
<ul>
<li>Cache 是什么？<ul>
<li>缓存，把之后可能要查询的东西先存一下<ul>
<li>下次用的时候直接从这里拿，无需重新计算和存取数据库</li>
</ul>
</li>
<li>可以理解为一个Java中的HashMap</li>
<li>key-value的结构</li>
</ul>
</li>
<li>有哪些常用的Cache软件？<ul>
<li>memcached（不支持数据持久化）</li>
<li>Redis(支持数据持久化)</li>
</ul>
</li>
<li>Cache一定存在内存中么？<ul>
<li>不是</li>
<li>Cache是用于连接不同的介质，解决速度差异的问题</li>
<li>File System有时候也是一种cache</li>
<li>CPU也有Cache</li>
<li>内存是硬盘和CPU的cache</li>
</ul>
</li>
<li>Cache一定是Server Cache 么?<ul>
<li>不，浏览器也可能有客户端的cache</li>
</ul>
</li>
</ul>
<h2 id="1-2-Mem-Cache"><a href="#1-2-Mem-Cache" class="headerlink" title="1.2 Mem-Cache"></a>1.2 Mem-Cache</h2><p>内存中的Cache</p>
<p>Memcached：一个内存cache软件，就看成hashmap用</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-31-00-30-58.png" alt=""> </p>
<p>memcached如何优化DB的查询?</p>
<p>先去cache中查找，如果没有，再去DB中查找：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-01-23-23-56.png" alt=""> </p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-01-23-28-05.png" alt=""> </p>
<p>分析：</p>
<p>我们认为database中的才是最正确的</p>
<p>A：database set时可能会出现问题，但没有太大问题，比如你发了一条微博，显示没成功。</p>
<p>但是如果database成功了，cache更新失败了，那么用户得到的数据都是更新之前的数据。</p>
<p>B：如果cache成功了，但是database没有成功，cache里存的不是database中的真正数据，看成脏数据。</p>
<p>C：如果cache delete成功了，但是database更新失败，没关系，还可以去database里面读取</p>
<p>D：如果database 修改成功了，但是cache失败了，此时用户从cache读取的就是之前的数据</p>
<p>相比之下C比较好，但是C也存在一定的问题：</p>
<p>比如第8行和第9行程序，如果我们刚刚获取了user但是这个时候有另一个进程修改了用户信息，此时再更新cache中的user信息就是旧数据了。</p>
<h2 id="1-3-Cache-Aside-和-Cache-Through"><a href="#1-3-Cache-Aside-和-Cache-Through" class="headerlink" title="1.3 Cache Aside 和 Cache Through"></a>1.3 Cache Aside 和 Cache Through</h2><h3 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-21-40-11.png" alt=""> </p>
<p>前面代码中的例子就是Cache Aside，需要分别对Cache和DB进行操作，这样就会造成不同步的后果</p>
<h3 id="Cache-Through"><a href="#Cache-Through" class="headerlink" title="Cache Through"></a>Cache Through</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-21-40-30.png" alt=""> </p>
<h1 id="2-Service-服务"><a href="#2-Service-服务" class="headerlink" title="2. Service 服务"></a>2. Service 服务</h1><h2 id="2-1-Authentication-Service"><a href="#2-1-Authentication-Service" class="headerlink" title="2.1. Authentication Service"></a>2.1. Authentication Service</h2><ul>
<li>如何实现用户登录和保持登录</li>
<li>会话表，session</li>
</ul>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-01-23-44-43.png" alt=""> </p>
<ul>
<li>用户Login之后<ul>
<li>创建一个session对象</li>
<li>并把seesion_key作为cookie返回给浏览器</li>
<li>浏览器将该值记录在浏览器的cookie中</li>
<li>用户每次想服务器发送的访问，都会自动带上该网站所有的cookie</li>
<li>此时服务器检测到cookie中的session_key是有效的，就认为用户登录了</li>
</ul>
</li>
<li>用户logout之后，从session table中删除对应的数据</li>
<li>Session table存在哪？<ul>
<li>数据库？</li>
<li>缓存？</li>
<li>都可以？</li>
<li>理论上都可以的，但是如果只存在cache中，一旦负责cache的机器宕机，就会有很多用户同时需要重新登录，所以存在数据库里更好一些，如果访问用户多的话，可以用cache做优化。</li>
</ul>
</li>
</ul>
<h2 id="2-2-Friendship-Service"><a href="#2-2-Friendship-Service" class="headerlink" title="2.2. Friendship Service"></a>2.2. Friendship Service</h2><h3 id="好友关系分类"><a href="#好友关系分类" class="headerlink" title="好友关系分类"></a>好友关系分类</h3><ul>
<li><p>单向好友关系（微博、twitter、Instagram）</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-19-50.png" alt=""> </p>
</li>
</ul>
<ul>
<li><p>双向好友关系（微信、Facebook）</p>
<ul>
<li><p>方案一：存为两条信息，A关注了B，B关注了A</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-31-39.png" alt=""> </p>
</li>
<li><p>方案二：存为一条信息，但查询的时候需要查询两次</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-34-58.png" alt=""> </p>
</li>
</ul>
</li>
<li><p>好友关系所涉及的操作非常简单，基本都是Key-value</p>
<ul>
<li>求某个user的所有关注对象</li>
<li>求某个user的所有粉丝</li>
<li>A关注B → 插入一条数据</li>
<li>B关注A → 删除一条数据</li>
</ul>
</li>
</ul>
<h2 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3. 小结"></a>2.3. 小结</h2><ul>
<li>对于用户系统而言：<ul>
<li>写很少</li>
<li>读很多</li>
</ul>
</li>
<li>写操作很少，意味着<ul>
<li>从QPS角度来说，一台mysql就够了</li>
</ul>
</li>
<li>读操作很多，意味着<ul>
<li>可以使用memcached进行读操作的缓存优化</li>
</ul>
</li>
<li>进一步的问题，如果读写操作都很多怎么办？<ul>
<li>方法一：使用更多的数据库服务器分摊流量</li>
<li>方法二：使用像Redis这样的读写操作都很快的Cache-through型数据库<ul>
<li>Memcached是一个Cached-aside型的database,Client需要自己负责管理Cache-miss时的数据的loading</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="3-Storage-数据库的选取"><a href="#3-Storage-数据库的选取" class="headerlink" title="3. Storage 数据库的选取"></a>3. Storage 数据库的选取</h1><h2 id="3-1-数据库的选取原则SQL-vs-NoSQL"><a href="#3-1-数据库的选取原则SQL-vs-NoSQL" class="headerlink" title="3.1. 数据库的选取原则SQL vs NoSQL"></a>3.1. 数据库的选取原则SQL vs NoSQL</h2><ol>
<li><p>大部分情况用SQL和noSQL都可以</p>
</li>
<li><p>需要支持transaction的话不能选用NoSQL</p>
<p>什么是transaction？（交易）</p>
<p>transaction需要数据处理同时成立，比如在银行转账，A转给B10元，需要A-10和B+10同时成立</p>
</li>
<li><p>SQL型的数据库比较成熟，可以帮你做很多事，但是NoSQL很多事都要亲力亲为，比如序列化，多级索引</p>
</li>
<li><p>如果想省点服务器获得更高的性能，NoSQL更好，硬盘型的NoSQL比SQL一般要快10倍以上</p>
</li>
</ol>
<h2 id="3-2-好友关系的存储"><a href="#3-2-好友关系的存储" class="headerlink" title="3.2. 好友关系的存储"></a>3.2. 好友关系的存储</h2><ol>
<li><p>存在SQL</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-46-37.png" alt=""> </p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-48-30.png" alt=""> </p>
</li>
<li><p>存在NoSQL</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-46-59.png" alt=""> </p>
</li>
</ol>
<h2 id="3-3-以Cassandra为例剖析经典的NOSQL数据结构"><a href="#3-3-以Cassandra为例剖析经典的NOSQL数据结构" class="headerlink" title="3.3. 以Cassandra为例剖析经典的NOSQL数据结构"></a>3.3. 以Cassandra为例剖析经典的NOSQL数据结构</h2><h4 id="Cassandra是一个三层结构-三元组结构-的NoSQL数据库"><a href="#Cassandra是一个三层结构-三元组结构-的NoSQL数据库" class="headerlink" title="Cassandra是一个三层结构(三元组结构)的NoSQL数据库:"></a>Cassandra是一个三层结构(三元组结构)的NoSQL数据库:</h4><p><strong>插入数据：insert(row_key,column_key,value)</strong></p>
<ol>
<li>第一层：row_key<ul>
<li>又称为hash_key，cassandra会根据这个key计算一个hash值，然后决定这条数据存在哪</li>
<li>是传统我们所说的key-value中的key</li>
<li>任何查询都需要带上这个key，但无法进行range query</li>
<li>最常用的row_key:uer_id</li>
</ul>
</li>
<li>第二层：column_key<ul>
<li>是排序的，可以进行range query</li>
<li>可以按column指定顺序排序，支持按column范围查询query(row_key,column_start,column_end)</li>
<li>可以是复合值，比如是一个timestamp+user_id的组合</li>
</ul>
</li>
<li>第三层：value<ul>
<li>一般是string</li>
<li>如果需要存很多信息的话，可以自己做序列化</li>
</ul>
</li>
</ol>
<h4 id="SQL-vs-NoSQL"><a href="#SQL-vs-NoSQL" class="headerlink" title="SQL  vs NoSQL"></a>SQL  vs NoSQL</h4><ul>
<li><p>SQL的一条数据以行为单位，取出整个row作为一条数据</p>
</li>
<li><p>SQL的column实在Schema中事先指定好的，不能随意添加。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-14-51-02.png" alt=""> </p>
</li>
<li><p>NoSQL的column是动态的，无限大，可以随意添加</p>
</li>
<li><p>一条数据以grid为单位，row_key + column_key + value = 一条数据</p>
</li>
<li><p>只需要提前定义好column_key本身的格式（是int还是int+string）</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-15-10-31.png" alt=""> </p>
</li>
</ul>
<h4 id="Cassandra存储friendship"><a href="#Cassandra存储friendship" class="headerlink" title="Cassandra存储friendship"></a>Cassandra存储friendship</h4><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-16-25-51.png" alt=""> </p>
<p> 重要的信息，需要频繁查的信息不能放在value中，要放在column_key中</p>
<h4 id="Cassandra存储NewsFeed"><a href="#Cassandra存储NewsFeed" class="headerlink" title="Cassandra存储NewsFeed"></a>Cassandra存储NewsFeed</h4><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-16-30-49.png" alt=""> </p>
<p>将create_time存在column_key中可以按时间排序</p>
<h1 id="4-How-to-scale-单点失效"><a href="#4-How-to-scale-单点失效" class="headerlink" title="4. How to scale? 单点失效"></a>4. How to scale? 单点失效</h1><p>100M用户存在一台mysql数据库存的下，Storage没问题</p>
<p>通过Cache优化读操作之后，只有300QPS的写，QPS也没有问题</p>
<p>还有什么问题？</p>
<p><strong>单点失效 Simgle Point Failure</strong></p>
<p>万一某一台数据库挂了，短暂的挂：网站不可用了，彻底挂了：数据全部丢失</p>
<p><strong>需要做sharding和Replica</strong></p>
<h2 id="4-1-Sharding-数据拆分"><a href="#4-1-Sharding-数据拆分" class="headerlink" title="4.1. Sharding 数据拆分"></a>4.1. Sharding 数据拆分</h2><ul>
<li>按照一定的规则，将数据拆分成不同的部分，保存在不同的机器上</li>
<li>这样就算某个机器挂了，也不会导致网站100%不可用。</li>
</ul>
<h3 id="4-1-1-Sharding-in-SQL-vs-NoSQL"><a href="#4-1-1-Sharding-in-SQL-vs-NoSQL" class="headerlink" title="4.1.1. Sharding in SQL vs NoSQL"></a>4.1.1. Sharding in SQL vs NoSQL</h3><p>SQL自身不带Sharding功能，需要手动实现</p>
<p>以Cassandra为代表的NoSQL大多自带Sharding</p>
<p>这就是为什么发明NoSQL</p>
<h3 id="4-1-2-纵向拆分（Horiaontal-Sharding）"><a href="#4-1-2-纵向拆分（Horiaontal-Sharding）" class="headerlink" title="4.1.2. 纵向拆分（Horiaontal Sharding）"></a>4.1.2. 纵向拆分（Horiaontal Sharding）</h3><p>简单的纵向切分：</p>
<ul>
<li>user table 放一台数据库</li>
<li>Friendship Table 放一台数据库</li>
<li>Message Table 放一台数据库</li>
</ul>
<p>复杂的纵向切分：</p>
<ul>
<li>比如User Table里有如下信息：<ul>
<li>Email</li>
<li>Username</li>
<li>Password</li>
<li>push_preference</li>
<li>avatar</li>
</ul>
</li>
<li>一般email/username/password不会经常变动，而push_preference,avatar变动频率较高</li>
<li>可以把这样的一张表拆分成两个表，User Table 和User Profile Table<ul>
<li>将这两张表放在两台机器上</li>
<li>如果UserprofileTable挂了，不会影响user的正常登录操作</li>
</ul>
</li>
</ul>
<p>实际上就是将table按column进行切分，存储在不同的机器上</p>
<p>缺点：如果数据量很大，有很多很多个用户，纵向拆分之后，仍然很大</p>
<h3 id="4-1-3-横向拆分（核心）"><a href="#4-1-3-横向拆分（核心）" class="headerlink" title="4.1.3. 横向拆分（核心）"></a>4.1.3. 横向拆分（核心）</h3><p>一个粗暴的想法：</p>
<p>假如拆分Friendship Table，假设有10台数据库的机器，可以想到按照from_user_id%10来进行查分，这样做有什么问题？</p>
<p>假设10台机器不够用了，现在买了一台新机器，原来的%10变成了%11，几乎所有的数据都需要进行位置大迁移！！！！</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-17-38-23.png" alt=""> </p>
<p><strong>数据迁移造成的问题：</strong></p>
<ol>
<li>慢，牵一发而动全身</li>
<li>前一期间，服务器压力增大，容易宕机</li>
<li>容易造成数据不一致</li>
</ol>
<p>如何解决？</p>
<p><strong>一致性Hash算法</strong></p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-17-42-48.png" alt=""></p>
<p>更具体的内容听说在下一节，哈哈</p>
<h2 id="4-2-Replica-数据备份"><a href="#4-2-Replica-数据备份" class="headerlink" title="4.2. Replica 数据备份"></a>4.2. Replica 数据备份</h2><ul>
<li>通常的做法是：一式三份（重要的事情说三遍）</li>
<li>Replica同时还能分摊读请求</li>
</ul>
<p>剩下的内容听说也在下一节，哈哈</p>
<h1 id="5-缓存淘汰算法："><a href="#5-缓存淘汰算法：" class="headerlink" title="5. 缓存淘汰算法："></a>5. 缓存淘汰算法：</h1><p>缓存调度算法，缓存页面调度算法：先分配一定的页面空间，使用页面的时候首先去查询空间是否有该页面的缓存，如果有的话直接拿出来，如果没有的话先查询，如果页面空间没有满的时候，使用新页面的时候，就释放旧的页面空间，把新页面缓存起来，以便下次使用同样的页面的时候方便调用。</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">def <span class="title">getUser</span><span class="params">(user_id)</span>:</span></div><div class="line"><span class="function">	user </span>= cache.get(user_id)</div><div class="line">    <span class="keyword">if</span> user :</div><div class="line">      <span class="keyword">return</span> user</div><div class="line">    user = database.get(user_id)</div><div class="line">    cache.set(key, user)</div><div class="line">    <span class="keyword">return</span> user</div><div class="line">  </div><div class="line"><span class="function">def <span class="title">setUser</span><span class="params">(user)</span>:</span></div><div class="line"><span class="function">  cache.<span class="title">delete</span><span class="params">(user.user_id)</span></span></div><div class="line"><span class="function">  database.<span class="title">set</span><span class="params">(user)</span></span></div></pre></td></tr></table></figure>
<p><code>cache</code> 一般是有有效期的，也就是如果缓存中这个数据过期了，那就从缓存中清理出去。而<code>cache</code> 的实现过程和淘汰机制不同，会导致不同的性能表现。常见的就是IFIO，LRU，LFU缓存过期策略。</p>
<ol>
<li>FIFO(First In First Out) : 先进先出。淘汰掉很久以前进来的数据，而新数据等到之后再淘汰。也就是一个队列。</li>
<li>LRU (Least recently used) : 最近最少使用。淘汰最近不适用的数据</li>
<li>LFU (Least frequently used) : 最近使用次数最少。淘汰掉使用次数最少的页面。</li>
</ol>
<h2 id="5-1-FIFO"><a href="#5-1-FIFO" class="headerlink" title="5.1. FIFO"></a>5.1. FIFO</h2><p>按照“先进先出（First In，First Out）”的原理淘汰数据，正好符合队列的特性，数据结构上使用队列Queue来实现。</p>
<p>如下图：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-27-15-54-58.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-27-15-54-58.png" alt="img"></a></p>
<ol>
<li>新访问的数据插入FIFO队列尾部，数据在FIFO队列中顺序移动；</li>
<li>淘汰FIFO队列头部的数据；</li>
</ol>
<h2 id="5-2-LRU-Cache"><a href="#5-2-LRU-Cache" class="headerlink" title="5.2. LRU Cache"></a>5.2. LRU Cache</h2><p>（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”，因此优先将最近没有被访问的数据删掉。</p>
<p>最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-27-15-56-25.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-27-15-56-25.png" alt="img"></a></p>
<ol>
<li>新数据插入到链表头部；</li>
</ol>
<ol>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li>
<li>当链表满的时候，将链表尾部的数据丢弃。</li>
</ol>
<p>leetcode题目： <a href="https://leetcode.com/problems/lru-cache" target="_blank" rel="external">LRU Cache</a></p>
<blockquote>
<p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank" rel="external">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; LRUCache cache = new LRUCache( 2 /* capacity */ );</div><div class="line">&gt;</div><div class="line">&gt; cache.put(1, 1);</div><div class="line">&gt; cache.put(2, 2);</div><div class="line">&gt; cache.get(1);       // returns 1</div><div class="line">&gt; cache.put(3, 3);    // evicts key 2</div><div class="line">&gt; cache.get(2);       // returns -1 (not found)</div><div class="line">&gt; cache.put(4, 4);    // evicts key 1</div><div class="line">&gt; cache.get(1);       // returns -1 (not found)</div><div class="line">&gt; cache.get(3);       // returns 3</div><div class="line">&gt; cache.get(4);       // returns 4</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>简单的说，就是保证基本的get和set的功能的同时，还要保证最近访问(get或put)的节点保持在限定容量的Cache中，如果超过容量则应该把LRU(近期最少使用)的节点删除掉。</p>
<p>思路：</p>
<p>题目要求利用LRU缓存淘汰机制，在<script type="math/tex">O(1)</script> 时间复杂度下实现缓存的加入和删除操作</p>
<p>代码：</p>
<h2 id="5-2-LFU-Cache"><a href="#5-2-LFU-Cache" class="headerlink" title="5.2. LFU Cache"></a>5.2. <a href="https://leetcode.com/problems/lfu-cache" target="_blank" rel="external">LFU Cache</a></h2>]]></content>
      
        <categories>
            
            <category> 系统设计 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Java常用笔记]]></title>
      <url>/2018/01/27/%E3%80%90Java%E3%80%91Java%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="JAVA集合类ArrayList删除指定值元素"><a href="#JAVA集合类ArrayList删除指定值元素" class="headerlink" title="JAVA集合类ArrayList删除指定值元素"></a>JAVA集合类ArrayList删除指定值元素</h2><h3 id="错误做法："><a href="#错误做法：" class="headerlink" title="错误做法："></a>错误做法：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for(int i = 0, len = list.size(); i &lt; len; i++)&#123;  </div><div class="line">    if(list.get(i) == 1) &#123;  </div><div class="line">       list.remove(i);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为删除了元素，但是未改变迭代的下标，这样当迭代到最后一个的时候就会抛异常。</p>
<h3 id="正确做法："><a href="#正确做法：" class="headerlink" title="正确做法："></a>正确做法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = list.size(); i &lt; len; i++)&#123;  </div><div class="line">    <span class="keyword">if</span>(list.get(i) == <span class="number">1</span>)&#123;  </div><div class="line">       list.remove(i);  </div><div class="line">       len--;</div><div class="line">       i--;</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>更好的一个做法</li>
</ul>
<p>List接口内部实现了Iterator接口，提供开发者一个iterator()得到当前list对象的一个iterator对象。所以我们还有一个更好的做法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Iterator&lt;Integer&gt; iterator = list.iterator();  </div><div class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;  </div><div class="line">    <span class="keyword">int</span> i = iterator.next();  </div><div class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;  </div><div class="line">        iterator.remove();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="比较、排序Comparator-Comparable"><a href="#比较、排序Comparator-Comparable" class="headerlink" title="比较、排序Comparator/Comparable"></a>比较、排序Comparator/Comparable</h2><h3 id="1-自定义的类后面需要按指定属性实现排序等操作"><a href="#1-自定义的类后面需要按指定属性实现排序等操作" class="headerlink" title="1.自定义的类后面需要按指定属性实现排序等操作"></a>1.自定义的类后面需要按指定属性实现排序等操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</div><div class="line">	String name;</div><div class="line">	<span class="keyword">double</span> salary;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span>&#123;</div><div class="line">      <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.salary,other.salary);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-已有模板，定义排序顺序（最大堆、最小堆）"><a href="#2-已有模板，定义排序顺序（最大堆、最小堆）" class="headerlink" title="2.已有模板，定义排序顺序（最大堆、最小堆）"></a>2.已有模板，定义排序顺序（最大堆、最小堆）</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//先定义一个比较器</span></div><div class="line">Comparator&lt;Integer&gt; cmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer e1,Integer e2)</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> e1 - e2;<span class="comment">//最小堆，默认</span></div><div class="line">         	<span class="comment">//return e2-e1;最大堆</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue(cmp);</div></pre></td></tr></table></figure>
<p>Long型数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Comparator&lt;Long&gt; cmp = <span class="keyword">new</span> Comparator&lt;Long&gt;()&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long e1,Long e2)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> Long.compare(e1,e2);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue(cmp);</div></pre></td></tr></table></figure>
<h2 id="string和int相互转化"><a href="#string和int相互转化" class="headerlink" title="string和int相互转化"></a>string和int相互转化</h2><h3 id="string转int"><a href="#string转int" class="headerlink" title="string转int"></a>string转int</h3><ol>
<li>int i = Integer.parseInt(String s);</li>
<li>int i = Integer.valueOf(String s).intValue();</li>
</ol>
<h3 id="int转string"><a href="#int转string" class="headerlink" title="int转string"></a>int转string</h3><ol>
<li>String s = String.valueOf(i);</li>
<li>String s = Integer.toString(i);</li>
<li>String s= “”+i;</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章系统设计】新鲜事系统]]></title>
      <url>/2018/01/27/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E6%96%B0%E9%B2%9C%E4%BA%8B%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<h2 id="系统涉及面试的两种形式及常见问题"><a href="#系统涉及面试的两种形式及常见问题" class="headerlink" title="系统涉及面试的两种形式及常见问题"></a>系统涉及面试的两种形式及常见问题</h2><h3 id="设计某某系统"><a href="#设计某某系统" class="headerlink" title="设计某某系统"></a>设计某某系统</h3><p>设计微博、滴滴、微信、短网址系统、nosql数据库</p>
<h3 id="找问题"><a href="#找问题" class="headerlink" title="找问题"></a>找问题</h3><ul>
<li>网站挂了怎么办</li>
<li>网站太慢怎么办</li>
<li>流量增长怎么</li>
</ul>
<h3 id="面试官：请设计Twitter"><a href="#面试官：请设计Twitter" class="headerlink" title="面试官：请设计Twitter"></a>面试官：请设计Twitter</h3><h3 id="系统设计问题的4S分析法"><a href="#系统设计问题的4S分析法" class="headerlink" title="系统设计问题的4S分析法"></a>系统设计问题的4S分析法</h3><ul>
<li>Scenario场景<ul>
<li>需要设计哪些功能，设计的多牛</li>
<li>向面试官提问：features/QPS/DAU(日活跃用户)/inerfaces</li>
</ul>
</li>
<li>Servece服务<ul>
<li>将大系统拆分成小服务</li>
<li>Split/Application/Module</li>
</ul>
</li>
<li>Storage存储<ul>
<li>数据如何存储与访问</li>
<li>Schema(表头字段)/data/sql/nosql/File System</li>
</ul>
</li>
<li>Scale升级<ul>
<li>解决缺陷，处理可能遇到的问题</li>
<li>Sharding/optimize/soecial case</li>
</ul>
</li>
</ul>
<h3 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h3><h4 id="Scenario场景-Ask"><a href="#Scenario场景-Ask" class="headerlink" title="Scenario场景-Ask"></a>Scenario场景-Ask</h4><p>询问面试官：</p>
<ol>
<li>需要设计哪些功能</li>
<li>需要承受多大的访问量？<ol>
<li>日活跃用户DAU</li>
<li>Twitter:MAU ：313M+ DAU：150M+（一般MAU是DAU的2倍）</li>
</ol>
</li>
</ol>
<h4 id="Scenario场景-Analyze-amp-predict"><a href="#Scenario场景-Analyze-amp-predict" class="headerlink" title="Scenario场景-Analyze&amp;predict"></a>Scenario场景-Analyze&amp;predict</h4><ul>
<li>根据DAU计算并发用户数：<ul>
<li><code>日活跃*每个用户平均请求次数/一天多少秒 = 150M*60/86400 ~100k</code></li>
<li>峰值peak = 3*QPS ~300k</li>
<li>快速增长的产品：<ul>
<li>max peak users in 3 months = peak users*2</li>
</ul>
</li>
</ul>
</li>
<li>读频率Read QPS(Queries per second)<ul>
<li>300k</li>
</ul>
</li>
<li>写频率Write QPS<ul>
<li>5k</li>
</ul>
</li>
</ul>
<h4 id="QPS有什么用"><a href="#QPS有什么用" class="headerlink" title="QPS有什么用"></a>QPS有什么用</h4><ul>
<li>QPS = 100<ul>
<li>用笔记本做web服务器就可以</li>
</ul>
</li>
<li>QPS = 1k<ul>
<li>用一台好一点的web服务器就差不多</li>
<li>需要考虑Single Point Failure</li>
</ul>
</li>
<li>QPS = 1m<ul>
<li>需要假设一个1000台web服务器的集群</li>
<li>需要考虑如何Maintanance(某一台挂了怎么办)</li>
</ul>
</li>
<li>QPS和web server/database之间的关系<ul>
<li>一台web service 承受量是1k QPS</li>
<li>一台SQL Database 承受量是1k QPS</li>
<li>一台 no SQL Database 承受量是10k QPS</li>
</ul>
</li>
</ul>
<h4 id="Scenario场景-需要设计哪些功能"><a href="#Scenario场景-需要设计哪些功能" class="headerlink" title="Scenario场景-需要设计哪些功能"></a>Scenario场景-需要设计哪些功能</h4><ul>
<li><p>step1:列举需要的功能</p>
<ul>
<li>注册、登录</li>
<li>用户信息展示、编辑</li>
<li>上传照片、视频</li>
<li>搜索</li>
<li>发送、分享推文</li>
<li>时间轴</li>
<li>关注、取关用户</li>
</ul>
</li>
<li><p>step2:sort按功能优先级排序</p>
<p>​</p>
</li>
</ul>
<h3 id="Service服务"><a href="#Service服务" class="headerlink" title="Service服务"></a>Service服务</h3><p>将大的系统拆分为小服务</p>
<ol>
<li>replay重放需求</li>
<li>merge归并需求</li>
</ol>
<p><img src="https://i.loli.net/2018/01/17/5a5ec793139ea.png" alt=""> </p>
<h3 id="storage存储——数据如何存储与访问（最重点占50-）"><a href="#storage存储——数据如何存储与访问（最重点占50-）" class="headerlink" title="storage存储——数据如何存储与访问（最重点占50%）"></a>storage存储——数据如何存储与访问（最重点占50%）</h3><ul>
<li>关系型数据库SQL Database（结构化数据）MySQL<ul>
<li>用户信息</li>
</ul>
</li>
<li>非关系型数据库（非结构化数据）MangoDB<ul>
<li>推文</li>
<li>社交图谱</li>
</ul>
</li>
<li>文件系统<ul>
<li>图片、视频（Media files）</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2018/01/17/5a5ec9773713d.png" alt=""> </p>
<p>Step1：为每个service选择合适的存储结构</p>
<p>Step2：选好合适的存储结构之后，设计数据表的结果，需要存储哪些字段</p>
<p><img src="https://i.loli.net/2018/01/17/5a5eca2f1b538.png" alt=""> </p>
<h3 id="新鲜事系统News-Feed"><a href="#新鲜事系统News-Feed" class="headerlink" title="新鲜事系统News Feed"></a>新鲜事系统News Feed</h3><ul>
<li>什么是新鲜事News Feed?<ul>
<li>登录Faebook/Twitter/朋友圈之后看到的信息流</li>
<li>你的所有朋友发的信息的集合</li>
</ul>
</li>
<li>典型新鲜事系统<ul>
<li>Facebook</li>
<li>Twitter</li>
<li>朋友圈</li>
<li>RSS Reader（头条）</li>
</ul>
</li>
<li>新鲜事系统的核心因素<ul>
<li>关注与被关注</li>
<li>每个人看到的新鲜事是不同的</li>
</ul>
</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>Pull模型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">用merge K sorted arrays的思想</div><div class="line">用户的时间线：		-&gt;		整合成		-&gt;		feed流</div><div class="line">A：An1,An2,...			↘</div><div class="line">B: Bn1,Bn2,...		  	  →			An1,n2,Bn1,Cn1,Cnw,Bn2.....</div><div class="line">C：Cn1,Cn2,... 			↗</div><div class="line">...</div></pre></td></tr></table></figure>
<ul>
<li>当用户查看News Feed时，获取其每一个好友的最近100条推文，merge这些推文，按时间排序展示给用户</li>
<li>复杂度分析：<ul>
<li>News Feed:加入用户关注了N个对象，则时间为N此DB read的时间（读取数据库）+ N路归并的时间（在内存中计算的O(logK)，时间忽略）读取数据库耗时很长</li>
<li>Post a tweet:一次DB write（写入数据库）时间</li>
</ul>
</li>
</ul>
</li>
<li><p>Push模型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">用户的News Feed List：				用户D\E\F发了tweet，推送到其好友的List中</div><div class="line">A：D,E...			↘</div><div class="line">B: F,...		  	  →			An1,n2,Bn1,Cn1,Cnw,Bn2.....</div><div class="line">C：E,F,... 			↗</div><div class="line">...</div></pre></td></tr></table></figure>
<ul>
<li><p>为每个用户建立一个List存储池存储其好友的News Feed信息，当用户发送一个tweet之后，将该推文推送到每一个关注了他的用户的News Feed中.用户需要查看News Feed时只需要从他的News Feed中读取最近的100条即可</p>
<p><strong>关键词：Fanout</strong></p>
</li>
<li><p>复杂度分析</p>
<ul>
<li>News Feed：1次DB read(相比push模型快很多)</li>
<li>post a tweet：N个粉丝需要N次DB writes<ul>
<li>如果粉丝数量N巨大，写入粉丝News Feed List耗时大</li>
<li>但好处是可以用异步任务在后台执行，无需用户等待</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2018/01/18/5a5f76ad915ab.png" alt=""> </p>
<p>所有的用户公用一个表格，当一个用户发送推文时，他自己和他的关注着都将看到，所以插入n+1条数经验，owner_id为他自己和他的好友们，然后读取时在数据表中select owner_id为自己的。</p>
<p><img src="https://i.loli.net/2018/01/18/5a5f76056f895.png" alt=""> </p>
<p>Web Server 到Asynct是通过消息队列发送，比如RabitMQ，拿到任务后，先去好友关系表中拿到发文用户的关注者们，然后把消息加入News Feed Table</p>
<p>缺陷：</p>
<ol>
<li><p>浪费数据库，但硬盘很便宜，不需要考虑存储数据量大</p>
</li>
<li><p>如果粉丝数量很大，异步操作需要时间，有些粉丝不能及时看到大V发送的tweet</p>
<p>​</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="Design-Twitter"><a href="#Design-Twitter" class="headerlink" title="Design Twitter"></a><a href="https://leetcode.com/problems/design-twitter" target="_blank" rel="external">Design Twitter</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.jws.soap.SOAPBinding;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTwitter</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer,User&gt; UsersList;</div><div class="line">        <span class="keyword">int</span> tweetTimeStamp = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> id;</div><div class="line">            <span class="keyword">int</span> userId;</div><div class="line">            <span class="keyword">int</span> timeStamp;</div><div class="line">            Tweet(<span class="keyword">int</span> id,<span class="keyword">int</span> useId,<span class="keyword">int</span> timeStamp)&#123;</div><div class="line">                <span class="keyword">this</span>.id = id;</div><div class="line">                <span class="keyword">this</span>.userId = useId;</div><div class="line">                <span class="keyword">this</span>.timeStamp = timeStamp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> uid;</div><div class="line">            List&lt;Tweet&gt; tweets = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            List&lt;Integer&gt; followers = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//被谁关注</span></div><div class="line">            List&lt;Integer&gt; followees = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//关注了谁</span></div><div class="line">            User(<span class="keyword">int</span> uid)&#123;</div><div class="line">                <span class="keyword">this</span>.uid = uid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</div><div class="line">            UsersList = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Compose a new tweet. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(userId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(userId);</div><div class="line">                UsersList.put(userId,user);</div><div class="line">            &#125;</div><div class="line">            Tweet tweet = <span class="keyword">new</span> Tweet(tweetId,userId,tweetTimeStamp);</div><div class="line">            UsersList.get(userId).tweets.add(tweet);</div><div class="line">            tweetTimeStamp++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</div><div class="line">            List&lt;Integer&gt; feeds = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(userId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(userId);</div><div class="line">                UsersList.put(userId,user);</div><div class="line">                <span class="keyword">return</span> feeds;</div><div class="line">            &#125;</div><div class="line">            Comparator&lt;Tweet&gt; cmp = <span class="keyword">new</span> Comparator&lt;Tweet&gt;()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Tweet t1,Tweet t2)</span></span>&#123;</div><div class="line">                    <span class="keyword">return</span> t2.timeStamp - t1.timeStamp;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            Queue&lt;Tweet&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">10</span>,cmp);</div><div class="line">            <span class="comment">//先处理自己的新鲜事</span></div><div class="line">            List&lt;Tweet&gt; ownTweets = UsersList.get(userId).tweets;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = ownTweets.size()-<span class="number">1</span>;i &gt;= ownTweets.size() - <span class="number">10</span> &amp;&amp; i &gt;= <span class="number">0</span>;i--)&#123;</div><div class="line">                heap.add(ownTweets.get(i));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//处理关注的人的新鲜事</span></div><div class="line">            List&lt;Integer&gt; followees = UsersList.get(userId).followees;</div><div class="line">            <span class="keyword">for</span>(Integer followee : followees)&#123;</div><div class="line">                List&lt;Tweet&gt; tweets = UsersList.get(followee).tweets;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = tweets.size()-<span class="number">1</span>;i &gt;= tweets.size() - <span class="number">10</span> &amp;&amp; i &gt;= <span class="number">0</span>;i--)&#123;</div><div class="line">                    heap.add(tweets.get(i));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> k = <span class="number">10</span>;</div><div class="line">            <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; !heap.isEmpty())&#123;</div><div class="line">                feeds.add(heap.poll().id);</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> feeds;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</div><div class="line">            <span class="comment">//如果没有用户，新建用户</span></div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(followeeId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(followeeId);</div><div class="line">                UsersList.put(followeeId,user);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(followerId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(followerId);</div><div class="line">                UsersList.put(followerId,user);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(followeeId == followerId || UsersList.get(followerId).followees.contains(followeeId))&#123;<span class="keyword">return</span>;&#125;</div><div class="line">            <span class="comment">//更新用户关注和被关注列表</span></div><div class="line">            UsersList.get(followeeId).followers.add(followerId);</div><div class="line">            UsersList.get(followerId).followees.add(followeeId);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(followeeId == followerId || !UsersList.containsKey(followeeId) || !UsersList.containsKey(followerId) ||</div><div class="line">                    !UsersList.get(followerId).followees.contains(followeeId) || !UsersList.get(followeeId).followers.contains(followerId))&#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            Iterator&lt;Integer&gt; iterator =  UsersList.get(followeeId).followers.iterator();</div><div class="line">            <span class="keyword">while</span>(iterator.hasNext())&#123;</div><div class="line">                <span class="keyword">int</span> i = iterator.next();</div><div class="line">                <span class="keyword">if</span>(i == followerId)&#123;</div><div class="line">                    iterator.remove();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            Iterator&lt;Integer&gt; iterator2 =  UsersList.get(followerId).followees.iterator();</div><div class="line">            <span class="keyword">while</span>(iterator2.hasNext())&#123;</div><div class="line">                <span class="keyword">int</span> i = iterator2.next();</div><div class="line">                <span class="keyword">if</span>(i == followeeId)&#123;</div><div class="line">                    iterator2.remove();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        Twitter obj = <span class="keyword">new</span> Twitter();</div><div class="line">        obj.postTweet(<span class="number">1</span>,<span class="number">5</span>);</div><div class="line">        List&lt;Integer&gt; param_2 = obj.getNewsFeed(<span class="number">1</span>);</div><div class="line">        obj.follow(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">        obj.postTweet(<span class="number">2</span>,<span class="number">6</span>);</div><div class="line">        List&lt;Integer&gt; param_3 = obj.getNewsFeed(<span class="number">1</span>);</div><div class="line">        obj.unfollow(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">        List&lt;Integer&gt; param_4 = obj.getNewsFeed(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        DesignTwitter test = <span class="keyword">new</span> DesignTwitter();</div><div class="line">        test.test();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实这里有个问题，就是follow unfollow post这些都是用户的操作，应该放在用户类里面的，然后再外部调用。有时间重写一下。</p>
]]></content>
      
        <categories>
            
            <category> 系统设计 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[理解Java垃圾回收机制]]></title>
      <url>/2018/01/24/%E3%80%90Java%E3%80%91Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-JVM内存模型"><a href="#1-JVM内存模型" class="headerlink" title="1. JVM内存模型"></a>1. JVM内存模型</h1><p>运行时内存数据区大体上被分为5个区域、两种类型。</p>
<p>5个数据区包括：<code>方法区</code>、<code>堆区</code>、<code>虚拟机栈</code>、<code>本地方法栈</code>、<code>程序计数器</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2654250-152293461531f520.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>两种类型:</p>
<ul>
<li>所有线程共享的数据区：<ol>
<li><strong>方法区</strong>: 存储已被虚拟机加载的类信息、常量、静态变量、即时编译后代码等数据。常量池位于方法区，并使用永久代来实现方法区</li>
<li><strong>堆区</strong>: 我们常说用于存放<strong>对象</strong>的区域</li>
</ol>
</li>
</ul>
<ul>
<li>线程私有(隔离)数据区：<ol>
<li><strong>虚拟机栈</strong>: 方法执行时创建一个栈帧，用于存储局部变量、操作数栈、动态链接、方法出口等信息。<strong>每个方法一个栈帧，互不干扰</strong></li>
<li><strong>本地方法栈</strong>: 用于存放执行native方法的运行数据</li>
<li><strong>程序计数器</strong>: 当前线程所执行的字节码的指示器，通过改变计数器来选取下一条需要执行的字节码指令</li>
</ol>
</li>
</ul>
<p><strong>Java的垃圾回收机制是针对堆区的，通常我们声明的对象和数组都是在堆区的。</strong></p>
<h1 id="2-堆内存模型"><a href="#2-堆内存模型" class="headerlink" title="2. 堆内存模型"></a>2. 堆内存模型</h1><p>既然重点是堆内存，我们就再看看堆的内存模型。</p>
<blockquote>
<p>堆内存由垃圾回收器的自动内存管理系统回收。<br>堆内存分为两大部分：新生代和老年代。比例为1：2。<br>老年代主要存放应用程序中生命周期长的存活对象。<br>新生代又分为三个部分：一个Eden区和两个Survivor区，比例为8：1：1。<br>Eden区存放新生的对象。<br>Survivor存放每次垃圾回收后存活的对象。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/gc_heap.png" target="_blank" rel="external"><img src="http://jayfeng.com/images/gc_heap.png" alt="堆内存模型"></a></p>
<h1 id="3-垃圾回收的意义-amp-内存泄漏"><a href="#3-垃圾回收的意义-amp-内存泄漏" class="headerlink" title="3. 垃圾回收的意义&amp;内存泄漏"></a>3. 垃圾回收的意义&amp;内存泄漏</h1><p>​    Java语言中一个显著的特点就是引入了垃圾回收机制，它使得Java程序员在编写程序的时候<strong>不再需要考虑内存管理</strong>。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。</p>
<p>　　ps:<strong>内存泄露</strong>是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为“对象游离”。</p>
<p>内存泄漏通俗的说就是：不再会被使用的对象内存不能被回收，就是内存泄露。</p>
<p><strong>Java中的内存泄露与C++中的表现有所不同。</strong></p>
<p>​    在C++中，所有被分配了内存的对象，不再使用后，都必须程序员手动的释放他们。所以，每个类，都会含有一个析构函数，作用就是完成清理工作，如果我们忘记了某些对象的释放，就会造成内存泄露。</p>
<p>​    但是在Java中，我们不用（也没办法）自己释放内存，无用的对象由GC自动清理，这也极大的简化了我们的编程工作。但，实际有时候一些不再会被使用的对象，在GC看来不能被释放，就会造成内存泄露。</p>
<p>​    我们知道，对象都是有生命周期的，有的长，有的短，<strong>如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露</strong>。我们举一个简单的例子：</p>
<h1 id="4-可回收对象的判定"><a href="#4-可回收对象的判定" class="headerlink" title="4. 可回收对象的判定"></a>4. 可回收对象的判定</h1><p>任何一种垃圾回收算法一般要<strong>做2件基本的事情</strong>：</p>
<p>（1）发现无用信息对象；</p>
<p>（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。</p>
<p>讲算法之前，我们先要搞清楚一个问题，什么样的对象是垃圾（无用对象），需要被回收？<br>目前市面上有<strong>两种算法用来判定一个对象是否为垃圾，引用计数法和可达性分析法。</strong></p>
<h2 id="4-1-引用计数法"><a href="#4-1-引用计数法" class="headerlink" title="4.1 引用计数法"></a>4.1 引用计数法</h2><p><strong>引用计数算法是通过判断对象的引用数量来决定对象是否可以被回收。</strong></p>
<p><strong>任何引用计数为0的对象实例可以被当作垃圾收集。</strong></p>
<p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p><img src="http://img.blog.csdn.net/20170505173602440?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="循环引用"></p>
<p><strong>优点</strong> ：简单，高效，现在的objective-c用的就是这种算法。</p>
<p><strong>缺点</strong> ：很难处理<strong>循环引用</strong>，如下面的程序和示意图所示，对象objA和objB之间的引用计数永远不可能为 0，那么这两个对象就永远不能被回收。</p>
<h2 id="4-2-可达性分析法（根搜索算法）"><a href="#4-2-可达性分析法（根搜索算法）" class="headerlink" title="4.2 可达性分析法（根搜索算法）"></a>4.2 可达性分析法（根搜索算法）</h2><p><strong>可达性分析算法是通过判断对象的引用链是否可达来决定对象是否可以被回收。</strong></p>
<p>为了解决上面的循环引用问题，Java采用了一种新的算法：<strong>可达性分析算法。</strong><br>从GC Roots（每种具体实现对GC Roots有不同的定义）作为起点，<strong>向下搜索它们引用的对象</strong>，可以生成一棵引用树，树的节点视为可达对象，反之视为不可达。<br><a href="http://jayfeng.com/images/gc_root_object.png" target="_blank" rel="external"><img src="http://jayfeng.com/images/gc_root_object.png" alt="可达性分析算法"></a><br>OK，即使循环引用了，只要没有被GC Roots引用了依然会被回收，完美！<br>但是，这个GC Roots的定义就要考究了，Java语言定义了如下GC Roots对象：</p>
<ul>
<li>虚拟机栈(栈帧中的局部变量表)中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中Native方法引用的对象；</li>
</ul>
<h3 id="4-3-Stop-The-World"><a href="#4-3-Stop-The-World" class="headerlink" title="4.3 Stop The World"></a>4.3 Stop The World</h3><p>​    有了上面的垃圾对象的判定，我们还要考虑一个问题，请大家做好心里准备，那就是Stop The World。<br>因为垃圾回收的时候，需要整个的引用状态保持不变，否则判定是判定垃圾，等我稍后回收的时候它又被引用了，这就全乱套了。所以，GC的时候，其他所有的程序执行处于暂停状态，卡住了。<br>幸运的是，这个卡顿是非常短（尤其是新生代），对程序的影响微乎其微 （关于其他GC比如并发GC之类的，在此不讨论）。<br>​    所以GC的卡顿问题由此而来，也是情有可原，暂时无可避免。</p>
<h1 id="5-垃圾收集算法"><a href="#5-垃圾收集算法" class="headerlink" title="5. 垃圾收集算法"></a>5. 垃圾收集算法</h1><h2 id="5-1-标记清楚算法"><a href="#5-1-标记清楚算法" class="headerlink" title="5.1 标记清楚算法"></a>5.1 标记清楚算法</h2><p>　<strong>标记-清除算法分为标记和清除两个阶段：标记阶段和清除阶段。</strong></p>
<p><strong>该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收</strong>，如下图所示。　　　　　　　　<a href="http://jayfeng.com/images/gc_mark_sweep.png" target="_blank" rel="external"><img src="http://jayfeng.com/images/gc_mark_sweep.png" alt="标记清除算法示意图"></a></p>
<p>优点是简单、容易实现。</p>
<p>主要不足有两个：</p>
<ul>
<li><p><strong>效率问题：</strong>标记和清除两个过程的效率都不高;</p>
</li>
<li><p><strong>空间问题：</strong>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<p>　　　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/mkqv5cf4vg8v72wvxtz0abwz/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95" alt="标记-清除算法-10.6kB"></p>
</li>
</ul>
<h2 id="5-2-复制算法"><a href="#5-2-复制算法" class="headerlink" title="5.2 复制算法"></a>5.2 复制算法</h2><p>​    复制算法将可用内存按容量<strong>划分为大小相等的两块</strong>，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。</p>
<p><strong>优点</strong>：实现简单，运行高效且不容易产生内存碎片，</p>
<p>缺点：但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。<br>从算法原理我们可以看出，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。<br>示意图如下（不用我解说了吧）：<br><a href="http://jayfeng.com/images/gc_copying.png" target="_blank" rel="external"><img src="http://jayfeng.com/images/gc_copying.png" alt="复制算法示意图"></a></p>
<p>　　<strong>事实上，现在商用的虚拟机都采用这种算法来回收新生代</strong></p>
<h2 id="5-3-标记整理算法"><a href="#5-3-标记整理算法" class="headerlink" title="5.3 标记整理算法"></a>5.3 标记整理算法</h2><p>​    复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以<strong>在老年代一般不能直接选用这种算法</strong>。</p>
<p>​    该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。<br>所以，特别适用于存活对象多，回收对象少的情况下。<br>示意图如下（不用我解说了吧）：<br><a href="http://jayfeng.com/images/gc_mark_compact.png" target="_blank" rel="external"><img src="http://jayfeng.com/images/gc_mark_compact.png" alt="标记整理算法示意图"></a></p>
<h2 id="5-4-分代回收算法"><a href="#5-4-分代回收算法" class="headerlink" title="5.4 分代回收算法"></a>5.4 分代回收算法</h2><p>​    对于一个大型的系统，当创建的对象和方法变量比较多时，堆内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必造成效率低下。分代收集算法是基于这样一个事实：<strong>不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。</strong></p>
<p>当代商用虚拟机使用的都是分代收集算法：</p>
<ul>
<li>新生代对象存活率低，就采用复制算法；</li>
<li>老年代存活率高，就用标记清除算法或者标记整理算法。</li>
</ul>
<p><strong>Java堆内存一般可以分为新生代、老年代和永久代三个模块</strong>，如下图所示：</p>
<p><img src="http://static.zybuluo.com/Rico123/bqgcx5anvacebj1yxpaufk0x/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%80%BB.jpg" alt="分代收集算法总.jpg-35.5kB"></p>
<h3 id="5-4-1-新生代（Young-Generation）"><a href="#5-4-1-新生代（Young-Generation）" class="headerlink" title="5.4.1 新生代（Young Generation）"></a>5.4.1 新生代（Young Generation）</h3><p>​    <strong>新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。</strong></p>
<p>​    新生代内存按照 8:1:1 的比例分为<strong>一个eden区和两个survivor</strong>(survivor0，survivor1)区，大部分对象在Eden区中生成。大部分对象在Eden区中生成。在进行垃圾回收时，先将eden区存活对象复制到survivor0区，然后清空eden区，当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即保持survivor0区为空，如此往复。特别地，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等 Eden区满了才触发。</p>
<p>​    基于大多数新生对象都会在 GC 中被收回的假设。新生代的 GC 使用复制算法。在 GC 前 To 幸存区 (survivor) 保持清空，对象保存在 Eden 和 From 幸存区 (survivor) 中，GC 运行时，Eden 中的幸存对象被复制到 To 幸存区 (survivor)。针对 From 幸存区 (survivor) 中的幸存对象，会考虑对象年龄，如果年龄没达到阀值 (tenuring threshold)，对象会被复制到 To 幸存区 (survivor)。如果达到阀值对象被复制到老年代。复制阶段完成后，Eden 和 From 幸存区中只保存死对象，可以视为清空。如果在复制过程中 To 幸存区被填满了，剩余的对象会被复制到老年代中。最后 From 幸存区和 To 幸存区会调换下名字，在下次 GC 时，To 幸存区会成为 From 幸存区。</p>
<p><img src="http://wiki.jikexueyuan.com/project/jvm-parameter/images/1.png" alt="img"></p>
<p>三个问题：</p>
<h4 id="1-为什么不是一块Survivor空间而是两块？"><a href="#1-为什么不是一块Survivor空间而是两块？" class="headerlink" title="1. 为什么不是一块Survivor空间而是两块？"></a>1. 为什么不是一块Survivor空间而是两块？</h4><p>这里涉及到一个新生代和老年代的存活周期的问题，比如一个对象在新生代经历15次（仅供参考）GC，就可以移到老年代了。问题来了，当我们第一次GC的时候，我们可以把Eden区的存活对象放到Survivor A空间，但是第二次GC的时候，Survivor A空间的存活对象也需要再次用Copying算法，放到Survivor B空间上，而把刚刚的Survivor A空间和Eden空间清除。第三次GC时，又把Survivor B空间的存活对象复制到Survivor A空间，如此反复。<br>所以，这里就需要两块Survivor空间来回倒腾。</p>
<h4 id="2-为什么Eden空间这么大而Survivor空间要分的少一点？"><a href="#2-为什么Eden空间这么大而Survivor空间要分的少一点？" class="headerlink" title="2. 为什么Eden空间这么大而Survivor空间要分的少一点？"></a>2. 为什么Eden空间这么大而Survivor空间要分的少一点？</h4><p>新创建的对象都是放在Eden空间，这是很频繁的，尤其是大量的局部变量产生的临时对象，这些对象绝大部分都应该马上被回收，能存活下来被转移到survivor空间的往往不多。所以，设置较大的Eden空间和较小的Survivor空间是合理的，大大提高了内存的使用率，缓解了Copying算法的缺点。<br>我看8：1：1就挺好的，当然这个比例是可以调整的，包括上面的新生代和老年代的1：2的比例也是可以调整的。<br>新的问题又来了，从Eden空间往Survivor空间转移的时候Survivor空间不够了怎么办？<strong>根据实际情况，动态设置放到老年代的次数，直接放到老年代去。</strong></p>
<h4 id="3-Eden空间和两块Survivor空间的工作流程"><a href="#3-Eden空间和两块Survivor空间的工作流程" class="headerlink" title="3. Eden空间和两块Survivor空间的工作流程"></a>3. Eden空间和两块Survivor空间的工作流程</h4><p>这里本来简单的Copying算法被划分为三部分后很多朋友一时理解不了，也确实不好描述，下面我来演示一下Eden空间和两块Survivor空间的工作流程。</p>
<p>现在假定有新生代Eden，Survivor A， Survivor B三块空间和老生代Old一块空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 分配了一个又一个对象</div><div class="line">放到Eden区</div><div class="line">// 不好，Eden区满了，只能GC(新生代GC：Minor GC)了</div><div class="line">把Eden区的存活对象copy到Survivor A区，然后清空Eden区（本来Survivor B区也需要清空的，不过本来就是空的）</div><div class="line">// 又分配了一个又一个对象</div><div class="line">放到Eden区</div><div class="line">// 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了</div><div class="line">把Eden区和Survivor A区的存活对象copy到Survivor B区，然后清空Eden区和Survivor A区</div><div class="line">// 又分配了一个又一个对象</div><div class="line">放到Eden区</div><div class="line">// 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了</div><div class="line">把Eden区和Survivor B区的存活对象copy到Survivor A区，然后清空Eden区和Survivor B区</div><div class="line">// ...</div><div class="line">// 有的对象来回在Survivor A区或者B区呆了比如15次，就被分配到老年代Old区</div><div class="line">// 有的对象太大，超过了Eden区，直接被分配在Old区</div><div class="line">// 有的存活对象，放不下Survivor区，也被分配到Old区</div><div class="line">// ...</div><div class="line">// 在某次Minor GC的过程中突然发现：</div><div class="line">// 不好，老年代Old区也满了，这是一次大GC(老年代GC：Major GC)</div><div class="line">Old区慢慢的整理一番，空间又够了</div><div class="line">// 继续Minor GC</div><div class="line">// ...</div><div class="line">// ...</div></pre></td></tr></table></figure>
<h3 id="5-4-2-老年代（Old-Generation）"><a href="#5-4-2-老年代（Old-Generation）" class="headerlink" title="5.4.2 老年代（Old Generation）"></a>5.4.2 <strong>老年代（Old Generation）</strong></h3><p>​    <strong>老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。</strong>此外，老年代的内存也比新生代大很多(大概比例是1:2)，当老年代满时会触发Major GC(Full GC)，老年代对象存活时间比较长，因此FullGC发生的频率比较低。</p>
<h3 id="5-4-3-永久代（Permanent-Generation）"><a href="#5-4-3-永久代（Permanent-Generation）" class="headerlink" title="5.4.3 永久代（Permanent Generation）"></a>5.4.3 永久代（Permanent Generation）</h3><p>​    <strong>永久代主要用于存放静态文件，如Java类、方法等。</strong>永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如使用反射、动态代理、CGLib等bytecode框架时，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。</p>
<h2 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5 小结"></a>5.5 小结</h2><p><img src="http://img.blog.csdn.net/20170515153931088?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="6-两种垃圾回收类型"><a href="#6-两种垃圾回收类型" class="headerlink" title="6. 两种垃圾回收类型"></a>6. 两种垃圾回收类型</h1><p>　由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。<strong>垃圾回收有两种类型，Minor GC 和 Full GC。</strong></p>
<ul>
<li><strong>Minor GC：</strong>对新生代进行回收，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。</li>
<li><strong>Full GC：</strong>也叫 Major GC，对整个堆进行回收，包括新生代和老年代。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。</li>
</ul>
<h1 id="7-内存分配与回收策略"><a href="#7-内存分配与回收策略" class="headerlink" title="7.内存分配与回收策略"></a>7.内存分配与回收策略</h1><p> Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：<strong>给对象分配内存 </strong>以及<strong> 回收分配给对象的内存</strong>。一般而言，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓存(TLAB)，将按线程优先在TLAB上分配。少数情况下也可能直接分配在老年代中。总的来说，内存分配规则并不是一层不变的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p>
<p>　　1) <strong>对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。</strong>现在的商业虚拟机一般都采用复制算法来回收新生代，将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。 当进行垃圾回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后处理掉Eden和刚才的Survivor空间。（HotSpot虚拟机默认Eden和Survivor的大小比例是8:1）当Survivor空间不够用时，需要依赖老年代进行分配担保。</p>
<p>　　2) <strong>大对象直接进入老年代。</strong>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。</p>
<p>　　3) <strong>长期存活的对象将进入老年代。</strong>当对象在新生代中经历过一定次数（默认为15）的Minor GC后，就会被晋升到老年代中。</p>
<p>　　4) <strong>动态对象年龄判定。</strong>为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<p>　　需要注意的是，Java的垃圾回收机制是Java虚拟机提供的能力，用于在空闲时间以不定时的方式动态回收无任何引用的对象占据的内存空间。也就是说，垃圾收集器回收的是无任何引用的对象占据的内存空间而不是对象本身。</p>
<h1 id="8-垃圾收集器"><a href="#8-垃圾收集器" class="headerlink" title="8. 垃圾收集器"></a>8. 垃圾收集器</h1><p>　　如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。</p>
<p>　　　　　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/9hswys8w1pqy0ch06vmlbqi2/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="垃圾收集器.jpg-64.2kB"></p>
<ul>
<li>Serial收集器<strong>（复制算法)</strong>: <strong>新生代单线程收集器，</strong>标记和清理都是单线程，优点是简单高效；</li>
<li>Serial Old收集器<strong> (标记-整理算法)</strong>: <strong>老年代单线程收集器</strong>，Serial收集器的老年代版本；</li>
<li>ParNew收集器<strong> (复制算法)</strong>: <strong>新生代收并行集器</strong>，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li>
<li>Parallel Scavenge收集器<strong> (复制算法)</strong>: <strong>新生代并行收集器</strong>，<strong>追求高吞吐量</strong>，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li>
<li>Parallel Old收集器<strong> (标记-整理算法)</strong>： <strong>老年代并行收集器</strong>，<strong>吞吐量优先</strong>，Parallel Scavenge收集器的老年代版本；</li>
<li>CMS(Concurrent Mark Sweep)收集器<strong>（标记-清除算法）</strong>： <strong>老年代并行收集器</strong>，<strong>以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点</strong>，追求最短GC回收停顿时间。</li>
<li>G1(Garbage First)收集器<strong> (标记-整理算法)</strong>： <strong>Java堆并行收集器</strong>，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://blog.csdn.net/justloveyou_/article/details/71216049" target="_blank" rel="external"> 图解Java 垃圾回收机制</a></p>
<p><a href="http://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">杰风居的博客-理解Java垃圾回收机制</a></p>
<p><a href="https://www.jianshu.com/p/1579aafac60b" target="_blank" rel="external">JVM内存模型</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法基础班】图与搜索]]></title>
      <url>/2018/01/23/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E5%9B%BE%E4%B8%8E%E6%90%9C%E7%B4%A2/</url>
      <content type="html"><![CDATA[<h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><ul>
<li><p>graph</p>
<ul>
<li>Clone Graph</li>
<li>Topological Sorting</li>
</ul>
</li>
<li><p>Search</p>
<ul>
<li><p>DFS</p>
</li>
<li><p>BFS:（O(m+n)m为边树，n为点数)</p>
<ul>
<li><p>遍历图</p>
<p>树的BFS需要用队列，在图中除了要用队列还需要用到hash表，用来存储节点是否被访问过</p>
<p>BFS还可以用于求深度，最短路径</p>
</li>
<li><p>简单图求最短路径</p>
</li>
<li><p>拓扑排序</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="BFS例题"><a href="#BFS例题" class="headerlink" title="BFS例题"></a>BFS例题</h2><h3 id="1-Clone-Graph"><a href="#1-Clone-Graph" class="headerlink" title="1. Clone Graph"></a>1. <a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="external">Clone Graph</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Clone an undirected graph. Each node in the graph contains a <code>label</code> and a list of its <code>neighbors</code>.</p>
<p>OJ’s undirected graph serialization:</p>
<p>Nodes are labeled uniquely.</p>
<p> We use <code>#</code>as a separator for each node, and <code>,</code> as a separator for node label and each neighbor of the node.</p>
<p>As an example, consider the serialized graph <code>{0,1,2#1,2#2,2}</code>.</p>
<p>The graph has a total of three nodes, and therefore contains three parts as separated by <code>#</code>.</p>
<ol>
<li>First node is labeled as <code>0</code>. Connect node <code>0</code> to both nodes <code>1</code> and <code>2</code>.</li>
<li>Second node is labeled as <code>1</code>. Connect node <code>1</code> to node <code>2</code>.</li>
<li>Third node is labeled as <code>2</code>. Connect node <code>2</code> to node <code>2</code> (itself), thus forming a self-cycle.</li>
</ol>
<p>Visually, the graph looks like the following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;        1</div><div class="line">&gt;       / \</div><div class="line">&gt;      /   \</div><div class="line">&gt;     0 --- 2</div><div class="line">&gt;          / \</div><div class="line">&gt;          \_/</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定图中的一个节点，克隆整个图</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>考点：</p>
<ol>
<li>从一个点出发，把整张图的所有节点找到（BFS）nodes</li>
<li>获得nodes之后复制所有的点，将新老节点建立映射关系，存入hashmap中</li>
<li>根据老节点之间的关系和新老节点的映射关系，复制所有的边</li>
<li>最后返回给定的node对应的新节点</li>
</ol>
<p>还可以用DFS：</p>
<p>递归调用复制节点和邻居关系。</p>
<p>DFS的输入是旧结点，返回值是新节点。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>BFS:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphClone</span> </span>&#123;</div><div class="line">     <span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraphNode</span> </span>&#123;</div><div class="line">         <span class="keyword">int</span> label;</div><div class="line">         List&lt;UndirectedGraphNode&gt; neighbors;</div><div class="line">         UndirectedGraphNode(<span class="keyword">int</span> x) &#123; label = x; neighbors = <span class="keyword">new</span> ArrayList&lt;UndirectedGraphNode&gt;(); &#125;</div><div class="line">     &#125;</div><div class="line">     HashMap&lt;UndirectedGraphNode,UndirectedGraphNode&gt; nodeMap = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//用于存储新旧节点映射关系</span></div><div class="line">     List&lt;UndirectedGraphNode&gt; oldNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//旧结点</span></div><div class="line">     List&lt;UndirectedGraphNode&gt; newNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//新节点</span></div><div class="line"></div><div class="line">    <span class="comment">//bfs获取图中所有的点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(UndirectedGraphNode node)</span></span>&#123;</div><div class="line">        Queue&lt;UndirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        HashSet&lt;UndirectedGraphNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        queue.add(node);</div><div class="line">        set.add(node);</div><div class="line">        <span class="comment">//BFS</span></div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            UndirectedGraphNode temp = queue.poll();</div><div class="line">            UndirectedGraphNode newNode = <span class="keyword">new</span> UndirectedGraphNode(temp.label);</div><div class="line">            oldNodes.add(temp);<span class="comment">//加入旧点集</span></div><div class="line">            newNodes.add(newNode);<span class="comment">//加入新点集</span></div><div class="line">            nodeMap.put(temp,newNode);<span class="comment">//加入mapping</span></div><div class="line"></div><div class="line">            <span class="comment">//遍历当前节点的所有邻居</span></div><div class="line">            <span class="keyword">for</span>(UndirectedGraphNode neighbor : temp.neighbors)&#123;</div><div class="line">                <span class="comment">//如果已经加入结合了，跳过</span></div><div class="line">                <span class="keyword">if</span>(set.contains(neighbor))&#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果还未加入</span></div><div class="line">                queue.add(neighbor);</div><div class="line">                set.add(neighbor);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//获取图中所有的节点</span></div><div class="line">        bfs(node);</div><div class="line">        <span class="comment">//复制所有的边</span></div><div class="line">        <span class="keyword">for</span>(UndirectedGraphNode oldNode : oldNodes)&#123;</div><div class="line">            <span class="keyword">for</span>(UndirectedGraphNode neighbor : oldNode.neighbors)&#123;</div><div class="line">                nodeMap.get(oldNode).neighbors.add(nodeMap.get(neighbor));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//返回node对应的新节点</span></div><div class="line">        <span class="keyword">return</span> nodeMap.get(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DFS：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">dfs</span><span class="params">(UndirectedGraphNode node,HashMap&lt;UndirectedGraphNode,UndirectedGraphNode&gt; map)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(map.containsKey(node))&#123;</div><div class="line">        <span class="keyword">return</span> map.get(node);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//新建节点</span></div><div class="line">    UndirectedGraphNode newNode = <span class="keyword">new</span> UndirectedGraphNode(node.label);</div><div class="line">    map.put(node,newNode);</div><div class="line">    <span class="comment">//遍历邻居节点</span></div><div class="line">    <span class="keyword">for</span>(UndirectedGraphNode neighbor : node.neighbors)&#123;</div><div class="line">        newNode.neighbors.add(dfs(neighbor,map));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</div><div class="line">    HashMap&lt;UndirectedGraphNode,UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dfs(node,map);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-拓扑排序"><a href="#2-拓扑排序" class="headerlink" title="2. 拓扑排序"></a>2. 拓扑排序</h3><p>下面这个图假设是一种上课顺序，比如上1之前必须上0。求这个图的任意一个拓扑排序（按照这个顺序上课则可以上完所有课）</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" alt="img"></a></p>
<p>拓扑排序很好的参考资料：<a href="http://www.stoimen.com/blog/2012/10/01/computer-algorithms-topological-sort-of-a-graph/" target="_blank" rel="external">Topological Sort of a Graph</a></p>
<p>拓扑排序的思路如下：</p>
<ol>
<li>统计当前入度为0的点，加入队列</li>
<li>将当前所有入度为0的点删掉，并将这些点的下一点的连线删掉，将其下一个节点的入度减1</li>
<li>重复1和2，直到所有的点都被删掉</li>
<li>如果不能拓扑排序说明图中一定有环</li>
</ol>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-11-16-43-48.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-16-43-48.png" alt="img"></a></p>
<h3 id="Topological-Sorting"><a href="#Topological-Sorting" class="headerlink" title="Topological Sorting"></a><a href="http://www.lintcode.com/en/problem/topological-sorting/" target="_blank" rel="external">Topological Sorting</a></h3><blockquote>
<p>Given an directed graph, a topological order of the graph nodes is defined as follow:</p>
<ul>
<li>For each directed edge <code>A -&gt; B</code> in graph, A must before B in the order list.</li>
<li>The first node in the order can be any node in the graph with no nodes direct to it.</li>
</ul>
<p>Find any topological order for the given graph.</p>
<p>Example</p>
<p>For graph as follow:</p>
</blockquote>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" alt="img"></p>
<blockquote>
<p>The topological order can be:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [0, 1, 2, 3, 4, 5]</div><div class="line">&gt; [0, 2, 3, 1, 5, 4]</div><div class="line">&gt; ...</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>核心就是根据拓扑排序给出一条合理的路径，能够遍历图中所有的点，且不违背箭头顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;DirectedGraphNode&gt; <span class="title">topSort</span><span class="params">(ArrayList&lt;DirectedGraphNode&gt; graph)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    HashMap&lt;DirectedGraphNode,Integer&gt; degreeIn = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    Queue&lt;DirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    ArrayList&lt;DirectedGraphNode&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">//计算入度出度</span></div><div class="line">    <span class="keyword">for</span>(DirectedGraphNode nodeFrom : graph) &#123;</div><div class="line">        <span class="keyword">for</span> (DirectedGraphNode nodeEnd : nodeFrom.neighbors) &#123;</div><div class="line">            <span class="comment">//计算NodeEnd入度</span></div><div class="line">            <span class="keyword">if</span> (!degreeIn.containsKey(nodeEnd)) &#123;</div><div class="line">                degreeIn.put(nodeFrom, <span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                degreeIn.put(nodeEnd, degreeIn.get(nodeEnd) + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//bfs</span></div><div class="line">    <span class="comment">//queue.add(graph.get(0));</span></div><div class="line">    <span class="keyword">for</span>(DirectedGraphNode node : graph)&#123;</div><div class="line">        <span class="keyword">if</span>(!degreeIn.containsKey(node))&#123;</div><div class="line">            queue.offer(node);</div><div class="line">            results.add(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">        DirectedGraphNode node = queue.poll();</div><div class="line">        <span class="comment">//results.add(node);</span></div><div class="line">        <span class="keyword">for</span>(DirectedGraphNode neighbor : node.neighbors)&#123;</div><div class="line">            degreeIn.put(neighbor,degreeIn.get(neighbor)-<span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>(degreeIn.get(neighbor) == <span class="number">0</span>)&#123;</div><div class="line">                queue.add(neighbor);</div><div class="line">                results.add(neighbor);</div><div class="line">                <span class="comment">//numNodes--;</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="Course-Schedule"><a href="#Course-Schedule" class="headerlink" title="Course Schedule"></a><a href="https://leetcode.com/problems/course-schedule" target="_blank" rel="external">Course Schedule</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>
<p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 2, [[1,0]]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 2, [[1,0],[0,1]]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>
</blockquote>
<p>给定课程门数，和课程之间的依赖关系，判断是否可以无冲突完成课程。</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>BFS和DFS都可以做</p>
<p>BFS：</p>
<p>拓扑排序的思想，如果最后所有的点都被访问到了，就是可以的，反之不可以。</p>
<p>DFS：</p>
<p>用DFS的核心思想就是遇到某条路径上有环就可以返回false，不用继续判断了。所以需要用一个visited数组来保存节点的访问状态。当沿着某一条路径前进时遇到之前已经访问过的节点，就返回false，如果一直没有出现环则在最后返回true。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>BFS:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseSchedule</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] classDegreeIn = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];<span class="comment">//记录入度</span></div><div class="line">        <span class="keyword">int</span>[] classDegreeOut = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];<span class="comment">//记录出度</span></div><div class="line">        HashMap&lt;Integer,List&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">        <span class="comment">//遍历所有的点记录入度和出度,加入边集和</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> edgeFrom = prerequisites[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> edgeEnd = prerequisites[i][<span class="number">1</span>];</div><div class="line">            classDegreeIn[edgeEnd]++;</div><div class="line">            classDegreeOut[edgeFrom]++;</div><div class="line">            List&lt;Integer&gt; listTemp = edges.getOrDefault(edgeFrom,<span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">            listTemp.add(edgeEnd);</div><div class="line">            edges.put(edgeFrom,listTemp);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//寻找入度为0的点入栈</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numCourses;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(classDegreeIn[i] == <span class="number">0</span>)&#123;</div><div class="line">                queue.add(i);</div><div class="line">                counter++;</div><div class="line">                <span class="keyword">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</div><div class="line">                hasVisited[i] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//bfs</span></div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> classID = queue.poll();</div><div class="line">            <span class="keyword">if</span>(edges.getOrDefault(classID,<span class="keyword">new</span> ArrayList&lt;&gt;()).size() == <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//遍历classID的所有邻居，将其入度-1</span></div><div class="line">            <span class="keyword">for</span>(Integer neighbor : edges.get(classID))&#123;</div><div class="line">                classDegreeIn[neighbor]--;</div><div class="line">                <span class="comment">//如果入度为0,入栈</span></div><div class="line">                <span class="keyword">if</span>(classDegreeIn[neighbor] == <span class="number">0</span>)&#123;</div><div class="line">                    queue.add(neighbor);</div><div class="line">                    counter++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> counter == numCourses;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DFS：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] used;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] used,HashMap&lt;Integer, List&lt;Integer&gt;&gt; edges,Integer node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(used[node])&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(edges.containsKey(node)) &#123;</div><div class="line">            used[node] = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">for</span>(Integer next: edges.get(node))&#123;</div><div class="line">                <span class="keyword">if</span>(!dfs(used,edges,next))&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            used[node] = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer, List&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</div><div class="line"></div><div class="line">        <span class="comment">//遍历所有的点记录入度和出度,加入边集和</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> edgeFrom = prerequisites[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> edgeEnd = prerequisites[i][<span class="number">1</span>];</div><div class="line">            List&lt;Integer&gt; listTemp = edges.getOrDefault(edgeFrom, <span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">            listTemp.add(edgeEnd);</div><div class="line">            edges.put(edgeFrom, listTemp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(Integer node : edges.keySet())&#123;</div><div class="line">            <span class="keyword">if</span>(!dfs(used,edges,node))&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a><a href="https://leetcode.com/problems/word-ladder" target="_blank" rel="external">Word Ladder</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>
</ol>
<p>For example,</p>
<p>Given:<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p>
<p>As one shortest transformation is <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,<br>return its length <code>5</code>.</p>
</blockquote>
<p>求从起点到终点的最短路径长度</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>求路径长度一般用BFS，从起点开始把相差一个字母的单词一次入队列，知道遇到结束词时， 此时bfs的深度就是最短路径长度。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] isUsed;</div><div class="line"></div><div class="line">    <span class="comment">//判断两个单词是否只相差一个字母</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word1, String word2)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> diffSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</div><div class="line">                diffSum++;</div><div class="line">                <span class="keyword">if</span>(diffSum &gt; <span class="number">1</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</div><div class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(beginWord);</div><div class="line">        <span class="keyword">int</span> step = <span class="number">2</span>;</div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> queueSize = queue.size();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; queueSize;i++)&#123;</div><div class="line">                String temp  = queue.peek();</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;wordList.size();j++)&#123;</div><div class="line">                    <span class="keyword">if</span>(!isUsed[j] &amp;&amp; isValid(temp,wordList.get(j)))&#123;</div><div class="line">                        <span class="keyword">if</span>(wordList.get(j).equals(endWord))&#123;</div><div class="line">                            <span class="keyword">return</span> step;</div><div class="line">                        &#125;</div><div class="line">                        queue.add(wordList.get(j));</div><div class="line">                        isUsed[j] = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                queue.poll();</div><div class="line">            &#125;</div><div class="line">            step++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</div><div class="line">        isUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[wordList.size()];</div><div class="line">        <span class="keyword">return</span> solve(beginWord,endWord,wordList);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Word-Ladder-II"><a href="#Word-Ladder-II" class="headerlink" title="Word Ladder II"></a><a href="https://leetcode.com/problems/word-ladder-ii" target="_blank" rel="external">Word Ladder II</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>
</ol>
<p>For example,</p>
<p>Given:<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p>
<p>Return</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;   [</div><div class="line">&gt;     [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</div><div class="line">&gt;     [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</div><div class="line">&gt;   ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>返回所有的路径长度最短的合法路径。</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>找到合法路径，考虑用BFS，找到所有合法的路径，考虑用DFS，这道题目要求找到路径最短的所有合法路径，所以是一道BFS和DFS的综合题目。</p>
<p>如果只用DFS找的话，要遍历所有的路径，势必会超时（我试了，真的超时）</p>
<p>所以采用dfs和bfs结合的办法：</p>
<p>先从endWord到beginWord用BFS找到最短的路径是多少，同时标记经过的点到endWord的最短距离是多少</p>
<p>然后再用DFS从beginWord到endWord找到确定的路径，此时只需要遍历之前遍历过的点，其余的没有经过的点无需遍历，而且可以按距离顺序来遍历，将所有合法的路径加入的结果结合中。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    List&lt;List&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span>[] disToBegin;<span class="comment">//记录距离起点的距离</span></div><div class="line"></div><div class="line">    <span class="comment">//判断两个单词是否只相差一个字母</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word1, String word2)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(word1.length() != word2.length())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> diffSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</div><div class="line">                diffSum++;</div><div class="line">                <span class="keyword">if</span>(diffSum &gt; <span class="number">1</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//bfs从后向前寻找最短路径长度,标记点到终点的距离</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</div><div class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(endWord);</div><div class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;<span class="comment">//endword深度为0</span></div><div class="line">        <span class="comment">//bfs</span></div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            depth++;</div><div class="line">            <span class="keyword">int</span> size = queue.size();</div><div class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</div><div class="line">                String temp = queue.poll();</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;wordList.size();i++)&#123;</div><div class="line">                    String word = wordList.get(i);</div><div class="line">                    <span class="comment">//如果单词已经加入过队列了，或者和当前节点相差不为1，跳过</span></div><div class="line">                    <span class="keyword">if</span>(word.equals(endWord) || disToBegin[i] &gt; <span class="number">0</span> || !isValid(temp,word))&#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(word.equals(beginWord))&#123;</div><div class="line">                        <span class="keyword">return</span> depth;<span class="comment">//begin节点深度</span></div><div class="line">                    &#125;</div><div class="line">                    queue.add(word);</div><div class="line">                    disToBegin[i] = depth;</div><div class="line">                &#125;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//从前向后dfs确定具体路径</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String tempWord, String endWord,List&lt;String&gt; wordList,<span class="keyword">int</span> depth)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(depth == <span class="number">0</span>)&#123;</div><div class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            temp.add(endWord);</div><div class="line">            results.add(temp);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; disToBegin.length;i++)&#123;</div><div class="line">            String wordNext = wordList.get(i);</div><div class="line">            <span class="comment">//寻找深度和字母都符合的单词</span></div><div class="line">            <span class="keyword">if</span>(disToBegin[i] != depth || !isValid(tempWord,wordNext))&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            result.add(wordNext);</div><div class="line">            dfs(wordNext,endWord,wordList,depth-<span class="number">1</span>);</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</div><div class="line">        <span class="keyword">if</span>(!wordList.contains(endWord))&#123;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//List&lt;String&gt; words = new ArrayList&lt;&gt;(wordList);</span></div><div class="line">        wordList.add(beginWord);</div><div class="line">        disToBegin = <span class="keyword">new</span> <span class="keyword">int</span>[wordList.size()];</div><div class="line">        <span class="keyword">int</span> depth = bfs(beginWord,endWord,wordList);</div><div class="line">        result.add(beginWord);</div><div class="line">        dfs(beginWord,endWord,wordList,depth-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="DFS排列组合"><a href="#DFS排列组合" class="headerlink" title="DFS排列组合"></a>DFS排列组合</h2><p>排列：</p>
<p><a href="https://leetcode.com/problems/permutations" target="_blank" rel="external">Permutations</a>   </p>
<p><a href="https://leetcode.com/problems/permutations-ii" target="_blank" rel="external">Permutations II</a>   </p>
<p>组合：</p>
<h3 id="Palindrome-Partitioning"><a href="#Palindrome-Partitioning" class="headerlink" title="Palindrome Partitioning"></a><a href="https://leetcode.com/problems/palindrome-partitioning" target="_blank" rel="external">Palindrome Partitioning</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of <em>s</em>.</p>
<p>For example, given <em>s</em> = <code>&quot;aab&quot;</code>,<br>Return</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[</div><div class="line">  [&quot;aa&quot;,&quot;b&quot;],</div><div class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</div><div class="line">]</div></pre></td></tr></table></figure>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>DFS，对字符串进行分割</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromePartitioning</span> </span>&#123;</div><div class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;List&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Palindrome</span><span class="params">(String s)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length() == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = s.length()-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j))&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            i++;j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</div><div class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//规定左段包含i,右段不包含i</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end;i++)&#123;</div><div class="line">            String left = s.substring(start,i+<span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>(!Palindrome(left))&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            result.add(left);</div><div class="line">            helper(s,i+<span class="number">1</span>,end);</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</div><div class="line">        helper(s,<span class="number">0</span>,s.length()-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://leetcode.com/problems/combination-sum" target="_blank" rel="external">Combination Sum</a> </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>找所有方案的问题一般都是DFS，90%的DFS是排列或者组合。</p>
<h2 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h2><h3 id="01-Matrix"><a href="#01-Matrix" class="headerlink" title="01 Matrix"></a>01 <a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="external">Matrix</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.</p>
<p>The distance between two adjacent cells is 1.</p>
<p><strong>Example 1: </strong><br>Input:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 0 0 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 0 0 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2: </strong><br>Input:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 1 1 1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 1 2 1</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>计算每个点距离最近的0的距离</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>方法一:</p>
<p>用BFS，先将所有0的位置放入队列，然后出队列，将其周围点置位1，如队列，然后出队，将其周围点置为2，以此类推。</p>
<p>方法二：</p>
<p>动态规划，先从左上到右下计算每个点离最近的0的距离</p>
<p>然后从右下到左上再来一遍</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><p>BFS:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">  <span class="keyword">int</span> rows = matrix.length;</div><div class="line">  <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">  <span class="keyword">int</span>[][] dist = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">      <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)&#123;</div><div class="line">        dist[i][j] = <span class="number">0</span>;</div><div class="line">        queue.add(i*cols+j);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        dist[i][j] = -<span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    depth++;</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">while</span> (size&gt;<span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">int</span> location = queue.poll();</div><div class="line">      <span class="keyword">int</span> row = location/cols;</div><div class="line">      <span class="keyword">int</span> col = location%cols;</div><div class="line">      <span class="keyword">int</span>[] rdelta = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</div><div class="line">      <span class="keyword">int</span>[] cdelta = &#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)&#123;</div><div class="line">        <span class="keyword">int</span> new_row = row+rdelta[i];</div><div class="line">        <span class="keyword">int</span> new_col = col+cdelta[i];</div><div class="line">        <span class="keyword">if</span>(new_row &gt;=<span class="number">0</span> &amp;&amp; new_row &lt; rows &amp;&amp; new_col &gt;= <span class="number">0</span> &amp;&amp; new_col &lt; cols &amp;&amp; dist[new_row][new_col] == -<span class="number">1</span>)&#123;</div><div class="line">          dist[new_row][new_col] = depth;</div><div class="line">          queue.add(new_row * cols + new_col);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      size--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dist;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>动态规划</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] dist;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        dist = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="comment">//First pass: check for left and top</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</div><div class="line">                    dist[i][j] = <span class="number">0</span>;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    dist[i][j] = rows+cols;</div><div class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</div><div class="line">                        dist[i][j] = Math.min(dist[i][j], dist[i - <span class="number">1</span>][j] + <span class="number">1</span>);</div><div class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</div><div class="line">                        dist[i][j] = Math.min(dist[i][j], dist[i][j - <span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//Second pass: check for bottom and right</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = rows - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = cols - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">                <span class="keyword">if</span> (i &lt; rows - <span class="number">1</span>)</div><div class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i + <span class="number">1</span>][j] + <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (j &lt; cols - <span class="number">1</span>)</div><div class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i][j + <span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dist;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Pacific-Atlantic-Water-Flow"><a href="#Pacific-Atlantic-Water-Flow" class="headerlink" title="Pacific Atlantic Water Flow"></a><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="external">Pacific Atlantic Water Flow</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an <code>m x n</code> matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.</p>
<p>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.</p>
<p>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p>
<p><strong>Note:</strong></p>
<ol>
<li>The order of returned grid coordinates does not matter.</li>
<li>Both <em>m</em> and <em>n</em> are less than 150.</li>
</ol>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given the following 5x5 matrix:</div><div class="line">&gt;</div><div class="line">&gt;   Pacific ~   ~   ~   ~   ~ </div><div class="line">&gt;        ~  1   2   2   3  (5) *</div><div class="line">&gt;        ~  3   2   3  (4) (4) *</div><div class="line">&gt;        ~  2   4  (5)  3   1  *</div><div class="line">&gt;        ~ (6) (7)  1   4   5  *</div><div class="line">&gt;        ~ (5)  1   1   2   4  *</div><div class="line">&gt;           *   *   *   *   * Atlantic</div><div class="line">&gt; Return:</div><div class="line">&gt; [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>矩阵左上是pacific 右下是atlantic,找出所有水能够同时流向两个ocean的位置</p>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>用dfs，对pacific ocean从边缘的每一个点向内dfs搜索可以到达的点，就是考虑每一个点的上下左右四个邻居是否比自己高，如果比自己高而且之前还没有遍历过，就继续dfs。对atlantic做同样的操作。两边都可以到达的加入结果集。</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">boolean</span>[][] pacific,<span class="keyword">boolean</span>[][] used)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt; rows || j &gt; cols)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        pacific[i][j] = <span class="keyword">true</span>;</div><div class="line">        used[i][j] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">int</span>[] r_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] c_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> id = <span class="number">0</span> ; id  &lt; <span class="number">4</span>; id++)&#123;</div><div class="line">            <span class="keyword">int</span> new_row = i + r_delta[id];</div><div class="line">            <span class="keyword">int</span> new_col = j + c_delta[id];</div><div class="line">            <span class="keyword">if</span>(new_row &gt;= <span class="number">0</span> &amp;&amp; new_col &gt;= <span class="number">0</span> &amp;&amp; new_row &lt; rows &amp;&amp; new_col &lt; cols &amp;&amp; !used[new_row][new_col] &amp;&amp;matrix[new_row][new_col] &gt;= matrix[i][j])&#123;</div><div class="line">                <span class="comment">//pacific[new_row][new_col] = true;</span></div><div class="line">                dfs(matrix,new_row,new_col,pacific,used);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">        List&lt;<span class="keyword">int</span>[]&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">boolean</span>[][] pacific = n，ew <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="keyword">boolean</span>[][] atlantic = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="keyword">boolean</span>[][] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="comment">//处理pacific</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cols;i++)&#123;</div><div class="line">            <span class="comment">//pacific[0][i] = true;</span></div><div class="line">            dfs(matrix,<span class="number">0</span>,i,pacific,used);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">            <span class="comment">//pacific[i][0] = true;</span></div><div class="line">            dfs(matrix,i,<span class="number">0</span>,pacific,used);</div><div class="line">        &#125;</div><div class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="comment">//处理atlantic</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cols;i++)&#123;</div><div class="line">            <span class="comment">//pacific[rows-1][i] = true;</span></div><div class="line">            dfs(matrix,rows-<span class="number">1</span>,i,atlantic,used);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">            <span class="comment">//pacific[i][cols-1] = true;</span></div><div class="line">            dfs(matrix,i,cols-<span class="number">1</span>,atlantic,used);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//两个都是true的位置</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j])&#123;</div><div class="line">                    results.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Minesweeper"><a href="#Minesweeper" class="headerlink" title="Minesweeper"></a><a href="https://leetcode.com/problems/minesweeper/" target="_blank" rel="external">Minesweeper</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p>给定棋盘和点击的点，返回点击之后的棋盘</p>
<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>分两种情况讨论，如果点到的地雷，就显示地雷即可；</p>
<p>如果没有点到地雷，则要从这个点开始dfs计算其周围的每个点周围的8个点处有多少个地雷，如果没有就改成B，如果有的话显示数字。对于显示数字的点就无需继续dfs其周围的点了。</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minesweeper</span> </span>&#123;</div><div class="line">    <span class="comment">//计算某个位置周围有多少个地雷</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calSweeper</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = board.length;</div><div class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>;ii++)&#123;</div><div class="line">            <span class="keyword">if</span>(i+x_delta[ii] &lt; <span class="number">0</span> || j+y_delta[ii] &lt; <span class="number">0</span> || i+x_delta[ii] &gt;= rows || j+y_delta[ii] &gt;= cols)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(board[i+x_delta[ii]][j+y_delta[ii]] == <span class="string">'M'</span>)&#123;</div><div class="line">                sum ++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = board.length;</div><div class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</div><div class="line">        <span class="comment">//如果出界了，返回</span></div><div class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= rows || j &gt;= cols || board[i][j] == <span class="string">'B'</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">'E'</span>)&#123;</div><div class="line">            <span class="keyword">int</span> sum = calSweeper(board,i,j);</div><div class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">                board[i][j] = <span class="string">'B'</span>;</div><div class="line">                <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">                <span class="keyword">int</span>[] y_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>;ii++)&#123;</div><div class="line">                    <span class="comment">//如果还没点过，计算它周围有多少个地雷</span></div><div class="line">                    dfs(board,i+x_delta[ii],j+y_delta[ii]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                board[i][j] = Integer.toString(sum).charAt(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</div><div class="line">        <span class="comment">//如果点到地雷</span></div><div class="line">        <span class="keyword">if</span>(board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] == <span class="string">'M'</span>)&#123;</div><div class="line">            board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">'X'</span>;</div><div class="line">            <span class="keyword">return</span> board;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//没点到地雷</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            dfs(board,click[<span class="number">0</span>],click[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> board;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Minesweeper test = <span class="keyword">new</span> Minesweeper();</div><div class="line">        <span class="keyword">char</span>[][] board = &#123;&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'M'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;&#125;;</div><div class="line">        <span class="keyword">char</span>[][] result = test.updateBoard(board,<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">0</span>&#125;);</div><div class="line">        System.out.print(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Minimum-Height-Trees"><a href="#Minimum-Height-Trees" class="headerlink" title="Minimum Height Trees"></a><a href="https://leetcode.com/problems/minimum-height-trees/" target="_blank" rel="external">Minimum Height Trees</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p>
<p><strong>Format</strong><br>The graph contains <code>n</code> nodes which are labeled from <code>0</code> to <code>n - 1</code>. You will be given the number <code>n</code> and a list of undirected <code>edges</code> (each edge is a pair of labels).</p>
<p>You can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.</p>
<p><strong>Example 1:</strong></p>
<p>Given <code>n = 4</code>, <code>edges = [[1, 0], [1, 2], [1, 3]]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;         0</div><div class="line">&gt;         |</div><div class="line">&gt;         1</div><div class="line">&gt;        / \</div><div class="line">&gt;       2   3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return <code>[1]</code></p>
<p><strong>Example 2:</strong></p>
<p>Given <code>n = 6</code>, <code>edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      0  1  2</div><div class="line">&gt;       \ | /</div><div class="line">&gt;         3</div><div class="line">&gt;         |</div><div class="line">&gt;         4</div><div class="line">&gt;         |</div><div class="line">&gt;         5</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return <code>[3, 4]</code></p>
</blockquote>
<p>选取图中某一点作为root，使得形成的树高度最小，返回所有高度最小的root点。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>用BFS计算了每一个点作为root的深度，超时了。。。。</p>
<p>逐层去掉叶子节点，留下的就是作为root树高最小的节点。思路不难，但还是写了好久</p>
<p>步骤：</p>
<ol>
<li>存储图中节点的度数和点边关系</li>
<li>把度数为1的节点加入叶子节点集合</li>
<li>遍历叶子节点，将与之相连的节点的度数-1，然后将叶子节点删除，同时，如果有节点的度数为1，说明是下一层的叶子节点，加入新叶子集合</li>
<li>当新叶子集合的大小&lt;=2时，说明找到了最终的MHT的root</li>
</ol>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</div><div class="line">        <span class="comment">//边界条件处理</span></div><div class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</div><div class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            res.add(<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</div><div class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            res.add(<span class="number">0</span>);</div><div class="line">            res.add(<span class="number">1</span>);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//存储点边关系</span></div><div class="line">        List&lt;HashSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</div><div class="line">            map.add(<span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">      </div><div class="line">        <span class="keyword">int</span>[] edgesNum = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//存储节点的度数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;edges.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> node1 = edges[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> node2 = edges[i][<span class="number">1</span>];</div><div class="line">            edgesNum[node1]++;</div><div class="line">            edgesNum[node2]++;</div><div class="line">            map.get(node1).add(node2);</div><div class="line">            map.get(node2).add(node1);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> counter = n;</div><div class="line">      <span class="comment">//叶子节点加入结合</span></div><div class="line">        List&lt;Integer&gt; leaves = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(edgesNum[i] == <span class="number">1</span>)&#123;</div><div class="line">                leaves.add(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//遍历叶子节点，将与之相连的点的度数-1，删去叶子节点</span></div><div class="line">        <span class="keyword">while</span> (counter &gt; <span class="number">2</span>)&#123;</div><div class="line">            counter -= leaves.size();</div><div class="line">            List&lt;Integer&gt; newLeaves = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存储下一轮的新叶子节点</span></div><div class="line">            <span class="keyword">for</span>(Integer leave : leaves)&#123;</div><div class="line">                edgesNum[leave]--;</div><div class="line">                <span class="keyword">for</span>(Integer node : map.get(leave))&#123;</div><div class="line">                    edgesNum[node]--;</div><div class="line">                    <span class="keyword">if</span>(edgesNum[node] == <span class="number">1</span>)&#123;<span class="comment">//遇到度数为1的节点就是下一轮的叶子节点</span></div><div class="line">                        newLeaves.add(node);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            leaves = newLeaves;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> leaves;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="The-Maze"><a href="#The-Maze" class="headerlink" title="The Maze"></a><a href="https://leetcode.com/problems/the-maze/" target="_blank" rel="external">The Maze</a></h3><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><blockquote>
<p>There is a <strong>ball</strong> in a maze with empty spaces and walls. The ball can go through empty spaces by rolling <strong>up</strong>, <strong>down</strong>, <strong>left</strong> or <strong>right</strong>, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.</p>
<p>Given the ball’s <strong>start position</strong>, the <strong>destination</strong> and the <strong>maze</strong>, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of <strong>empty spaces</strong> traveled by the ball from the start position (excluded) to the destination (included). If the ball cannot stop at the destination, return -1.</p>
<p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.</p>
<p><strong>Example 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input 1: a maze represented by a 2D array</div><div class="line">&gt;</div><div class="line">&gt; 0 0 1 0 0</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt; 0 0 0 1 0</div><div class="line">&gt; 1 1 0 1 1</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt;</div><div class="line">&gt; Input 2: start coordinate (rowStart, colStart) = (0, 4)</div><div class="line">&gt; Input 3: destination coordinate (rowDest, colDest) = (4, 4)</div><div class="line">&gt;</div><div class="line">&gt; Output: 12</div><div class="line">&gt; Explanation: One shortest way is : left -&gt; down -&gt; left -&gt; down -&gt; right -&gt; down -&gt; right.</div><div class="line">&gt;              The total distance is 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.</div><div class="line">&gt;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input 1: a maze represented by a 2D array</div><div class="line">&gt;</div><div class="line">&gt; 0 0 1 0 0</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt; 0 0 0 1 0</div><div class="line">&gt; 1 1 0 1 1</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt;</div><div class="line">&gt; Input 2: start coordinate (rowStart, colStart) = (0, 4)</div><div class="line">&gt; Input 3: destination coordinate (rowDest, colDest) = (3, 2)</div><div class="line">&gt;</div><div class="line">&gt; Output: -1</div><div class="line">&gt; Explanation: There is no way for the ball to stop at the destination.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>矩阵中1是障碍，0是通的，小球从start滚到destination，不遇到障碍或者边界小球不会停下来，返回小球是否可以从start滚到end</p>
<h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>BFS，小球从起点开始可以向上下左右四个方向滚，每次滚到障碍或者边界处，滚到终点就返回true</p>
<p>另外需要一个数组记录小球是否到过该节点，如果到过，后续就无需再走这里了。</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = maze.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = maze[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[maze.length][maze[<span class="number">0</span>].length];</div><div class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//上下左右</span></div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        queue.add(start);</div><div class="line">        visited[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span>[] node = queue.poll();</div><div class="line">            <span class="keyword">if</span>(node[<span class="number">0</span>] == destination[<span class="number">0</span>] &amp;&amp; node[<span class="number">1</span>] == destination[<span class="number">1</span>])&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span> ; ii &lt; <span class="number">4</span>;ii++)&#123;</div><div class="line">                <span class="keyword">int</span> newStartX = node[<span class="number">0</span>] + x_delta[ii];</div><div class="line">                <span class="keyword">int</span> newStartY = node[<span class="number">1</span>] + y_delta[ii];</div><div class="line">                <span class="comment">//走的通的方向，一直走到尽头</span></div><div class="line">                <span class="keyword">while</span>(newStartX &gt;= <span class="number">0</span> &amp;&amp; newStartY &gt;= <span class="number">0</span> &amp;&amp; newStartX &lt; rows &amp;&amp; newStartY &lt; cols &amp;&amp; maze[newStartX][newStartY] == <span class="number">0</span>)&#123;</div><div class="line">                    newStartX += x_delta[ii];</div><div class="line">                    newStartY += y_delta[ii];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(!visited[newStartX-x_delta[ii]][newStartY-y_delta[ii]])&#123;</div><div class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newStartX - x_delta[ii],newStartY - y_delta[ii]&#125;);</div><div class="line">                    visited[newStartX-x_delta[ii]][newStartY-y_delta[ii]] = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="The-Maze-II"><a href="#The-Maze-II" class="headerlink" title="The Maze II"></a><a href="https://leetcode.com/problems/the-maze-ii" target="_blank" rel="external">The Maze II</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><p>跟上一题一样，这个题要求返回从起点滚到终点的最短路径长度。如果滚不到就返回-1</p>
<h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>用一个二维数组记录地图中的点到start的距离。BFS更新计算start到能够到达的点的最小距离，最后返回二维数组中的终点的值。</p>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = maze.length;</div><div class="line">        <span class="keyword">int</span> cols = maze[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[maze.length][maze[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;distance.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; distance[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                distance[i][j] = Integer.MAX_VALUE;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//上下左右</span></div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        queue.add(start);</div><div class="line">        distance[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span>[] node = queue.poll();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">4</span>; ii++) &#123;</div><div class="line">                <span class="keyword">int</span> newStartX = node[<span class="number">0</span>] + x_delta[ii];</div><div class="line">                <span class="keyword">int</span> newStartY = node[<span class="number">1</span>] + y_delta[ii];</div><div class="line">                <span class="comment">//走的通的方向，一直走到尽头</span></div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录走了多少步</span></div><div class="line">                <span class="keyword">while</span> (newStartX &gt;= <span class="number">0</span> &amp;&amp; newStartY &gt;= <span class="number">0</span> &amp;&amp; newStartX &lt; rows &amp;&amp; newStartY &lt; cols &amp;&amp; maze[newStartX][newStartY] == <span class="number">0</span>) &#123;</div><div class="line">                    newStartX += x_delta[ii];</div><div class="line">                    newStartY += y_delta[ii];</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">              <span class="comment">//如果这条路径到达该点比之前的距离短，更新该点的最短距离</span></div><div class="line">                <span class="keyword">if</span> (distance[node[<span class="number">0</span>]][node[<span class="number">1</span>]] + count &lt; distance[newStartX - x_delta[ii]][newStartY - y_delta[ii]]) &#123;</div><div class="line">                    distance[newStartX - x_delta[ii]][newStartY - y_delta[ii]] = distance[node[<span class="number">0</span>]][node[<span class="number">1</span>]] + count;</div><div class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newStartX - x_delta[ii], newStartY - y_delta[ii]&#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> distance[destination[<span class="number">0</span>]][destination[<span class="number">1</span>]] &lt; Integer.MAX_VALUE ? distance[destination[<span class="number">0</span>]][destination[<span class="number">1</span>]] : -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】BFS问题]]></title>
      <url>/2018/01/20/%E3%80%90leetcode%E3%80%91BFS%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="Perfect-Squares"><a href="#Perfect-Squares" class="headerlink" title="Perfect Squares"></a><a href="https://leetcode.com/problems/perfect-squares" target="_blank" rel="external">Perfect Squares</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p>
<p>For example, given <em>n</em> = <code>12</code>, return <code>3</code> because <code>12 = 4 + 4 + 4</code>; given <em>n</em> = <code>13</code>, return <code>2</code> because <code>13 = 4 + 9</code>.</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>典型的BFS题目</p>
<p>方法：</p>
<p>需要一个队列记录当前剩余的和。</p>
<p>首先将n加入队列，然后n出队列，计算小于他的最大平方数，然后递减计算剩余的数字差，如如队列，层数+1</p>
<p>当队列中有某一层出现剩余的和为0的时候说明找到了一条合法相加形式，此时就是所需的最少数组组合，返回此时的depth即可。</p>
<p>优化：DP</p>
<p>dp[n]：记录n可以由几个平方数加和得到</p>
<p>递推公式：dp[n] = min(dp[n-1]+1,dp[n-4]+1,dp[n-9]+1,……)</p>
<p>初始化：</p>
<p>​    dp[0] = 0;</p>
<p>​    dp[1] = 1;</p>
<p>返回值：dp[n]</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue.add(n);</div><div class="line">  <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    depth++;</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">int</span> temp = queue.poll();</div><div class="line">      <span class="comment">//计算小于等于n的最大的平方数</span></div><div class="line">      <span class="keyword">int</span> maxSquare = (<span class="keyword">int</span>) Math.sqrt(temp);</div><div class="line">      <span class="keyword">while</span>(maxSquare &gt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">int</span> sumLeft = temp - maxSquare*maxSquare;</div><div class="line">        <span class="keyword">if</span>(sumLeft == <span class="number">0</span>)&#123;<span class="comment">//和等于0了</span></div><div class="line">          <span class="keyword">return</span> depth;</div><div class="line">        &#125;</div><div class="line">        queue.add(sumLeft);</div><div class="line">        maxSquare--;</div><div class="line">      &#125;</div><div class="line">      size--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//动态规划</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n;i++)&#123;</div><div class="line">    <span class="keyword">int</span> dpMinTemp = dp[i-<span class="number">1</span>] +<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j*j &lt;= i;j++)&#123;</div><div class="line">      dpMinTemp = Math.min(dpMinTemp,dp[i - j*j] +<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    dp[i] = dpMinTemp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dp[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】DFS问题]]></title>
      <url>/2018/01/20/%E3%80%90leetcode%E3%80%91DFS%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="二叉树的深度优先遍历"><a href="#二叉树的深度优先遍历" class="headerlink" title="二叉树的深度优先遍历"></a>二叉树的深度优先遍历</h2><p>DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</p>
<p>当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。</p>
<p>如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-20-21-52-42.png" alt=""> </p>
<p>如上图的例子，DFS访问数组为：ABDECFG。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>分析一下，在遍历了根结点后，就开始遍历左子树，最后才是右子树。</p>
<p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，</p>
<p>这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>思路比较简单，就是从root开始，先将root值加入结果集，然后先对其做左节点递归调用做DFS，然后是对右节点DFS。当遇到空节点时，返回上层。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDFS</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line"></div><div class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSRecurtionHelper</span><span class="params">(TreeNode root,List&lt;Integer&gt; results)</span></span>&#123;</div><div class="line">        <span class="comment">//遇到空节点，返回</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//root放入results,递归处理左右节点</span></div><div class="line">        results.add(root.val);</div><div class="line">        DFSRecurtion(root.left);</div><div class="line">        DFSRecurtion(root.right);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSRecurtion</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        DFSRecurtionHelper(root,results);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="非递归（栈）"><a href="#非递归（栈）" class="headerlink" title="非递归（栈）"></a>非递归（栈）</h4><p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSwithStack</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    stack.push(root);</div><div class="line">    <span class="keyword">while</span> (!stack.empty())&#123;</div><div class="line">        TreeNode temp = stack.pop();</div><div class="line">        results.add(temp.val);</div><div class="line">        <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.left);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="leetcode-相关习题"><a href="#leetcode-相关习题" class="headerlink" title="leetcode 相关习题"></a>leetcode 相关习题</h2><h3 id="Populating-Next-Right-Pointers-in-Each-Node"><a href="#Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="Populating Next Right Pointers in Each Node"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="external">Populating Next Right Pointers in Each Node</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     struct TreeLinkNode &#123;</div><div class="line">&gt;       TreeLinkNode *left;</div><div class="line">&gt;       TreeLinkNode *right;</div><div class="line">&gt;       TreeLinkNode *next;</div><div class="line">&gt;     &#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p><strong>Note:</strong></p>
<ul>
<li>You may only use constant extra space.</li>
<li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li>
</ul>
<p>For example,<br>Given the following perfect binary tree,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;          1</div><div class="line">&gt;        /  \</div><div class="line">&gt;       2    3</div><div class="line">&gt;      / \  / \</div><div class="line">&gt;     4  5  6  7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>After calling your function, the tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;          1 -&gt; NULL</div><div class="line">&gt;        /  \</div><div class="line">&gt;       2 -&gt; 3 -&gt; NULL</div><div class="line">&gt;      / \  / \</div><div class="line">&gt;     4-&gt;5-&gt;6-&gt;7 -&gt; NULL</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>就是将同一层上的节点的next指向右边的节点</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>tag是DFS，但我一开始想到的是BFS。</p>
<ol>
<li>BFS：</li>
</ol>
<p>将每一层节点加入队列，出队列时，左边节点的next指向右边节点。</p>
<p>但DFS会更快一些</p>
<ol>
<li>DFS：</li>
</ol>
<p>用DFS的核心思想是对于一个节点来说，将其左孩子的next指向右孩子，其右孩子的next指向其本身next节点的左孩子。</p>
<p>题目要求不能引入额外的空间，所以更应该用dfs的</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PopulatingNextRightPointersinEachNode</span> </span>&#123;</div><div class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</div><div class="line">         <span class="keyword">int</span> val;</div><div class="line">         TreeLinkNode left, right, next;</div><div class="line">         TreeLinkNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</div><div class="line">     &#125;</div><div class="line">	<span class="comment">//BFS</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</div><div class="line">         <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">        Queue&lt;TreeLinkNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(root);</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> len = queue.size();</div><div class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="comment">//如果是本层最后一个了，其next指向NULL</span></div><div class="line">                TreeLinkNode temp = queue.poll();</div><div class="line">                <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</div><div class="line">                    temp.next = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果不是本层最后一个，其next指向下一个节点</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    temp.next = queue.peek();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">                    queue.add(temp.left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">                    queue.add(temp.right);</div><div class="line">                &#125;</div><div class="line">                len--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//DFS</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfshelper</span><span class="params">(TreeLinkNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)&#123;</div><div class="line">            root.left.next = root.right;</div><div class="line">            <span class="keyword">if</span>(root.next !=<span class="keyword">null</span>)&#123;</div><div class="line">                root.right.next = root.next.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                root.right.next = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            dfshelper(root.left);</div><div class="line">            dfshelper(root.right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//DFS</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectDFS</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">         root.next = <span class="keyword">null</span>;</div><div class="line">         dfshelper(root);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Path-Sum"><a href="#Path-Sum" class="headerlink" title="Path Sum"></a><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="external">Path Sum</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:</p>
<p>Given the below binary tree and </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; sum = 22</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;               5</div><div class="line">&gt;              / \</div><div class="line">&gt;             4   8</div><div class="line">&gt;            /   / \</div><div class="line">&gt;           11  13  4</div><div class="line">&gt;          /  \      \</div><div class="line">&gt;         7    2      1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
</blockquote>
<p>给定二叉树和一个整数sum,返回二叉树中是否存在一条从root到叶子的路径，长度为sum</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>DFS，分别对节点的左右孩子做DFS，sum需减掉当前节点的值。</p>
<p>当遇到叶子节点，且该点的值==sum时，即找到了一条合法路径，返回true</p>
<p>这里需要注意的是测试样例中有负数的情况，所以不能根据剩余的sum值进行剪枝。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfshelper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">  <span class="comment">//sum == root且root是叶子节点</span></div><div class="line">  <span class="keyword">if</span>(sum == root.val &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span>(dfshelper(root.left, sum - root.val))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="keyword">if</span>(dfshelper(root.right, sum - root.val))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dfshelper(root,sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Path-Sum-II"><a href="#Path-Sum-II" class="headerlink" title="Path Sum II"></a><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="external">Path Sum II</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>For example:</p>
<p>Given the below binary tree and </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; sum = 22</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;               5</div><div class="line">&gt;              / \</div><div class="line">&gt;             4   8</div><div class="line">&gt;            /   / \</div><div class="line">&gt;           11  13  4</div><div class="line">&gt;          /  \    / \</div><div class="line">&gt;         7    2  5   1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;    [5,4,11,2],</div><div class="line">&gt;    [5,8,4,5]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>跟上一题一样的，这次要把合法路径全都记录下来返回。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left, right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root.val == sum &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">            result.add(root.val);</div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            result.add(root.val);</div><div class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</div><div class="line">                helper(root.left,sum - root.val);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</div><div class="line">                helper(root.right,sum - root.val);</div><div class="line">            &#125;</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;</div><div class="line">        helper(root,sum);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Path-Sum-III"><a href="#Path-Sum-III" class="headerlink" title="Path Sum III"></a><a href="https://leetcode.com/problems/path-sum-iii" target="_blank" rel="external">Path Sum III</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>You are given a binary tree in which each node contains an integer value.</p>
<p>Find the number of paths that sum to a given value.</p>
<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>
<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</div><div class="line">&gt;</div><div class="line">&gt;       10</div><div class="line">&gt;      /  \</div><div class="line">&gt;     5   -3</div><div class="line">&gt;    / \    \</div><div class="line">&gt;   3   2   11</div><div class="line">&gt;  / \   \</div><div class="line">&gt; 3  -2   1</div><div class="line">&gt;</div><div class="line">&gt; Return 3. The paths that sum to 8 are:</div><div class="line">&gt;</div><div class="line">&gt; 1.  5 -&gt; 3</div><div class="line">&gt; 2.  5 -&gt; 2 -&gt; 1</div><div class="line">&gt; 3. -3 -&gt; 11</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>跟前面两道的不同是：起止点不一定是root和leaf可以是树中的任意两点</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>方法一：双层递归</p>
<p>对树中的每一个节点都进行搜索，从该点开始是否有合法路径。</p>
<p>可以转化为，对根节点搜索sum合法路径，然后对根节点的左右节点分别搜索sum合法路径，其中对其左右节点搜索合法路径时，也需要对其自身和其左右节点分别搜索，这是外层递归</p>
<p>搜索路径长度本身又是一层递归，每次减掉当前节点val，这是第二层递归</p>
<p>方法二：前缀长度</p>
<p>计算从root到每一个节点的路径长度，存储在一个hashmap中，key为root到树种节点的路径长度，value为出现次数。</p>
<p>当计算到某一个节点时，从root到该节点的路径长度为len，则以该节点为结尾的合法路径的个数为map中key为sum-len的value值。</p>
<p>注意：每次回退时需要将root到这点的路径长度在hashmap中的value-1。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><p>方法一：双层递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumIII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left, right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果到当前点已经是合法路径了，res+1</span></div><div class="line">        <span class="keyword">if</span>(root.val == sum)&#123;</div><div class="line">            res++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//接续沿着左右节点寻找是否还有合法路径</span></div><div class="line">        res += helper(root.left,sum - root.val);</div><div class="line">        res += helper(root.right,sum - root.val);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//从当前节点开始和为sum 和从左、右节点开始和为sum</span></div><div class="line">        <span class="keyword">return</span> helper(root,sum) + pathSum(root.left,sum) + pathSum(root.right,sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：前缀搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumIII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left, right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum,<span class="keyword">int</span> fromR)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> temp = fromR + root.val;</div><div class="line">        res += map.getOrDefault(temp - sum,<span class="number">0</span>);</div><div class="line">        map.put(temp,map.getOrDefault(temp,<span class="number">0</span>)+<span class="number">1</span>);</div><div class="line">        res = res + helper(root.left,sum,temp)+helper(root.right,sum,temp);</div><div class="line">        map.put(temp,map.get(temp)-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">        <span class="comment">//从当前节点开始和为sum 和从左、右节点开始和为sum</span></div><div class="line">        <span class="keyword">return</span> helper(root,sum,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Path-Sum-IV"><a href="#Path-Sum-IV" class="headerlink" title="Path Sum IV"></a><a href="https://leetcode.com/problems/path-sum-iv" target="_blank" rel="external">Path Sum IV</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>If the depth of a tree is smaller than <code>5</code>, then this tree can be represented by a list of three-digits integers.</p>
<p>For each integer in this list:</p>
<ol>
<li>The hundreds digit represents the depth <code>D</code> of this node, <code>1 &lt;= D &lt;= 4.</code></li>
<li>The tens digit represents the position <code>P</code> of this node in the level it belongs to, <code>1 &lt;= P &lt;= 8</code>. The position is the same as that in a full binary tree.</li>
<li>The units digit represents the value <code>V</code> of this node, <code>0 &lt;= V &lt;= 9.</code></li>
</ol>
<p>Given a list of <code>ascending</code> three-digits integers representing a binary with the depth smaller than 5. You need to return the sum of all paths from the root towards the leaves.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [113, 215, 221]</div><div class="line">&gt; Output: 12</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The tree that the list represents is:</div><div class="line">&gt;     3</div><div class="line">&gt;    / \</div><div class="line">&gt;   5   1</div><div class="line">&gt;</div><div class="line">&gt; The path sum is (3 + 5) + (3 + 1) = 12.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [113, 221]</div><div class="line">&gt; Output: 4</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The tree that the list represents is: </div><div class="line">&gt;     3</div><div class="line">&gt;      \</div><div class="line">&gt;       1</div><div class="line">&gt;</div><div class="line">&gt; The path sum is (3 + 1) = 4.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>以数组的形式给定一棵二叉树，用三位数表示节点，其中百位代表层数，十位代表在某一层中从左到右的位置，各位代表节点数值，计算从root到每一个leaf的路径长度之和。</p>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>假设一个几点的百位和十位是xy，则其左孩子和右孩子分别是：</p>
<p>left：(x+1)(2y-1)</p>
<p>right：(x+1)(2y)</p>
<p>可以根据这个性质，将数组中的节点放入hashmap中，key为百位十位，value为节点值。然后在map中寻找左右节点进行DFS，当遍历到叶子节点时，将本条路径长度加入路径长度总和。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> sum;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(HashMap&lt;Integer,Integer&gt; map,<span class="keyword">int</span> root,<span class="keyword">int</span> res)</span></span>&#123;</div><div class="line">  res += map.get(root);</div><div class="line">  <span class="keyword">int</span> left = (root/<span class="number">10</span>+<span class="number">1</span>) * <span class="number">10</span> + (root%<span class="number">10</span>)*<span class="number">2</span>-<span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> right = (root/<span class="number">10</span>+<span class="number">1</span>) * <span class="number">10</span> + (root%<span class="number">10</span>)*<span class="number">2</span>;</div><div class="line">  <span class="comment">//如果左右都没有了路径了，是叶子节点</span></div><div class="line">  <span class="keyword">if</span>(!map.containsKey(left) &amp;&amp; !map.containsKey(right))&#123;</div><div class="line">    sum += res;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果左边有路径</span></div><div class="line">  <span class="keyword">if</span>(map.containsKey(left))&#123;</div><div class="line">    dfs(map,left,res);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果右边有路径</span></div><div class="line">  <span class="keyword">if</span>(map.containsKey(right))&#123;</div><div class="line">    dfs(map,right,res);</div><div class="line">  &#125;</div><div class="line">  res -= map.get(root);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;nums.length;i++)&#123;</div><div class="line">    map.put(nums[i]/<span class="number">10</span>,nums[i] % <span class="number">10</span>);</div><div class="line">  &#125;</div><div class="line">  dfs(map,<span class="number">11</span>,<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Flatten-Binary-Tree-to-Linked-List"><a href="#Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Flatten Binary Tree to Linked List"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="external">Flatten Binary Tree to Linked List</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;          1</div><div class="line">&gt;         / \</div><div class="line">&gt;        2   5</div><div class="line">&gt;       / \   \</div><div class="line">&gt;      3   4   6</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The flattened tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1</div><div class="line">&gt;     \</div><div class="line">&gt;      2</div><div class="line">&gt;       \</div><div class="line">&gt;        3</div><div class="line">&gt;         \</div><div class="line">&gt;          4</div><div class="line">&gt;           \</div><div class="line">&gt;            5</div><div class="line">&gt;             \</div><div class="line">&gt;              6</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>将二叉树压到一条右子树上</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题实际上是要将每个节点左子树的前序遍历插入到右子树前面。</p>
<p>所以我的思路是如果遇到节点root有右子树，就先把右子树存下来，然后dfs处理左子树，当左子树处理完之后，再将右子树插入到左子树。</p>
<p>DSF的时候，把原来的左子树放到节点的右边，然后节点向下移动，递归处理左子树。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlattenBinaryTreetoLinkedList</span> </span>&#123;</div><div class="line">    TreeNode temp;<span class="comment">//记录当前节点</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果右节点不空，先把右边节点存下来</span></div><div class="line">        TreeNode right = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) &#123;</div><div class="line">            right = <span class="keyword">new</span> TreeNode(root.right.val);</div><div class="line">            right.left = root.right.left;</div><div class="line">            right.right = root.right.right;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果左子树非空，将左子树挪到右边，左子树置为空，temp下移，继续dfs temp的左子树</span></div><div class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">            temp.right = temp.left;</div><div class="line">            temp.left = <span class="keyword">null</span>;</div><div class="line">            temp = temp.right;</div><div class="line">            dfs(temp);</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//如果右节点非空，将之前记录下来的右子树放到temp右边，然后temp下移，继续dfs</span></div><div class="line">        <span class="keyword">if</span>(right != <span class="keyword">null</span>)&#123;</div><div class="line">            temp.right = right;</div><div class="line">            temp = temp.right;</div><div class="line">            dfs(temp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        temp = root;</div><div class="line">        dfs(root);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="House-Robber-III"><a href="#House-Robber-III" class="headerlink" title="House Robber III"></a><a href="https://leetcode.com/problems/house-robber-iii/" target="_blank" rel="external">House Robber III</a></h3><h4 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h4><p>递归调用，相当于暴力遍历所有情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="comment">//如果选择root，则需避开其左右孩子</span></div><div class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;<span class="comment">//选择左边孩子的左右孩子</span></div><div class="line">        sum += rob(root.left.left) + rob(root.left.right);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;<span class="comment">//选择右边孩子的左右孩子</span></div><div class="line">        sum += rob(root.right.left) + rob (root.right.right);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//选当前节点和不选当前节点的最大值</span></div><div class="line">    <span class="keyword">return</span> Math.max(root.val + sum,rob(root.left) + rob(root.right));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h4><p>用hashmap将计算过的每一个节点的max值存储下来，后面再用到直接返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobberIII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    HashMap&lt;TreeNode,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果已经计算过了</span></div><div class="line">        <span class="keyword">if</span>(map.containsKey(root))&#123;</div><div class="line">            <span class="keyword">return</span> map.get(root);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="comment">//如果选择root，则需避开其左右孩子</span></div><div class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;<span class="comment">//选择左边孩子的左右孩子</span></div><div class="line">            sum += rob(root.left.left) + rob(root.left.right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;<span class="comment">//选择右边孩子的左右孩子</span></div><div class="line">            sum += rob(root.right.left) + rob (root.right.right);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//选当前节点和不选当前节点的最大值</span></div><div class="line">        <span class="keyword">int</span> maxval =  Math.max(root.val + sum,rob(root.left) + rob(root.right));</div><div class="line">        map.put(root,maxval);</div><div class="line">        <span class="keyword">return</span> maxval;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>递归函数返回一个大小为2的一维数组res，其中res[0]表示不包含当前节点值的最大值，res[1]表示包含当前值的最大值，那么我们在遍历某个节点时，首先对其左右子节点调用递归函数，分别得到包含与不包含左子节点值的最大值，和包含于不包含右子节点值的最大值，那么当前节点的res[0]就是左子节点两种情况的较大值加上右子节点两种情况的较大值，res[1]就是不包含左子节点值的最大值加上不包含右子节点值的最大值，和当前节点值之和，返回即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] solve(TreeNode root)&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;<span class="comment">//如果是空节点</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[] left = solve(root.left);<span class="comment">//左孩子的res</span></div><div class="line">    <span class="keyword">int</span>[] right = solve(root.right);<span class="comment">//右孩子的res</span></div><div class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">    <span class="comment">//不包含root的情况：左孩子包括和不包括的最大值+右孩子同理</span></div><div class="line">    res[<span class="number">0</span>] = Math.max(left[<span class="number">0</span>],left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>],right[<span class="number">1</span>]);</div><div class="line">    <span class="comment">//包含root的情况：不包括左孩子和右孩子，需要加上自身value</span></div><div class="line">    res[<span class="number">1</span>] = left[<span class="number">0</span>] + right[<span class="number">0</span>] + root.val;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] res = solve(root);</div><div class="line">    <span class="keyword">return</span> Math.max(res[<span class="number">0</span>],res[<span class="number">1</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[回文问题]]></title>
      <url>/2018/01/19/%E5%9B%9E%E6%96%87%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="最长回文子串-Longest-Palindromic-Substring"><a href="#最长回文子串-Longest-Palindromic-Substring" class="headerlink" title="最长回文子串 Longest Palindromic Substring"></a>最长回文子串 <a href="https://leetcode.com/problems/longest-palindromic-substring" target="_blank" rel="external">Longest Palindromic Substring</a></h3>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法基础班】数据结构]]></title>
      <url>/2018/01/19/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h1><ul>
<li>线性数据结构<ul>
<li>Queue</li>
<li>Stack</li>
<li>HashTable</li>
</ul>
</li>
<li>树形数据结构<ul>
<li>Heap/Priority Queue</li>
<li>TreeMap</li>
</ul>
</li>
</ul>
<h1 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h1><ul>
<li>支持操作：Push/Pop/Top，时间复杂度都是<script type="math/tex">O(1)</script></li>
<li>考点：宽度优先搜索BFS</li>
<li>多做做BFS就可以了</li>
</ul>
<h1 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h1><ul>
<li>支持操作：Push/Pop/Top，时间复杂度都是<script type="math/tex">O(1)</script></li>
<li>考点：非递归实现DFS</li>
</ul>
<h3 id="例题Min-Stack"><a href="#例题Min-Stack" class="headerlink" title="例题Min Stack"></a>例题<a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="external">Min Stack</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) — Push element x onto stack.</li>
<li>pop() — Removes the element on top of the stack.</li>
<li>top() — Get the top element.</li>
<li>getMin() — Retrieve the minimum element in the stack.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; MinStack minStack = new MinStack();</div><div class="line">&gt; minStack.push(-2);</div><div class="line">&gt; minStack.push(0);</div><div class="line">&gt; minStack.push(-3);</div><div class="line">&gt; minStack.getMin();   --&gt; Returns -3.</div><div class="line">&gt; minStack.pop();</div><div class="line">&gt; minStack.top();      --&gt; Returns 0.</div><div class="line">&gt; minStack.getMin();   --&gt; Returns -2.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>要求实现一个stack能够在0(1)时间内实现push(x),pop(),top(),getMin()获取最小值</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>额外维护一个stack，存储最小值</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.Queue;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; queue;</div><div class="line">    Stack&lt;Integer&gt; minqueue;</div><div class="line">    <span class="comment">//int min = Integer.MAX_VALUE;</span></div><div class="line"></div><div class="line">    <span class="comment">/** initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        minqueue = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        queue.add(x);</div><div class="line">        <span class="keyword">int</span> min;</div><div class="line">        <span class="keyword">if</span>(minqueue.isEmpty())&#123;</div><div class="line">            min = x;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (x &lt; minqueue.peek()) &#123;</div><div class="line">                min = x;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> min = minqueue.peek();</div><div class="line">        &#125;</div><div class="line">        minqueue.add(min);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue.pop();</div><div class="line">        minqueue.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> minqueue.peek();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Implement-Queue-using-Stacks"><a href="#Implement-Queue-using-Stacks" class="headerlink" title="Implement Queue using Stacks"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank" rel="external">Implement Queue using Stacks</a></h3><blockquote>
<p>Implement the following operations of a queue using stacks.</p>
<ul>
<li>push(x) — Push element x to the back of queue.</li>
<li>pop() — Removes the element from in front of queue.</li>
<li>peek() — Get the front element.</li>
<li>empty() — Return whether the queue is empty.</li>
</ul>
</blockquote>
<p>用stack实现queue</p>
<p>stack：先进后出</p>
<p>queue：先进先出</p>
<p>需要两个stack实现一个queue。</p>
<p>push时先将元素压入stack1，然后当pop时，如果stack2非空，就从stack2中pop出一个，否则将stack1中元素全部加入stcak2之后再pop</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; stack1;</div><div class="line">    Stack&lt;Integer&gt; stack2;</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Push element x to the back of queue. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        stack1.push(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</div><div class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</div><div class="line">                stack2.push(stack1.pop());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack2.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Get the front element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</div><div class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</div><div class="line">                stack2.push(stack1.pop());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack2.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.isEmpty() &amp;&amp; stack1.isEmpty())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="external">Largest Rectangle in Histogram</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p><img src="https://leetcode.com/static/images/problemset/histogram.png" alt="img"></p>
<p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p>
<p><img src="https://leetcode.com/static/images/problemset/histogram_area.png" alt="img"></p>
<p>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p>
<p>For example,<br>Given heights = <code>[2,1,5,6,2,3]</code>,<br>return <code>10</code>.</p>
</blockquote>
<p>求直方图中的最大举行的面积。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>baseline：</p>
<p>两个指针i和j分别从前往后扫描，k在i和j之间扫描，找i和j中间最低的柱子Kmin，计算Kmin*(j-i)的最大值。时间复杂度<script type="math/tex">O(n^3)</script></p>
<p>优化：</p>
<p>K从左向右遍历，在每一位置，向左看，找到左边第一个比它小的位置i，向右看，找到右边第一个比他小的位置j，此时矩形面积为<script type="math/tex">K*(j-i-1)</script> ，找到最小的即可。时间复杂度<script type="math/tex">O(n^2)</script></p>
<p>Stack：</p>
<p>对于任意一个bar n，我们得到的包含该bar n的矩形区域里面bar n是最小的。我们使用ln和rn来表示bar n向左以及向右第一个小于bar n的bar的索引位置。</p>
<p>我们可以从左到右遍历所有bar，并将其push到一个stack中，如果当前bar的高度小于栈顶bar，我们pop出栈顶的bar，同时以该bar计算矩形面积。那么我们如何知道该bar的ln和rn呢？rn就是当前遍历到的bar的索引，而ln则是弹出当前元素之后的栈顶bar的索引，因为此时栈顶中的元素都是递增的。</p>
<p>为了更好的处理最后一个bar的情况，我们在实际中会插入一个高度为0的bar，这样就能pop出最后一个bar并计算了。</p>
<p>stack中存储的是下标！！！</p>
<p>时间复杂度<script type="math/tex">O(n)</script></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack.push(-<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; heights.length;i++)&#123;</div><div class="line">            <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span> &amp;&amp; heights[i] &lt; heights[stack.peek()])&#123;</div><div class="line">                <span class="keyword">int</span> size = heights[stack.pop()] * (i-stack.peek()-<span class="number">1</span>);</div><div class="line">                max = Math.max(max,size);</div><div class="line">            &#125;</div><div class="line">            stack.push(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">int</span> size = heights[stack.pop()] * (heights.length-stack.peek()-<span class="number">1</span>);</div><div class="line">            max = Math.max(max,size);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Maximal-Rectangle"><a href="#Maximal-Rectangle" class="headerlink" title="Maximal Rectangle"></a><a href="https://leetcode.com/problems/maximal-rectangle/" target="_blank" rel="external">Maximal Rectangle</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>
<p>For example, given the following matrix:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 0 1 0 0</div><div class="line">&gt; 1 0 1 1 1</div><div class="line">&gt; 1 1 1 1 1</div><div class="line">&gt; 1 0 0 1 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>题目给定一个01矩阵，要求求出矩阵中面积最大的全1矩阵。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><img src="https://upload-images.jianshu.io/upload_images/424375-2a5a361549e471e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>把每一行看作直方图的底，可以把这个题转化成上一道题，对每一行建立一个直方图，利用stack求直方图中的最大矩形，返回全局最大矩形的面积。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calMax</span><span class="params">(<span class="keyword">char</span>[][] matrix,<span class="keyword">int</span>[] heights)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack.push(-<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; heights.length;j++)&#123;</div><div class="line">            <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span> &amp;&amp; heights[j] &lt; heights[stack.peek()])&#123;</div><div class="line">                <span class="keyword">int</span> area = heights[stack.pop()] * (j - stack.peek()- <span class="number">1</span>);</div><div class="line">                max = Math.max(max,area);</div><div class="line">            &#125;</div><div class="line">            stack.push(j);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">int</span> area = heights[stack.pop()] * (heights.length - stack.peek()- <span class="number">1</span>);</div><div class="line">            max = Math.max(max,area);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;matrix.length;i++)&#123;</div><div class="line">            <span class="comment">//计算本行heights</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; matrix[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'0'</span>)&#123;</div><div class="line">                    heights[j] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    heights[j] += <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            maxArea = Math.max(maxArea,calMax(matrix,heights));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxArea;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Implement-Stack-using-Queues"><a href="#Implement-Stack-using-Queues" class="headerlink" title="Implement Stack using Queues"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="external">Implement Stack using Queues</a></h3><blockquote>
<p>Implement the following operations of a stack using queues.</p>
<ul>
<li>push(x) — Push element x onto stack.</li>
<li>pop() — Removes the element on top of the stack.</li>
<li>top() — Get the top element.</li>
<li>empty() — Return whether the stack is empty.</li>
</ul>
</blockquote>
<p>题目要求用队列实现栈。</p>
<p>方法一：</p>
<p>用两个queue实现，push时间复杂度<script type="math/tex">O(1)</script> , pop时间复杂度<script type="math/tex">O(n)</script></p>
<p>push的时候加入queue1:</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-45-34.png" alt=""> </p>
<p>pop的时候利用queue1，每次pop的时候将queue1中的元素放到queue2，保留一个pop，然后再把queue1和queue2交换，此时queue2又是空的了。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-48-38.png" alt=""> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Queue&lt;Integer&gt; queue1;</div><div class="line">Queue&lt;Integer&gt; queue2;</div><div class="line"></div><div class="line"><span class="comment">/** Initialize your data structure here. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</div><div class="line">  queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Push element x onto stack. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">  queue1.add(x);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> size = queue1.size();</div><div class="line">  <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</div><div class="line">    queue2.add(queue1.remove());</div><div class="line">    size--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> res = queue1.poll();</div><div class="line">  Queue&lt;Integer&gt; temp = queue1;</div><div class="line">  queue1 = queue2;</div><div class="line">  queue2 = temp;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Get the top element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> size = queue1.size();</div><div class="line">  <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</div><div class="line">    queue2.add(queue1.remove());</div><div class="line">    size--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> res = queue1.peek();</div><div class="line">  queue2.add(queue1.remove());</div><div class="line">  Queue&lt;Integer&gt; temp = queue1;</div><div class="line">  queue1 = queue2;</div><div class="line">  queue2 = temp;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns whether the stack is empty. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<p>用两个queue实现，push时间复杂度<script type="math/tex">O(n)</script> , pop时间复杂度<script type="math/tex">O(1)</script></p>
<p>push时先将元素push进queue2,然后将queue2中元素加入queue2，然后交换queue1和queue2</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-49-02.png" alt=""> </p>
<p>pop时直接pop q1中元素</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-49-27.png" alt=""> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Queue&lt;Integer&gt; queue1;</div><div class="line">Queue&lt;Integer&gt; queue2;</div><div class="line"></div><div class="line"><span class="comment">/** Initialize your data structure here. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</div><div class="line">  queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Push element x onto stack. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">  queue2.add(x);</div><div class="line">  <span class="keyword">while</span>(!queue1.isEmpty())&#123;</div><div class="line">    queue2.add(queue1.remove());</div><div class="line">  &#125;</div><div class="line">  Queue&lt;Integer&gt; temp = queue1;</div><div class="line">  queue1 = queue2;</div><div class="line">  queue2 = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.poll();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Get the top element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.peek();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns whether the stack is empty. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法三：</p>
<p>用一个队列实现，push时间复杂度<script type="math/tex">O(n)</script> , pop时间复杂度<script type="math/tex">O(1)</script></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</div><div class="line">    Queue&lt;Integer&gt; queue;</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Push element x onto stack. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        queue.add(x);</div><div class="line">        <span class="keyword">int</span> size = queue.size();</div><div class="line">        <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</div><div class="line">            queue.add(queue.poll());</div><div class="line">            size--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.poll();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Get the top element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.peek();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Next-Greater-Element-I"><a href="#Next-Greater-Element-I" class="headerlink" title="Next Greater Element I"></a><a href="https://leetcode.com/problems/next-greater-element-i/" target="_blank" rel="external">Next Greater Element I</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>You are given two arrays <strong>(without duplicates)</strong> <code>nums1</code> and <code>nums2</code> where <code>nums1</code>’s elements are subset of <code>nums2</code>. Find all the next greater numbers for <code>nums1</code>‘s elements in the corresponding places of <code>nums2</code>.</p>
<p>The Next Greater Number of a number <strong>x</strong> in <code>nums1</code> is the first greater number to its right in <code>nums2</code>. If it does not exist, output -1 for this number.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: nums1 = [4,1,2], nums2 = [1,3,4,2].</div><div class="line">&gt; Output: [-1,3,-1]</div><div class="line">&gt; Explanation:</div><div class="line">&gt;     For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</div><div class="line">&gt;     For number 1 in the first array, the next greater number for it in the second array is 3.</div><div class="line">&gt;     For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: nums1 = [2,4], nums2 = [1,2,3,4].</div><div class="line">&gt; Output: [3,-1]</div><div class="line">&gt; Explanation:</div><div class="line">&gt;     For number 2 in the first array, the next greater number for it in the second array is 3.</div><div class="line">&gt;     For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定数组nums2,nums1中的元素来自nums2,返回nums1中的元素在nums2中右边第一个比它的大元素。</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>baseline：两层循环，在nums2中寻找右边第一个比它大的,时间复杂度<script type="math/tex">O(m*n)</script></p>
<p>优化：利用栈+hashmap</p>
<p>将nums2中元素依次入栈：</p>
<ol>
<li>如果当前元素&lt;栈顶元素,压栈</li>
<li>当前元素i&gt;栈顶元素j，弹出栈顶元素i，此时i右边第一个大于i的元素为j，可以加入hashmap中</li>
<li>一次出栈之后如果还是满足当前元素i&gt;栈顶元素j，重复2知道栈为空或者站顶元素&gt;当前元素，将i压栈</li>
</ol>
<p>时间复杂度<script type="math/tex">O(m+n)</script></p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</div><div class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</div><div class="line">    LinkedHashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; nums1.length;i++)&#123;</div><div class="line">        map.put(nums1[i],-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums2.length;i++)&#123;</div><div class="line">        <span class="comment">//如果栈空，入栈</span></div><div class="line">        <span class="keyword">if</span>(stack.isEmpty() || nums2[i] &lt; stack.peek())&#123;</div><div class="line">            stack.push(nums2[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; stack.peek())&#123;</div><div class="line">                <span class="keyword">int</span> val = stack.pop();</div><div class="line">                <span class="keyword">if</span>(map.containsKey(val))&#123;</div><div class="line">                    map.put(val,nums2[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            stack.push(nums2[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ii = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(Integer val:map.values())&#123;</div><div class="line">        result[ii] = val;</div><div class="line">        ii++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Next-Greater-Element-II"><a href="#Next-Greater-Element-II" class="headerlink" title="Next Greater Element II"></a><a href="https://leetcode.com/problems/next-greater-element-ii/" target="_blank" rel="external">Next Greater Element II</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, output -1 for this number.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,2,1]</div><div class="line">&gt; Output: [2,-1,2]</div><div class="line">&gt; Explanation: The first 1&apos;s next greater number is 2; </div><div class="line">&gt; The number 2 can&apos;t find next greater number; </div><div class="line">&gt; The second 1&apos;s next greater number needs to search circularly, which is also 2.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定一个循环数组，返回数组中每个数字x右边第一个比x大的数字</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>和上一题一样的思路，但这次需要吧数组扩大2倍，做同样的操作</p>
<p>加入stack的元素是数组的下标，这样可以方便后面存储比x大的数字。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">    Arrays.fill(result,-<span class="number">1</span>);</div><div class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>*nums.length-<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(stack.isEmpty() || nums[stack.peek()] &gt;= nums[i%nums.length])&#123;</div><div class="line">            stack.push(i%nums.length);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i%nums.length])&#123;</div><div class="line">                <span class="keyword">int</span> idx = stack.pop();</div><div class="line">                result[idx] = nums[i%nums.length];</div><div class="line">            &#125;</div><div class="line">            stack.push(i%nums.length);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Decode-String"><a href="#Decode-String" class="headerlink" title="Decode String"></a><a href="https://leetcode.com/problems/decode-string/" target="_blank" rel="external">Decode String</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an encoded string, return it’s decoded string.</p>
<p>The encoding rule is: <code>k[encoded_string]</code>, where the <em>encoded_string</em> inside the square brackets is being repeated exactly <em>k</em> times. Note that <em>k</em> is guaranteed to be a positive integer.</p>
<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>
<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <em>k</em>. For example, there won’t be input like <code>3a</code> or <code>2[4]</code>.</p>
<p><strong>Examples:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.</div><div class="line">&gt; s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.</div><div class="line">&gt; s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>利用stack，从左向右遍历字符串：</p>
<ol>
<li>遇到数字：数字可能不止一位，因此继续遍历，累加数字，直到遇到非数字，将数字入栈</li>
<li>遇到字母和’[‘：入栈</li>
<li>遇到’]’：出栈，将字母加入字符串直到遇见’[‘，将’[‘弹出，将前面的数字弹出，计算完字符串之后入栈</li>
<li>重复上面操作，最后将stack中的字符串弹出连接成最终结果</li>
</ol>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        StringBuilder reusult = <span class="keyword">new</span> StringBuilder();</div><div class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; s.length())&#123;</div><div class="line">            <span class="comment">//数字</span></div><div class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</div><div class="line">                <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> (Character.isDigit(s.charAt(i)))&#123;</div><div class="line">                    num = num * <span class="number">10</span> + (s.charAt(i)-<span class="string">'0'</span>);</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">                stack.push(String.valueOf(num));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//字母和‘[’</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) != <span class="string">']'</span>)&#123;</div><div class="line">                stack.push(<span class="string">""</span> + s.charAt(i));</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                StringBuilder temp = <span class="keyword">new</span> StringBuilder();</div><div class="line">                <span class="keyword">while</span>(!stack.peek().equals(<span class="string">"["</span>))&#123;</div><div class="line">                    temp.insert(<span class="number">0</span>,stack.pop());</div><div class="line">                &#125;</div><div class="line">                stack.pop();</div><div class="line">                <span class="keyword">int</span> times = Integer.parseInt(stack.pop());</div><div class="line">                StringBuilder ntemp = <span class="keyword">new</span> StringBuilder();</div><div class="line">                <span class="keyword">while</span> (times &gt; <span class="number">0</span>)&#123;</div><div class="line">                    ntemp = ntemp.append(temp);</div><div class="line">                    times--;</div><div class="line">                &#125;</div><div class="line">                stack.push(ntemp.toString());</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</div><div class="line">            reusult.insert(<span class="number">0</span>,stack.pop());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> reusult.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Remove-Duplicate-Letters"><a href="#Remove-Duplicate-Letters" class="headerlink" title="Remove Duplicate Letters"></a><a href="https://leetcode.com/problems/remove-duplicate-letters/" target="_blank" rel="external">Remove Duplicate Letters</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>
<p><strong>Example:</strong></p>
<p>Given <code>&quot;bcabc&quot;</code><br>Return <code>&quot;abc&quot;</code></p>
<p>Given <code>&quot;cbacdcbc&quot;</code><br>Return <code>&quot;acdb&quot;</code></p>
</blockquote>
<p>移除字符串中重复的字母，保证字母间的相对顺序不变，返回结果中字典序最小的结果。</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>这道题让我们移除重复字母，使得每个字符只能出现一次，而且结果要按字母顺序排，前提是不能打乱其原本的相对位置。我们的解题思路是：先建立一个哈希表来统计每个字母出现的次数，还需要一个visited数字来纪录每个字母是否被访问过，我们遍历整个字符串，对于遍历到的字符，先在哈希表中将其值减一，然后看visited中是否被访问过，若访问过则继续循环，说明该字母已经出现在结果中并且位置已经安排妥当。如果没访问过，我们和结果中最后一个字母比较，如果该字母的ASCII码小并且结果中的最后一个字母在哈希表中的值不为0(说明后面还会出现这个字母)，那么我们此时就要在结果中删去最后一个字母且将其标记为未访问，然后加上当前遍历到的字母，并且将其标记为已访问，以此类推直至遍历完整个字符串s，此时结果里的字符串即为所求。</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</div><div class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</div><div class="line">        map[s.charAt(i)-<span class="string">'a'</span>]++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;<span class="keyword">if</span>(visited[s.charAt(i)-<span class="string">'a'</span>])&#123;</div><div class="line">            map[s.charAt(i)-<span class="string">'a'</span>]--;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; s.charAt(i) &lt; stack.peek().charAt(<span class="number">0</span>) &amp;&amp; map[stack.peek().charAt(<span class="number">0</span>)-<span class="string">'a'</span>] &gt; <span class="number">0</span>)&#123;</div><div class="line">                visited[stack.peek().charAt(<span class="number">0</span>)-<span class="string">'a'</span>] = <span class="keyword">false</span>;</div><div class="line">                stack.pop();</div><div class="line">            &#125;</div><div class="line">            stack.push(String.valueOf(s.charAt(i)));</div><div class="line">            visited[s.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">true</span>;</div><div class="line">            map[s.charAt(i)-<span class="string">'a'</span>]--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</div><div class="line">        res.insert(<span class="number">0</span>,stack.pop());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Basic-Calculator"><a href="#Basic-Calculator" class="headerlink" title="Basic Calculator"></a><a href="https://leetcode.com/problems/basic-calculator/" target="_blank" rel="external">Basic Calculator</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string may contain open <code>(</code> and closing parentheses <code>)</code>, the plus <code>+</code> or minus sign <code>-</code>, <strong>non-negative</strong>integers and empty spaces ``.</p>
<p>You may assume that the given expression is always valid.</p>
<p>Some examples:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; &quot;1 + 1&quot; = 2</div><div class="line">&gt; &quot; 2-1 + 2 &quot; = 3</div><div class="line">&gt; &quot;(1+(4+5+2)-3)+(6+8)&quot; = 23</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>这道题让我们实现一个基本的计算器来计算简单的算数表达式，而且题目限制了表达式中只有加减号，数字，括号和空格。我们需要一个栈来辅助计算，用个变量sign来表示当前的符号，由于有括号的存在，所以用变量res存储当前括号中计算的结果，将之前计算结果存在栈里。</p>
<p>我们遍历给定的字符串s：</p>
<ol>
<li>如果遇到了数字，由于可能是个多位数，所以我们要用while循环把之后的数字都读进来，然后用sign*num来更新结果res；</li>
<li>如果遇到了加号，则sign赋为1，如果遇到了符号，则赋为-1；</li>
<li>如果遇到了左括号，则把当前结果res和符号sign压入栈，res重置为0，sign重置为1；</li>
<li>如果遇到了右括号，结果res乘以栈顶的符号，栈顶元素出栈，结果res加上栈顶的数字，栈顶元素出栈。</li>
</ol>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; s.length())&#123;</div><div class="line">        <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</div><div class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span>(i &lt;s.length() &amp;&amp; Character.isDigit(s.charAt(i)))&#123;</div><div class="line">                sum = sum*<span class="number">10</span> + s.charAt(i)-<span class="string">'0'</span>;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            res += sum * sign;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span>)&#123;</div><div class="line">            sign = <span class="number">1</span>;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'-'</span>)&#123;</div><div class="line">            sign = -<span class="number">1</span>;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</div><div class="line">            stack.push(res);</div><div class="line">            stack.push(sign);</div><div class="line">            i++;</div><div class="line">            res = <span class="number">0</span>;</div><div class="line">            sign = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span>)&#123;</div><div class="line">            res *= stack.pop();</div><div class="line">            res += stack.pop();</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">      <span class="keyword">else</span>&#123;i++;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Basic-Calculator-II"><a href="#Basic-Calculator-II" class="headerlink" title="Basic Calculator II"></a><a href="https://leetcode.com/problems/basic-calculator-ii/" target="_blank" rel="external">Basic Calculator II</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string contains only <strong>non-negative</strong> integers, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> operators and empty spaces ``. The integer division should truncate toward zero.</p>
<p>You may assume that the given expression is always valid.</p>
<p>Some examples:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; &quot;3+2*2&quot; = 7</div><div class="line">&gt; &quot; 3/2 &quot; = 1</div><div class="line">&gt; &quot; 3+5 / 2 &quot; = 5</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>加减乘除运算，没有括号，求结果</p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>用一个变量sign存储符号，用stack存储计算完的值。</p>
<p>遍历字符串：</p>
<ol>
<li>遇到符号：更新sign</li>
<li>遇到数字，计算数字num，根据sign的值入栈：<ol>
<li>sign==’+’:num入栈</li>
<li>sign==’-‘:-num入栈</li>
<li>sign==’*’:和栈顶元素做乘法后入栈</li>
<li>sign==’/‘:和栈顶元素做除法后入栈</li>
</ol>
</li>
<li>最后将栈中所有元素弹出做加法得到result</li>
</ol>
<p>总之核心思想就是将减法转化成相反数入栈，将*和/计算之后入栈，最后就都转化成加法了</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();i++)&#123;</div><div class="line">            <span class="comment">//记录符号</span></div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span> || s.charAt(i) == <span class="string">'-'</span> || s.charAt(i) == <span class="string">'*'</span> || s.charAt(i) == <span class="string">'/'</span>)&#123;</div><div class="line">                sign = s.charAt(i);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果是数字</span></div><div class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</div><div class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i)))&#123;</div><div class="line">                    sum = sum*<span class="number">10</span> + (s.charAt(i)-<span class="string">'0'</span>);</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">                i--;</div><div class="line">                <span class="keyword">if</span>(sign == <span class="string">'+'</span>)&#123;</div><div class="line">                    stack.push(sum);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(sign == <span class="string">'-'</span>)&#123;</div><div class="line">                    stack.push(-sum);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(sign == <span class="string">'*'</span>)&#123;</div><div class="line">                    stack.push(stack.pop() * sum);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(sign == <span class="string">'/'</span>)&#123;</div><div class="line">                    stack.push(stack.pop()/sum);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</div><div class="line">            res += stack.pop();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Flatten-Nested-List-Iterator"><a href="#Flatten-Nested-List-Iterator" class="headerlink" title="Flatten Nested List Iterator"></a><a href="https://leetcode.com/problems/flatten-nested-list-iterator/" target="_blank" rel="external">Flatten Nested List Iterator</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a nested list of integers, implement an iterator to flatten it.</p>
<p>Each element is either an integer, or a list — whose elements may also be integers or other lists.</p>
<p><strong>Example 1:</strong><br>Given the list <code>[[1,1],2,[1,1]]</code>,</p>
<p>By calling <em>next</em> repeatedly until <em>hasNext</em> returns false, the order of elements returned by <em>next</em> should be: <code>[1,1,2,1,1]</code>.</p>
<p><strong>Example 2:</strong><br>Given the list <code>[1,[4,[6]]]</code>,</p>
<p>By calling <em>next</em> repeatedly until <em>hasNext</em> returns false, the order of elements returned by <em>next</em> should be: <code>[1,4,6]</code>.</p>
</blockquote>
<p>给定一个list，里面元素是nestedInteger,可能是Integer，也可能是个IntegerList,要求实现hasNext()和next()函数</p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>利用stack</p>
<ol>
<li><p>初始化：将给定list中的元素都放入stack</p>
</li>
<li><p>在hasNext()中，如果栈顶元素是Integer直接返回true,如果不是Integer则是个List,遍历这个List将元素入栈。</p>
<p>循环上面的操作，直到栈空如果依然没有integer则返回false</p>
</li>
<li><p>next()函数直接pop()</p>
</li>
</ol>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlattenNestedListIterator</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedInteger</span> </span>&#123;</div><div class="line">        <span class="comment">// @return true if this NestedInteger holds a single integer, rather than a nested list.</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInteger</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        <span class="comment">// @return the single integer that this NestedInteger holds, if it holds a single integer</span></div><div class="line">        <span class="comment">// Return null if this NestedInteger holds a nested list</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        <span class="comment">// @return the nested list that this NestedInteger holds, if it holds a nested list</span></div><div class="line">        <span class="comment">// Return null if this NestedInteger holds a single integer</span></div><div class="line">        <span class="function"><span class="keyword">public</span> List&lt;NestedInteger&gt; <span class="title">getList</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">        Stack&lt;NestedInteger&gt; stack = <span class="keyword">new</span> Stack();</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = nestedList.size()-<span class="number">1</span>;i &gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">                stack.push(nestedList.get(i));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> stack.pop().getInteger();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</div><div class="line">                <span class="keyword">if</span> (stack.peek().isInteger()) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    List&lt;NestedInteger&gt; list = stack.pop().getList();</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                        stack.push(list.get(i));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Simplify-Path"><a href="#Simplify-Path" class="headerlink" title="Simplify Path"></a><a href="https://leetcode.com/problems/simplify-path/" target="_blank" rel="external">Simplify Path</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br><strong>path</strong> = <code>&quot;/home/&quot;</code>, =&gt; <code>&quot;/home&quot;</code><br><strong>path</strong> = <code>&quot;/a/./b/../../c/&quot;</code>, =&gt; <code>&quot;/c&quot;</code></p>
<p><a href="https://leetcode.com/problems/simplify-path/description/#" target="_blank" rel="external">click to show corner cases.</a></p>
<p>Corner Cases:</p>
<ul>
<li>Did you consider the case where <strong>path</strong> = <code>&quot;/../&quot;</code>?<br>In this case, you should return <code>&quot;/&quot;</code>.</li>
<li>Another corner case is the path might contain multiple slashes <code>&#39;/&#39;</code> together, such as <code>&quot;/home//foo/&quot;</code>.<br>In this case, you should ignore redundant slashes and return <code>&quot;/home/foo&quot;</code>.</li>
</ul>
</blockquote>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>linux系统中<code>“../”</code>代表上层文件夹，<code>“./”</code>代表当前文件夹</p>
<p>利用stack存储路径</p>
<p>将给定字符串按“/”分割：</p>
<ol>
<li>遇到.和空字符串跳过，遇到“..”pop栈顶字符串</li>
<li>遇到正常字符串push(“/“+str)</li>
</ol>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(path.length()==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(String str : path.split(<span class="string">"/"</span>))&#123;</div><div class="line">            <span class="comment">//遇到..</span></div><div class="line">            <span class="keyword">if</span>(str.equals(<span class="string">".."</span>))&#123;</div><div class="line">                <span class="keyword">if</span>(!stack.isEmpty())&#123;</div><div class="line">                    stack.pop();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//遇到.或者空字符串，跳过</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str.equals(<span class="string">"."</span>) || str.equals(<span class="string">""</span>))&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                stack.push(<span class="string">"/"</span>+str);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</div><div class="line">            res.insert(<span class="number">0</span>,stack.pop());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(res.length() == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"/"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Verify-Preorder-Sequence-in-Binary-Search-Tree"><a href="#Verify-Preorder-Sequence-in-Binary-Search-Tree" class="headerlink" title="Verify Preorder Sequence in Binary Search Tree"></a><a href="https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/" target="_blank" rel="external">Verify Preorder Sequence in Binary Search Tree</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><p>验证一个序列是否是BST的中序遍历</p>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>BST根节点左边的元素都比根节点小，右边的元素都比跟节点大</p>
<p>利用这个性质，用一个栈和一个low变量来维护遍历过程</p>
<p>当出现比根大的元素之后，说明在根节点的右子树，此后就不可能出现比根小的元素了</p>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> low = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : preorder)&#123;</div><div class="line">            <span class="keyword">if</span>(p &lt; low)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; p&gt;stack.peek())&#123;</div><div class="line">                low = stack.pop();</div><div class="line">            &#125;</div><div class="line">            stack.push(p);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Mini-Parser"><a href="#Mini-Parser" class="headerlink" title="Mini Parser"></a><a href="https://leetcode.com/problems/mini-parser/" target="_blank" rel="external">Mini Parser</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a nested list of integers represented as a string, implement a parser to deserialize it.</p>
<p>Each element is either an integer, or a list — whose elements may also be integers or other lists.</p>
<p><strong>Note:</strong> You may assume that the string is well-formed:</p>
<ul>
<li>String is non-empty.</li>
<li>String does not contain white spaces.</li>
<li>String contains only digits <code>0-9</code>, <code>[</code>, <code>-</code> <code>,</code>, <code>]</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given s = &quot;324&quot;,</div><div class="line">&gt;</div><div class="line">&gt; You should return a NestedInteger object which contains a single integer 324.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given s = &quot;[123,[456,[789]]]&quot;,</div><div class="line">&gt;</div><div class="line">&gt; Return a NestedInteger object containing a nested list with 2 elements:</div><div class="line">&gt;</div><div class="line">&gt; 1. An integer containing value 123.</div><div class="line">&gt; 2. A nested list containing two elements:</div><div class="line">&gt;     i.  An integer containing value 456.</div><div class="line">&gt;     ii. A nested list with one element:</div><div class="line">&gt;          a. An integer containing value 789.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>利用stack，每次遇到’[‘就新建一个nest放入stack,遇到，或者‘]’代表一个数字结束，放入栈顶的nest里</p>
<p>如果遇到的是‘]’还需要将栈顶的第一个nest嵌套入前一个nest中，最后栈中只有一个nest</p>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></div><div class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></div><div class="line"><span class="comment"> * public interface NestedInteger &#123;</span></div><div class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></div><div class="line"><span class="comment"> *     public NestedInteger();</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></div><div class="line"><span class="comment"> *     public NestedInteger(int value);</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // <span class="doctag">@return</span> true if this NestedInteger holds a single integer, rather than a nested list.</span></div><div class="line"><span class="comment"> *     public boolean isInteger();</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // <span class="doctag">@return</span> the single integer that this NestedInteger holds, if it holds a single integer</span></div><div class="line"><span class="comment"> *     // Return null if this NestedInteger holds a nested list</span></div><div class="line"><span class="comment"> *     public Integer getInteger();</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></div><div class="line"><span class="comment"> *     public void setInteger(int value);</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></div><div class="line"><span class="comment"> *     public void add(NestedInteger ni);</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // <span class="doctag">@return</span> the nested list that this NestedInteger holds, if it holds a nested list</span></div><div class="line"><span class="comment"> *     // Return null if this NestedInteger holds a single integer</span></div><div class="line"><span class="comment"> *     public List&lt;NestedInteger&gt; getList();</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> NestedInteger <span class="title">deserialize</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NestedInteger();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) != <span class="string">'['</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NestedInteger(Integer.parseInt(s));</div><div class="line">        &#125;</div><div class="line">        Stack&lt;NestedInteger&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="comment">//NestedInteger nest = new NestedInteger();//存储当前未入栈nest</span></div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</div><div class="line">            <span class="comment">//遇到'['新建一个NestedInteger放入栈里</span></div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'['</span>)&#123;</div><div class="line">                stack.push(<span class="keyword">new</span> NestedInteger());</div><div class="line">                left = i+<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//遇到','||']'将left和i之间的数字放入栈顶的nestedInteger里</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">','</span> || s.charAt(i) == <span class="string">']'</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(left &lt; i)&#123;</div><div class="line">                    NestedInteger nest = <span class="keyword">new</span> NestedInteger(Integer.parseInt(s.substring(left,i)));</div><div class="line">                    NestedInteger top = stack.pop();</div><div class="line">                    top.add(nest);</div><div class="line">                    stack.push(top);</div><div class="line">                &#125;</div><div class="line">                left = i+<span class="number">1</span>;</div><div class="line">              <span class="comment">//遇到']'，将stack中nested嵌套，最后只剩一个nest</span></div><div class="line">                <span class="keyword">if</span> (s.charAt(i) == <span class="string">']'</span>)&#123;</div><div class="line">                    <span class="keyword">if</span>(stack.size() &gt; <span class="number">1</span>)&#123;</div><div class="line">                        NestedInteger first = stack.pop();</div><div class="line">                        NestedInteger second = stack.pop();</div><div class="line">                        second.add(first);</div><div class="line">                        stack.push(second);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack.pop();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Verify-Preorder-Serialization-of-a-Binary-Tree"><a href="#Verify-Preorder-Serialization-of-a-Binary-Tree" class="headerlink" title="Verify Preorder Serialization of a Binary Tree"></a><a href="https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/" target="_blank" rel="external">Verify Preorder Serialization of a Binary Tree</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as <code>#</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      _9_</div><div class="line">&gt;     /   \</div><div class="line">&gt;    3     2</div><div class="line">&gt;   / \   / \</div><div class="line">&gt;  4   1  #  6</div><div class="line">&gt; / \ / \   / \</div><div class="line">&gt; # # # #   # #</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>For example, the above binary tree can be serialized to the string <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>, where <code>#</code>represents a null node.</p>
<p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p>
<p>Each comma separated value in the string must be either an integer or a character <code>&#39;#&#39;</code> representing <code>null</code> pointer.</p>
<p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as <code>&quot;1,,3&quot;</code>.</p>
<p><strong>Example 1:</strong><br><code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code><br>Return <code>true</code></p>
<p><strong>Example 2:</strong><br><code>&quot;1,#&quot;</code><br>Return <code>false</code></p>
<p><strong>Example 3:</strong><br><code>&quot;9,#,#,1&quot;</code><br>Return <code>false</code></p>
</blockquote>
<p>给定一个二叉树的前序遍历，#代表空节点，判断是否是一个二叉树</p>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>方法一：利用stack</p>
<p>遍历节点，压栈，如果遇到“#”，且当前栈顶也是“#”说明栈顶#前面的那个节点已经有两个空子节点了，则将栈顶的#和前一个节点弹出，压入一个“#”表示空节点，有点类似于剪枝，下面的如果是二叉树，就剪枝。</p>
<p>过程中如果有stack为空，则不是二叉树</p>
<p>最后如果栈里只剩一个“#”了就是二叉树</p>
<p>方法二：</p>
<p>根据节点的出度和入度</p>
<p>二叉树中，每增加一个非叶子节点增加2个出度1个入度，增加一个叶子节点增加0个出度1个入度</p>
<p>用一个变量diff记录出度-入度的差</p>
<p>跟节点时diff=1;</p>
<p>每增加一个非叶子节点diff+1;</p>
<p>每增加一个叶子节点diff-1;</p>
<p>在这个过程中diff应该恒大于0.</p>
<p>最后满二叉树的出度应该等于入度</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><p>方法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</div><div class="line">    String[] str = preorder.split(<span class="string">","</span>);</div><div class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; str.length;i++)&#123;</div><div class="line">        <span class="keyword">while</span> (str[i].equals(<span class="string">"#"</span>) &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek().equals(<span class="string">"#"</span>))&#123;</div><div class="line">            stack.pop();</div><div class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</div><div class="line">                <span class="keyword">return</span>  <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            stack.pop();</div><div class="line">        &#125;</div><div class="line">        stack.push(str[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> stack.size()==<span class="number">1</span> &amp;&amp; stack.peek().equals(<span class="string">"#"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</div><div class="line">    String[] str = preorder.split(<span class="string">","</span>);</div><div class="line">    <span class="keyword">int</span> diff = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; str.length;i++)&#123;</div><div class="line">        diff--;</div><div class="line">        <span class="keyword">if</span>(diff &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!str[i].equals(<span class="string">"#"</span>))&#123;</div><div class="line">            diff+=<span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> diff==<span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Closest-Binary-Search-Tree-Value-II"><a href="#Closest-Binary-Search-Tree-Value-II" class="headerlink" title="Closest Binary Search Tree Value II"></a><a href="https://leetcode.com/problems/closest-binary-search-tree-value-ii/" target="_blank" rel="external">Closest Binary Search Tree Value II</a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><p>给定一个BST，一个target，一个k</p>
<p>返回BST中和target最接近的k个节点的值。</p>
<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>根据性质BST的中序遍历是递增序列</p>
<p>所以用栈实现BST的中序遍历。又因为求k个最接近的，也就是差值的绝对值最小的k个，可以用维护一个最大堆的方法。</p>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">closestKValues</span><span class="params">(TreeNode root, <span class="keyword">double</span> target, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> val;</div><div class="line">            <span class="keyword">double</span> delta;</div><div class="line">            Node(<span class="keyword">int</span> val,<span class="keyword">double</span> delta)&#123;</div><div class="line">                <span class="keyword">this</span>.delta = delta;</div><div class="line">                <span class="keyword">this</span>.val = val;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Comparator&lt;Node&gt; cmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span>(o2.delta &gt; o1.delta)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(cmp);</div><div class="line">        <span class="comment">//中序遍历</span></div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        TreeNode curt = root;</div><div class="line">        <span class="keyword">while</span> (curt != <span class="keyword">null</span> || !stack.isEmpty())&#123;</div><div class="line">            <span class="keyword">while</span>(curt!= <span class="keyword">null</span>)&#123;</div><div class="line">                stack.push(curt);</div><div class="line">                curt = curt.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!stack.isEmpty())&#123;</div><div class="line">                curt = stack.pop();</div><div class="line">                <span class="keyword">int</span> val = curt.val;</div><div class="line">                <span class="comment">//System.out.println(val);</span></div><div class="line">                <span class="keyword">double</span> delta = Math.abs(target-val);</div><div class="line">                <span class="keyword">if</span>(heap.size() == k &amp;&amp; delta &gt; heap.peek().delta)&#123;</div><div class="line">                    <span class="comment">//System.out.println("hh");</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    heap.add(<span class="keyword">new</span> Node(val,delta));</div><div class="line">                    <span class="keyword">if</span>(heap.size() &gt; k)&#123;</div><div class="line">                        heap.poll();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                curt = curt.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</div><div class="line">            res.add(heap.poll().val);</div><div class="line">            k--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="哈希表Hash"><a href="#哈希表Hash" class="headerlink" title="哈希表Hash"></a>哈希表Hash</h1><h3 id="hash-特性"><a href="#hash-特性" class="headerlink" title="hash 特性"></a>hash 特性</h3><ul>
<li>支持操作：Insert/Find/Delete,时间复杂度都是<script type="math/tex">O(1)</script></li>
<li>Hash Table/Hash Map/Hash Set的区别是什么？<ul>
<li>hash set 只有key没有value</li>
<li>hash table是线程安全的数据结构，hash map线程不安全</li>
<li>多线程和多进程的区别：线程之间共享同一片内存</li>
<li>hash table有锁，可以保证同一时间只有一个进程对其进行操作，因此是线程安全的</li>
</ul>
</li>
</ul>
<h3 id="hash-Table实现"><a href="#hash-Table实现" class="headerlink" title="hash Table实现"></a>hash Table实现</h3><p>通过一个Hash function将key映射到一个大数组中，查找的时候计算下标，直接获取<script type="math/tex">O(1)</script></p>
<p>Hash function的设计：</p>
<ul>
<li>无冲突</li>
<li>大数组的长度大概是key数量的10倍以上才是安全的</li>
</ul>
<p>Hash 函数解决冲突的两种办法：</p>
<ol>
<li><p>open hashing</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-19-12-20-31.png" alt=""> </p>
<p>每个位置可以维护一个链表，插入时，遇到冲突就加到链表里；查找时，查找下标对应的链表</p>
</li>
<li><p>closed hashing</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-19-12-23-30.png" alt=""> </p>
<p>占坑，如果hash函数计算完发现自己的坑被占了，就依次向后找到空位放进去；查找时，hash函数计算应该在的位置，如果不是该元素，继续向后寻找直到空</p>
</li>
</ol>
<p>rehashing问题</p>
<p>当已经存储的元素个数已经超过大数组的1/10l了就需要扩大hash表数组了，这就是rehashing问题。</p>
<p>需要把hash表中现有的元素全部扫描一遍，重新计算其在新的大hash表中的位置，放到新位置。</p>
<h3 id="Max-Points-on-a-Line"><a href="#Max-Points-on-a-Line" class="headerlink" title="Max Points on a Line"></a><a href="https://leetcode.com/problems/max-points-on-a-line/" target="_blank" rel="external">Max Points on a Line</a></h3><p>给定2维坐标平面上n个点，求最多有多少个点共线</p>
<p>遍历每一个点，针对每一个点，用hashmap记录其余跟该点共线的点的个数，key是斜率，value是个数，因为斜率相等的一定在同一直线。遇到跟该点重合的点需要单独累加个数</p>
<p>其中斜率要用分数形式存储，存分子和分母，这就需要计算最大公约数了。</p>
<p>计算最大公约数的方法：辗转相除法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="comment">//求最大公约数，递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">  	<span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</div><div class="line">    <span class="keyword">if</span> (x%y == <span class="number">0</span>) &#123;</div><div class="line">      	<span class="keyword">return</span> y;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      	<span class="keyword">return</span> gcd(y,x%y);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">//求最大公约数，非递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">  	<span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</div><div class="line">    <span class="keyword">while</span> (x%y != <span class="number">0</span>)&#123;</div><div class="line">      	<span class="keyword">int</span> temp = y;</div><div class="line">      	y = x%y;</div><div class="line">      	x = temp;</div><div class="line">    &#125;</div><div class="line">  	<span class="keyword">return</span> y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"> <span class="comment">//求最大公约数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</div><div class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> y;</div><div class="line">        <span class="keyword">while</span>(x%y != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">int</span> temp = x%y;</div><div class="line">            x = y;</div><div class="line">            y = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (points.length &lt;= <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> points.length;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="comment">//遍历每一个点</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; points.length;i++)&#123;</div><div class="line">            HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap();<span class="comment">//存储斜率和个数</span></div><div class="line">            Point p = points[i];</div><div class="line">            <span class="keyword">int</span> selfoverlap = <span class="number">0</span>;<span class="comment">//记录与本身重合的点的个数</span></div><div class="line">            <span class="keyword">int</span> lineNum = <span class="number">0</span>;</div><div class="line">            <span class="comment">//遍历后面的点</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; points.length;j++)&#123;</div><div class="line">                Point q = points[j];</div><div class="line">                <span class="keyword">int</span> delta_x = p.x-q.x;</div><div class="line">                <span class="keyword">int</span> delta_y = p.y-q.y;</div><div class="line">                <span class="comment">//重合的点，单独计算</span></div><div class="line">                <span class="keyword">if</span>(delta_x == <span class="number">0</span> &amp;&amp; delta_y == <span class="number">0</span>)&#123;</div><div class="line">                    selfoverlap++;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">int</span> maxCommon = gcd(delta_x,delta_y);</div><div class="line">                delta_x = delta_x/maxCommon;</div><div class="line">                delta_y = delta_y/maxCommon;</div><div class="line"></div><div class="line">                String k = delta_x +<span class="string">"/"</span>+ delta_y;</div><div class="line">                <span class="keyword">int</span> count = map.getOrDefault(k,<span class="number">0</span>)+<span class="number">1</span>;</div><div class="line">                map.put(k,count);</div><div class="line">                lineNum = Math.max(lineNum,count);</div><div class="line">            &#125;</div><div class="line">            res = Math.max(res,lineNum + selfoverlap + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="堆Heap"><a href="#堆Heap" class="headerlink" title="堆Heap"></a>堆Heap</h1><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><ul>
<li><p>支持操作：Add <script type="math/tex">O(logN)</script>/Remove<script type="math/tex">O(logN)</script>/Min or Max<script type="math/tex">O(1)</script></p>
</li>
<li><p>heap可以用来求最大值或者最小值，不能同时求最大和最小值。</p>
</li>
<li><p>Heap结构：</p>
<p>一颗尽量填满的二叉树，每次插入节点时，插到最后一行的最左端的空余位置，如果本层没有空余位置了，另起一行。因此节点数目为N的堆对应的二叉树高度为<script type="math/tex">O(logN)</script></p>
</li>
</ul>
<ul>
<li><p>MaxHeap vs MinHeap</p>
<ul>
<li>MaxHeap：父亲节点比左右孩子都大</li>
<li>MinHeap：父亲节点比左右孩子都小</li>
</ul>
<p>因此当取最大或最小时，将root值取出即可，因此getMin/Max的时间复杂度为<script type="math/tex">O(1)</script></p>
</li>
<li><p>堆的存储</p>
<p>由于我们需要频繁的对堆进行增加删除，所以一般堆的底层都是通过数组来实现（而不能用链表，因为链表需要频繁new 或 delete对象，非常慢）</p>
<p>对于元素A[i]：</p>
<ul>
<li>父节点：A[i-2/2] (右移1)</li>
<li>左孩子：A[2i+1] (左移1，可得到2i)</li>
<li>右孩子：A[2i+2] (左移1，低位+1，可得到2i+1)</li>
</ul>
</li>
<li><p>插入操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例子：在最小堆中插入元素：</div><div class="line">	<span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">2</span>		<span class="number">3</span></div><div class="line">插入<span class="number">0</span>，因为第二行已经满了，加入到第三行最左边：</div><div class="line">	<span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">2</span>		<span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">0</span></div><div class="line">此时这个堆已经不满足最小堆的条件（父亲节点都比孩子小）了，因此，先交换<span class="number">0</span>和<span class="number">2</span>：</div><div class="line">	<span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">0</span>		<span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">2</span></div><div class="line">此时仍然不满足最小堆条件，继续交换：</div><div class="line">	<span class="number">0</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">1</span>		<span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">2</span></div><div class="line">此时满足最小堆条件了，因此，需要交换最多 O(logN)次，插入的时间复杂度为O(logN)</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>删除操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例子：在最小堆中删除元素：</div><div class="line">     	 <span class="number">1</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>			<span class="number">2</span></div><div class="line"> ↙  ↘       ↙  	↘</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">10</span>		<span class="number">100</span></div><div class="line">删除堆顶元素<span class="number">1</span>，用堆中最后一个节点替换堆顶元素：</div><div class="line">     	<span class="number">100</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>			<span class="number">2</span></div><div class="line"> ↙  ↘       ↙  	</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">10</span>		</div><div class="line">此时这个堆已经不满足最小堆的条件（父亲节点都比孩子小）了，因此将堆顶元素下沉，选择左右孩子中较小的交换：</div><div class="line">     	 <span class="number">2</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>		  <span class="number">100</span></div><div class="line"> ↙  ↘       ↙  	</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">10</span>	</div><div class="line">此时仍然不满足最小堆条件，继续交换：</div><div class="line">     	 <span class="number">2</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>		  <span class="number">10</span></div><div class="line"> ↙  ↘       ↙  	</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">100</span>	</div><div class="line"></div><div class="line">好了，删好了</div></pre></td></tr></table></figure>
<p>PriorityQueue支持<script type="math/tex">O(logN)</script> 删除堆顶元素，但对于删除除root外的任意一点的操作，PriorityQueue的时间复杂度会降到<script type="math/tex">O(N)</script></p>
<p>Java中还有另外一种数据结构TreeMap，支持<script type="math/tex">O(logN)</script> 删除任意元素，而且支持同时获取最大和最小。</p>
<p>TreeMap是一平衡二叉搜索树，因此插入和删除任意元素的时间复杂度都是<script type="math/tex">O(logN)</script></p>
<p>|               | 用    | 原理          | 实现   |<br>| ——————- | —— | —————- | —— |<br>| TreeMap       | 必会   | 平衡二叉搜索树，红黑树 | 不需要  |<br>| PriorityQueue | 必会   | heap，二叉树    | 选做   |</p>
</li>
</ul>
<h2 id="leetcode相关习题"><a href="#leetcode相关习题" class="headerlink" title="leetcode相关习题"></a>leetcode相关习题</h2><h3 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a><a href="https://leetcode.com/problems/ugly-number" target="_blank" rel="external">Ugly Number</a></h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>6, 8</code> are ugly while <code>14</code> is not ugly since it includes another prime factor <code>7</code>.</p>
<p>Note that <code>1</code> is typically treated as an ugly number.</p>
</blockquote>
<p>检验输入数组num是否是unly number：因子只有2,3,5</p>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>思路就是把num中的2、3、5全部除掉，最后==1了就是ugly number，如果最后不是1，说明还有其他因数，因此返回false</p>
<h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(num % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            num /= <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(num % <span class="number">3</span> == <span class="number">0</span>)&#123;</div><div class="line">            num /= <span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(num % <span class="number">5</span> == <span class="number">0</span>)&#123;</div><div class="line">            num /= <span class="number">5</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Ugly-Number-II"><a href="#Ugly-Number-II" class="headerlink" title="Ugly Number II"></a><a href="https://leetcode.com/problems/ugly-number-ii/" target="_blank" rel="external">Ugly Number II</a></h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Write a program to find the <code>n</code>-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</p>
<p>Note that <code>1</code> is typically treated as an ugly number, and <em>n</em> <strong>does not exceed 1690</strong>.</p>
</blockquote>
<h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>从1开始分别乘{2,3,5}，得到2,3,5是ugly number，然后对于2，依次乘2,3,5，得到4,6,10是ugly number，此时ugly number有：1,2,3,4,5,6,10，1,2处理过了，继续处理3，由此，我们需要一个最小堆来维护现有ugly number中还未与2,3,5相乘的最小的，相乘之后加入该堆，同时需要一个hashmap记录已经计算过的ugly number，以免重复入堆。</p>
<h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.HashSet;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UglyNumberII</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        HashSet&lt;Long&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        Comparator&lt;Long&gt; cmp = <span class="keyword">new</span> Comparator&lt;Long&gt;()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long e1,Long e2)</span></span>&#123;</div><div class="line">                <span class="keyword">return</span> Long.compare(e1,e2);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue(cmp);</div><div class="line">        Long[] prime = &#123;Long.valueOf(<span class="number">2</span>),Long.valueOf(<span class="number">3</span>),Long.valueOf(<span class="number">5</span>)&#125;;</div><div class="line">        heap.add(Long.valueOf(<span class="number">1</span>));</div><div class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</div><div class="line">            Long ugly = heap.poll();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> i:prime)&#123;</div><div class="line">                <span class="keyword">if</span>(!set.contains(ugly*i))&#123;</div><div class="line">                    heap.add(ugly*i);</div><div class="line">                    set.add(ugly*i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            n--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> heap.peek().intValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[BFS & DFS]]></title>
      <url>/2018/01/16/BFS-DFS/</url>
      <content type="html"><![CDATA[<h3 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a><a href="https://leetcode.com/problems/word-ladder" target="_blank" rel="external">Word Ladder</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>
</ol>
<p>For example,</p>
<p>Given:<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p>
<p>As one shortest transformation is <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,<br>return its length <code>5</code>.</p>
</blockquote>
<p>给定起始单词和结束单词，利用wordlist中的单词爬梯子，每次只允许改变一个字母，返回能够到达结束词的最短路径长度</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>一开始用了回溯，相当于暴力了所有可能，超时了，看了解答，这道题应该用广度优先搜索（BFS）：</p>
<p>需要用到队列<code>Queue</code></p>
<p>因为要求最短路径，如果我们用深度优先搜索的话必须遍历所有的路径才能确定哪个是最短的，而用广度优先搜索的话，一旦搜到目标就可以提前终止了，而且根据广度优先的性质，我们肯定是先通过较短的路径搜到目标。另外，为了避免产生环路和重复计算，我们找到一个存在于字典的新的词时，就要把它从字典中移去。这么做是因为根据广度优先，我们第一次发现词A的路径一定是从初始词到词A最短的路径，对于其他可能再经过词A的路径，我们都没有必要再计算了。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span>[] isUsed;</div><div class="line"></div><div class="line"><span class="comment">//判断两个单词是否只相差一个字母</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word1, String word2)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(word1.length() != word2.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> diffSum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</div><div class="line">      diffSum++;</div><div class="line">      <span class="keyword">if</span>(diffSum &gt; <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</div><div class="line">  Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue.add(beginWord);</div><div class="line">  <span class="keyword">int</span> step = <span class="number">2</span>;<span class="comment">//记录层数</span></div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    <span class="keyword">int</span> queueSize = queue.size();<span class="comment">//当前queue长度</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; queueSize;i++)&#123;<span class="comment">//遍历queue中元素，将其后续节点入队列</span></div><div class="line">      String temp  = queue.peek();</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;wordList.size();j++)&#123;</div><div class="line">        <span class="comment">//如果该词与队列顶端元素只相差一个字母，入队列，标记为使用过</span></div><div class="line">        <span class="keyword">if</span>(!isUsed[j] &amp;&amp; isValid(temp,wordList.get(j)))&#123;</div><div class="line">          <span class="keyword">if</span>(wordList.get(j).equals(endWord))&#123;<span class="comment">//一旦找到了endword结束搜索，返回当前层数</span></div><div class="line">            <span class="keyword">return</span> step;</div><div class="line">          &#125;</div><div class="line">          queue.add(wordList.get(j));</div><div class="line">          isUsed[j] = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      queue.poll();</div><div class="line">    &#125;</div><div class="line">    step++;<span class="comment">//层数+1</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</div><div class="line">  isUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[wordList.size()];</div><div class="line">  <span class="keyword">return</span> solve(beginWord,endWord,wordList);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Remove-Invalid-Parentheses"><a href="#Remove-Invalid-Parentheses" class="headerlink" title="Remove Invalid Parentheses"></a><a href="https://leetcode.com/problems/remove-invalid-parentheses" target="_blank" rel="external">Remove Invalid Parentheses</a></h3><blockquote>
<p>emove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.</p>
<p>Note: The input string may contain letters other than the parentheses <code>(</code> and <code>)</code>.</p>
<p><strong>Examples:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; &quot;()())()&quot; -&gt; [&quot;()()()&quot;, &quot;(())()&quot;]</div><div class="line">&gt; &quot;(a)())()&quot; -&gt; [&quot;(a)()()&quot;, &quot;(a())()&quot;]</div><div class="line">&gt; &quot;)(&quot; -&gt; [&quot;&quot;]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>思路：</p>
<p>BFS:set+queue</p>
<p>用set记录出现过的字符串，将字符串放入queue，一次删除一个字符，如果在set中没有出现，放入queue。</p>
<p>每次弹出一个字符串判断是否为合法字符串，如果合法加入结果集</p>
<p>由于只能返回去掉字符最少的字符串，所以采用按层遍历的方式，一旦某一层出现了合法字符串，本层遍历结束之后就返回结果，不再验证后面的字符串</p>
<p>DFS:</p>
<p>论坛上的高票解法，非常巧妙</p>
<p>核心思想就是记录当前出现过的左右括号数目，当右括号多于左括号时，说明从此位置向前可以删掉一个右括号，用dfs依次遍历删除此位置之前的每一个右括号，这里需要注意的有几点：</p>
<ol>
<li>对于相邻的右括号，删除哪一个都一样，所以只删除第一个就好</li>
<li>需要记录上一轮删除右括号的位置，下一轮dfs的时候不需要再删除在此之前的右括号</li>
<li>dfs到字符串末尾，说明字符串中的右括号不比左括号多了，但还需要保证左括号不比右括号多，所以需要将字符串翻转，再来一遍，最后满足条件了才可以放入结果集</li>
</ol>
<p>很难写出来的，看了答案写的，还没吃透，需要复习！！！</p>
<p>代码：</p>
<p>bfs:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> leftNum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> rightNum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</div><div class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</div><div class="line">            leftNum++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span>)&#123;</div><div class="line">            rightNum++;</div><div class="line">            <span class="keyword">if</span>(rightNum &gt; leftNum)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> leftNum == rightNum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">if</span>(s.isEmpty() || isValid(s))&#123;</div><div class="line">        res.add(s);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    queue.add(s);</div><div class="line">    set.add(s);</div><div class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">        <span class="keyword">int</span> size = queue.size();</div><div class="line">        <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</div><div class="line">            String temp = queue.poll();</div><div class="line">            <span class="keyword">if</span>(isValid(temp))&#123;</div><div class="line">                res.add(temp);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length();i++)&#123;</div><div class="line">                <span class="keyword">if</span>(temp.charAt(i) != <span class="string">'('</span> &amp;&amp; temp.charAt(i) != <span class="string">')'</span>)&#123;<span class="keyword">continue</span>;&#125;</div><div class="line">                String t = temp.substring(<span class="number">0</span>,i)+temp.substring(i+<span class="number">1</span>,temp.length());</div><div class="line">                <span class="keyword">if</span>(!set.contains(t))&#123;</div><div class="line">                    queue.add(t);</div><div class="line">                    set.add(t);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            size--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(res.size() &gt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>dfs:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveInvalidParenthess</span> </span>&#123;</div><div class="line">    <span class="comment">//idx_i: idx_i以前左右括号数量相等    ddx_j:从idx_j开始）没有被删除了</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s,<span class="keyword">int</span> idx_i,<span class="keyword">int</span> idx_j,List&lt;String&gt; res,<span class="keyword">char</span>[] ch)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> leftNum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> rightNum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx_i;i &lt; s.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == ch[<span class="number">0</span>])&#123;</div><div class="line">                leftNum++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == ch[<span class="number">1</span>])&#123;</div><div class="line">                rightNum++;</div><div class="line">                <span class="comment">//如果右括号比左括号多了</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(rightNum &lt;= leftNum)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = idx_j;j &lt;= i;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(s.charAt(j) == ch[<span class="number">1</span>] &amp;&amp; (s.charAt(j-<span class="number">1</span>) != ch[<span class="number">1</span>] || j == idx_j))&#123;</div><div class="line">                    dfs(s.substring(<span class="number">0</span>,j)+s.substring(j+<span class="number">1</span>,s.length()),i,j,res,ch);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String reversed = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</div><div class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>] == <span class="string">')'</span>)&#123;</div><div class="line">            System.out.println(reversed);</div><div class="line">            res.add(reversed);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            dfs(reversed,<span class="number">0</span>,<span class="number">0</span>,res,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">')'</span>,<span class="string">'('</span>&#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        dfs(s,<span class="number">0</span>, <span class="number">0</span>, res, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'('</span>, <span class="string">')'</span>&#125;);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        RemoveInvalidParenthess test = <span class="keyword">new</span> RemoveInvalidParenthess();</div><div class="line">        String s = <span class="string">"()())()"</span>;</div><div class="line">        List&lt;String&gt; res = test.removeInvalidParentheses(s);</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【DSP系统】Java UDP通信模拟监听模块]]></title>
      <url>/2018/01/10/%E3%80%90DSP%E7%B3%BB%E7%BB%9F%E3%80%91Java-UDP%E9%80%9A%E4%BF%A1%E6%A8%A1%E6%8B%9F%E7%9B%91%E5%90%AC%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h2 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h2><ul>
<li>无连接，不可靠，会造成数据丢失</li>
<li>速度快，因为无需进行三次握手</li>
<li>限制数据传输大小64K</li>
</ul>
<h2 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h2><p>发送端模拟ADx发送竞价请求，这里采用从文件中按行读取数据，然后发送给接收端的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">//DatagramSocket类表示用来发送和接收(udp)数据报包的套接字。</span></div><div class="line">  DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</div><div class="line"></div><div class="line">  <span class="comment">//获取本机ip地址</span></div><div class="line">  String localIp = InetAddress.getLocalHost().getHostAddress();</div><div class="line"></div><div class="line">  <span class="comment">//读取文件名</span></div><div class="line">  String fileName = <span class="string">"D://datasets//ipinyou.contest.dataset//ipinyou.contest.dataset//training2nd//training2nd//conv.20130610.txt"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// read file content from file</span></div><div class="line">  <span class="comment">//StringBuffer sb= new StringBuffer("");</span></div><div class="line">  FileReader reader = <span class="keyword">new</span> FileReader(fileName);</div><div class="line">  BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</div><div class="line">  String str = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">while</span>((str = br.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">//sb.append(str+"/n");</span></div><div class="line">    System.out.println(str);</div><div class="line"></div><div class="line">    <span class="comment">//需要发送的数据</span></div><div class="line">    <span class="comment">//byte[] buf = "Hello Udp".getBytes();</span></div><div class="line">    <span class="keyword">byte</span>[] buf = str.getBytes();</div><div class="line"></div><div class="line">    <span class="comment">//将数据传送到本地ip，端口为9999</span></div><div class="line">    DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf, buf.length, InetAddress.getByName(localIp), <span class="number">9999</span>);</div><div class="line"></div><div class="line">    <span class="comment">//发送数据报包</span></div><div class="line">    ds.send(dp);</div><div class="line">  &#125;</div><div class="line">  br.close();</div><div class="line">  reader.close();</div><div class="line"></div><div class="line">  <span class="comment">//关闭资源</span></div><div class="line">  ds.close();</div><div class="line">  System.out.println(<span class="string">"Done."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenModule</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//创建udp服务对象，指定接收端口号为9999的报包</span></div><div class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</div><div class="line"></div><div class="line">        <span class="comment">//构造空的数据报包， 用于存储待会接收到的数据报包</span></div><div class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(data, data.length);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="comment">//接收数据</span></div><div class="line">            ds.receive(dp);</div><div class="line"></div><div class="line">            <span class="comment">//显示数据</span></div><div class="line">            String ipAddress = dp.getAddress().getHostAddress();</div><div class="line">            <span class="keyword">int</span> port = dp.getPort();</div><div class="line">            String datas = <span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>, dp.getLength());</div><div class="line">            <span class="comment">//System.out.println(ipAddress + "::" + datas + "::" + port);</span></div><div class="line">            System.out.println(datas);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//ds.close();</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行时先运行接收端，后运行发送端</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[DSP系统mysql数据库搭建]]></title>
      <url>/2018/01/09/DSP%E7%B3%BB%E7%BB%9Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h2 id="MySQL操作"><a href="#MySQL操作" class="headerlink" title="MySQL操作"></a>MySQL操作</h2><h3 id="执行sql脚本方法："><a href="#执行sql脚本方法：" class="headerlink" title="执行sql脚本方法："></a>执行sql脚本方法：</h3><ol>
<li>cmd执行</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">【Mysql的bin目录】\mysql –u用户名 –p密码 –D数据库&lt;【sql脚本文件路径全名】，示例：</div><div class="line">mysql –uroot –p123456 -D database_name &lt; d:\<span class="built_in">test</span>\ss.sql</div></pre></td></tr></table></figure>
<ol>
<li>进入mysql的控制台后，使用source命令执行</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">Mysql&gt;</span><span class="bash"><span class="built_in">source</span> 【sql脚本文件的路径全名】 或 Mysql&gt;\. 【sql脚本文件的路径全名】，示例：</span></div><div class="line">source d:\test\ss.sql 或者 \. d:\test\ss.sql</div></pre></td></tr></table></figure>
<h3 id="从文件导入数据表"><a href="#从文件导入数据表" class="headerlink" title="从文件导入数据表"></a>从文件导入数据表</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">LOAD DATA LOCAL INFILE "xxx.txt" INTO TABLE xx;</div><div class="line">LOAD DATA LOCAL INFILE "xxx.txt" INTO TABLE xx (colA,colB);</div></pre></td></tr></table></figure>
<h3 id="auto-increment实现自动递增编号"><a href="#auto-increment实现自动递增编号" class="headerlink" title="auto_increment实现自动递增编号"></a>auto_increment实现自动递增编号</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">1.建表</div><div class="line">CREATE TABLE IF NOT EXISTS `Bid`(</div><div class="line">  `ID` bigint primary key not NULL auto_increment,</div><div class="line">  `BidId` varchar(255) DEFAULT NULL,</div><div class="line">)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;</div><div class="line"><span class="meta">#</span><span class="bash"> AUTO_INCREMENT=0设置开始值</span></div><div class="line">2.导入数据</div><div class="line">LOAD DATA LOCAL INFILE "xxx.txt" INTO TABLE Bid (BidId);</div><div class="line">！！需要注意：利用auto_increment生成的列不能导入数据，只导入后面的字段</div></pre></td></tr></table></figure>
<h3 id="从一个表选取部分数据插入到另一个表"><a href="#从一个表选取部分数据插入到另一个表" class="headerlink" title="从一个表选取部分数据插入到另一个表"></a>从一个表选取部分数据插入到另一个表</h3><p>两个表都带有auto_increment列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DROP TABLE IF EXISTS `bid_1458`;</div><div class="line">CREATE TABLE bid_1458 LIKE bid;</div><div class="line">insert into bid_1458 (colA,colB) select colA,colB from bid where AdvertiserID=1458;</div></pre></td></tr></table></figure>
<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><h3 id="shell脚本调用sql"><a href="#shell脚本调用sql" class="headerlink" title="shell脚本调用sql"></a>shell脚本调用sql</h3><ol>
<li>脚本中执行mysql命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">1、通过mysql的 -e 参数实现</div><div class="line">mysql -uuser -ppasswd -e "show databases;show databases;"</div><div class="line"></div><div class="line">2、通过echo实现</div><div class="line">echo "show databases;show databases"|mysql -uuser -ppassword</div><div class="line"></div><div class="line">3、通过EOF指定要执行的sql</div><div class="line">mysql -uroot  -ppassword &lt;&lt;EOF</div><div class="line">show databases;</div><div class="line">show databases;</div><div class="line">EOF</div><div class="line"></div><div class="line">关于EOF的说明：</div><div class="line">在主shell执行命令，进入其他的命令（如mysql），后面的输入，想作为其他命令（如mysql）的输入，而不是主shell的输入，使用&lt;&lt;EOF，告诉主shell，后续的输入，是其他命令或者子shell的输入，直到遇到EOF为止，再回到主shell。</div></pre></td></tr></table></figure>
<ol>
<li>脚本中执行mysql的sql文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">1. mysql -uroot -ppassword -e "source /root/temp.sql" </div><div class="line">2. mysql -uroot -ppassword &lt;/root/temp.sql</div></pre></td></tr></table></figure>
<h3 id="shell脚本字符串连接"><a href="#shell脚本字符串连接" class="headerlink" title="shell脚本字符串连接"></a>shell脚本字符串连接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">AAA="abc"</div><div class="line">BBB="def"</div><div class="line">CCC=$AAA$BBB"ghi"</div><div class="line">echo $ccc</div></pre></td></tr></table></figure>
<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">echo $contetn &gt; write.txt#写入</div><div class="line">echo $contetn &gt;&gt; write.txt#追加写入</div></pre></td></tr></table></figure>
<h2 id="ipinyou2nd数据分析"><a href="#ipinyou2nd数据分析" class="headerlink" title="ipinyou2nd数据分析"></a>ipinyou2nd数据分析</h2><h3 id="广告主"><a href="#广告主" class="headerlink" title="广告主"></a>广告主</h3><p>一共有5个广告主，其中有转化数据的只有3个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; select distinct AdvertiserId from click;</div><div class="line">+--------------+</div><div class="line">| AdvertiserId |</div><div class="line">+--------------+</div><div class="line">|         3476 |</div><div class="line">|         3358 |</div><div class="line">|         3386 |</div><div class="line">|         3427 |</div><div class="line">|         1458 |</div><div class="line">+--------------+</div><div class="line">5 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select distinct AdvertiserId from conv;</div><div class="line">+--------------+</div><div class="line">| AdvertiserId |</div><div class="line">+--------------+</div><div class="line">|         3358 |</div><div class="line">|         3476 |</div><div class="line">|         1458 |</div><div class="line">+--------------+</div><div class="line">3 rows in set (0.06 sec)</div><div class="line">其中3476的数据相对较少</div></pre></td></tr></table></figure>
<p>AdvertiserID_3476</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">bid:<span class="number">6712268</span></div><div class="line">impression:<span class="number">1970360</span></div><div class="line">click:<span class="number">1092</span></div><div class="line">conv:<span class="number">27</span></div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法基础班】数与数组]]></title>
      <url>/2017/12/24/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E6%95%B0%E4%B8%8E%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><ol>
<li>Sorted Array<ul>
<li>merge two sorted array<ul>
<li>Intersection of Two Arrays</li>
<li>Multiply Two Arrays</li>
</ul>
</li>
<li>median of two sorted array</li>
</ul>
</li>
<li>Subarray<ul>
<li>Best Time to Buy and Sekk Stoocks I,II,III</li>
<li>Subarrat I,II,III,IV</li>
</ul>
</li>
<li>Two pointers<ul>
<li>Two Sum,3Sum,4Sum,kSum,3Sum Closest</li>
<li>Partition Array</li>
</ul>
</li>
</ol>
<h1 id="排序数组Sorted-Array"><a href="#排序数组Sorted-Array" class="headerlink" title="排序数组Sorted Array"></a>排序数组Sorted Array</h1><h3 id="Merge-Sorted-Array"><a href="#Merge-Sorted-Array" class="headerlink" title="Merge Sorted Array"></a><a href="https://leetcode.com/problems/merge-sorted-array" target="_blank" rel="external">Merge Sorted Array</a></h3><blockquote>
<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong><br>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>. The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</p>
</blockquote>
<p>给定两个排序数组nums1,nums2，合并到nums1</p>
<p>三个指针i,j,k分别指向nums1元素结尾，nums2结尾，nums1数组结尾</p>
<p>依次向前遍历，比较大小，插入nums1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> k = m + n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</div><div class="line">                nums1[k] = nums1[i];</div><div class="line">                i--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                nums1[k] = nums2[j];</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            k--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">while</span>(j &gt;=<span class="number">0</span>)&#123;</div><div class="line">                nums1[k] = nums2[j];</div><div class="line">                j--;</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(j &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">while</span>(i &gt;=<span class="number">0</span>)&#123;</div><div class="line">                nums1[k] = nums1[i];</div><div class="line">                i--;</div><div class="line">                k--</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Intersection-of-Two-Arrays"><a href="#Intersection-of-Two-Arrays" class="headerlink" title="Intersection of Two Arrays"></a><a href="https://leetcode.com/problems/intersection-of-two-arrays" target="_blank" rel="external">Intersection of Two Arrays</a></h3><blockquote>
<p>Given two arrays, write a function to compute their intersection.</p>
<p><strong>Example:</strong><br>Given <em>nums1</em> = <code>[1, 2, 2, 1]</code>, <em>nums2</em> = <code>[2, 2]</code>, return <code>[2]</code>.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Each element in the result must be unique.</li>
<li>The result can be in any order.</li>
</ul>
</blockquote>
<p>给定两个数组，返回交集，返回的交集中在原数组中的相对位置保持不变，元素只出现一次。</p>
<p>方法:</p>
<ol>
<li>把两个数组排序</li>
<li>两指针分别遍历两个数组比较大小，如果两指针指向的元素相等，且与result中前一个元素不相等，加入result</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</div><div class="line">        <span class="comment">//排序</span></div><div class="line">        Arrays.sort(nums1);</div><div class="line">        Arrays.sort(nums2);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</div><div class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</div><div class="line">            <span class="keyword">if</span>(nums1[i] == nums2[j])&#123;</div><div class="line">                <span class="keyword">if</span>(index == <span class="number">0</span> || nums1[i] != result[index-<span class="number">1</span>])&#123;</div><div class="line">                    result[index] = nums1[i];</div><div class="line">                    index++;</div><div class="line">                &#125;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt;nums2[j])&#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                j++ ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[index];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">0</span>;idx &lt; index;idx++) &#123;</div><div class="line">            res[idx] = result[idx];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Sparse-Matrix-Multiplication"><a href="#Sparse-Matrix-Multiplication" class="headerlink" title="Sparse Matrix Multiplication"></a><a href="https://leetcode.com/problems/sparse-matrix-multiplication/" target="_blank" rel="external">Sparse Matrix Multiplication</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given two <a href="https://en.wikipedia.org/wiki/Sparse_matrix" target="_blank" rel="external">sparse matrices</a> <strong>A</strong> and <strong>B</strong>, return the result of <strong>AB</strong>.</p>
<p>You may assume that <strong>A</strong>‘s column number is equal to <strong>B</strong>‘s row number.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; A = [</div><div class="line">&gt;   [ 1, 0, 0],</div><div class="line">&gt;   [-1, 0, 3]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt; B = [</div><div class="line">&gt;   [ 7, 0, 0 ],</div><div class="line">&gt;   [ 0, 0, 0 ],</div><div class="line">&gt;   [ 0, 0, 1 ]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div><div class="line">&gt;      |  1 0 0 |   | 7 0 0 |   |  7 0 0 |</div><div class="line">&gt; AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |</div><div class="line">&gt;                   | 0 0 1 |</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>逐个遍历计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</div><div class="line">  <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B[<span class="number">0</span>].length];</div><div class="line">  <span class="keyword">int</span> A_rows = A.length;</div><div class="line">  <span class="keyword">int</span> A_cols = A[<span class="number">0</span>].length;</div><div class="line">  <span class="keyword">int</span> B_rows = B.length;</div><div class="line">  <span class="keyword">int</span> B_cols = B[<span class="number">0</span>].length;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A_rows;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B_cols;j++)&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; A_cols;k++)&#123;</div><div class="line">        <span class="keyword">if</span>(A[i][k] != <span class="number">0</span> &amp;&amp; B[k][j] != <span class="number">0</span>)&#123;</div><div class="line">          result[i][j] = result[i][j] + A[i][k] * B[k][j];</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优化</p>
<ol>
<li>遍历矩阵B，把B中值不为0的位置（注意是位置不是值）按每一列存下来</li>
<li>遍历A矩阵，寻找B中对应位置不为0的元素做乘积</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] multiply2(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</div><div class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; nonZeroIndexB = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; nonZeroIndexA = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B[<span class="number">0</span>].length];</div><div class="line">    <span class="keyword">int</span> A_rows = A.length;</div><div class="line">    <span class="keyword">int</span> A_cols = A[<span class="number">0</span>].length;</div><div class="line">    <span class="keyword">int</span> B_rows = B.length;</div><div class="line">    <span class="keyword">int</span> B_cols = B[<span class="number">0</span>].length;</div><div class="line"></div><div class="line">    <span class="comment">//按列将B中的非零元素index存储下来</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>;col &lt; B_cols;col++)&#123;</div><div class="line">        ArrayList&lt;Integer&gt; rowIndex = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; B_rows;row++)&#123;</div><div class="line">            <span class="keyword">if</span>(B[row][col] != <span class="number">0</span>)&#123;</div><div class="line">                rowIndex.add(row);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        nonZeroIndexB.add(rowIndex);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//按行将A中的非零元素index存储下来</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>;row &lt; A_rows;row++)&#123;</div><div class="line">        ArrayList&lt;Integer&gt; rowIndex = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; A_cols;col++)&#123;</div><div class="line">            <span class="keyword">if</span>(A[row][col] != <span class="number">0</span>)&#123;</div><div class="line">                rowIndex.add(col);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        nonZeroIndexA.add(rowIndex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遍历矩阵A.B</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A_rows;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B_cols;j++)&#123;</div><div class="line">           <span class="keyword">int</span> ii = <span class="number">0</span>;</div><div class="line">           <span class="keyword">int</span> jj = <span class="number">0</span>;;</div><div class="line">           <span class="keyword">while</span>(ii &lt; nonZeroIndexA.get(i).size() &amp;&amp; jj &lt; nonZeroIndexB.get(j).size())&#123;</div><div class="line">               <span class="keyword">if</span>(nonZeroIndexA.get(i).get(ii) == nonZeroIndexB.get(j).get(jj))&#123;</div><div class="line">                   result[i][j] += A[i][nonZeroIndexA.get(i).get(ii)] * B[nonZeroIndexB.get(j).get(jj)][j];</div><div class="line">                   ii++;</div><div class="line">                   jj++;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(nonZeroIndexA.get(i).get(ii) &lt; nonZeroIndexB.get(j).get(jj))&#123;</div><div class="line">                   ii++;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">else</span> &#123;</div><div class="line">                   jj++;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Kth-Largest-Element-in-an-Array"><a href="#Kth-Largest-Element-in-an-Array" class="headerlink" title="Kth Largest Element in an Array"></a><a href="https://leetcode.com/problems/kth-largest-element-in-an-array" target="_blank" rel="external">Kth Largest Element in an Array</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>For example,<br>Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.</p>
</blockquote>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<p>在前面的课程里讲过可以利用堆Heap</p>
<p>方法二：</p>
<p>利用quickselect的方法，来源于quicksort</p>
<p>quicksort核心思想：每次选一个数字作为基准，比它小的放到左边，比它大的放到右边，然后再递归对左右两边数组做quicksort</p>
<p>步骤：从数组中选取一个数字作为“基准”pivot，找第K大的元素时可以跟基准比较：</p>
<ol>
<li>pivot左边元素个数 = K-1，该基准元素就是第K大元素</li>
<li>pivot左边元素个数 &gt; K-1，丢弃右边全部元素，在左边元素中继续寻找</li>
<li>pivot左边元素个数 &lt; K-1，丢弃左边全部元素，在右边元素中继续寻找</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickselect</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">  <span class="comment">//快速排序，寻找pivot应该放置的位置</span></div><div class="line">  <span class="keyword">int</span> i = start;</div><div class="line">  <span class="keyword">int</span> j = end;</div><div class="line">  <span class="keyword">int</span> pivot = nums[i];</div><div class="line">  <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= pivot)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    nums[i] = nums[j];</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt;= pivot)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    nums[j]</div><div class="line">  nums[i] = pivot;</div><div class="line">  <span class="comment">//start~i-1的元素都小于等于pivot，一共用i-start个</span></div><div class="line">  <span class="comment">//i+1到end的元素都大于等于pivot，一共end-i个</span></div><div class="line">  <span class="keyword">if</span>(i-start == k-<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> nums[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(i-start &gt; k-<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> quickselect(nums,start,i-<span class="number">1</span>,k);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> quickselect(nums,i+<span class="number">1</span>,end,k-(i-start+<span class="number">1</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> quickselect(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,nums.length+<span class="number">1</span>-k);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Median"><a href="#Median" class="headerlink" title="Median"></a><a href="http://www.lintcode.com/en/problem/median/" target="_blank" rel="external">Median</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a unsorted array with integers, find the median of it.</p>
<p>A median is the middle number of the array after it is sorted.</p>
<p>If there are even numbers in the array, return the <code>N/2</code>-th number after sorted.</p>
<p>Example</p>
<p>Given <code>[4, 5, 1, 2, 3]</code>, return <code>3</code>.</p>
<p>Given <code>[7, 9, 4, 5]</code>, return <code>5</code>.</p>
</blockquote>
<p>返回给定数组中位数</p>
<p>和上一题思路一样，K=nums.length/2</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = start;</div><div class="line">    <span class="keyword">int</span> j = end;</div><div class="line">    <span class="keyword">int</span> pivot = nums[i];</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= pivot)&#123;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        nums[i] = nums[j];</div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivot)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        nums[j] = nums[i];</div><div class="line">    &#125;</div><div class="line">    nums[i] = pivot;</div><div class="line">    <span class="keyword">if</span>(i - start == k-<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i-start &gt; k-<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> quickSelect(nums,start,i-<span class="number">1</span>,k);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> quickSelect(nums,i+<span class="number">1</span>,end,k-(i-start+<span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">median</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">return</span> quickSelect(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,nums.length - nums.length/<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays" target="_blank" rel="external">Median of Two Sorted Arrays</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums1 = [1, 3]</div><div class="line">&gt; nums2 = [2]</div><div class="line">&gt;</div><div class="line">&gt; The median is 2.0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums1 = [1, 2]</div><div class="line">&gt; nums2 = [3, 4]</div><div class="line">&gt;</div><div class="line">&gt; The median is (2 + 3)/2 = 2.5</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>这道题在二分法里面讲过了，先将找中点的问题转化成找第k大的问题，然后继续沿用二分法中的思路。详见<a href="https://siyaozhang.github.io/2017/12/07/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%B3%95/" target="_blank" rel="external">【九章算法基础班】二分法</a></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthInTwo</span><span class="params">(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span> start1,<span class="keyword">int</span>[] nums2,<span class="keyword">int</span> start2,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"></div><div class="line">      <span class="comment">//end1中没有元素了，返回nums2中的第k个</span></div><div class="line">      <span class="keyword">if</span>(start1 &gt;= nums1.length)&#123;</div><div class="line">          <span class="keyword">return</span> nums2[start2+k-<span class="number">1</span>];</div><div class="line"></div><div class="line">      &#125;</div><div class="line">      <span class="comment">//end2中没有元素了，返回nums1中的第k个</span></div><div class="line">      <span class="keyword">if</span>(start2 &gt;= nums2.length)&#123;</div><div class="line">          <span class="keyword">return</span> nums1[start1+k-<span class="number">1</span>];</div><div class="line">      &#125;</div><div class="line"><span class="comment">//边界条件，递归出口</span></div><div class="line">      <span class="keyword">if</span>(k ==<span class="number">1</span>)&#123;</div><div class="line">          <span class="keyword">return</span> Math.min(nums1[start1],nums2[start2]);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//nums1中剩余元素不足K/2个,nums2的前K/2个元素一定在前k个中，</span></div><div class="line">      <span class="comment">// 去掉nums2的前K/2个元素</span></div><div class="line">      <span class="keyword">if</span>(nums1.length - start1 &lt; k/<span class="number">2</span>)&#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1,nums2,start2+k/<span class="number">2</span>,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(nums2.length - start2 &lt; k/<span class="number">2</span>)&#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1+k/<span class="number">2</span>,nums2,start2,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">     </div><div class="line">      <span class="keyword">if</span>(nums1[start1 + k/<span class="number">2</span> - <span class="number">1</span>] &lt; nums2[start2 + k/<span class="number">2</span> - <span class="number">1</span>])&#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1+k/<span class="number">2</span>,nums2,start2,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1,nums2,start2+k/<span class="number">2</span>,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> len = nums1.length+nums2.length;</div><div class="line">      <span class="comment">//偶数个元素</span></div><div class="line">      <span class="keyword">if</span>(len % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">          <span class="keyword">int</span> k1 = findKthInTwo(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,len/<span class="number">2</span>);</div><div class="line">          <span class="keyword">int</span> k2 = findKthInTwo(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,len/<span class="number">2</span>+<span class="number">1</span>);</div><div class="line">          <span class="keyword">return</span> (<span class="keyword">double</span>) (k1+k2)/<span class="number">2.0</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//奇数个元素</span></div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,len/<span class="number">2</span>+<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="子数组-Subarray"><a href="#子数组-Subarray" class="headerlink" title="子数组 Subarray"></a>子数组 Subarray</h1><h3 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a><a href="https://leetcode.com/problems/maximum-subarray" target="_blank" rel="external">Maximum Subarray</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br>the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.</p>
</blockquote>
<p>最大子数组，找到子数组（连续），和最大</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>前缀和数组prefixSum：<code>sum[i] = SUM(nums[0~i])</code></p>
<p>数组中从i到j的数组和：<code>sum[i~j] = sum[j]-sum[i-1]</code></p>
<p>以当前位置i为结尾的最大子数组是sum[i]-min(sum[0]~sum[i-1])</p>
<p>所以思路就是：从前向后遍历，三个变量存储信息：</p>
<ol>
<li>从起点到当前元素的和，前缀和</li>
<li>截止目前的最大子数组</li>
<li>前面的最小和</li>
</ol>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//记录前缀和</span></div><div class="line">  <span class="keyword">int</span> min_before = <span class="number">0</span>;<span class="comment">//记录前面最小和,初始化为0,</span></div><div class="line">  <span class="keyword">int</span> max = Integer.MIN_VALUE;<span class="comment">//记录最大子数组</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</div><div class="line">    sum += nums[i];<span class="comment">//从0到当前元素的前缀和</span></div><div class="line">    max = Math.max(max,sum-min_before);<span class="comment">//更新最大子数组</span></div><div class="line">    min_before = Math.min(min_before,sum);<span class="comment">//更新前面最小和</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二维数组的Maximum-Subarray"><a href="#二维数组的Maximum-Subarray" class="headerlink" title="二维数组的Maximum Subarray"></a>二维数组的Maximum Subarray</h3><p>前缀和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">  i-1  i           x</div><div class="line">   *---*---*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line">j-1*---*---*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line"> j *-[i,j]-*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line">   *---*---*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line">y  *---*---*---*-[x,y]</div><div class="line"></div><div class="line"></div><div class="line">sum[i,j - x,y] = sum[x,y] - sum[x,j-1] - sum[i-1,y] + sum[i-1,j-1]</div></pre></td></tr></table></figure>
<h3 id="Range-Sum-Query-2D-Immutable"><a href="#Range-Sum-Query-2D-Immutable" class="headerlink" title="Range Sum Query 2D - Immutable"></a><a href="https://leetcode.com/problems/range-sum-query-2d-immutable" target="_blank" rel="external">Range Sum Query 2D - Immutable</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a 2D matrix <em>matrix</em>, find the sum of the elements inside the rectangle defined by its upper left corner (<em>row</em>1, <em>col</em>1) and lower right corner (<em>row</em>2, <em>col</em>2).</p>
<p><img src="https://leetcode.com/static/images/courses/range_sum_query_2d.png" alt="Range Sum Query 2D"><br>The above rectangle (with the red border) is defined by (row1, col1) = <strong>(2, 1)</strong> and (row2, col2) = <strong>(4, 3)</strong>, which contains sum = <strong>8</strong>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given matrix = [</div><div class="line">&gt;   [3, 0, 1, 4, 2],</div><div class="line">&gt;   [5, 6, 3, 2, 1],</div><div class="line">&gt;   [1, 2, 0, 1, 5],</div><div class="line">&gt;   [4, 1, 0, 1, 7],</div><div class="line">&gt;   [1, 0, 3, 0, 5]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt; sumRegion(2, 1, 4, 3) -&gt; 8</div><div class="line">&gt; sumRegion(1, 1, 2, 2) -&gt; 11</div><div class="line">&gt; sumRegion(1, 2, 2, 4) -&gt; 12</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>You may assume that the matrix does not change.</li>
<li>There are many calls to <em>sumRegion</em> function.</li>
<li>You may assume that <em>row</em>1 ≤ <em>row</em>2 and <em>col</em>1 ≤ <em>col</em>2.</li>
</ol>
</blockquote>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>利用二维数组的前缀和，给定左上和右下的坐标为(row1, col1)， (row2, col2)</p>
<p>那么和为sum[i,j - x,y] = sum[x,y] - sum[x,j-1] - sum[i-1,y] + sum[i-1,j-1]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] Matrix;</div><div class="line">    <span class="keyword">int</span>[][] Sum;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.Matrix = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">this</span>.Sum = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line">        Sum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; matrix.length;i++)&#123;</div><div class="line">            Sum[i][<span class="number">0</span>] = Sum[i-<span class="number">1</span>][<span class="number">0</span>] + matrix[i][<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; matrix[<span class="number">0</span>].length;i++)&#123;</div><div class="line">            Sum[<span class="number">0</span>][i] = Sum[<span class="number">0</span>][i-<span class="number">1</span>] + matrix[<span class="number">0</span>][i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; matrix.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; matrix[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                Sum[i][j] = Sum[i-<span class="number">1</span>][j] + Sum[i][j-<span class="number">1</span>] - Sum[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(row1 == <span class="number">0</span> &amp;&amp; col1 == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Sum[row2][col2];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(row1 == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Sum[row2][col2] - Sum[row2][col1 -<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(col1 == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Sum[row2][col2] - Sum[row1-<span class="number">1</span>][col2];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Sum[row2][col2] - Sum[row1-<span class="number">1</span>][col2] - Sum[row2][col1 -<span class="number">1</span>] + Sum[row1-<span class="number">1</span>][col1 -<span class="number">1</span> ];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Range-Sum-Query-2D-Mutable"><a href="#Range-Sum-Query-2D-Mutable" class="headerlink" title="Range Sum Query 2D - Mutable"></a><a href="https://leetcode.com/problems/range-sum-query-2d-mutable" target="_blank" rel="external">Range Sum Query 2D - Mutable</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>Given a 2D matrix <em>matrix</em>, find the sum of the elements inside the rectangle defined by its upper left corner (<em>row</em>1, <em>col</em>1) and lower right corner (<em>row</em>2, <em>col</em>2).</p>
<p><img src="https://leetcode.com/static/images/courses/range_sum_query_2d.png" alt="Range Sum Query 2D"><br>The above rectangle (with the red border) is defined by (row1, col1) = <strong>(2, 1)</strong> and (row2, col2) = <strong>(4, 3)</strong>, which contains sum = <strong>8</strong>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Given matrix = [</div><div class="line">  [3, 0, 1, 4, 2],</div><div class="line">  [5, 6, 3, 2, 1],</div><div class="line">  [1, 2, 0, 1, 5],</div><div class="line">  [4, 1, 0, 1, 7],</div><div class="line">  [1, 0, 3, 0, 5]</div><div class="line">]</div><div class="line"></div><div class="line">sumRegion(2, 1, 4, 3) -&gt; 8</div><div class="line">update(3, 2, 2)</div><div class="line">sumRegion(2, 1, 4, 3) -&gt; 10</div></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>The matrix is only modifiable by the <em>update</em> function.</li>
<li>You may assume the number of calls to <em>update</em> and <em>sumRegion</em> function is distributed evenly.</li>
<li>You may assume that <em>row</em>1 ≤ <em>row</em>2 and <em>col</em>1 ≤ <em>col</em>2.</li>
</ol>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> delta = val  - Matrix[row][col];<span class="comment">//更新值和原来差值</span></div><div class="line">  <span class="keyword">this</span>.Matrix[row][col] = val;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = row;i &lt; Matrix.length;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = col;j  &lt; Matrix[<span class="number">0</span>].length;j++)&#123;</div><div class="line">      Sum[i][j] += delta;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最小子数组"><a href="#最小子数组" class="headerlink" title="最小子数组"></a><a href="http://www.lintcode.com/en/problem/minimum-subarray/" target="_blank" rel="external">最小子数组</a></h3><blockquote>
<p>Given an array of integers, find the subarray with smallest sum.</p>
<p>Return the sum of the subarray.</p>
<p>Example</p>
<p>For <code>[1, -1, -2, 1]</code>, return <code>-3</code>.</p>
</blockquote>
<p>和最大子数组相同的思路</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArray</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> minsub = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">int</span> maxbefore = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size();i++)&#123;</div><div class="line">        sum += nums.get(i);</div><div class="line">        minsub = Math.min(minsub,sum - maxbefore);</div><div class="line">        maxbefore = Math.max(maxbefore,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minsub;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Minimum-Size-Subarray-Sum"><a href="#Minimum-Size-Subarray-Sum" class="headerlink" title="Minimum Size Subarray Sum"></a><a href="https://leetcode.com/problems/minimum-size-subarray-sum" target="_blank" rel="external">Minimum Size Subarray Sum</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <strong>contiguous</strong> subarray of which the sum ≥ <strong>s</strong>. If there isn’t one, return 0 instead.</p>
<p>For example, given the array <code>[2,3,1,2,4,3]</code> and <code>s = 7</code>,<br>the subarray <code>[4,3]</code> has the minimal length under the problem constraint.</p>
</blockquote>
<p>求和大于等于s的连续子数组的最小长度</p>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>用滑动窗口来做。</p>
<p>两个指针i和j分别指向子数组的头和尾</p>
<p>sumi代表从nums[0]到nums[i]的和</p>
<p>sumj代表从nums[0]到nums[j]的和</p>
<p>如果sumj-sumi &gt;= s，将i向后移动，直至sumj-sumi &lt; s，此时子数组和&gt;=s的长度为j-i+2，更新最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sumj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sumi = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> minlen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length;j++)&#123;</div><div class="line">            sumj += nums[j];</div><div class="line">            <span class="keyword">int</span> delta = sumj - sumi;</div><div class="line">            <span class="keyword">while</span>(delta &gt;= s)&#123;</div><div class="line">                sumi += nums[i];</div><div class="line">                i++;</div><div class="line">                delta = sumj - sumi;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//跳出时sumj-sumi &lt; s</span></div><div class="line">            <span class="keyword">if</span>(sumj &gt;= s)&#123;</div><div class="line">                minlen = Math.min(minlen,j-i+<span class="number">2</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(minlen != Integer.MAX_VALUE)&#123;</div><div class="line">            <span class="keyword">return</span> minlen;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Maximum-Subarray-II"><a href="#Maximum-Subarray-II" class="headerlink" title="Maximum Subarray II"></a><a href="http://www.lintcode.com/en/problem/maximum-subarray-ii/" target="_blank" rel="external">Maximum Subarray II</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array of integers, find two non-overlapping subarrays which have the largest sum.<br>The number in each subarray should be contiguous.<br>Return the largest sum.</p>
<p>Example</p>
<p>For given <code>[1, 3, -1, 2, -1, 2]</code>, the two subarrays are <code>[1, 3]</code> and <code>[2, -1, 2]</code> or <code>[1, 3, -1, 2]</code> and <code>[2]</code>, they both have the largest sum <code>7</code>.</p>
</blockquote>
<p>求数组中两个不相交的最大子数组的和最大</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>两个数组不相交，两个数组中间必然存在一个分割线，分割线左边求一个maxsubarray，右边求一个maxsubarray，两个子数组的和加在一起，就是当前分割线的最大子数组和</p>
<p>从左向右遍历分割线，分别求左边和右边的最大子数组，求和，记录最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MaxSubarray</span><span class="params">(List&lt;Integer&gt; nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (start == end) &#123;</div><div class="line">        <span class="keyword">return</span> nums.get(start);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">int</span> minbefore = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= end;i++)&#123;</div><div class="line">        sum += nums.get(i);</div><div class="line">        maxSum = Math.max(maxSum,sum - minbefore);</div><div class="line">        minbefore = Math.min(minbefore,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxSum;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxTwoSubArrays</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size()-<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">int</span> sum = MaxSubarray(nums,<span class="number">0</span>,i) + MaxSubarray(nums,i+<span class="number">1</span>,nums.size()-<span class="number">1</span>);</div><div class="line">        maxSum = Math.max(maxSum,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxSum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Maximum-Product-Subarray"><a href="#Maximum-Product-Subarray" class="headerlink" title="Maximum Product Subarray"></a><a href="https://leetcode.com/problems/maximum-product-subarray" target="_blank" rel="external">Maximum Product Subarray</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array <code>[2,3,-2,4]</code>,<br>the contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.</p>
</blockquote>
<p>求乘积最大的子数组</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>子数组乘积最大值的可能性为：累乘的最大值碰到了一个正数；或者，累乘的最小值（负数），碰到了一个负数。所以每次要保存累乘的最大（正数）和最小值（负数）。同时还有一个选择起点的逻辑，如果之前的最大和最小值同当前元素相乘之后，没有当前元素大（或小）那么当前元素就可作为新的起点，比如遇到了0。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//局部最大最小</span></div><div class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</div><div class="line">    <span class="comment">//全局最大</span></div><div class="line">    <span class="keyword">int</span> global_max = nums[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="comment">//计算局部最大和最小与当前数字的乘积</span></div><div class="line">        <span class="keyword">int</span> a = max * nums[i];</div><div class="line">        <span class="keyword">int</span> b = min * nums[i];</div><div class="line">        <span class="comment">//更新局部最大和最小，必在a,b,nums[i]之中</span></div><div class="line">        max = Math.max(Math.max(a,b),nums[i]);</div><div class="line">        min = Math.min(Math.min(a,b),nums[i]);</div><div class="line">        <span class="comment">//更新全局最大</span></div><div class="line">        global_max = Math.max(global_max,max);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>  global_max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最大子数组差"><a href="#最大子数组差" class="headerlink" title="最大子数组差"></a><a href="http://www.lintcode.com/en/problem/maximum-subarray-difference/" target="_blank" rel="external">最大子数组差</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array with integers.</p>
<p>Find two <em>non-overlapping</em> subarrays <em>A</em> and <em>B</em>, which <code>|SUM(A) - SUM(B)|</code> is the largest.</p>
<p>Return the largest difference.</p>
<p>The subarray should contain at least one number</p>
<p>Example</p>
<p>For <code>[1, 2, -3, 1]</code>, return <code>6</code>.</p>
</blockquote>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>两个不相交的数字，中间必然存在分割线，对分割线左右两边一编求最大一边求最小，<code>|SUM(A) - SUM(B)|</code>最大有两种情况：</p>
<ol>
<li>max_sum(A) - min_sum(B)</li>
<li>min_sum(A) - max_sum(B)</li>
</ol>
<p>遍历分割线，计算，取1,2的绝对值的最大值</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarray</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(start == end)&#123;<span class="keyword">return</span> nums[start];&#125;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> min_before = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt;= end;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        max = Math.max(max,sum - min_before);</div><div class="line">        min_before = Math.min(min_before,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubarray</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(start == end)&#123;<span class="keyword">return</span> nums[start];&#125;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> max_before = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt;= end;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        min = Math.min(min,sum - max_before);</div><div class="line">        max_before = Math.max(max_before,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDiffSubArrays</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> max_abs = Integer.MIN_VALUE;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length-<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">int</span> left_max = maxSubarray(nums,<span class="number">0</span>,i);</div><div class="line">        <span class="keyword">int</span> left_min = minSubarray(nums,<span class="number">0</span>,i);</div><div class="line">        <span class="keyword">int</span> right_max = maxSubarray(nums,i+<span class="number">1</span>,nums.length-<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> right_min = minSubarray(nums,i+<span class="number">1</span>,nums.length-<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> max = Math.max(Math.abs(left_max - right_min),Math.abs(left_min - right_max));</div><div class="line">        max_abs = Math.max(max_abs,max);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max_abs;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="子数组之和"><a href="#子数组之和" class="headerlink" title="子数组之和"></a><a href="http://www.lintcode.com/en/problem/subarray-sum/" target="_blank" rel="external">子数组之和</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an integer array, find a subarray where the sum of numbers is <strong>zero</strong>. Your code should return the index of the first number and the index of the last number.</p>
<p>There is at least one subarray that it’s sum equals to zero.</p>
<p>Given <code>[-3, 1, 2, -3, 4]</code>, return <code>[0, 2]</code> or <code>[1, 3]</code>.</p>
</blockquote>
<p>返回和为0的子数组开始和结尾所对应的idx</p>
<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>计算出每一个位置的前缀和，然后二重循环计算每一个子数组的和sum[i,j]，遇到有等于0的就返回，时间复杂度<script type="math/tex">O(n^2)</script>，超时了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] prefixSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">            prefixSum[i] = sum;</div><div class="line">            sum += nums[i];</div><div class="line">        &#125;</div><div class="line">        prefixSum[nums.length] = sum;</div><div class="line">        System.out.println(prefixSum);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nums.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>;j &gt;= <span class="number">0</span>;j--)&#123;</div><div class="line">                <span class="keyword">if</span>(prefixSum[i] - prefixSum[j] == <span class="number">0</span>)&#123;</div><div class="line">                    result.add(j);</div><div class="line">                    result.add(i-<span class="number">1</span>);</div><div class="line">                    <span class="keyword">return</span> result;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>改进，利用HashMap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">根据给的例子：[-3, 1, 2, -3, 4]，其累加和:</div><div class="line"></div><div class="line">nums [-3, 1,  2, -3,  4]</div><div class="line">      0   1   2   3   4</div><div class="line">sum  [-3，-2， 0， -3， 1]</div><div class="line">       i           j</div><div class="line">1. i=2出现了一个数0 -&gt; sum[0,i] = 0  ,是一个答案</div><div class="line"></div><div class="line">2. 同时在i,j发现两个-3   -&gt; sum[i+1,j] = 0 ,是一个答案</div><div class="line">因此前缀和中如果有0或者有两个相等的，即为所求</div></pre></td></tr></table></figure>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">            result.add(<span class="number">0</span>);</div><div class="line">            result.add(i);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(map.containsKey(sum))&#123;</div><div class="line">            result.add(map.get(sum)+<span class="number">1</span>);</div><div class="line">            result.add(i);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        map.put(sum,i);<span class="comment">//key是前缀和，value是idx</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Subarray-Sum-Equals-K"><a href="#Subarray-Sum-Equals-K" class="headerlink" title="Subarray Sum Equals K"></a><a href="https://leetcode.com/problems/subarray-sum-equals-k" target="_blank" rel="external">Subarray Sum Equals K</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array of integers and an integer <strong>k</strong>, you need to find the total number of continuous subarrays whose sum equals to <strong>k</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:nums = [1,1,1], k = 2</div><div class="line">&gt; Output: 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>The length of the array is in range [1, 20,000].</li>
<li>The range of numbers in the array is [-1000, 1000] and the range of the integer <strong>k</strong> is [-1e7, 1e7].</li>
</ol>
</blockquote>
<h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>跟上一题类似的思路，利用HashMap，存储前缀和的值和出现的次数，当有相同的前缀和出现时，result增加的数量就是当前map里面改值出现的次数。</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="comment">//如果之前出现过该值</span></div><div class="line">            <span class="keyword">if</span>(map.containsKey(sum-k))&#123;</div><div class="line">                result += map.get(sum-k);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(map.containsKey(sum))&#123;</div><div class="line">                map.put(sum,map.get(sum)+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果之前没有出现过该值，加入map</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                map.put(sum,<span class="number">1</span>);<span class="comment">//key是前缀和，value是出现次数，初始化为1</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Maximum-Size-Subarray-Sum-Equals-k"><a href="#Maximum-Size-Subarray-Sum-Equals-k" class="headerlink" title="Maximum Size Subarray Sum Equals k"></a><a href="https://leetcode.com/problems/maximum-size-subarray-sum-equals-k" target="_blank" rel="external">Maximum Size Subarray Sum Equals k</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array <em>nums</em> and a target value <em>k</em>, find the maximum length of a subarray that sums to <em>k</em>. If there isn’t one, return 0 instead.</p>
<p><strong>Note:</strong><br>The sum of the entire <em>nums</em> array is guaranteed to fit within the 32-bit signed integer range.</p>
<p><strong>Example 1:</strong></p>
<p>Given <em>nums</em> = <code>[1, -1, 5, -2, 3]</code>, <em>k</em> = <code>3</code>,<br>return <code>4</code>. (because the subarray <code>[1, -1, 5, -2]</code> sums to 3 and is the longest)</p>
<p><strong>Example 2:</strong></p>
<p>Given <em>nums</em> = <code>[-2, -1, 2, 1]</code>, <em>k</em> = <code>1</code>,<br>return <code>2</code>. (because the subarray <code>[-1, 2]</code> sums to 1 and is the longest)</p>
<p><strong>Follow Up:</strong><br>Can you do it in O(<em>n</em>) time?</p>
</blockquote>
<p>计算和为k的子数组的最大长度</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>利用hashmap将出现过的前缀和第一次出现所在的index记录下来，在hashmap中寻找sum[i]-k，若找到，子数组的长度为<code>i - map.get(sum-k)</code> ，记录下满足条件的子数组的最大长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArrayLen</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    map.put(<span class="number">0</span>,-<span class="number">1</span>);</div><div class="line">    <span class="keyword">int</span> maxlen = <span class="number">0</span>;<span class="comment">//用以记录子数组的最大长度</span></div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        <span class="comment">//如果之前出现过sum-k</span></div><div class="line">        <span class="keyword">if</span>(map.containsKey(sum-k))&#123;</div><div class="line">            maxlen = Math.max(maxlen,i - map.get(sum-k));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//该值在map中没有出现过</span></div><div class="line">        <span class="keyword">if</span>(!map.containsKey(sum))&#123;</div><div class="line">            map.put(sum,i);<span class="comment">//key是前缀和，value是index</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Subarray-Sum-Closest"><a href="#Subarray-Sum-Closest" class="headerlink" title="Subarray Sum Closest "></a><a href="http://www.lintcode.com/en/problem/subarray-sum-closest/" target="_blank" rel="external">Subarray Sum Closest </a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an integer array, find a subarray with sum closest to zero. Return the indexes of the first number and last number</p>
<p>Example</p>
<p>Given <code>[-3, 1, 1, -3, 5]</code>, return <code>[0, 2]</code>, <code>[1, 3]</code>, <code>[1, 1]</code>, <code>[2, 2]</code> or <code>[0, 4]</code>.</p>
</blockquote>
<p>给定数组，返回和最接近0的子数组的开始和结束位置的index</p>
<h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>计算前缀和，排序，取每一个位置的前缀和和相邻前缀和的差的最大值，记录其起点终点，取最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * @param nums: A list of integers</span></div><div class="line"><span class="comment">     * @return: A list of integers includes the index of the first number and the index of the last number</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">node</span>&gt;</span>&#123;</div><div class="line">        <span class="keyword">int</span> sum;</div><div class="line">        <span class="keyword">int</span> idx;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> sum,<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.sum = sum;</div><div class="line">            <span class="keyword">this</span>.idx = idx;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(node b)</span> </span>&#123;<span class="comment">// Comparable接口中的方法</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sum- b.sum; <span class="comment">// 按书的id比较大小，用于默认排序</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] subarraySumClosest(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        node[] prefixSum = <span class="keyword">new</span> node[nums.length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            prefixSum[i] = <span class="keyword">new</span> node(sum,i);</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(prefixSum);</div><div class="line">        <span class="keyword">int</span> min = Math.abs(prefixSum[<span class="number">0</span>].sum);</div><div class="line">        <span class="keyword">int</span> min_a = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> min_b = prefixSum[<span class="number">0</span>].idx;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(Math.abs(prefixSum[i].sum) &lt; min)&#123;</div><div class="line">                min = Math.abs(prefixSum[i].sum);</div><div class="line">                min_a = -<span class="number">1</span>;</div><div class="line">                min_b = prefixSum[i].idx;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(Math.abs(prefixSum[i].sum - prefixSum[i-<span class="number">1</span>].sum) &lt; min)&#123;</div><div class="line">                min = Math.abs(prefixSum[i].sum - prefixSum[i-<span class="number">1</span>].sum);</div><div class="line">                min_a = prefixSum[i].idx;</div><div class="line">                min_b = prefixSum[i-<span class="number">1</span>].idx;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> min_idx = Math.min(min_a,min_b);</div><div class="line">        <span class="keyword">int</span> max_idx = Math.max(min_a,min_b);</div><div class="line">      result[<span class="number">0</span>] = min_idx+<span class="number">1</span>;</div><div class="line">      result[<span class="number">1</span>] = max_idx;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Contiguous-Array"><a href="#Contiguous-Array" class="headerlink" title="Contiguous Array"></a><a href="https://leetcode.com/problems/contiguous-array" target="_blank" rel="external">Contiguous Array</a></h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [0,1]</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [0,1,0]</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong> The length of the given binary array will not exceed 50,000.</p>
</blockquote>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>计算从0到i位中0的个数<code>zeroSum</code>和1的个数<code>oneSum</code>，以及0比1多多少<code>zeroMoreThanOne</code></p>
<p>利用hashmap将zeroMoreThanOne和index存储起来，当遇到zeroMoreThanOne == 0或者map.containsKey(zeroMoreThanOne )时说明遇到了01数量相等的子数组，记录最大长度</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxlen = <span class="number">0</span>;</div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//存储0比1多多少idx</span></div><div class="line">    <span class="keyword">int</span> zeroSum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> oneSum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> zeroMoreThanOne = <span class="number">0</span>;</div><div class="line">    map.put(<span class="number">0</span>,-<span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</div><div class="line">            zeroSum++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            oneSum++;</div><div class="line">        &#125;</div><div class="line">        zeroMoreThanOne = zeroSum - oneSum;</div><div class="line">        <span class="keyword">if</span>(map.containsKey(zeroMoreThanOne))&#123;</div><div class="line">            <span class="keyword">int</span> len = i - map.get(zeroMoreThanOne);</div><div class="line">            maxlen = Math.max(maxlen,len);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            map.put(zeroMoreThanOne,i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Longest-Continuous-Increasing-Subsequence"><a href="#Longest-Continuous-Increasing-Subsequence" class="headerlink" title="Longest Continuous Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-continuous-increasing-subsequence" target="_blank" rel="external">Longest Continuous Increasing Subsequence</a></h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an unsorted array of integers, find the length of longest <code>continuous</code> increasing subsequence (subarray).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,4,7]</div><div class="line">&gt; Output: 3</div><div class="line">&gt; Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. </div><div class="line">&gt; Even though [1,3,5,7] is also an increasing subsequence, it&apos;s not a continuous one where 5 and 7 are separated by 4. </div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [2,2,2,2,2]</div><div class="line">&gt; Output: 1</div><div class="line">&gt; Explanation: The longest continuous increasing subsequence is [2], its length is 1. </div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong> Length of the array will not exceed 10,000.</p>
</blockquote>
<p>求最长递增子数组</p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>从前向后遍历，两个变量<code>maxlen</code>，<code>len_local</code> 分别记录全局最长递增子数组和局部最长递增子数组的长度，如果</p>
<ol>
<li>nums[i]&gt;nums[i-1]，len_local++,更新maxlen</li>
<li>nums[i]&gt;nums[i-1]，len_local重置为1</li>
</ol>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> maxlen = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> len_local = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</div><div class="line">            len_local++;</div><div class="line">            maxlen = Math.max(maxlen,len_local);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            len_local = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Degree-of-an-Array"><a href="#Degree-of-an-Array" class="headerlink" title="Degree of an Array"></a><a href="https://leetcode.com/problems/degree-of-an-array" target="_blank" rel="external">Degree of an Array</a></h3><h4 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a non-empty array of non-negative integers <code>nums</code>, the <strong>degree</strong> of this array is defined as the maximum frequency of any one of its elements.</p>
<p>Your task is to find the smallest possible length of a (contiguous) subarray of <code>nums</code>, that has the same degree as <code>nums</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1, 2, 2, 3, 1]</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The input array has a degree of 2 because both elements 1 and 2 appear twice.</div><div class="line">&gt; Of the subarrays that have the same degree:</div><div class="line">&gt; [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</div><div class="line">&gt; The shortest length is 2. So return 2.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,2,2,3,1,4,2]</div><div class="line">&gt; Output: 6</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong></p>
<p><code>nums.length</code> will be between 1 and 50,000.</p>
<p><code>nums[i]</code> will be an integer between 0 and 49,999.</p>
</blockquote>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>方法一：利用hashmap存储元素出现的次数和第一次出现的idx，从前向后遍历，更新出现次数最多的元素和最小子数组长度</p>
<p>方法二：遍历数组，用left[val]和right[val]存储val出现的第一次和最后一次，记录出现次数最多的元素和最短长度</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> earlyIdx;</div><div class="line">    <span class="keyword">int</span> nums;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> nums)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.earlyIdx = idx;</div><div class="line">        <span class="keyword">this</span>.nums = nums;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxNum = <span class="number">0</span>;<span class="comment">//记录元素出现的最多次数</span></div><div class="line">    <span class="keyword">int</span> minlen = <span class="number">1</span>;<span class="comment">//记录最短长度</span></div><div class="line">    HashMap&lt;Integer,node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="comment">//如果之前有此元素了</span></div><div class="line">        <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</div><div class="line">            <span class="comment">//算上这次跟当前出现最多次数的元素一样</span></div><div class="line">            <span class="keyword">if</span>(map.get(nums[i]).nums + <span class="number">1</span> == maxNum) &#123;</div><div class="line">                minlen = Math.min(minlen,i - map.get(nums[i]).earlyIdx+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//算上这次比当前出现最多次数的元素还多</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(map.get(nums[i]).nums + <span class="number">1</span> &gt; maxNum) &#123;</div><div class="line">                maxNum = map.get(nums[i]).nums + <span class="number">1</span>;<span class="comment">//更新最多次数</span></div><div class="line">                minlen = i - map.get(nums[i]).earlyIdx+<span class="number">1</span>;<span class="comment">//更新最短长度</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//更新map</span></div><div class="line">            node newNode = <span class="keyword">new</span> node(map.get(nums[i]).earlyIdx,map.get(nums[i]).nums+<span class="number">1</span>);</div><div class="line">            map.put(nums[i],newNode);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            map.put(nums[i],<span class="keyword">new</span> node(i,<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Container-With-Most-Water"><a href="#Container-With-Most-Water" class="headerlink" title="Container With Most Water"></a><a href="https://leetcode.com/problems/container-with-most-water" target="_blank" rel="external">Container With Most Water</a></h3><h4 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and <em>n</em> is at least 2.</p>
</blockquote>
<p>给定数组<em>a1</em>, <em>a2</em>, …, <em>an</em>,表示边界高度，选取其中两个作为边界，求能够容纳水的最大量。</p>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>若选取i,j作为边界，能够容纳的水量是：<script type="math/tex">(j-i) * min(a_i,a_j)</script></p>
<p>步骤：</p>
<ol>
<li>初始化：i指向height[0],j指向height[len-1]</li>
<li>两指针由外向内移动，记录最大的容水量：<ol>
<li>如果height[i] &lt; height[j],i++</li>
<li>如果height[i] &gt;= height[j],j—</li>
</ol>
</li>
</ol>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = height.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">if</span>(height[i] &lt; height[j])&#123;</div><div class="line">            max = Math.max(max,(j-i) *height[i]);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            max = Math.max(max,(j-i) * height[j]);</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Array-Nesting"><a href="#Array-Nesting" class="headerlink" title="Array Nesting"></a><a href="https://leetcode.com/problems/array-nesting" target="_blank" rel="external">Array Nesting</a></h3><blockquote>
<p>A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], … } subjected to the rule below.</p>
<p>Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: A = [5,4,0,3,1,6,2]</div><div class="line">&gt; Output: 6</div><div class="line">&gt; Explanation: </div><div class="line">&gt; A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.</div><div class="line">&gt;</div><div class="line">&gt; One of the longest S[K]:</div><div class="line">&gt; S[0] = &#123;A[0], A[5], A[6], A[2]&#125; = &#123;5, 6, 2, 0&#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>N is an integer within the range [1, 20,000].</li>
<li>The elements of A are all distinct.</li>
<li>Each element of A is an integer within the range [0, N-1].</li>
</ol>
</blockquote>
<p>求数组中能够成环的最大长度</p>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>i从头向后遍历，以i为入口访问环，把访问过的标记为-1，记录最大长度</p>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;<span class="comment">//记录最大长度</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; nums.length;i ++)&#123;</div><div class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//记录以i为入口的环长度</span></div><div class="line">            <span class="keyword">int</span> j = i;</div><div class="line">            <span class="keyword">while</span>(nums[j] != -<span class="number">1</span>)&#123;</div><div class="line">                len++;</div><div class="line">                <span class="keyword">int</span> temp = j;</div><div class="line">                j = nums[j];</div><div class="line">                nums[temp] = -<span class="number">1</span>;<span class="comment">//访问过的元素标记</span></div><div class="line">            &#125;</div><div class="line">           maxlen = Math.max(maxlen,len);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxlen;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Find-Pivot-Index"><a href="#Find-Pivot-Index" class="headerlink" title="Find Pivot Index"></a><a href="https://leetcode.com/problems/find-pivot-index" target="_blank" rel="external">Find Pivot Index</a></h3><blockquote>
<p>Given an array of integers <code>nums</code>, write a method that returns the “pivot” index of this array.</p>
<p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p>
<p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: </div><div class="line">&gt; nums = [1, 7, 3, 6, 5, 6]</div><div class="line">&gt; Output: 3</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.</div><div class="line">&gt; Also, 3 is the first index where this occurs.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: </div><div class="line">&gt; nums = [1, 2, 3]</div><div class="line">&gt; Output: -1</div><div class="line">&gt; Explanation: </div><div class="line">&gt; There is no index that satisfies the conditions in the problem statement.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>先计算数组的全部元素和<code>sum</code> ，再遍历一次，计算前缀和<code>prefixsum</code>，二者做差是右边的和，prefixsum-nums[i]是左边的和，二者相等就返回</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ;i++)&#123;</div><div class="line">    sum += nums[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> prefixsum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</div><div class="line">    prefixsum += nums[i];</div><div class="line">    <span class="keyword">if</span>(sum - prefixsum == prefixsum - nums[i])&#123;</div><div class="line">      <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Product-of-Array-Except-Self"><a href="#Product-of-Array-Except-Self" class="headerlink" title="Product of Array Except Self"></a><a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="external">Product of Array Except Self</a></h3><h4 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h4><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>要分三种情况讨论：</p>
<ol>
<li>如果没有0，计算总乘积、当前乘积</li>
<li>有1个0，除了0位置不为0，其余位置都是0</li>
<li>有2个以上0，所有位置都为0</li>
</ol>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">  <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">  <span class="keyword">int</span> zeros = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> product = <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> zeroloc = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</div><div class="line">      zeros += <span class="number">1</span>;</div><div class="line">      zeroloc = i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      product *= nums[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(zeros == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;res.length;i++)&#123;</div><div class="line">      res[i] = product/nums[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(zeros == <span class="number">1</span>)&#123;</div><div class="line">    res[zeroloc] = product;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h1><h3 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="external">Best Time to Buy and Sell Stock</a></h3><h4 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [7, 1, 5, 3, 6, 4]</div><div class="line">&gt; Output: 5</div><div class="line">&gt;</div><div class="line">&gt; max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [7, 6, 4, 3, 1]</div><div class="line">&gt; Output: 0</div><div class="line">&gt;</div><div class="line">&gt; In this case, no transaction is done, i.e. max profit = 0.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p> 第i天卖出所获的最大利润为：</p>
<p>prices[i] - min(prices[0]~prices[i-1])</p>
<p>步骤：从前向后遍历，更新到当前天的价格最低值，更新到当前天的利润最大值</p>
<h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (prices.length == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//记录最大利润</span></div><div class="line">  <span class="keyword">int</span> maxprofit = Integer.MIN_VALUE;</div><div class="line">  <span class="comment">//记录当前最低价格，初始化不能是0，应该是第一天的价格</span></div><div class="line">  <span class="keyword">int</span> minprice = prices[<span class="number">0</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">    maxprofit = Math.max(maxprofit,prices[i] - minprice);<span class="comment">//更新最大利润</span></div><div class="line">    minprice = Math.min(minprice,prices[i]);<span class="comment">//更新最低价格</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> maxprofit;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="external">Best Time to Buy and Sell Stock II</a></h3><h4 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<p>相比Best Time to Buy and Sell Stock I，可以多次买卖，计算可获得的最大利润</p>
<h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>计算每一天跟前一天的价格差，将价格差大于0 的利润累加，就是获得的最大利润</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">        <span class="keyword">int</span> delta = prices[i] - prices[i-<span class="number">1</span>];</div><div class="line">        <span class="keyword">if</span>(delta &gt; <span class="number">0</span>)&#123;</div><div class="line">            max += delta;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="external">Best Time to Buy and Sell Stock III</a></h3><h4 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p>
</blockquote>
<p>可以交易两次，设计算法求出最大利润</p>
<h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>可以交易两次，可将数组分成左右两段，分别计算左段和右段的最大值</p>
<p>可以采用两次遍历，第一次从左向右，计算从0到i的最大利润，存在<code>maxprofits[i]</code>里。</p>
<p>第二次从右向左，计算从i到0的最大利润</p>
<p>maxprofit[i] = maxprofitfromleft[i]+maxprofitfromright[i]</p>
<p>以第i天为分割点的最大利润 = 从0到i的最大利润+从i到末尾的最大利润之和</p>
<p>以第i天为分割点在左右同时计算，包含了只交易一次，即第i天不买不卖的操作</p>
<h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxresult = <span class="number">0</span>;<span class="comment">//最终结果</span></div><div class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> maxprofitfromleft = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] maxprofits = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];<span class="comment">//记录从0到i的最大利润</span></div><div class="line">        <span class="comment">//计算从前到i最大利润</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">            minprice = Math.min(minprice,prices[i]);</div><div class="line">            maxprofitfromleft = Math.max(maxprofitfromleft,prices[i] - minprice);</div><div class="line">            maxprofits[i] = maxprofitfromleft;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//计算从后到i最大利润+从前导i-1最大利润和</span></div><div class="line">        <span class="keyword">int</span> maxprice = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">int</span> maxprofitformright = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = prices.length - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</div><div class="line">            maxprice = Math.max(maxprice,prices[i]);<span class="comment">//从后向前最高价格</span></div><div class="line">            maxprofitformright = Math.max(maxprofitformright,maxprice - prices[i]);<span class="comment">//从后向前最大利润</span></div><div class="line">            maxresult = Math.max(maxresult,maxprofitformright + maxprofits[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxresult;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="Best Time to Buy and Sell Stock with Transaction Fee"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="external">Best Time to Buy and Sell Stock with Transaction Fee</a></h3><h4 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p>
<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>
<p>Return the maximum profit you can make.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: prices = [1, 3, 2, 8, 4, 9], fee = 2</div><div class="line">&gt; Output: 8</div><div class="line">&gt; Explanation: The maximum profit can be achieved by:</div><div class="line">&gt; Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>不限制交易次数，但需支付交易费用，求最大利润</p>
<h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时扣费,扣交易费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：</div><div class="line">cash:在第i天不持股所获最大利润</div><div class="line">hold:在第i天持股所获最大利润</div><div class="line"></div><div class="line">转移方程：</div><div class="line">在第i天cash状态的例如来源于两个方面：</div><div class="line">  <span class="number">1</span>.前一天cash，第i天不操作</div><div class="line">  <span class="number">2</span>.前一天hold，第i天卖出，收益prices[i]</div><div class="line">在第i天hold状态的例如来源于两个方面：</div><div class="line">  <span class="number">1</span>.前一天hold，第i天不操作</div><div class="line">  <span class="number">2</span>.前一天cash，第i天买入，扣去prices[i]和交易费用fee</div><div class="line">因此状态转移方程为：</div><div class="line">temp = cash</div><div class="line">cash = max(cash,hold + price[i])</div><div class="line">hold = max(hold,cash - price[i] - fee)</div><div class="line">  </div><div class="line">返回值：</div><div class="line">cash 最后一天结束时不持股的最大利润</div><div class="line"></div><div class="line">初始化：</div><div class="line">cash = <span class="number">0</span> 第<span class="number">0</span>天不持股，利润为<span class="number">0</span></div><div class="line">hold = -prices[<span class="number">0</span>] - fee 为了使第一天买入时利润为<span class="number">0</span>，将第<span class="number">0</span>天持股，利润设置为 ：-prices[<span class="number">0</span>] - fee</div><div class="line"></div><div class="line"></div><div class="line">代码：</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> cash = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> hold = -prices[<span class="number">0</span>] - fee;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">        	<span class="keyword">int</span> temp = cash;</div><div class="line">            cash = Math.max(cash,hold + prices[i]);</div><div class="line">            hold = Math.max(hold,temp - prices[i] - fee);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cash;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时计算交易次数，扣费,扣交易费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：T表示收益</div><div class="line">T[i][<span class="number">0</span>]表示到第i天，第i天不持股</div><div class="line">T[i][<span class="number">1</span>]表示到第i天，第i天持股</div><div class="line"></div><div class="line">转移方程：</div><div class="line">【第i天交易k次不持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不卖：第i-<span class="number">1</span>天不持股，第i天不操作</div><div class="line">    <span class="number">2</span>.卖：第i-<span class="number">1</span>天持股，第i天卖掉，得到收益prices[i]</div><div class="line"></div><div class="line">【第i天交易k次持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不买：第i-<span class="number">1</span>天持股，第i天不操作  </div><div class="line">    <span class="number">2</span>.买：第i-<span class="number">1</span>天不持股，第i天买入，花费prices[i]+fee</div><div class="line"></div><div class="line">综上，转移方程为：</div><div class="line">T[i][<span class="number">0</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">0</span>],T[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</div><div class="line">T[i][<span class="number">1</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">1</span>]，T[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]-fee)</div><div class="line">  </div><div class="line">初始化：</div><div class="line">T[<span class="number">0</span>][<span class="number">1</span>] = -Infinity; </div><div class="line"></div><div class="line">返回值：</div><div class="line">T[i][<span class="number">0</span>]:最后一天用光所有交易次数不持股的最大利润</div><div class="line"></div><div class="line">代码：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> profit[][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length+<span class="number">1</span>][<span class="number">2</span>];</div><div class="line">  profit[<span class="number">0</span>][<span class="number">1</span>] = - prices[<span class="number">0</span>] - fee;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= prices.length;i++)&#123;</div><div class="line">    profit[i][<span class="number">0</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">0</span>],profit[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>]);</div><div class="line">    profit[i][<span class="number">1</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">1</span>],profit[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] - fee);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> profit[prices.length][<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="Best Time to Buy and Sell Stock with Cooldown"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown" target="_blank" rel="external">Best Time to Buy and Sell Stock with Cooldown</a></h3><h4 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<ul>
<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>
<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; prices = [1, 2, 3, 0, 2]</div><div class="line">&gt; maxProfit = 3</div><div class="line">&gt; transactions = [buy, sell, cooldown, buy, sell]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>买卖股票存在一天的冷却期，卖出股票后第二天不可以买入，需要冷却一天，求最大利润。</p>
<h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时计算交易次数，扣费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：T表示收益</div><div class="line">T[i][<span class="number">0</span>]表示到第i天，第i天不持股</div><div class="line">T[i][<span class="number">1</span>]表示到第i天，第i天持股</div><div class="line"></div><div class="line">转移方程：</div><div class="line">【第i天不持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不卖：第i-<span class="number">1</span>天不持股，第i天不操作</div><div class="line">    <span class="number">2</span>.卖：第i-<span class="number">1</span>天持股，第i天卖掉，得到收益prices[i]</div><div class="line"></div><div class="line">【第i天持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不买：第i-<span class="number">1</span>天持股，第i天不操作  </div><div class="line">    <span class="number">2</span>.买：第i-<span class="number">2</span>天不持股，第i天买入，花费prices[i]</div><div class="line"></div><div class="line">综上，转移方程为：</div><div class="line">T[i][<span class="number">0</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">0</span>],T[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</div><div class="line">T[i][<span class="number">1</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">1</span>]，T[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i])</div><div class="line">  </div><div class="line">初始化：</div><div class="line">T[i][<span class="number">0</span>] = T[-<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//前i天无操作，利润为0；没有股票利润为0</span></div><div class="line">T[i][<span class="number">1</span>] = T[-<span class="number">1</span>][<span class="number">1</span>] = -Infinity; <span class="comment">//前i天无操作持股，没有股票持股，不可能，利润为负无穷</span></div><div class="line"></div><div class="line">返回值：</div><div class="line">T[i][<span class="number">0</span>]:最后一天用光所有交易次数不持股的最大利润</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">代码：</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] profit = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length+<span class="number">2</span>][<span class="number">2</span>];</div><div class="line">        profit[<span class="number">0</span>][<span class="number">1</span>] = Math.max(-prices[<span class="number">0</span>],-prices[<span class="number">1</span>]);</div><div class="line">        profit[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            profit[i][<span class="number">0</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">0</span>],profit[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">2</span>]);</div><div class="line">            profit[i][<span class="number">1</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">1</span>],profit[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i-<span class="number">2</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> profit[prices.length+<span class="number">1</span>][<span class="number">0</span>];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="Best Time to Buy and Sell Stock IV"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv" target="_blank" rel="external">Best Time to Buy and Sell Stock IV</a></h3><h4 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most <strong>k</strong> transactions.</p>
</blockquote>
<p>最多可以买卖k次，求最大收益</p>
<h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>动态规划的思想，下面是一种通用解法，前面的题目也同样适用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时计算交易次数，扣费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：T表示收益</div><div class="line">T[i][k][<span class="number">0</span>]表示到第i天，交易k次，第i天不持股</div><div class="line">T[i][k][<span class="number">1</span>]表示到第i天，交易k次，第i天持股</div><div class="line"></div><div class="line">转移方程：</div><div class="line">【第i天交易k次不持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不卖：第i-<span class="number">1</span>天不持股，之前操作k次，第i天不操作</div><div class="line">    <span class="number">2</span>.卖：第i-<span class="number">1</span>天持股，之前操作k次，第i天卖掉，得到收益prices[i]</div><div class="line"></div><div class="line">【第i天交易k次持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不买：第i-<span class="number">1</span>天持股，之前操作k次，第i天不操作  </div><div class="line">    <span class="number">2</span>.买：第i-<span class="number">1</span>天不持股，之前操作k-<span class="number">1</span>次，第i天买入，花费prices[i]</div><div class="line"></div><div class="line">综上，转移方程为：</div><div class="line">T[i][k][<span class="number">0</span>] = Math.max(T[i-<span class="number">1</span>][k][<span class="number">0</span>],T[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</div><div class="line">T[i][k][<span class="number">1</span>] = Math.max(T[i-<span class="number">1</span>][k][<span class="number">1</span>]，T[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</div><div class="line">  </div><div class="line">初始化：</div><div class="line">T[i][<span class="number">0</span>][<span class="number">0</span>] = T[-<span class="number">1</span>][k][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//前i天无操作，利润为0；没有股票利润为0</span></div><div class="line">T[i][<span class="number">0</span>][<span class="number">1</span>] = T[-<span class="number">1</span>][k][<span class="number">1</span>] = -Infinity; <span class="comment">//前i天无操作持股，没有股票持股，不可能，利润为负无穷</span></div><div class="line"></div><div class="line">返回值：</div><div class="line">T[i][k][<span class="number">0</span>]:最后一天用光所有交易次数不持股的最大利润</div></pre></td></tr></table></figure>
<h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(prices.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(k &gt;= prices.length/<span class="number">2</span>)&#123;</div><div class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">      <span class="keyword">if</span>(prices[i] &gt;= prices[i-<span class="number">1</span>])&#123;</div><div class="line">        profit += prices[i] - prices[i-<span class="number">1</span>];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> profit;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[][][] profit = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length+<span class="number">1</span>][k+<span class="number">1</span>][<span class="number">2</span>];</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= prices.length;i++)&#123;<span class="comment">//前i天无操作，持股，不可能</span></div><div class="line">    profit[i][<span class="number">0</span>][<span class="number">1</span>] = Integer.MIN_VALUE;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k;i++)&#123;<span class="comment">//没有股票持股，不可能</span></div><div class="line">    profit[<span class="number">0</span>][i][<span class="number">1</span>] = Integer.MIN_VALUE;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> kk = <span class="number">1</span> ; kk &lt;= k ; kk++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= prices.length;i++)&#123;</div><div class="line">      profit[i][kk][<span class="number">0</span>] = Math.max(profit[i-<span class="number">1</span>][kk][<span class="number">0</span>],profit[i-<span class="number">1</span>][kk][<span class="number">1</span>] + prices[i-<span class="number">1</span>]);</div><div class="line">      profit[i][kk][<span class="number">1</span>] = Math.max(profit[i-<span class="number">1</span>][kk][<span class="number">1</span>],profit[i-<span class="number">1</span>][kk-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> profit[prices.length][k][<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Two-Sum问题"><a href="#Two-Sum问题" class="headerlink" title="Two Sum问题"></a>Two Sum问题</h1><h3 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a><a href="https://leetcode.com/problems/two-sum" target="_blank" rel="external">Two Sum</a></h3><blockquote>
<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given nums = [2, 7, 11, 15], target = 9,</div><div class="line">&gt;</div><div class="line">&gt; Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line">&gt; return [0, 1].</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>方法一：遍历，用hash表存储下来，然后遍历数组i,在hash表中查找是否有target-i</p>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">7</span>  <span class="number">9</span>  <span class="number">11</span>  <span class="number">18</span> ,target=<span class="number">16</span></div><div class="line">↑                ↑</div><div class="line">i                j</div><div class="line">步骤：</div><div class="line"><span class="number">1</span>. 排序，需要把元素在原来数组中的idx存下来</div><div class="line"><span class="number">2</span>. 两个指针i,j，i指向头，j指向尾</div><div class="line"><span class="number">3</span>.<span class="keyword">if</span>(nums[i]+nums[j] &lt; targert) i++</div><div class="line">  <span class="keyword">if</span>(nums[i]+nums[j] &gt; targert) j--</div><div class="line">  <span class="keyword">if</span>(nums[i]+nums[j] == targert) <span class="keyword">return</span></div></pre></td></tr></table></figure>
<p>若给定数组是有序的<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted" target="_blank" rel="external">Two Sum II - Input array is sorted</a>用方法二就非常简单了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">    Arrays.sort(nums);</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</div><div class="line">            result[<span class="number">0</span>] = i;</div><div class="line">            result[<span class="number">1</span>] = j;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[j] &lt; target)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a><a href="https://leetcode.com/problems/3sum" target="_blank" rel="external">3Sum</a></h3><h4 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; For example, given array S = [-1, 0, 1, 2, -1, -4],</div><div class="line">&gt;</div><div class="line">&gt; A solution set is:</div><div class="line">&gt; [</div><div class="line">&gt;   [-1, 0, 1],</div><div class="line">&gt;   [-1, -1, 2]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法一：hash + 遍历 , 空间<script type="math/tex">O(n)</script> + 时间<script type="math/tex">O(n^2)</script></p>
<p>方法二：排序后two pointer，空间<script type="math/tex">O(1)</script> + 时间<script type="math/tex">O(n^2)</script></p>
<ol>
<li>排序</li>
<li>求a+b+c = target<br>固定a ， 然后对b + c利用Two Sum方法</li>
<li>需要注意的是遍历时要跳过重复的元素</li>
</ol>
<h4 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="comment">//排序</span></div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length -<span class="number">3</span>;a++)&#123;</div><div class="line">    <span class="comment">//跳过重复元素</span></div><div class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a-<span class="number">1</span>])&#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(b &lt; c)&#123;</div><div class="line">      <span class="comment">//找到了一组解</span></div><div class="line">      <span class="keyword">if</span>(nums[b] + nums[c] + nums[a] == <span class="number">0</span>)&#123;</div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        result.add(nums[a]);</div><div class="line">        result.add(nums[b]);</div><div class="line">        result.add(nums[c]);</div><div class="line">        results.add(result);</div><div class="line">        b++;</div><div class="line">        c--;</div><div class="line">        <span class="comment">// 跳过重复的 , 一定要注意这里，我自己没做上</span></div><div class="line">        <span class="keyword">while</span> (b &lt; c &amp;&amp; nums[b] == nums[b - <span class="number">1</span>])&#123;</div><div class="line">          b++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (b &lt; c &amp;&amp; nums[c] == nums[c + <span class="number">1</span>])&#123;</div><div class="line">          c--;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(nums[b] + nums[c]+ nums[a] &lt; <span class="number">0</span>)&#123;</div><div class="line">        b++;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        c--;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3Sum-Closest"><a href="#3Sum-Closest" class="headerlink" title="3Sum Closest"></a><a href="https://leetcode.com/problems/3sum-closest" target="_blank" rel="external">3Sum Closest</a></h3><h4 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array <em>S</em> of <em>n</em> integers, find three integers in <em>S</em> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.</div><div class="line">&gt;</div><div class="line">&gt;     The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>跟上一题一样的思路，计算nums[b] + nums[c] + nums[a] - target的值：</p>
<ol>
<li>nums[b] + nums[c] + nums[a] - target == 0，最小差为0，直接返回</li>
<li>nums[b] + nums[c] + nums[a] - target &lt; 0,跟新最小差，b++</li>
<li>nums[b] + nums[c] + nums[a] - target &gt; 0,跟新最小差，c—</li>
</ol>
<h4 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">  <span class="comment">//排序</span></div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="keyword">int</span> min_delta = Integer.MAX_VALUE;<span class="comment">//记录最小差值</span></div><div class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//记录最小差值时三个数字和</span></div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">2</span>;a++)&#123;</div><div class="line">    <span class="comment">//跳过重复元素</span></div><div class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a-<span class="number">1</span>])&#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(b &lt; c)&#123;</div><div class="line">      <span class="comment">//找到和target相等的情况</span></div><div class="line">      <span class="keyword">if</span>(nums[b] + nums[c] + nums[a] - target == <span class="number">0</span>)&#123;</div><div class="line">        sum = target;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(nums[b] + nums[c] + nums[a] &lt; target)&#123;</div><div class="line">        <span class="keyword">int</span> delta = Math.abs(nums[b] + nums[c] + nums[a] - target);</div><div class="line">        <span class="keyword">if</span>(delta &lt; min_delta)&#123;</div><div class="line">          min_delta = delta;</div><div class="line">          sum = nums[b] + nums[c] + nums[a];</div><div class="line">        &#125;</div><div class="line">        b++;</div><div class="line">        <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[b] == nums[b-<span class="number">1</span>])&#123;</div><div class="line">          b++;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> delta = Math.abs(nums[b] + nums[c] + nums[a] - target);</div><div class="line">        <span class="keyword">if</span>(delta &lt; min_delta)&#123;</div><div class="line">          min_delta = delta;</div><div class="line">          sum = nums[b] + nums[c] + nums[a];</div><div class="line">        &#125;</div><div class="line">        c--;</div><div class="line">        <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[c] == nums[c+<span class="number">1</span>])&#123;</div><div class="line">          c--;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3Sum-Smaller"><a href="#3Sum-Smaller" class="headerlink" title="3Sum Smaller"></a><a href="https://leetcode.com/problems/3sum-smaller" target="_blank" rel="external">3Sum Smaller</a></h3><h4 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array of <em>n</em> integers <em>nums</em> and a <em>target</em>, find the number of index triplets <code>i, j, k</code> with <code>0 &lt;= i &lt; j &lt; k &lt; n</code> that satisfy the condition <code>nums[i] + nums[j] + nums[k] &lt; target</code>.</p>
<p>For example, given <em>nums</em> = <code>[-2, 0, 1, 3]</code>, and <em>target</em> = 2.</p>
<p>Return 2. Because there are two triplets which sums are less than 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [-2, 0, 1]</div><div class="line">&gt; [-2, 0, 3]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Follow up:</strong><br>Could you solve it in <em>O</em>(<em>n</em>2) runtime?</p>
</blockquote>
<h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>这道题没有说清楚，重复的元素也可以，步骤如下：</p>
<ol>
<li>排序</li>
<li>从0到len-3遍历a，b从a+1到len-2，c从len-1到b+1</li>
<li>确定a和b的位置之后，c从后向前遍历，寻找第一个满足nums[b] + nums[c] + nums[a] &lt; target的位置，则从当前的b+1到找到的c的位置之间的c-b个位置都可以作为c，使得nums[b] + nums[c] + nums[a] &lt; target</li>
</ol>
<h4 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumSmaller</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">2</span>;a++) &#123;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (b &lt; c) &#123;</div><div class="line">      <span class="keyword">while</span> (b &lt; c &amp;&amp; nums[b] + nums[c] + nums[a] &gt;= target) &#123;</div><div class="line">        c--;</div><div class="line">      &#125;<span class="comment">//跳出时nums[b] + nums[c] + nums[a] &lt; target,或者b==c了</span></div><div class="line">      <span class="comment">//找到了第一个c的位置使得nums[b] + nums[c] + nums[a] &lt; target</span></div><div class="line">      <span class="keyword">if</span>(b &lt; c &amp;&amp; nums[b] + nums[c] + nums[a] &lt; target)&#123;</div><div class="line">        res += c - b;<span class="comment">//b+1~c之间的元素都可以做c满足nums[b] + nums[c] + nums[a] &lt; target</span></div><div class="line">      &#125;</div><div class="line">      b++;</div><div class="line">      c = nums.length - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4Sum"><a href="#4Sum" class="headerlink" title="4Sum"></a><a href="https://leetcode.com/problems/4sum" target="_blank" rel="external">4Sum</a></h3><blockquote>
<p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate quadruplets.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.</div><div class="line">&gt;</div><div class="line">&gt; A solution set is:</div><div class="line">&gt; [</div><div class="line">&gt;   [-1,  0, 0, 1],</div><div class="line">&gt;   [-2, -1, 1, 2],</div><div class="line">&gt;   [-2,  0, 0, 2]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>跟前面一样的思路，固定a，b对c,d做2Sum</p>
<h4 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="comment">//排序</span></div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">3</span>;a++)&#123;</div><div class="line">    <span class="comment">//跳过重复元素</span></div><div class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a-<span class="number">1</span>])&#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> b = a+<span class="number">1</span>;b &lt; nums.length - <span class="number">2</span>;b++)&#123;</div><div class="line">      <span class="comment">//跳过重复元素</span></div><div class="line">      <span class="keyword">if</span>(b &gt; a+<span class="number">1</span> &amp;&amp; nums[b] == nums[b-<span class="number">1</span>])&#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//c和d做TwoSum</span></div><div class="line">      <span class="keyword">int</span> c = b+<span class="number">1</span>;</div><div class="line">      <span class="keyword">int</span> d = nums.length-<span class="number">1</span>;</div><div class="line">      <span class="keyword">while</span>(c &lt; d)&#123;</div><div class="line">        <span class="comment">//找到了一组解</span></div><div class="line">        <span class="keyword">if</span>(nums[b] + nums[c] + nums[d] + nums[a] == target)&#123;</div><div class="line">          ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">          result.add(nums[a]);</div><div class="line">          result.add(nums[b]);</div><div class="line">          result.add(nums[c]);</div><div class="line">          result.add(nums[d]);</div><div class="line">          results.add(result);</div><div class="line">          c++;</div><div class="line">          d--;</div><div class="line">          <span class="comment">// 跳过重复的 , 一定要注意这里，我自己没做上</span></div><div class="line">          <span class="keyword">while</span> (c &lt; d &amp;&amp; nums[c] == nums[c - <span class="number">1</span>])&#123;</div><div class="line">            c++;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">while</span> (c &lt; d &amp;&amp; nums[d] == nums[d + <span class="number">1</span>])&#123;</div><div class="line">            d--;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[b] + nums[c] + nums[d] + nums[a] &lt; target)&#123;</div><div class="line">          c++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          d--;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4Sum-II"><a href="#4Sum-II" class="headerlink" title="4Sum II"></a><a href="https://leetcode.com/problems/4sum-ii" target="_blank" rel="external">4Sum II</a></h3><h4 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given four lists A, B, C, D of integer values, compute how many tuples <code>(i, j, k, l)</code> there are such that <code>A[i] + B[j] + C[k] + D[l]</code> is zero.</p>
<p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:</div><div class="line">&gt; A = [ 1, 2]</div><div class="line">&gt; B = [-2,-1]</div><div class="line">&gt; C = [-1, 2]</div><div class="line">&gt; D = [ 0, 2]</div><div class="line">&gt;</div><div class="line">&gt; Output:</div><div class="line">&gt; 2</div><div class="line">&gt;</div><div class="line">&gt; Explanation:</div><div class="line">&gt; The two tuples are:</div><div class="line">&gt; 1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</div><div class="line">&gt; 2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给四个数组，从每个数组中选一个数字，和为0的选择方案有多少</p>
<h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>方法一：直接遍历四个数组，复杂度<script type="math/tex">O(n^4)</script></p>
<p>方法二：AB为一组，CD为一组，用两个hashmap记录两组中出现的和及其出现次数，互为相反数的和为0。</p>
<p>改进：存储两个hashmap再遍历速度很慢，所以只计算AB的和存入hashmap，然后计算CD时去AB的hashmap中寻找-sum出现的次数累加到result上即可。</p>
<h4 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        HashMap&lt;Integer,Integer&gt; mapab = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="comment">//计算AB的和，存入hashmap</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; A.length;j++)&#123;</div><div class="line">                <span class="keyword">int</span> sumab = A[i]+B[j];</div><div class="line">                <span class="keyword">if</span>(mapab.containsKey(sumab))&#123;</div><div class="line">                    mapab.put(sumab,mapab.get(sumab)+<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    mapab.put(sumab,<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; A.length;j++)&#123;</div><div class="line">                <span class="keyword">int</span> sum = C[i] + D[j];</div><div class="line">                <span class="keyword">if</span>(mapab.containsKey(-sum))&#123;</div><div class="line">                    result += mapab.get(-sum);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Valid-Triangle-Number"><a href="#Valid-Triangle-Number" class="headerlink" title="Valid Triangle Number"></a><a href="https://leetcode.com/problems/valid-triangle-number" target="_blank" rel="external">Valid Triangle Number</a></h3><h4 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [2,2,3,4]</div><div class="line">&gt; Output: 3</div><div class="line">&gt; Explanation:</div><div class="line">&gt; Valid combinations are: </div><div class="line">&gt; 2,3,4 (using the first 2)</div><div class="line">&gt; 2,3,4 (using the second 2)</div><div class="line">&gt; 2,2,3</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>选取三个数组作为三边长度，返回能够组成三角形的选取方案数</p>
<h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p>构成三角形条件：两边之和大于第三边</p>
<ol>
<li>排序，两个小边之和大于第三边</li>
<li>固定a，遍历b、c，寻找第一个nums[a] + nums[b] &gt; nums[c]的位置</li>
<li>bc之间的位置都可以作为c，使得nums[a] + nums[b] &gt; nums[c]，result+= c-b。</li>
</ol>
<h4 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">2</span>;a++)&#123;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(b &lt; c)&#123;</div><div class="line">      <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[a] + nums[b] &lt;= nums[c])&#123;</div><div class="line">        c--;</div><div class="line">      &#125;<span class="comment">//跳出时nums[a] + nums[b] &gt; nums[c]或者b==c</span></div><div class="line">      <span class="keyword">if</span>(b &lt; c &amp;&amp; nums[a] + nums[b] &gt; nums[c])&#123;</div><div class="line">        result += c-b;</div><div class="line">      &#125;</div><div class="line">      b++;</div><div class="line">      c = nums.length - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Partition类问题"><a href="#Partition类问题" class="headerlink" title="Partition类问题"></a>Partition类问题</h1><p>不开额外的空间，用两个指针分成两个、三个部分，利用quicksort的思想</p>
<h3 id="partition-Array"><a href="#partition-Array" class="headerlink" title="partition Array"></a><a href="http://www.lintcode.com/en/problem/partition-array/" target="_blank" rel="external">partition Array</a></h3><h4 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array <code>nums</code> of integers and an int <code>k</code>, partition the array (i.e move the elements in “nums”) such that:</p>
<ul>
<li>All elements &lt; <em>k</em> are moved to the <em>left</em></li>
<li>All elements &gt;= <em>k</em> are moved to the <em>right</em></li>
</ul>
<p>Return the partitioning index, i.e the first index <em>i</em> nums[<em>i</em>] &gt;= <em>k</em>.</p>
<p>Example</p>
<p>If nums = <code>[3,2,2,1]</code> and <code>k=2</code>, a valid answer is <code>1</code>.</p>
</blockquote>
<h4 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h4><p>利用quicksort的思想，两指针一前一后向中间遍历，前面遇到大的，后面遇到小的交换，最后判断nums[j]和target的大小关系，返回结果。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-02-10-28-18.png" alt=""> </p>
<h4 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partitionArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt; k)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= k)&#123;</div><div class="line">            j--;</div><div class="line">        &#125;<span class="comment">//j右边都&gt;=k</span></div><div class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</div><div class="line">            <span class="keyword">int</span> temp = nums[i];</div><div class="line">            nums[i] = nums[j];</div><div class="line">            nums[j] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums[j] &gt;= k)&#123;</div><div class="line">        <span class="keyword">return</span> j;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> j+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两个指针，利用快速排序</p>
<h3 id="Sort-Colors"><a href="#Sort-Colors" class="headerlink" title="Sort Colors"></a><a href="https://leetcode.com/problems/sort-colors" target="_blank" rel="external">Sort Colors</a></h3><h4 id="题目-32"><a href="#题目-32" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array with <em>n</em> objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
</blockquote>
<h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><p>方法一：计数排序，遍历，记录0,1,2出现的个数，然后重新输出，时间复杂度<script type="math/tex">O(n)</script></p>
<p>方法二：两次partition，先把0分一堆，1，2分一堆，然后再把1,2分开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColorsPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="comment">//先分成左边都&lt;1，右边&gt;=1</span></div><div class="line">  <span class="keyword">while</span>(i &lt;= j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[i] &lt; <span class="number">1</span>)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;<span class="comment">//i是第一个&gt;=1的位置，或者是与j相遇且过了</span></div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[j] &gt;= <span class="number">1</span>)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;<span class="comment">//j是第一个&lt;1的位置，或者是与i相遇且过了</span></div><div class="line">    <span class="comment">//如果还未相遇，交换ij元素，如果恰好相遇，</span></div><div class="line">    <span class="keyword">if</span>(i &lt;= j)&#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[i];</div><div class="line">      nums[i] = nums[j];</div><div class="line">      nums[j] = temp;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//对右半段，分成成左边都&lt;2，右边&gt;=2</span></div><div class="line">  j = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(i &lt;= j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[i] &lt; <span class="number">2</span>)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;<span class="comment">//i是第一个&gt;=1的位置，或者是与j相遇了</span></div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[j] &gt;= <span class="number">2</span>)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;<span class="comment">//j是第一个&lt;1的位置，或者是与i相遇了</span></div><div class="line">    <span class="keyword">if</span>(i &lt;= j)&#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[i];</div><div class="line">      nums[i] = nums[j];</div><div class="line">      nums[j] = temp;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法三：背程序，三个指针三分法。</p>
<ol>
<li>i，j指向头和尾，mid在中间</li>
<li>mid向后遍历，遇到0与i交换，遇到2与j交换</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> mid = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(mid &lt;= j)&#123;</div><div class="line">    <span class="keyword">if</span>(mid &lt;= j &amp;&amp; nums[mid] == <span class="number">1</span>)&#123;</div><div class="line">      mid++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mid &lt;= j &amp;&amp; nums[mid] == <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[i];</div><div class="line">      nums[i] = nums[mid];</div><div class="line">      nums[mid] = temp;</div><div class="line">      mid++;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[j];</div><div class="line">      nums[j] = nums[mid];</div><div class="line">      nums[mid] = temp;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Sort-Colors-II"><a href="#Sort-Colors-II" class="headerlink" title="Sort Colors II"></a><a href="http://www.lintcode.com/en/problem/sort-colors-ii/" target="_blank" rel="external">Sort Colors II</a></h3><blockquote>
<p>Given an array of <em>n</em> objects with <em>k</em> different colors (numbered from 1 to k), sort them so that objects of the same color are adjacent, with the colors in the order 1, 2, … k.</p>
<p>Example</p>
<p>Given colors=<code>[3, 2, 2, 1, 4]</code>, <code>k=4</code>, your code should sort colors in-place to <code>[1, 2, 2, 3, 4]</code>.</p>
</blockquote>
<h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors2</span><span class="params">(<span class="keyword">int</span>[] colors, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">if</span>(colors.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = colors.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> kk = <span class="number">2</span>;</div><div class="line">    <span class="comment">//先分成左边都&lt;1，右边&gt;=1</span></div><div class="line">    <span class="keyword">while</span>(kk &lt;= k)&#123;</div><div class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</div><div class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; colors[i] &lt; kk)&#123;</div><div class="line">                i++;</div><div class="line">            &#125;<span class="comment">//i是第一个&gt;=1的位置，或者是与j相遇且过了</span></div><div class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; colors[j] &gt;= kk)&#123;</div><div class="line">                j--;</div><div class="line">            &#125;<span class="comment">//j是第一个&lt;1的位置，或者是与i相遇且过了</span></div><div class="line">            <span class="comment">//如果还未相遇，交换ij元素，如果恰好相遇，</span></div><div class="line">            <span class="keyword">if</span>(i &lt;= j)&#123;</div><div class="line">                <span class="keyword">int</span> temp = colors[i];</div><div class="line">                colors[i] = colors[j];</div><div class="line">                colors[j] = temp;</div><div class="line">                i++;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        j = colors.length-<span class="number">1</span>;</div><div class="line">        kk++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Sort-Letters-by-Case"><a href="#Sort-Letters-by-Case" class="headerlink" title="Sort Letters by Case"></a><a href="http://www.lintcode.com/en/problem/sort-letters-by-case/" target="_blank" rel="external">Sort Letters by Case</a></h3><h4 id="题目-33"><a href="#题目-33" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a string which contains only letters. Sort it by lower case first and upper case second.</p>
<p>For <code>&quot;abAcD&quot;</code>, a reasonable answer is <code>&quot;acbAD&quot;</code></p>
</blockquote>
<p>给一串字母，把小写的排在左边，大写的排在右边</p>
<h4 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortLetters</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</div><div class="line">  <span class="comment">// write your code here</span></div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = chars.length - <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; chars[i] &gt;= <span class="string">'a'</span>)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; chars[j] &lt;= <span class="string">'Z'</span>)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</div><div class="line">      <span class="keyword">char</span> temp = chars[i];</div><div class="line">      chars[i] = chars[j];</div><div class="line">      chars[j] = temp;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Interleaving-Positive-and-Negative-Numbers"><a href="#Interleaving-Positive-and-Negative-Numbers" class="headerlink" title="Interleaving Positive and Negative Numbers"></a><a href="http://www.lintcode.com/en/problem/interleaving-positive-and-negative-numbers/" target="_blank" rel="external">Interleaving Positive and Negative Numbers</a></h3><blockquote>
<p>Given an array with positive and negative integers. Re-range it to interleaving with positive and negative integers.</p>
<p>Example</p>
<p>Given <code>[-1, -2, -3, 4, 5, 6]</code>, after re-range, it will be <code>[-1, 5, -2, 4, -3, 6]</code> or any other reasonable answer.</p>
</blockquote>
<p>把正的和负的先都挑出来，然后交替放入数组。如果正的多余负的，先放正的，否则先放负的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rerange</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] zheng = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</div><div class="line">    <span class="keyword">int</span>[] fu = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> zhengi = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> fui = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; A.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(A[i] &lt; <span class="number">0</span>)&#123;</div><div class="line">            fu[fui] = A[i];</div><div class="line">            fui++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            zheng[zhengi] = A[i];</div><div class="line">            zhengi++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(fui &lt; zhengi)&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> zhengj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> fuj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; A.length-<span class="number">2</span>)&#123;</div><div class="line">            A[i] = zheng[zhengj];</div><div class="line">            zhengj++;</div><div class="line">            i++;</div><div class="line">            A[i] = fu[fuj];</div><div class="line">            fuj++;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        A[i] = zheng[zhengj];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> zhengj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> fuj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; A.length-<span class="number">2</span>)&#123;</div><div class="line">            A[i] = fu[fuj];</div><div class="line">            fuj++;</div><div class="line">            i++;</div><div class="line">            A[i] = zheng[zhengj];</div><div class="line">            zhengj++;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        A[i] = fu[fuj];</div><div class="line">        i++;</div><div class="line">        <span class="keyword">if</span>(A.length % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            A[i] = zheng[zhengj];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Two-pointer问题"><a href="#Two-pointer问题" class="headerlink" title="Two pointer问题"></a>Two pointer问题</h1><h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="external">Longest Substring Without Repeating Characters</a></h3><h4 id="题目-34"><a href="#题目-34" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Examples:</strong></p>
<p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p>
<p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p>
<p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code>is a <em>subsequence</em> and not a substring.</p>
</blockquote>
<p>给定一个字符串，计算不包含重复字母的最长子串</p>
<h4 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h4><p>用滑动窗口做，窗口边界left、right，用数组<code>int[] map = new int[256]</code>存储当前窗口内出现的元素，用maxlen、len_local记录最大长度和当前窗口长度</p>
<ol>
<li>初始化left,right=0</li>
<li>right向后滑动，直至遇到窗口中已经存在该元素</li>
<li>left向后滑动，窗口缩小，直至将已经出现过的元素挪到窗口外面</li>
<li>循环更新local长度和全局最大长度</li>
</ol>
<h4 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> s.length();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> right = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> maxlen = Integer.MIN_VALUE;</div><div class="line">  <span class="keyword">int</span> len_local = <span class="number">0</span>;<span class="comment">//局部长度</span></div><div class="line">  <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">  <span class="keyword">while</span>(right &lt; s.length())&#123;</div><div class="line">    <span class="comment">//如果字母还未出现过</span></div><div class="line">    <span class="keyword">if</span>(map[s.charAt(right)] == <span class="number">0</span>)&#123;</div><div class="line">      <span class="comment">//存入字母表</span></div><div class="line">      map[s.charAt(right)]++;</div><div class="line">      <span class="comment">//更新局部长度和全局最大长度</span></div><div class="line">      len_local++;</div><div class="line">      maxlen = Math.max(maxlen,len_local);</div><div class="line">      right++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//出现过</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//寻找之前该元素出现的位置</span></div><div class="line">      <span class="keyword">while</span> (s.charAt(left) != s.charAt(right))&#123;</div><div class="line">        <span class="comment">//路上把滑窗缩减的字母从字母表中去掉</span></div><div class="line">        map[s.charAt(left)]--;</div><div class="line">        left++;</div><div class="line">        len_local--;</div><div class="line">      &#125;<span class="comment">//跳出时left和right字母相等</span></div><div class="line">      left++;</div><div class="line">      right++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Implement-strStr"><a href="#Implement-strStr" class="headerlink" title="Implement strStr()"></a><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="external">Implement strStr()</a></h3><h4 id="题目-35"><a href="#题目-35" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</div><div class="line">&gt; Output: 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</div><div class="line">&gt; Output: -1</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h4><p>方法一：双指针遍历比较判断每一个字符是否一样</p>
<p>方法二：<code>return haystack.indexOf(needle);</code></p>
<p>方法三：<code>haystack.substring(i, i + needle.length()).equals(needle)</code></p>
<h4 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(needle.length() == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(j &lt; haystack.length())&#123;</div><div class="line">    <span class="comment">//遇到相等的字母</span></div><div class="line">    <span class="keyword">if</span>(haystack.charAt(i) == needle.charAt(k))&#123;</div><div class="line">      <span class="comment">//j和k同时向后移动</span></div><div class="line">      <span class="keyword">while</span>(j &lt; haystack.length() &amp;&amp; k &lt; needle.length() &amp;&amp; haystack.charAt(j) == needle.charAt(k))&#123;</div><div class="line">        j++;</div><div class="line">        k++;</div><div class="line">      &#125;<span class="comment">//跳出时或者到头了或者有不相等的了</span></div><div class="line">      <span class="comment">//如果k到头了，说明已经包含了needls</span></div><div class="line">      <span class="keyword">if</span>(k == needle.length())&#123;</div><div class="line">        <span class="keyword">return</span> i;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//j到头了，剩下的字符串不够长了，不可能包含了</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(j == haystack.length())&#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        i++;</div><div class="line">        j = i;</div><div class="line">        k = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//不是相等的字母，ij向后移动</span></div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      i++;</div><div class="line">      j++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Reverse-Vowels-of-a-String"><a href="#Reverse-Vowels-of-a-String" class="headerlink" title="Reverse Vowels of a String"></a><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="external">Reverse Vowels of a String</a></h3><h4 id="题目-36"><a href="#题目-36" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<p><strong>Example 1:</strong><br>Given s = “hello”, return “holle”.</p>
<p><strong>Example 2:</strong><br>Given s = “leetcode”, return “leotcede”.</p>
<p><strong>Note:</strong><br>The vowels does not include the letter “y”.</p>
</blockquote>
<p>对换元音字母</p>
<h4 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h4><p>两指针一前一后向中间遍历，遇到元音对换即可。</p>
<p>这里需要注意的是java的String是不可更改的，需要用StringBuilder复制一份再做修改：<code>result.setCharAt(i,s.charAt(j))</code>;</p>
<h4 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseVowelsofaString</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(ch == <span class="string">'a'</span> || ch == <span class="string">'e'</span> || ch == <span class="string">'i'</span> || ch == <span class="string">'o'</span> || ch == <span class="string">'u'</span></div><div class="line">                || ch == <span class="string">'A'</span> || ch == <span class="string">'E'</span> || ch == <span class="string">'I'</span> || ch == <span class="string">'O'</span> || ch == <span class="string">'U'</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder(s);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = s.length() -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; !isVowel(s.charAt(i)))&#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; !isVowel(s.charAt(j)))&#123;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">char</span> temp = s.charAt(i);</div><div class="line">            result.setCharAt(i,s.charAt(j));</div><div class="line">            result.setCharAt(j,temp);</div><div class="line">            i++;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Valid-Palindrome"><a href="#Valid-Palindrome" class="headerlink" title="Valid Palindrome"></a><a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="external">Valid Palindrome</a></h3><h4 id="题目-37"><a href="#题目-37" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>For example,<br><code>&quot;A man, a plan, a canal: Panama&quot;</code> is a palindrome.<br><code>&quot;race a car&quot;</code> is <em>not</em> a palindrome.</p>
</blockquote>
<p>有效回文串，判断字符串中的有效字符是否可以构成有效回文串，其中有效字符仅包括字母和数字，大小写算同一个字母</p>
<h4 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h4><p>步骤</p>
<ol>
<li>需要一个确定是否是有效字符的函数<code>isvalid</code>,利用java中的<code>Character.isLetter()</code>和<code>Character.isDigit()</code></li>
<li>两指针一前一后遍历，遇到无效字符跳过，比较两指针指向的字符是否相等，如果不相等直接返回false</li>
</ol>
<h4 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isvalid</span> <span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> Character.isLetter(c) || Character.isDigit(c);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = s.length()-<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; !isvalid(s.charAt(i)))&#123;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//全是invalid字符的情况</span></div><div class="line">    <span class="keyword">if</span>(i == s.length())&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; !isvalid(s.charAt(j)))&#123;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j)))&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    i++;j--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Valid-Palindrome-II"><a href="#Valid-Palindrome-II" class="headerlink" title="Valid Palindrome II"></a><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="external">Valid Palindrome II</a></h3><h4 id="题目-38"><a href="#题目-38" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a non-empty string <code>s</code>, you may delete <strong>at most</strong> one character. Judge whether you can make it a palindrome.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: &quot;aba&quot;</div><div class="line">&gt; Output: True</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: &quot;abca&quot;</div><div class="line">&gt; Output: True</div><div class="line">&gt; Explanation: You could delete the character &apos;c&apos;.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定字符串，判断如果最多可以去掉一个字符，改字符串是否可以成为回文串</p>
<h4 id="分析-19"><a href="#分析-19" class="headerlink" title="分析"></a>分析</h4><p>跟上一题的思路有点不太一样，没有想到巧妙的方法</p>
<p>两指针指向头尾，如果两个指针指向元素相等，则i++;j—</p>
<p>如果两指针指向元素不相等，那么s[i+1]~s[j]和s[i]~s[j-1]中必然有一个是回文串</p>
<h4 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//判断是否是回文串</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(start == end)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> left = start;</div><div class="line">  <span class="keyword">int</span> right = end;</div><div class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</div><div class="line">    <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    left++;</div><div class="line">    right--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s.length() &lt;= <span class="number">2</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = s.length() -<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">    <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">return</span> isPalindrome(s,i,j-<span class="number">1</span>) || isPalindrome(s,i+<span class="number">1</span>,j);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Longest-Word-in-Dictionary-through-Deleting"><a href="#Longest-Word-in-Dictionary-through-Deleting" class="headerlink" title="Longest Word in Dictionary through Deleting"></a><a href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/" target="_blank" rel="external">Longest Word in Dictionary through Deleting</a></h3><h4 id="题目-39"><a href="#题目-39" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:</div><div class="line">&gt; s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</div><div class="line">&gt;</div><div class="line">&gt; Output: </div><div class="line">&gt; &quot;apple&quot;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:</div><div class="line">&gt; s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</div><div class="line">&gt;</div><div class="line">&gt; Output: </div><div class="line">&gt; &quot;a&quot;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定一个字符串s和一个字符串数组d,返回d中字符串是s的子序列的最长字符串，如果有长度相同的则返回在字母表中顺序最靠前的</p>
<h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><p>遍历d中的字符串，看其是否能够由s的子序列构成，如果能，更新最大长度，如果和当前最大长度相等，取字典序小的</p>
<h4 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//判断是否能够是s的子序列</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">issubqueue</span><span class="params">(String s,String stemp)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> si = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> stempi = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(si &lt; s.length() &amp;&amp; stempi &lt; stemp.length())&#123;</div><div class="line">    <span class="keyword">while</span>(si &lt; s.length() &amp;&amp; s.charAt(si) != stemp.charAt(stempi))&#123;</div><div class="line">      si++;</div><div class="line">    &#125;<span class="comment">//跳出时si==len或者遇到相等的了</span></div><div class="line">    <span class="keyword">if</span>(si == s.length())&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    si++;</div><div class="line">    stempi++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> stempi == stemp.length();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> maxlen = Integer.MIN_VALUE;</div><div class="line">  String result = <span class="keyword">new</span> String();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d.size();i++)&#123;</div><div class="line">    String stemp = d.get(i);</div><div class="line">    <span class="keyword">int</span> len = stemp.length();</div><div class="line">    <span class="keyword">boolean</span> flag = issubqueue(s,stemp);</div><div class="line">    <span class="keyword">if</span>(flag)&#123;</div><div class="line">      <span class="keyword">if</span>(len &gt; maxlen)&#123;</div><div class="line">        maxlen = len;</div><div class="line">        result= stemp;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(len == maxlen &amp;&amp; stemp.compareTo(result) &lt; <span class="number">0</span>)&#123;</div><div class="line">        result = stemp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里判断t是否是s的子序列存在优化的空间，可以利用Java的String中的indexOf(char,indexfrom)来判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//s是否包含t</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isContain</span><span class="params">(String s,String t)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(t.length() &gt; s.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length();i++)&#123;</div><div class="line">    pos = s.indexOf(t.charAt(i),pos);</div><div class="line">    <span class="keyword">if</span>(pos != -<span class="number">1</span>)&#123;</div><div class="line">      pos++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Permutation-in-String"><a href="#Permutation-in-String" class="headerlink" title="Permutation in String"></a><a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="external">Permutation in String</a></h3><h4 id="题目-40"><a href="#题目-40" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</div><div class="line">&gt; Output:True</div><div class="line">&gt; Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</div><div class="line">&gt; Output: False</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定字符串s1和s2，返回s2中是否包含一个子串，使得该子串可以由s1中字母的某种排列方式构成。</p>
<h4 id="分析-20"><a href="#分析-20" class="headerlink" title="分析"></a>分析</h4><p>滑动窗口法，窗口长度设置为s1的长度，在s2中寻找s1的排列子串</p>
<p>窗口向右滑动，直到窗口内出现的字母以及每个字母出现的次数和s1中一样，此时找到了满足条件的子数组。</p>
<p>将s1中出现的字母和每个字母出现的次数记录在一个hashtable中，因为只有26个字母，可以用一个长度为26的数组记录每个字母出现的次数</p>
<h4 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span>[] s1map,<span class="keyword">int</span>[] s2map)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span>;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(s1map[i] != s2map[i])&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s1.length() &gt; s2.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s1.length();i++)&#123;</div><div class="line">    s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">    s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s2.length() - s1.length();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(isSame(s1map,s2map))&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    s2map[s2.charAt(s1.length()+i) - <span class="string">'a'</span>]++;</div><div class="line">    s2map[s2.charAt(i) - <span class="string">'a'</span>]--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> isSame(s1map,s2map);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>这里判断字符串相等还有可以优化的空间，用变量count表示当前窗口内和s1出现相同次数的字母的个数，当count == 26，则所有的字母都出现相同次数了，找到了解。当滑窗向后移动时，需要更新count</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion2</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s1.length() &gt; s2.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s1.length();i++)&#123;</div><div class="line">    s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">    s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span>;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(s1map[i] == s2map[i])&#123;</div><div class="line">      count++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s2.length() - s1.length();i++)&#123;</div><div class="line">    <span class="keyword">int</span> r = s2.charAt(s1.length()+i) - <span class="string">'a'</span>;</div><div class="line">    <span class="keyword">int</span> l = s2.charAt(i) - <span class="string">'a'</span>;</div><div class="line">    <span class="comment">//所有字母出现次数相等</span></div><div class="line">    <span class="keyword">if</span>(count == <span class="number">26</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//窗口将右边元素加入</span></div><div class="line">    s2map[r]++;</div><div class="line">    <span class="keyword">if</span>(s1map[r] == s2map[r])&#123;<span class="comment">//新加入元素后这个元素变得个数相等了</span></div><div class="line">      count++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s2map[r] == s1map[r]+<span class="number">1</span>)&#123;<span class="comment">//新加入元素后比s1多一个了</span></div><div class="line">      count--;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">////窗口将左边元素去掉</span></div><div class="line">    s2map[l]--;</div><div class="line">    <span class="keyword">if</span>(s1map[l] == s2map[l])&#123;</div><div class="line">      count++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s1map[l] == s2map[l]+<span class="number">1</span>)&#123;</div><div class="line">      count--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> count == <span class="number">26</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Subarray-Product-Less-Than-K"><a href="#Subarray-Product-Less-Than-K" class="headerlink" title="Subarray Product Less Than K"></a><a href="https://leetcode.com/problems/subarray-product-less-than-k" target="_blank" rel="external">Subarray Product Less Than K</a></h3><h4 id="题目-41"><a href="#题目-41" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Your are given an array of positive integers <code>nums</code>.</p>
<p>Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than <code>k</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: nums = [10, 5, 2, 6], k = 100</div><div class="line">&gt; Output: 8</div><div class="line">&gt; Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</div><div class="line">&gt; Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-21"><a href="#分析-21" class="headerlink" title="分析"></a>分析</h4><p>滑窗+两指针i,j题:</p>
<p>如果窗口内乘积&gt;=k，i++,窗口缩小</p>
<p>如果滑窗内乘积&lt;k，窗口内包含的以j为结束的子数组个数为j-i+1</p>
<h4 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> end = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> product = <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(start &lt; end &amp;&amp; end &lt; nums.length)&#123;</div><div class="line">    product *= nums[end];</div><div class="line">    <span class="keyword">while</span> (start &lt; end &amp;&amp; product &gt;= k)&#123;</div><div class="line">      product /= nums[start];</div><div class="line">      start++;</div><div class="line">    &#125;</div><div class="line">    count += end - start +<span class="number">1</span>;</div><div class="line">    end++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Wiggle-Sort-II"><a href="#Wiggle-Sort-II" class="headerlink" title="Wiggle Sort II"></a><a href="https://leetcode.com/problems/wiggle-sort-ii" target="_blank" rel="external">Wiggle Sort II</a></h3><blockquote>
<p>Given an unsorted array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p>
<p><strong>Example:</strong><br>(1) Given <code>nums = [1, 5, 1, 1, 6, 4]</code>, one possible answer is <code>[1, 4, 1, 5, 1, 6]</code>.<br>(2) Given <code>nums = [1, 3, 2, 2, 3, 1]</code>, one possible answer is <code>[2, 3, 1, 3, 1, 2]</code>.</p>
<p><strong>Note:</strong><br>You may assume all input has valid answer.</p>
<p><strong>Follow Up:</strong><br>Can you do it in O(n) time and/or in-place with O(1) extra space?</p>
</blockquote>
<h4 id="分析-22"><a href="#分析-22" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<p>这道题给了我们一个无序数组，让我们排序成摆动数组，满足nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]…，并给了我们例子。我们可以先给数组排序，然后在做调整。调整的方法是找到数组的中间的数，相当于把有序数组从中间分成两部分，然后从前半段的末尾取一个，在从后半的末尾取一个，这样保证了第一个数小于第二个数，然后从前半段取倒数第二个，从后半段取倒数第二个，这保证了第二个数大于第三个数，且第三个数小于第四个数，以此类推直至都取完。</p>
<p>follow up：要求空间复杂度O(1)，没做上，要问下邓邓</p>
<h4 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> mid = end/<span class="number">2</span>;</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(idx &lt; nums.length)&#123;</div><div class="line">            <span class="keyword">if</span> (flag == <span class="keyword">false</span>)&#123;</div><div class="line">                copy[idx] = nums[mid];</div><div class="line">                mid--;</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                copy[idx] = nums[end];</div><div class="line">                end--;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            idx++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            nums[i] = copy[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Super-Ugly-Number"><a href="#Super-Ugly-Number" class="headerlink" title="Super Ugly Number"></a><a href="https://leetcode.com/problems/super-ugly-number" target="_blank" rel="external">Super Ugly Number</a></h3><h4 id="题目-42"><a href="#题目-42" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Write a program to find the nth super ugly number.</p>
<p>Super ugly numbers are positive numbers whose all prime factors are in the given prime list <code>primes</code> of size <code>k</code>. For example, <code>[1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]</code>is the sequence of the first 12 super ugly numbers given <code>primes</code> = <code>[2, 7, 13, 19]</code> of size 4.</p>
<p><strong>Note:</strong><br>(1) <code>1</code> is a super ugly number for any given <code>primes</code>.<br>(2) The given numbers in <code>primes</code> are in ascending order.<br>(3) 0 &lt; <code>k</code> ≤ 100, 0 &lt; <code>n</code> ≤ 106, 0 &lt; <code>primes[i]</code> &lt; 1000.<br>(4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer.</p>
</blockquote>
<p>给定n和素数序列，返回第n个ugly number:因子只能出现在素数序列中</p>
<h4 id="分析-23"><a href="#分析-23" class="headerlink" title="分析"></a>分析</h4><p>用上面的hashmap+heap的方法会超时，看了九章的答案和网上大神们给出的答案，才看明白啥意思</p>
<p>以上一题prime只有三个数字2,3,5为例，我们知道丑陋数序列可以拆分为下面3个子列表：</p>
<p>(1) <strong>1x2</strong>,  2x2, <strong>2x2</strong>, 3x2, <strong>3x2</strong>, <strong>4x2</strong>, 5x2…</p>
<p>(2) 1x3,  <strong>1x3</strong>, 2x3, 2x3, <strong>2x3</strong>, 3x3, <strong>3x3</strong>…</p>
<p>(3) 1x5,  1x5, 1x5, <strong>1x5,</strong> 2x5, 2x5, 2x5…</p>
<p>仔细观察上述三个列表，我们可以发现每个子列表都是一个丑陋数分别乘以2,3,5，而要求的丑陋数就是从已经生成的序列中取出来的，我们每次都从三个列表中取出当前最小的那个加入序列，比如第一次，ugly number当前只有1，分别于2,3,5相乘之后得到2,3,5三个数字，此时除1外，最小的是2，因此先把2加入ugly number 里，然后此时2就可以与当前ugly number中比1大的下一个数字相乘，与上一轮的3,5，进行比较了，。。。</p>
<p>因此，上面的规律总结起来就是：</p>
<ol>
<li>一共进行n轮计算和选择</li>
<li>每轮计算a*b，其中b是给定的prime列表中的数字，a是ugly number中的数字</li>
<li>每一轮选择本轮（本列）最小的元素加入ugly number,下一轮该行所选取的”a”的idx后移一位。</li>
</ol>
<h4 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] primes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] uglyNumbers = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">int</span>[] idx = <span class="keyword">new</span> <span class="keyword">int</span>[primes.length];</div><div class="line">        uglyNumbers[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</div><div class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; primes.length;j++)&#123;</div><div class="line">                min = Math.min(min,primes[j] * uglyNumbers[idx[j]]);</div><div class="line">            &#125;</div><div class="line">            uglyNumbers[i] = min;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; primes.length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(min == primes[j] * uglyNumbers[idx[j]])&#123;</div><div class="line">                    idx[j]++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> uglyNumbers[n-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Meeting-Rooms-II"><a href="#Meeting-Rooms-II" class="headerlink" title="Meeting Rooms II"></a><a href="https://leetcode.com/problems/meeting-rooms-ii/" target="_blank" rel="external">Meeting Rooms II</a></h3><h4 id="题目-43"><a href="#题目-43" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), find the minimum number of conference rooms required.</p>
<p>For example,<br>Given <code>[[0, 30],[5, 10],[15, 20]]</code>,<br>return <code>2</code>.</p>
</blockquote>
<p>给定一个interval序列，代表会议的开始和结束时间，返回需要的最大会议室数量，也就是同时开会的最大数量。</p>
<h4 id="分析-24"><a href="#分析-24" class="headerlink" title="分析"></a>分析</h4><p>方法一：扫描线的思路+heap实现</p>
<p>将会议的开始和结束时间排序，然后从较小的开始遍历，初始sum=0,遇到start+1,遇到end-1，过程中最大的sum即为同时召开的最大会议数量。要注意的是，遇到同一时刻既有会议开始也有会议结束时应该先访问end，将sum-1,然后再访问start.</p>
<p>需要用小顶堆维护会议开始和结束时间，小顶堆的判断依据为time和Start or End</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Comparator&lt;Node&gt; tmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(o1.time != o2.time) <span class="keyword">return</span> o1.time - o2.time;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">if</span>(o1.isStart == <span class="keyword">true</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<p>将所有开始时间和结束时间分别放入两个数组，分别排序，然后两指针一个指向开始数组i，一个指向结束数组j，初始化sum = 0;</p>
<p>i后移时sum++;</p>
<p>j后移时sum—;</p>
<p>当指向开始数组的指针&gt;=结束数组指针所指的值时，结束数组向后移动一位，否则开始指针后移。</p>
<h4 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h4><p>方法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeetingRoomsII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> start;</div><div class="line">        <span class="keyword">int</span> end;</div><div class="line">        Interval() &#123; start = <span class="number">0</span>; end = <span class="number">0</span>; &#125;</div><div class="line">        Interval(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123; start = s; end = e; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> time;</div><div class="line">        <span class="keyword">boolean</span> isStart;</div><div class="line">        Node(<span class="keyword">int</span> time,<span class="keyword">boolean</span> isStart)&#123;</div><div class="line">            <span class="keyword">this</span>.time = time;</div><div class="line">            <span class="keyword">this</span>.isStart = isStart;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</div><div class="line">        Comparator&lt;Node&gt; tmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span>(o1.time != o2.time) <span class="keyword">return</span> o1.time - o2.time;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">if</span>(o1.isStart == <span class="keyword">true</span>)&#123;</div><div class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(tmp);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intervals.length;i++)&#123;</div><div class="line">            heap.add(<span class="keyword">new</span> Node(intervals[i].start,<span class="keyword">true</span>));</div><div class="line">            heap.add(<span class="keyword">new</span> Node(intervals[i].end,<span class="keyword">false</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(!heap.isEmpty())&#123;</div><div class="line">            <span class="keyword">if</span>(heap.poll().isStart)&#123;</div><div class="line">                sum++;</div><div class="line">                max = Math.max(max,sum);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;sum--;&#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] starts = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</div><div class="line">    <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intervals.length;i++)&#123;</div><div class="line">        starts[i] = intervals[i].start;</div><div class="line">        ends[i] = intervals[i].end;</div><div class="line">    &#125;</div><div class="line">    Arrays.sort(starts);</div><div class="line">    Arrays.sort(ends);</div><div class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; starts.length &amp;&amp; j &lt; ends.length)&#123;</div><div class="line">        <span class="keyword">if</span>(starts[i] &lt; ends[j])&#123;</div><div class="line">            sum++;</div><div class="line">            max = Math.max(max,sum);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            j++;</div><div class="line">            sum--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="The-Skyline-Problem"><a href="#The-Skyline-Problem" class="headerlink" title="The Skyline Problem"></a><a href="https://leetcode.com/problems/the-skyline-problem" target="_blank" rel="external">The Skyline Problem</a></h3><h4 id="题目-44"><a href="#题目-44" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are <strong>given the locations and height of all the buildings</strong> as shown on a cityscape photo (Figure A), write a program to <strong>output the skyline</strong> formed by these buildings collectively (Figure B).</p>
<p><img src="https://leetcode.com/static/images/problemset/skyline1.jpg" alt="Buildings"> </p>
<p><img src="https://leetcode.com/static/images/problemset/skyline2.jpg" alt="Skyline Contour"></p>
<p>The geometric information of each building is represented by a triplet of integers <code>[Li, Ri, Hi]</code>, where <code>Li</code> and <code>Ri</code> are the x coordinates of the left and right edge of the ith building, respectively, and <code>Hi</code> is its height. It is guaranteed that <code>0 ≤ Li, Ri ≤ INT_MAX</code>, <code>0 &lt; Hi ≤ INT_MAX</code>, and <code>Ri - Li &gt; 0</code>. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p>
<p>For instance, the dimensions of all buildings in Figure A are recorded as: <code>[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ]</code>.</p>
<p>The output is a list of “<strong>key points</strong>“ (red dots in Figure B) in the format of <code>[ [x1,y1], [x2, y2], [x3, y3], ... ]</code> that uniquely defines a skyline. <strong>A key point is the left endpoint of a horizontal line segment</strong>. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</p>
<p>For instance, the skyline in Figure B should be represented as:<code>[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]</code>.</p>
</blockquote>
<p>给定建筑物的坐标和高度，有重叠，计算轮廓</p>
<h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><p>扫描线</p>
<h4 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h4>]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法基础班】课程笔记——链表]]></title>
      <url>/2017/12/11/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>考点重要程度：链表 -&gt; DFS/BFS -&gt;DP</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>test:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//print() 打印完整链表</span></div><div class="line">ListNode node1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</div><div class="line">ListNode node2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</div><div class="line">ListNode node3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</div><div class="line"></div><div class="line">ListNode head = node1;</div><div class="line">node1.next = node2;</div><div class="line">node2.next = node3;</div><div class="line"></div><div class="line">print(head);</div><div class="line"><span class="comment">//1-&gt;2-&gt;3</span></div><div class="line">node1 = node2;</div><div class="line">print(head);</div><div class="line"><span class="comment">//1-&gt;2-&gt;3</span></div><div class="line"></div><div class="line">ListNode包括一个值和一个指针，head占<span class="number">4</span>Byte(<span class="number">32</span>bit)空间，head实际上是一个指针，通过head所指向的地址去找对应节点存储的值和下一个指针。</div><div class="line"></div><div class="line">链表结构：</div><div class="line">    [<span class="number">1</span>,] -&gt;  [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,]  </div><div class="line">      ↑        ↑       ↑</div><div class="line">   head,n1     n2     n3</div><div class="line">   <span class="number">4</span><span class="keyword">byte</span>     <span class="number">4</span><span class="keyword">byte</span>   <span class="number">4</span><span class="keyword">byte</span></div><div class="line">   </div><div class="line">node1和node2都是指向节点的指针，如果令node1 = node2,那么只是node1存储的地址和node2存储的地址一样了，但是链表的机构没有改变，所以输出依然是:</div><div class="line"><span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span> </div><div class="line">  </div><div class="line">如果要改变链表的结构，需要node.next = balabala</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="相关习题"><a href="#相关习题" class="headerlink" title="相关习题"></a>相关习题</h2><h3 id="Remove-Duplicates-from-Sorted-List"><a href="#Remove-Duplicates-from-Sorted-List" class="headerlink" title="Remove Duplicates from Sorted List"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list" target="_blank" rel="external">Remove Duplicates from Sorted List</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p>
<p>For example,<br>Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.<br>Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>删掉链表中有重复的节点，保留一个</p>
<p>因为删除某个节点node，需要让node的前序节点.next = node.next，因此需要构造一个dummy node，让其指向前序节点，这样需要删除head的时候就可以令dummy.next = node.next。初始化时令dummy.next=head</p>
<p>最后返回dummy.next</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  ListNode prev;<span class="comment">//用于记录重复元素第一次出现的位置</span></div><div class="line">  ListNode curt = head;<span class="comment">//用于向后遍历链表</span></div><div class="line"></div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="comment">//遇到重复元素</span></div><div class="line">    <span class="keyword">if</span>(curt.next != <span class="keyword">null</span> &amp;&amp; curt.val == curt.next.val)&#123;</div><div class="line">      prev = curt;<span class="comment">//记录第一个出现的元素</span></div><div class="line">      <span class="keyword">int</span> val = curt.val;<span class="comment">//存储当前节点的值，用于后续判断是否和当前值相等</span></div><div class="line">      <span class="comment">//curt向后移动，直到和curt值不相等停止</span></div><div class="line">      <span class="keyword">while</span> (curt != <span class="keyword">null</span> &amp;&amp; curt.val == val)&#123;</div><div class="line">        curt = curt.next;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//curt == null || curt.val != val;此时curt指向后面第一个和它值不相等的元素</span></div><div class="line">      <span class="comment">//将prev.next指向第一个不相等的元素</span></div><div class="line">      prev.next = curt;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果没有遇到重复元素，curt继续后移一位</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      curt = curt.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Remove-Duplicates-from-Sorted-List-II"><a href="#Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Remove Duplicates from Sorted List II"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii" target="_blank" rel="external">Remove Duplicates from Sorted List II</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p>
<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>, return <code>1-&gt;2-&gt;5</code>.<br>Given <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.</p>
</blockquote>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>删除链表中重复出现的节点，全部删掉一个都不保留</p>
<p>因为删除某个节点node，需要让node的前序节点.next = node.next，删除全部重复的元素可能删掉head元素，因此需要构造一个dummy node，让其指向head的前序节点，也就是dummy.next = head。这样需要删除head的时候就可以令dummy.next = head.next。</p>
<p>最后反回dummy.next</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//虚拟节点用于指向head</span></div><div class="line">  dummy.next = head;</div><div class="line"></div><div class="line">  ListNode prev = dummy;</div><div class="line">  ListNode curt = head;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="comment">//遇到重复元素</span></div><div class="line">    <span class="keyword">if</span>(curt.next != <span class="keyword">null</span> &amp;&amp; curt.val == curt.next.val)&#123;</div><div class="line">      <span class="keyword">int</span> val = curt.val;<span class="comment">//存储当前节点的值，用于后续判断是否和当前值相等</span></div><div class="line">      <span class="comment">//curt向后移动，直到和curt值不相等停止</span></div><div class="line">      <span class="keyword">while</span> (curt != <span class="keyword">null</span> &amp;&amp; curt.val == val)&#123;</div><div class="line">        curt = curt.next;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//curt == null || curt.val != val;此时curt指向后面第一个和它值不相等的元素</span></div><div class="line">      <span class="comment">//将prev.next指向第一个不相等的元素</span></div><div class="line">      prev.next = curt;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果没有遇到重复元素，prev和curt都后移一位</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      prev = prev.next;</div><div class="line">      curt = curt.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a><a href="https://leetcode.com/problems/reverse-linked-list" target="_blank" rel="external">Reverse Linked List</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Reverse a singly linked list.、</p>
<p>Hint:</p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
</blockquote>
<p>链表反转</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="keyword">null</span>   [<span class="number">1</span>,] -&gt; [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">  ↑       ↑</div><div class="line"> prev   curt</div><div class="line"> </div><div class="line"><span class="number">1</span>. 用temp记录下curt.next（因为后面要修改curt.next）</div><div class="line"> <span class="keyword">null</span>   [<span class="number">1</span>,] -&gt; [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">  ↑       ↑      ↑</div><div class="line"> prev   curt    temp</div><div class="line"> </div><div class="line"><span class="number">2</span>. 将curt.next指向其前序节点prev，此时原来的后续链断掉:</div><div class="line"> <span class="keyword">null</span> &lt;- [<span class="number">1</span>,]  [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">  ↑       ↑      ↑</div><div class="line"> prev   curt    temp</div><div class="line"><span class="number">3</span>. 将prev移到curt位置，curt移动到原来的curt.next,即temp:</div><div class="line"><span class="keyword">null</span> &lt;- [<span class="number">1</span>,]  [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">         ↑      ↑       ↑</div><div class="line">        prev   curt    temp</div><div class="line"></div><div class="line">ListNode temp = curt.next;</div><div class="line">curt.next = prev</div><div class="line">prev = curt;</div><div class="line">curt = temp;</div></pre></td></tr></table></figure>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  ListNode prev = <span class="keyword">null</span>;</div><div class="line">  ListNode curt = head;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    ListNode temp = curt.next;</div><div class="line">    curt.next = prev;</div><div class="line">    prev = curt;</div><div class="line">    curt = temp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> prev;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Reverse-Linked-List-II"><a href="#Reverse-Linked-List-II" class="headerlink" title="Reverse Linked List II"></a><a href="https://leetcode.com/problems/reverse-linked-list-ii" target="_blank" rel="external">Reverse Linked List II</a></h3><blockquote>
<p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in-place and in one-pass.</p>
<p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <em>m</em> = 2 and <em>n</em> = 4,</p>
<p>return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p>
<p><strong>Note:</strong><br>Given <em>m</em>, <em>n</em> satisfy the following condition:<br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p>
</blockquote>
<p>将链表的第m-n位置上的元素反转</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[<span class="number">1</span>,]-&gt;[<span class="number">2</span>,]-&gt;...-&gt;[m-<span class="number">1</span>,]-&gt;[m,]-&gt;...-&gt;[n,]-&gt;[n+<span class="number">1</span>,]-&gt;...</div><div class="line">翻转m和n之间的部分，分为三个步骤：</div><div class="line"><span class="number">1</span>. 找到m-<span class="number">1</span>和m的点，设为prev和curt</div><div class="line"><span class="number">2</span>. 将m~n反转</div><div class="line"><span class="number">3</span>. 把m-<span class="number">1</span>.next指向n;把m.next指向n.next</div></pre></td></tr></table></figure>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-12-00-49-23.png" alt=""></p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        ListNode prev = dummy;</div><div class="line">        ListNode curt = head;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">        <span class="comment">//寻找第m个节点</span></div><div class="line">        <span class="keyword">while</span> (i &lt; m)&#123;</div><div class="line">            curt = curt.next;</div><div class="line">            prev = prev.next;</div><div class="line">            i++;</div><div class="line">        &#125;<span class="comment">//此时prev指向第m-1个节点，curt指向第m个节点</span></div><div class="line"></div><div class="line">        <span class="comment">//记录下m节点和m-1节点位置，用于反转后连接</span></div><div class="line">        ListNode m_node = curt;</div><div class="line">        ListNode m_prev = prev;</div><div class="line"></div><div class="line">        <span class="comment">//将m到n反转</span></div><div class="line">        <span class="keyword">while</span> (i &lt;= n)&#123;</div><div class="line">            ListNode temp = curt.next;</div><div class="line">            curt.next = prev;</div><div class="line">            prev = curt;</div><div class="line">            curt = temp;</div><div class="line">            i++;</div><div class="line">        &#125;<span class="comment">//此时curt指向第n+1个节点，prev指向第n个节点</span></div><div class="line"></div><div class="line">        <span class="comment">//将m的前序节点的next指向第n个节点</span></div><div class="line">        m_prev.next = prev;</div><div class="line">        <span class="comment">//将m节点的next指向第n+1个节点</span></div><div class="line">        m_node.next = curt;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a><a href="https://leetcode.com/problems/partition-list" target="_blank" rel="external">Partition List</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br>Given <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2</code> and <em>x</em> = 3,<br>return <code>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code>.</p>
<p>给定一个链表和一个数x，将链表中比x小的排在左边，大于等于x的数字排在右边，数字的相对顺序保持不变</p>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>将链表排成两队，小于x的一队，大于等于x的一队，然后把两个链表连起来。</p>
<p>链表的结构会发生变化，所以需要两个dummy node，一个用来指向小的队dummy_low，一个用来指向大的队dummy_high。</p>
<p><strong>解题步骤：</strong></p>
<ol>
<li>遍历数组，将比x小的元素放到dummy_low队伍后面，将比x大的元素放到dummy_high队伍后面</li>
<li>结束后将两个链表连接起来：dummy_low.next指向dummy_high.next</li>
<li>将链表结尾置空：tail.next = null,否则会保留原始节点的next。</li>
<li>返回dummy_low.next;</li>
</ol>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionList</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        ListNode next;</div><div class="line"></div><div class="line">        ListNode(<span class="keyword">int</span> val) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">establish</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode curt = dummy;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> item : array)&#123;</div><div class="line">            ListNode node = <span class="keyword">new</span> ListNode(item);</div><div class="line">            curt.next = node;</div><div class="line">            curt = curt.next;</div><div class="line">        &#125;</div><div class="line">        curt.next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        ListNode dummy_low = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode dummy_high = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line"></div><div class="line">        ListNode prev_low = dummy_low;<span class="comment">//用于向小链表插入</span></div><div class="line">        ListNode prev_high = dummy_high;<span class="comment">//用于向大链表插入</span></div><div class="line"></div><div class="line">        <span class="comment">//分别放到两个队伍里</span></div><div class="line">        ListNode curt = head;</div><div class="line">        <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(curt.val &lt; x)&#123;</div><div class="line">                prev_low.next = curt;</div><div class="line">                prev_low = prev_low.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                prev_high.next = curt;</div><div class="line">                prev_high = prev_high.next;</div><div class="line">            &#125;</div><div class="line">            curt = curt.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将两链表连接</span></div><div class="line">        prev_low.next = dummy_high.next;</div><div class="line">        prev_high.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dummy_low.next;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</div><div class="line">            System.out.println(head.val);</div><div class="line">            System.out.println(<span class="string">" -&gt; "</span>);</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"null"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        PartitionList test = <span class="keyword">new</span> PartitionList();</div><div class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</div><div class="line">        <span class="keyword">int</span> x = <span class="number">3</span>;</div><div class="line">        ListNode head = test.establish(array);</div><div class="line">        head = test.partition(head,x);</div><div class="line">        test.printList(head);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Merge-Two-Sorted-Lists"><a href="#Merge-Two-Sorted-Lists" class="headerlink" title="Merge Two Sorted Lists"></a><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="external">Merge Two Sorted Lists</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</div><div class="line">&gt; Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>链表结构可能改变， 所以需要dummy node</p>
<p>需要一个prev指针记录当前节点，初始化指向dummy_node两个curt指针分别指向两个链表当前节点，用于比较，将比较小的接在prev后面，知道两个curt中有一个为空，将另一个链表的后面直接接到prev后面。</p>
<p>最后返回dummy.next</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode prev = dummy;</div><div class="line">        ListNode curt1 = l1;</div><div class="line">        ListNode curt2 = l2;</div><div class="line">        <span class="keyword">while</span> (curt1 != <span class="keyword">null</span> &amp;&amp; curt2 != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(curt1.val &lt; curt2.val)&#123;</div><div class="line">                prev.next = curt1;</div><div class="line">                curt1 = curt1.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                prev.next = curt2;</div><div class="line">                curt2 = curt2.next;</div><div class="line">            &#125;</div><div class="line">            prev = prev.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curt1 == <span class="keyword">null</span>)&#123;</div><div class="line">            prev.next = curt2;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            prev.next = curt1;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Sort-List"><a href="#Sort-List" class="headerlink" title="Sort List"></a><a href="https://leetcode.com/problems/sort-list" target="_blank" rel="external">Sort List</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p>
<p>将链表排序，时间复杂度为 <em>O</em>(<em>n</em> log <em>n</em>)</p>
<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>时间复杂度为nlogn的排序：quick sort\merge sort\heap sort</p>
<p>quick sort和merge sort的区别：</p>
<ol>
<li><p>算法流程</p>
<p>quik sort：整体有序 -&gt; 局部有序、不稳定排序</p>
<ul>
<li>整体有序：选定一个元素，比它小的都在它左边，比它大的都在它右边</li>
<li>局部有序：然后再对左段和右段分别做快排</li>
</ul>
<p>merge sort：局部有序 -&gt; 整体有序、稳定排序</p>
<ul>
<li>局部有序：选取中点将序列分成左右两段，对左右两边分别排序</li>
<li>整体有序：将左右两边sort list 进行merge操作使得整个list有序</li>
</ul>
</li>
</ol>
<ol>
<li><p>排序的稳定性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[2 , 1&apos; , 1&apos;&apos;, 1&apos;&apos;&apos; , 4 , 3&apos; , 3&apos;&apos;]</div><div class="line">merge sort的merge操作不会改变元素的相对顺序，所以是稳定排序</div><div class="line">quick sort会改变元素的相对位置，所以不是稳定排序</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>时间复杂度</p>
<p>quick sort平均时间复杂度<script type="math/tex">O(nlogn)</script>，最坏时间复杂度<script type="math/tex">O(n^2)</script></p>
<p>merge sort时间复杂度：<script type="math/tex">O(nlogn)</script></p>
</li>
<li><p>空间复杂度</p>
<p>quick sort：<script type="math/tex">O(1)</script></p>
<p>merge sort：<script type="math/tex">O(n)</script> ，但是在链表中不需要开辟额外的空间</p>
</li>
</ol>
<p><strong>解题步骤：</strong></p>
<p>merge sort</p>
<p>​    具体步骤：</p>
<ol>
<li>merge sort在链表中找中点，有两种方法：<ol>
<li>遍历一遍，得到链表的长度n，则中间位置是n/2，再从头遍历一遍，到n/2的位置停止，找到中点</li>
<li>设置两个错位指针，一个slow一个fast，初始化都指向head，slow每次向右移动一位，fast每次向右移动两位，fast移动到末尾的时候，head指向中间，取到链表中点</li>
</ol>
</li>
<li>对左右两段递归进行排序</li>
<li>merge两段有序链表</li>
</ol>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">merge sort:</div><div class="line"><span class="comment">//寻找链表中点,中间偏前</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">findMid</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">  &#125;</div><div class="line">  ListNode slow = head;</div><div class="line">  ListNode fast = head;</div><div class="line">  <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</div><div class="line">    slow = slow.next;</div><div class="line">    fast = fast.next.next;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> slow;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//merge两段有序链表</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode left_h,ListNode right_h)</span></span>&#123;</div><div class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">  ListNode prev = dummy;</div><div class="line">  ListNode curt_l = left_h;</div><div class="line">  ListNode curt_r = right_h;</div><div class="line">  <span class="keyword">while</span> (curt_l != <span class="keyword">null</span> &amp;&amp; curt_r != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(curt_l.val &lt; curt_r.val)&#123;</div><div class="line">      prev.next = curt_l;</div><div class="line">      prev = prev.next;</div><div class="line">      curt_l = curt_l.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      prev.next = curt_r;</div><div class="line">      prev = prev.next;</div><div class="line">      curt_r = curt_r.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(curt_l == <span class="keyword">null</span>)&#123;</div><div class="line">    prev.next = curt_r;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(curt_r == <span class="keyword">null</span>)&#123;</div><div class="line">    prev.next = curt_l;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归调用merge sort</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//寻找链表中点mid</span></div><div class="line">  ListNode mid = findMid(head);</div><div class="line"></div><div class="line">  <span class="comment">//链表中点.next之后的链表排序</span></div><div class="line">  ListNode right = sortList(mid.next);</div><div class="line"></div><div class="line">  <span class="comment">//链表中点之前包括中点的链表排序</span></div><div class="line">  mid.next = <span class="keyword">null</span>;</div><div class="line">  ListNode left = sortList(head);</div><div class="line"></div><div class="line">  <span class="comment">//merge两段有序链表</span></div><div class="line">  ListNode res = merge(left,right);</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Reorder-List"><a href="#Reorder-List" class="headerlink" title="Reorder List"></a><a href="https://leetcode.com/problems/reorder-list/" target="_blank" rel="external">Reorder List</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n,</p>
<p>reorder it to: <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,</p>
<p>Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.</p>
</blockquote>
<h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>题目需要从后向前访问链表，但是链表是单向的，所以需要reverse反转操作，再和原链表merge。</p>
<p><strong>具体步骤：</strong></p>
<ol>
<li>找到链表中点，mid</li>
<li>将mid之后的链表反转</li>
<li>将mid之前的链表和mid之后反转的链表做merge操作</li>
</ol>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//找到中间位置的元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">findMid</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    &#125;</div><div class="line">    ListNode slow = head;</div><div class="line">    ListNode fast = head;</div><div class="line">    <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</div><div class="line">        slow = slow.next;</div><div class="line">        fast = fast.next.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//链表反转</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    ListNode prev = <span class="keyword">null</span>;</div><div class="line">    ListNode curt = head;</div><div class="line">    <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">        ListNode temp = curt.next;</div><div class="line">        curt.next = prev;</div><div class="line">        prev = curt;</div><div class="line">        curt = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> prev;</div><div class="line">&#125;</div><div class="line"><span class="comment">//交替merge</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(ListNode left,ListNode right)</span></span>&#123;</div><div class="line">    ListNode prev = left;</div><div class="line">    ListNode curt1 = left.next;</div><div class="line">    ListNode curt2 = right;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(curt1 != <span class="keyword">null</span> &amp;&amp; curt2 != <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            prev.next = curt2;</div><div class="line">            curt2 = curt2.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            prev.next = curt1;</div><div class="line">            curt1 = curt1.next;</div><div class="line">        &#125;</div><div class="line">        prev = prev.next;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(curt1 == <span class="keyword">null</span>)&#123;</div><div class="line">        prev.next = curt2;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        prev.next = curt1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">    <span class="comment">//边界条件</span></div><div class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//找到mid</span></div><div class="line">    ListNode mid = findMid(head);</div><div class="line"></div><div class="line">    <span class="comment">//将mid之后的部分反转</span></div><div class="line">    ListNode right = reverse(mid.next);</div><div class="line">    mid.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">//前半部分和反转后的后半部分merge</span></div><div class="line">    merge(head,right);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Fast-slow-pointer"><a href="#Fast-slow-pointer" class="headerlink" title="Fast-slow pointer"></a>Fast-slow pointer</h2><h3 id="1-Middle-of-Linked-List"><a href="#1-Middle-of-Linked-List" class="headerlink" title="1. Middle of Linked List"></a>1. Middle of Linked List</h3><p>寻找指针链表中点，快慢指针，快指针每次走两步，慢指针每次走一步，快指针走到链表结尾时，慢指针在中间</p>
<h3 id="2-Remove-Nth-Node-From-End-of-List"><a href="#2-Remove-Nth-Node-From-End-of-List" class="headerlink" title="2 .Remove Nth Node From End of List"></a>2 .<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="external">Remove Nth Node From End of List</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a linked list, remove the <em>n</em>th node from the end of list and return its head.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</div><div class="line">&gt;</div><div class="line">&gt;    After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong><br>Given <em>n</em> will always be valid.<br>Try to do this in one pass.</p>
</blockquote>
<p>删除掉从末尾开始第n个节点</p>
<h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>两个指针，fast先走n+！步slow再出发，当fast==null时，slow指向倒数第n+1个节点，删掉slow后面的节点：slow.next = slow.next.next</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    dummy.next = head;</div><div class="line">    ListNode slow = dummy;</div><div class="line">    ListNode fast = dummy;</div><div class="line">    <span class="comment">//fast先走n+1步</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</div><div class="line">        fast = fast.next;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//fast、slow同时向后遍历</span></div><div class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</div><div class="line">        fast =fast.next;</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//删除节点</span></div><div class="line">    slow.next = slow.next.next；</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-Linked-List-Cycle"><a href="#3-Linked-List-Cycle" class="headerlink" title="3. Linked List Cycle"></a>3. <a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="external">Linked List Cycle</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<p>给定一个链表，判断是否有圈</p>
<h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<p>判断node是否有被重复访问</p>
<p>从head出发，把所有访问过的点放到一个hash表里，空间复杂度O(n)</p>
<p>方法二：</p>
<p>一个快指针一个慢指针，如果路径上有环，快慢指针一定会相遇</p>
<p>初始化：slow = head;fast = head.next</p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    ListNode fast = head.next;</div><div class="line">    ListNode slow = head;</div><div class="line">    <span class="keyword">while</span>(fast != slow)&#123;</div><div class="line">        <span class="comment">//fast走到null</span></div><div class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        fast = fast.next.next;</div><div class="line">        slow =slow.next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//fast和slow相遇了</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-Linked-List-Cycle-II"><a href="#4-Linked-List-Cycle-II" class="headerlink" title="4. Linked List Cycle II"></a>4. <a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="external">Linked List Cycle II</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p><strong>Note:</strong> Do not modify the linked list.</p>
<p><strong>Follow up</strong>:<br>Can you solve it without using extra space?</p>
</blockquote>
<p>是否有环，如果有，找到环的入口</p>
<h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>slow从快慢指针相遇的地方出发，fast指针从初始地方出发，两个指针每次走一步，直到相遇，就是环的入口</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  ListNode fast = head.next;</div><div class="line">  ListNode slow = head;</div><div class="line">  <span class="keyword">while</span>(fast != slow)&#123;</div><div class="line">    <span class="comment">//fast走到null</span></div><div class="line">    <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    fast = fast.next.next;</div><div class="line">    slow = slow.next;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//fast和slow相遇了</span></div><div class="line">  slow = head;</div><div class="line">  fast = fast.next;</div><div class="line">  <span class="keyword">while</span>(slow != fast)&#123;</div><div class="line">    slow = slow.next;</div><div class="line">    fast = fast.next;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> slow;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-Rotate-List"><a href="#5-Rotate-List" class="headerlink" title="5. Rotate List"></a>5. <a href="https://leetcode.com/problems/rotate-list/" target="_blank" rel="external">Rotate List</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,</div><div class="line">&gt; return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p>将链表向后移k次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Given <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL and k = <span class="number">2</span>,</div><div class="line">            ↑  ↑  ↑</div><div class="line">node.next=head ↑  ↑</div><div class="line">      dummy.next tail.next=head</div></pre></td></tr></table></figure>
<p>求解步骤：</p>
<ol>
<li>求链表长度len，如果k&gt;len,k = k%len;</li>
<li>找到从后往前数第k个元素，也就是从前往后数第len-k个元素node，和末尾元素tail</li>
<li>tail.next = dummy.next;dummy.next = node.next;node.next = null</li>
</ol>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">           <span class="keyword">return</span> head;</div><div class="line">       &#125;</div><div class="line">       ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">       dummy.next = head;</div><div class="line">       ListNode tail = dummy;</div><div class="line">       <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">       <span class="keyword">while</span>(tail.next != <span class="keyword">null</span>)&#123;</div><div class="line">           tail = tail.next;</div><div class="line">           len++;</div><div class="line">       &#125;</div><div class="line">       k = k % len;</div><div class="line">       ListNode node = dummy;</div><div class="line">       <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">       <span class="keyword">while</span>(i &lt;= len - k)&#123;</div><div class="line">           node = node.next;</div><div class="line">           i++;</div><div class="line">       &#125;</div><div class="line">       tail.next = dummy.next;</div><div class="line">       dummy.next = node.next;</div><div class="line">       node.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> dummy.next;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="Merge-k-Sorted-Lists"><a href="#Merge-k-Sorted-Lists" class="headerlink" title="Merge k Sorted Lists"></a><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="external">Merge k Sorted Lists</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Merge <em>k</em> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
</blockquote>
<p>merge k 个有序链表</p>
<h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>一共三种方法，都需要掌握：</p>
<p>方法一：heap</p>
<p>用PriorityQueue实现</p>
<p>第一个参数 - 第二个参数：升序，最小堆</p>
<p>第二个参数 - 第一个参数：降序，最大堆</p>
<p>初始化：将链表头放进去</p>
<p>每次弹出最小的元素，放到结果链表后面，然后将其next入堆，重复上述</p>
<p>N：所有数的个数</p>
<p>K：链表个数</p>
<p>时间复杂度：<script type="math/tex">O(NlogK)</script> ，heap中最多有k各元素，插入操作时间复杂度是<script type="math/tex">O(logk)</script></p>
<p>空间复杂度：<script type="math/tex">O(K)</script></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//heap</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> k = lists.length;</div><div class="line">        PriorityQueue&lt;ListNode&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</div><div class="line">           <span class="comment">// @Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o1.val - o2.val;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode prev = dummy;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;i++)&#123;</div><div class="line">            ListNode head = lists[i];</div><div class="line">            <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</div><div class="line">                minHeap.add(head);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(!minHeap.isEmpty())&#123;</div><div class="line">            ListNode curt = minHeap.poll();</div><div class="line">            prev.next = curt;</div><div class="line">            <span class="keyword">if</span>(curt.next != <span class="keyword">null</span>)&#123;</div><div class="line">                minHeap.add(curt.next);</div><div class="line">            &#125;</div><div class="line">            prev = prev.next;</div><div class="line">        &#125;</div><div class="line">        prev.next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法二：分治法</p>
<p>merge k 个链表</p>
<ul>
<li>拆分成merge前k/2个链表得到list1和merge后k/2个链表得到list2</li>
<li>合并list1和 list2，得到结果</li>
</ul>
<p>递归调用求解上述子问题</p>
<p>时间复杂度：<script type="math/tex">O(NlogK)</script></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">     result</div><div class="line">     ↗    ↖</div><div class="line">   ↗      ↗ ↖</div><div class="line">↗  ↖    ↗   ↗  ↖</div><div class="line"><span class="number">1</span>	<span class="number">2</span> |	<span class="number">3</span> |	<span class="number">4</span>	<span class="number">5</span></div><div class="line"> </div><div class="line"></div><div class="line">    <span class="comment">//分治</span></div><div class="line">    <span class="comment">//merge两个List</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">MergeTwoList</span><span class="params">(ListNode left,ListNode right)</span></span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode prev = dummy;</div><div class="line">        ListNode prev1 = left;</div><div class="line">        ListNode prev2 = right;</div><div class="line">        <span class="keyword">while</span>(prev1 != <span class="keyword">null</span> &amp;&amp; prev2 != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(prev1.val &lt; prev2.val)&#123;</div><div class="line">                prev.next = prev1;</div><div class="line">                prev1 = prev1.next;</div><div class="line">                prev = prev.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                prev.next = prev2;</div><div class="line">                prev2 = prev2.next;</div><div class="line">                prev = prev.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(prev1 == <span class="keyword">null</span>)&#123;</div><div class="line">            prev.next = prev2;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(prev2 == <span class="keyword">null</span>)&#123;</div><div class="line">            prev.next = prev1;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//分治法mergek个数组</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">divideMergeKList</span><span class="params">(ListNode[] lists,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(start == end)&#123;</div><div class="line">            <span class="keyword">return</span> lists[start];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//拆分成两部分</span></div><div class="line">        ListNode left = divideMergeKList(lists,start,start+(end-start)/<span class="number">2</span>);</div><div class="line">        ListNode right = divideMergeKList(lists,start+(end-start)/<span class="number">2</span>+<span class="number">1</span>,end);</div><div class="line">        <span class="comment">//合并两部分结果返回</span></div><div class="line">        <span class="keyword">return</span> MergeTwoList(left,right);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//调用分治法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">DividemergeKLists</span><span class="params">(ListNode[] lists)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> len = lists.length;</div><div class="line">        <span class="keyword">if</span>(len ==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> divideMergeKList(lists,<span class="number">0</span>,len-<span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法三：两两合并</p>
<p>1、2合并，3、4合并，….n</p>
<p>向上递归合并</p>
<p>时间复杂度：<script type="math/tex">O(NlogK)</script></p>
<p>如果是1、2合并，然后忽然3合并，…n</p>
<p>时间复杂度O(NK)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="comment">//两两合并</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKListsOneByOne</span><span class="params">(ListNode[] lists)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(lists.length == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  List&lt;ListNode&gt; newlists = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length;i++) &#123;</div><div class="line">    newlists.add(lists[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (newlists.size() &gt; <span class="number">1</span>)&#123;</div><div class="line">    List&lt;ListNode&gt; listTemp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i+<span class="number">1</span> &lt; newlists.size();i+=<span class="number">2</span>)&#123;</div><div class="line">      listTemp.add(MergeTwoList(newlists.get(i),newlists.get(i+<span class="number">1</span>)));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(newlists.size() % <span class="number">2</span> == <span class="number">1</span>)&#123;</div><div class="line">      listTemp.add(newlists.get(newlists.size()-<span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">    newlists = listTemp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> newlists.get(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Copy-List-with-Random-Pointer"><a href="#Copy-List-with-Random-Pointer" class="headerlink" title="Copy List with Random Pointer"></a><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="external">Copy List with Random Pointer</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
</blockquote>
<p>给定一个链表，每个节点除包含一个next指针以外，还有一个指向任意节点的random pointer，clone链表</p>
<h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<p>hash_map</p>
<p>先按next指针复制链表，把原链表老节点和新链表新节点的映射关系存入hash_map，再遍历一遍原链表，按照hash_map中的对应关系，把random pointer在对应的新节点中标出。</p>
<p>空间复杂度<script type="math/tex">O(n)</script></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</div><div class="line">       RandomListNode dummy = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</div><div class="line">       RandomListNode prevNew = dummy;</div><div class="line">       RandomListNode prev = head;</div><div class="line">       HashMap&lt;RandomListNode,RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">       <span class="comment">//将链表和next指针复制，对应点存入hashmap</span></div><div class="line">       <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">           RandomListNode temp = <span class="keyword">new</span> RandomListNode(prev.label);</div><div class="line">           prevNew.next = temp;</div><div class="line">           map.put(prev,prevNew.next);</div><div class="line">           prev = prev.next;</div><div class="line">           prevNew = prevNew.next;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">//复制random poiner</span></div><div class="line">       prev = head;</div><div class="line">       prevNew = dummy.next;</div><div class="line">       <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">           prevNew.random = map.get(prev.random);</div><div class="line">           prev = prev.next;</div><div class="line">           prevNew = prevNew.next;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> dummy.next;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-14-23-57-14.png" alt=""> </p>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList2</span><span class="params">(RandomListNode head)</span> </span>&#123;</div><div class="line">  RandomListNode prev = head;</div><div class="line">  <span class="comment">//将每个元素都复制一份，插在原来元素的后面一位上</span></div><div class="line">  <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">    RandomListNode node = <span class="keyword">new</span> RandomListNode(prev.label);</div><div class="line">    node.next = prev.next;</div><div class="line">    prev.next = node;</div><div class="line">    prev = prev.next.next;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//加入random pointer</span></div><div class="line">  prev = head;</div><div class="line">  <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(prev.random != <span class="keyword">null</span>)&#123;</div><div class="line">      prev.next.random = prev.random.next;</div><div class="line">    &#125;</div><div class="line">    prev = prev.next.next;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//删掉原来元素；</span></div><div class="line">  RandomListNode dummy = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</div><div class="line">  dummy.next = head;</div><div class="line">  prev = dummy;</div><div class="line">  RandomListNode curt = head;</div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    prev.next = curt.next;</div><div class="line">    curt.next = curt.next.next;</div><div class="line">    prev = prev.next;</div><div class="line">    curt = curt.next;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-14-23-55-46.png" alt=""> </p>
<h2 id="leetcode-相关习题"><a href="#leetcode-相关习题" class="headerlink" title="leetcode 相关习题"></a>leetcode 相关习题</h2><h3 id="Palindrome-Linked-List"><a href="#Palindrome-Linked-List" class="headerlink" title="Palindrome Linked List"></a><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="external">Palindrome Linked List</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a singly linked list, determine if it is a palindrome.</p>
<p><strong>Follow up:</strong><br>Could you do it in O(n) time and O(1) space?</p>
</blockquote>
<p>给定链表，判读是否是回文串，要求时间复杂度<script type="math/tex">O(n)</script>，空间复杂度<script type="math/tex">O(1)</script></p>
<h4 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<p>利用stack，先进后出的性质：</p>
<ol>
<li>找到终点，过程中将前半部分链表入栈</li>
<li>继续向后遍历，出栈，对比元素是否一致</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindromeStack</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="comment">//空链表和只有一个元素</span></div><div class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//快慢指针寻找中点,前半部分元素入栈</span></div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        ListNode mid = head;</div><div class="line">        ListNode tail = head;</div><div class="line">        stack.push(head.val);</div><div class="line">        <span class="keyword">while</span>(tail.next != <span class="keyword">null</span> &amp;&amp; tail.next.next != <span class="keyword">null</span>)&#123;</div><div class="line">            mid = mid.next;</div><div class="line">            stack.push(mid.val);</div><div class="line">            tail = tail.next.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果是奇数个元素，将mid弹出，无须比较</span></div><div class="line">        <span class="keyword">if</span>(tail.next == <span class="keyword">null</span>)&#123;</div><div class="line">            stack.pop();</div><div class="line">        &#125;</div><div class="line">        mid = mid.next;</div><div class="line">        <span class="keyword">while</span>(mid != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">int</span> temp = stack.peek();</div><div class="line">            <span class="keyword">if</span>(temp != mid.val)&#123;</div><div class="line">                <span class="keyword">return</span>  <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            stack.pop();</div><div class="line">            mid = mid.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<ol>
<li>先找到中点</li>
<li>将后半部分的链表反转</li>
<li>对比前后两部分是否一致</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//快慢指针寻找中点</span></div><div class="line">        ListNode mid = head;</div><div class="line">        ListNode tail = head;</div><div class="line">        <span class="keyword">while</span>(tail.next != <span class="keyword">null</span> &amp;&amp; tail.next.next != <span class="keyword">null</span>)&#123;</div><div class="line">            mid = mid.next;</div><div class="line">            tail = tail.next.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//反转后半个链表</span></div><div class="line">        ListNode prev = <span class="keyword">null</span>;</div><div class="line">        ListNode curt = mid.next;</div><div class="line">        <span class="keyword">while</span>(curt !=  <span class="keyword">null</span>)&#123;</div><div class="line">            ListNode temp = curt.next;</div><div class="line">            curt.next = prev;</div><div class="line">            prev = curt;</div><div class="line">            curt = temp;</div><div class="line">        &#125;</div><div class="line">        mid.next = prev;</div><div class="line">        <span class="comment">//对比两段元素是否一致</span></div><div class="line">        ListNode first = head;</div><div class="line">        ListNode second = mid.next;</div><div class="line">        <span class="keyword">while</span>(second != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(first.val != second.val)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            first = first.next;</div><div class="line">            second = second.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160.Intersection of Two Linked Lists"></a><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="external">160.Intersection of Two Linked Lists</a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; A:          a1 → a2</div><div class="line">&gt;                    ↘</div><div class="line">&gt;                      c1 → c2 → c3</div><div class="line">&gt;                    ↗            </div><div class="line">&gt; B:     b1 → b2 → b3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>begin to intersect at node c1.</p>
<p><strong>Notes:</strong></p>
<ul>
<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>
<li>The linked lists must retain their original structure after the function returns.</li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
</blockquote>
<p>找到两个链表相交的地方</p>
<h4 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h4><p>是个技巧题，想到了就能做出来，想不到就做不出来</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-22-20-02-17.png" alt=""> </p>
<p>方法：</p>
<p>两个指针分别遍历，一个先A后B，一个先B后A，两指针指向节点相等即为相交处</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        ListNode n1 = headA;</div><div class="line">        ListNode n2 = headB;</div><div class="line">        <span class="comment">//记录是否遍历第二个链表</span></div><div class="line">        <span class="keyword">boolean</span> flag1 = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">boolean</span> flag2 = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="comment">//两个指针都遍历结束了，没有相交节点</span></div><div class="line">            <span class="keyword">if</span>(n1 == <span class="keyword">null</span> &amp;&amp; flag1)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//n1遍历完一个数组</span></div><div class="line">            <span class="keyword">if</span>(n1 == <span class="keyword">null</span> &amp;&amp; !flag1)&#123;</div><div class="line">                 n1 = headB;</div><div class="line">                 flag1 = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//n2遍历完一个数组</span></div><div class="line">            <span class="keyword">if</span>(n2 == <span class="keyword">null</span> &amp;&amp; !flag2)&#123;</div><div class="line">                n2 = headA;</div><div class="line">                flag2 = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (n1 == n2)&#123;</div><div class="line">                <span class="keyword">return</span> n1;</div><div class="line">            &#125;</div><div class="line">            n1 = n1.next;</div><div class="line">            n2 = n2.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> idx = Math.abs(nums[i]);</div><div class="line">            <span class="keyword">if</span>(nums[idx] &lt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">return</span> idx;</div><div class="line">            &#125;</div><div class="line">            nums[idx] = -nums[idx];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[DeepFM论文笔记]]></title>
      <url>/2017/12/10/DeepFM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>线性模型不好捕捉交叉特征，FM由于模型复杂性，通常只能捕捉到两维特征交互，NN捕获低维特征能力弱。wide&amp;deep模型能够同时获取低维特征，但是需要低纬、高维两部分特征分开输入模型，而且wide部分的特征也是需要专门的特征工程进行的。</p>
<a id="more"></a>
<p>现有模型要么偏重于处理低维度模型，或者高维度模型，或者需要依赖于专门的特征工程。本文我们提出一种end to end的方法可以同时获取高维度和低维度特征，无需额外的特征工程，可以将原有特征直接输入模型，主要贡献如下：</p>
<ol>
<li>整合FM和DNN，提出了DeepFM模型，像FM一样学习低维度交互特征，像DNN一样学习高维度交互特征，DeepFM可以endtoend训练不需要额外的特征工程</li>
<li>DeepFM训练高效，因为deep和wide使用同一输入和embedding向量，而在wide&amp;deep模型里，输入向量维度很大，因为有很多人工构造的成对的交叉特征，大大增加了模型的复杂程度</li>
<li>用benchmark和商用数据集测试后均发现DeepFM效果好于其他CTR预估模型。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> RTB </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法基础班】二分法]]></title>
      <url>/2017/12/07/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E4%BA%8C%E5%88%86%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="classical-Binary-Search"><a href="#classical-Binary-Search" class="headerlink" title="classical Binary Search"></a>classical Binary Search</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给定一个排序数组和一个元素n，返回元素n的位置</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>num</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>13</td>
<td>21</td>
<td>34</td>
<td>55</td>
<td>89</td>
</tr>
</tbody>
</table>
</div>
<p>查找元素5的位置</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>初始化:</p>
<p>​    start = 0;end = 8;mid = 4</p>
<ol>
<li>nums[mid] = 13;start = 0;end = 4,mid = 2</li>
<li>nums[mid] = 5;find it!</li>
</ol>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">数据规模为n:</div><div class="line">T(n) = T(n/<span class="number">2</span>)+O(<span class="number">1</span>)</div><div class="line">其中O(<span class="number">1</span>)为比较的时间复杂度，T(n/<span class="number">2</span>)为比较之后</div><div class="line">时间复杂度是:O(logn)</div></pre></td></tr></table></figure>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>递归：</p>
<ul>
<li>优点：代码简洁</li>
<li>缺点：递归利用栈空间，递归层数过多会导致栈溢出</li>
</ul>
</li>
<li><p>while循环</p>
<ul>
<li>优点：占用空间小</li>
<li>缺点：代码可读性稍差，不够简洁</li>
</ul>
<p>面试的时候用什么？</p>
<p>如果用递归的方式写会好理解很多，就用递归写，不然就不用递归，在工程上，递归很容易导致栈溢出。</p>
</li>
</ol>
<p>这道题用最好用非递归的方式写，因为是很简短的</p>
<h3 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h3><ul>
<li>start + 1 &lt; end</li>
<li>mid = start +(end - start)/2;如果用(start + end)/2，如果start和end都很大相加就有可能溢出</li>
<li>A[mid] = &lt; &gt; 三种情况讨论</li>
<li>A[start] A[end]?target</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">            <span class="comment">//中值</span></div><div class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="comment">//三种情况讨论</span></div><div class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//结果</span></div><div class="line">        <span class="keyword">if</span> (nums[start] == target) &#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (nums[end] == target) &#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="Search-for-a-Range"><a href="#Search-for-a-Range" class="headerlink" title="Search for a Range"></a><a href="https://leetcode.com/problems/search-for-a-range" target="_blank" rel="external">Search for a Range</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<p>For example,<br>Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>return <code>[3, 4]</code>.</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>需要分别找到n<strong>第一次出现的位置</strong>和<strong>最后一次出现的位置</strong>，返回即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">int</span>[] result = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">if</span>(nums.length &lt;=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length -<span class="number">1</span>;</div><div class="line">        <span class="comment">//寻找第一次出现的位置</span></div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start +(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</div><div class="line">                <span class="comment">//第一次出现的位置，在前半段，end前移</span></div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[start] == target)&#123;</div><div class="line">            result[<span class="number">0</span>] = start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[end] == target)&#123;</div><div class="line">            result[<span class="number">0</span>] = end;</div><div class="line">        &#125;</div><div class="line">        start = <span class="number">0</span>;</div><div class="line">        end = nums.length -<span class="number">1</span>;</div><div class="line">        <span class="comment">//寻找最后一次出现的位置</span></div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start +(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</div><div class="line">                <span class="comment">//第一次出现的位置，在后半段，start后移</span></div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[end] == target)&#123;</div><div class="line">            result[<span class="number">1</span>] = end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] == target)&#123;</div><div class="line">            result[<span class="number">1</span>] = start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Search-Insert-Position"><a href="#Search-Insert-Position" class="headerlink" title="Search Insert Position"></a><a href="https://leetcode.com/problems/search-insert-position" target="_blank" rel="external">Search Insert Position</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,6], 5</div><div class="line">&gt; Output: 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,6], 2</div><div class="line">&gt; Output: 1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,6], 7</div><div class="line">&gt; Output: 4</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,6], 0</div><div class="line">&gt; Output: 0</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>二分法的问题一般都是找满足条件的firstposition和lastposition.</p>
<p>这道题是需要找到firstposition &gt;= targrt，第一个&gt;=target的位置。</p>
<p>while结束后，需要找firstposition的话先判断start，找lastposition的话先判断end。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length &lt;=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length -<span class="number">1</span>;</div><div class="line">        <span class="comment">//寻找第一次出现的位置</span></div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start +(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="comment">//找到了</span></div><div class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//没找到target,在start和end中找比target大的</span></div><div class="line">        <span class="comment">//start&gt;=tartget</span></div><div class="line">        <span class="keyword">if</span>(nums[start] &gt;= target)&#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//end&gt;=tartget</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[end] &gt;= target)&#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums中所有元素都比target小</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> end+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Search-a-2D-Matrix"><a href="#Search-a-2D-Matrix" class="headerlink" title="Search a 2D Matrix"></a><a href="https://leetcode.com/problems/search-a-2d-matrix" target="_blank" rel="external">Search a 2D Matrix</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p>For example,</p>
<p>Consider the following matrix:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1,   3,  5,  7],</div><div class="line">&gt;   [10, 11, 16, 20],</div><div class="line">&gt;   [23, 30, 34, 50]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Given <strong>target</strong> = <code>3</code>, return <code>true</code>.</p>
</blockquote>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>两种做法：</p>
<ol>
<li><p>先按每行的首个数字二分确定target所在的行，再在这行里二分。</p>
</li>
<li><p>看成一维数组，二分查找，其中看成一维数组的序号n和二维数组中行号、列号对应关系为：</p>
<p>r = n/columns;</p>
<p>c = n%columns;</p>
</li>
</ol>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchA2DMatrix</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="comment">//空矩阵判断</span></div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span>(rows &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span>  <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(cols &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span>  <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = rows*cols -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start+<span class="number">1</span> &lt;end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">int</span> r = mid/cols;</div><div class="line">            <span class="keyword">int</span> c = mid%cols;</div><div class="line">            <span class="keyword">if</span> (matrix[r][c] == target)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(matrix[r][c] &lt; target)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(matrix[r][c] &gt; target)&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(matrix[start/cols][start%cols]==target)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(matrix[end/cols][end%cols]==target)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Search-a-2D-Matrix-II"><a href="#Search-a-2D-Matrix-II" class="headerlink" title="Search a 2D Matrix II"></a><a href="https://leetcode.com/problems/search-a-2d-matrix-ii" target="_blank" rel="external">Search a 2D Matrix II</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<p>For example,</p>
<p>Consider the following matrix:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1,   4,  7, 11, 15],</div><div class="line">&gt;   [2,   5,  8, 12, 19],</div><div class="line">&gt;   [3,   6,  9, 16, 22],</div><div class="line">&gt;   [10, 13, 14, 17, 24],</div><div class="line">&gt;   [18, 21, 23, 26, 30]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Given <strong>target</strong> = <code>5</code>, return <code>true</code>.</p>
<p>Given <strong>target</strong> = <code>20</code>, return <code>false</code>.</p>
</blockquote>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><ul>
<li>方法一：</li>
</ul>
<p>从对角线开始二分找， 找到第一个&gt;=target的位置，将大矩形分割成4个小矩形，分两种情况讨论：</p>
<ol>
<li>元素 = target，返回true</li>
<li>元素 &gt; target，左上角的矩阵中元素 &lt; target，右下角矩阵中的元素都 &gt; target，都不可能有符合条件的值了，所以只需继续在左下角和右上角的矩阵中继续寻找。</li>
</ol>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-08-13-20-33.png" alt=""> </p>
<p>​    时间复杂度分析：</p>
<p><script type="math/tex">T(n) = 2T(n/4)+O(log\sqrt{n})</script>，其中<script type="math/tex">\sqrt{n}</script>为对角线元素个数。</p>
<ul>
<li><p>方法二：</p>
<p>矩阵特点：每一行和每一列递增</p>
<p>从左下角往右上角找，有如下三种情况：</p>
</li>
</ul>
<ol>
<li>元素 = target，返回true</li>
<li>元素 &lt; target，下一步向右走，因为右边的元素都大于当前元素，上方元素小于当前元素</li>
<li>元素 &gt; target，下一步向上走，因为右边的元素都大于当前元素，上方元素小于当前元素</li>
</ol>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-08-09-51-55.png" alt=""> </p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span>(rows &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(cols &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> r = rows-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(r &gt;=<span class="number">0</span> &amp;&amp; c &lt;cols)&#123;</div><div class="line">            <span class="keyword">if</span>(matrix[r][c]==target)&#123;</div><div class="line">                <span class="keyword">return</span>  <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[r][c] &lt; target)&#123;</div><div class="line">                c++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[r][c] &gt; target)&#123;</div><div class="line">                r--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div></pre></td></tr></table></figure>
<h3 id="First-Bad-Version"><a href="#First-Bad-Version" class="headerlink" title="First Bad Version"></a><a href="https://leetcode.com/problems/first-bad-version" target="_blank" rel="external">First Bad Version</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>
<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
</blockquote>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>有1到n个版本，找到第一个错误版本的位置。利用从第一个错误的开始之后后面的都是错的，用二分查找到第一个错误版本。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> end = n;</div><div class="line">    <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">        <span class="keyword">int</span> mid = start+(end=start)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(isBadVersion(mid))&#123;</div><div class="line">            end = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            start = mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(isBadVersion(start))&#123;</div><div class="line">        <span class="keyword">return</span> start;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(isBadVersion(end))&#123;</div><div class="line">        <span class="keyword">return</span> end;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Find-Peak-Element"><a href="#Find-Peak-Element" class="headerlink" title="Find Peak Element"></a><a href="https://leetcode.com/problems/find-peak-element" target="_blank" rel="external">Find Peak Element</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array where <code>num[i] ≠ num[i+1]</code>, find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that <code>num[-1] = num[n] = -∞</code>.</p>
<p>For example, in array <code>[1, 2, 3, 1]</code>, 3 is a peak element and your function should return the index number 2.</p>
</blockquote>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>给定一个数组，返回peak的元素（左边右边都比自己小），如果有多个返回任意一个即可，要求时间复杂度为O(logn)</p>
<p>遇到O(logn)要考虑到二分法：</p>
<p>二分法选取mid元素，其跟左右元素的关系有如下四中情况：</p>
<ol>
<li>两边元素都比mid小，mid就是peak,，返回</li>
<li>两边元素都比mid大，左右都有可能有peak，任选一边二分</li>
<li>左边小又边大，右边一定有peak，继续对右边二分</li>
<li>左边大右边小，左边一定有peak，继续对左边二分</li>
</ol>
<p>需要注意的地方：</p>
<p>因为要将元素跟其左边和右边的元素比较，所以为了<strong>避免越界，初始需要将start设为1，end设为length-1</strong>；还需要把两个边界值设为负无穷，确保边界值也可以被选上。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span>[] nums2 = <span class="keyword">new</span> <span class="keyword">long</span>[nums.length+<span class="number">2</span>];</div><div class="line">    nums2[<span class="number">0</span>] = -Long.MAX_VALUE;</div><div class="line">    nums2[nums.length+<span class="number">1</span>] = -Long.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">        nums2[i+<span class="number">1</span>] = nums[i];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遇到这种需要判断元素左右的将start设为1，end设为len-2,放置越界</span></div><div class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> end = nums2.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(start+<span class="number">1</span>&lt;end)&#123;</div><div class="line">        <span class="keyword">int</span> mid = start + (end-start)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>((nums2[mid] &gt; nums2[mid+<span class="number">1</span>]) &amp;&amp; (nums2[mid] &gt; nums2[mid-<span class="number">1</span>]))&#123;</div><div class="line">            <span class="keyword">return</span> mid-<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((nums2[mid] &lt; nums2[mid+<span class="number">1</span>]) &amp;&amp; (nums2[mid] &lt; nums2[mid-<span class="number">1</span>]))&#123;</div><div class="line">            start = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((nums2[mid] &gt; nums2[mid+<span class="number">1</span>]) &amp;&amp; (nums2[mid] &lt; nums2[mid-<span class="number">1</span>]))&#123;</div><div class="line">            end = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            start = mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums2[start] &lt; nums2[end])&#123;</div><div class="line">        <span class="keyword">return</span>  end-<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> start-<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Find-Minimum-in-Rotated-Sorted-Array"><a href="#Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="Find Minimum in Rotated Sorted Array"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array" target="_blank" rel="external">Find Minimum in Rotated Sorted Array</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
</blockquote>
<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">递增数组：</div><div class="line">              ↗</div><div class="line">            ↗</div><div class="line">          ↗</div><div class="line">        ↗</div><div class="line">      ↗</div><div class="line">    ↗</div><div class="line">  ↗</div><div class="line">↗</div><div class="line">旋转数组：</div><div class="line">旋转数组，分成两段上升数组：</div><div class="line">              ↗|</div><div class="line">            ↗  |</div><div class="line">          ↗    |</div><div class="line">        ↗      |</div><div class="line">      ↗        |</div><div class="line">---------------|------------------</div><div class="line">               |    ↗</div><div class="line">               |  ↗</div><div class="line">               |↗</div><div class="line">      ↑     ↑        ↑</div><div class="line">    start  mid      end</div><div class="line">用二分法，判断mid与end的大小，确定mid位于两段上升数组的哪一段：</div><div class="line"><span class="number">1</span>. nums[mid] &lt; nums[end]:</div><div class="line">	mid在后段上升数组中，end = mid</div><div class="line"><span class="number">2</span>. nums[mid] &gt; nums[end]:</div><div class="line">	mid在前段上升数组中，start = mid</div></pre></td></tr></table></figure>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (start+<span class="number">1</span>&lt;end)&#123;</div><div class="line">    <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(nums[mid] &lt; nums[end])&#123;</div><div class="line">      end = mid;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums[mid] &gt; nums[end])&#123;</div><div class="line">      start = mid;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(nums[start] &gt; nums[end])&#123;</div><div class="line">    <span class="keyword">return</span> nums[end];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">return</span> nums[start];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="Find Minimum in Rotated Sorted Array II"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii" target="_blank" rel="external">Find Minimum in Rotated Sorted Array II</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote>
<blockquote>
<p><em>Follow up</em> for “Find Minimum in Rotated Sorted Array”:<br>What if <em>duplicates</em> are allowed?</p>
<p>Would this affect the run-time complexity? How and why?</p>
</blockquote>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
</blockquote>
<p>延续上一题，有重复数字的旋转数组，找到最小的值。</p>
<h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>如果存在重复元素，无法使用二分查找使得时间复杂度为O(logn)，最坏时间复杂度只能是o(n)。</p>
<p>证明方法：<strong>黑盒测试</strong></p>
<p>假设给定的数组中有一个1和n-1个2，此时mid=2，无法判断1在哪边。</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(nums[i] &lt; min)&#123;</div><div class="line">      min = nums[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array" target="_blank" rel="external">Search in Rotated Sorted Array</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
</blockquote>
<p>给定一个旋转递增数组和一个数，返回数在数组中的位置。</p>
<h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>二分法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">递增数组：</div><div class="line">              ↗</div><div class="line">            ↗</div><div class="line">          ↗</div><div class="line">        ↗</div><div class="line">      ↗</div><div class="line">    ↗</div><div class="line">  ↗</div><div class="line">↗</div><div class="line"></div><div class="line">旋转数组，分成两段上升数组：</div><div class="line">              ↗|</div><div class="line">            ↗  |</div><div class="line">          ↗    |</div><div class="line">        ↗      |</div><div class="line">      ↗        |</div><div class="line">---------------|------------------</div><div class="line">               |    ↗</div><div class="line">               |  ↗</div><div class="line">               |↗</div><div class="line">      ↑     ↑        ↑</div><div class="line">    start  mid      end</div><div class="line">二分法，mid和end比较：</div><div class="line"><span class="number">1</span>. nums[mid] &gt; nums[end]：</div><div class="line">	mid在第一段上升区间，跟target比较：</div><div class="line">		<span class="number">1</span>. 如果target在start和mid之间，end= mid</div><div class="line">		<span class="number">2</span>. 否则，start = mid,继续做二分查找，仍然是一个search in rotated sorted array问题</div><div class="line"><span class="number">2</span>. nums[mid] &lt; nums[end]：</div><div class="line">	mid在第二段上升区间，跟target比较：</div><div class="line">		<span class="number">1</span>. 如果target在mid和end之间，end= mid</div><div class="line">		<span class="number">2</span>. 否则，start = mid,继续做二分查找，仍然是一个search in rotated sorted array问题</div></pre></td></tr></table></figure>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchInRotatedSortedArray</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start+<span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(target == nums[mid])&#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//mid在第一个上升区间</span></div><div class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[end])&#123;</div><div class="line">                <span class="keyword">if</span>(target &lt; nums[mid] &amp;&amp; target &gt;= nums[start])&#123;</div><div class="line">                    end = mid;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    start = mid;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">///mid在第二个上升区间</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[end])&#123;</div><div class="line">                    start = mid;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    end = mid;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[start] == target)&#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[end] == target)&#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Search-in-Rotated-Sorted-Array-II"><a href="#Search-in-Rotated-Sorted-Array-II" class="headerlink" title="Search in Rotated Sorted Array II"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii" target="_blank" rel="external">Search in Rotated Sorted Array II</a></h3><p>有重复元素，无法二分查找，时间复杂度为O(n)，遍历查找即可。</p>
<h3 id="Merge-Sorted-Array"><a href="#Merge-Sorted-Array" class="headerlink" title="Merge Sorted Array"></a><a href="https://leetcode.com/problems/merge-sorted-array" target="_blank" rel="external">Merge Sorted Array</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p> Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p> <strong>Note:</strong><br> You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>. The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</p>
</blockquote>
<h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>合并连个有序数组，把S2并入S1，假设S1有足够大的空间。</p>
<p>考点：从后往前合并，因为后面的空间是空的，不会覆盖原有元素。</p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortedArray</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> end1 = m-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end2 = n-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = m+n-<span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (end1 &gt;=<span class="number">0</span> &amp;&amp; end2&gt;=<span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span>(nums1[end1] &lt; nums2[end2])&#123;</div><div class="line">                nums1[end] = nums2[end2];</div><div class="line">                end2--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                nums1[end] = nums1[end1];</div><div class="line">                end1--;</div><div class="line">            &#125;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums1元素剩下了</span></div><div class="line">        <span class="keyword">if</span> (end1 &gt;= <span class="number">0</span>) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums2元素剩下了</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (end2 &gt;=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">while</span> (end2 &gt;= <span class="number">0</span>)&#123;</div><div class="line">                nums1[end] = nums2[end2];</div><div class="line">                end--;</div><div class="line">                end2--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays" target="_blank" rel="external">Median of Two Sorted Arrays</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums1 = [1, 3]</div><div class="line">&gt; nums2 = [2]</div><div class="line">&gt;</div><div class="line">&gt; The median is 2.0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums1 = [1, 2]</div><div class="line">&gt; nums2 = [3, 4]</div><div class="line">&gt;</div><div class="line">&gt; The median is (2 + 3)/2 = 2.5</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>令nums1.length = m;nums2.length = n;总长度m+n。先确定中位数m是多少:</p>
<ol>
<li><p>(m+n)%2 == 0:</p>
<p>m=(m+n)/2,(m+n)/2+1</p>
</li>
<li><p>(m+n)%2 == 1:</p>
<p> m=(m+n)/2</p>
</li>
</ol>
<p>问题转化为找<strong>两个有序数组的第K大</strong>的问题，如果用merge的方法获得merge之后的排序数组需要O(m+n)的时间复杂度，题目要求使用O(log(m+n))的时间复杂度，所以需要使用二分法：</p>
<p>如果A[k/2] &lt;= B[k/2]：A的前k/2个数一定都在A、B合并后的前K个数中，去掉A的前k/2个元素，继续寻找A和B的第m-k/2个元素。</p>
<p>如果A[k/2] &gt; B[k/2]：B的前k/2个数一定都在A、B合并后的前K个数中，去掉B的前k/2个元素，继续寻找A和B的第m-k/2个元素。</p>
<p>如果A[k/2]越界，A中剩余元素不足k/2个，则B中前k/2个元素一定在前K个中，去掉B的前k/2个元素，继续寻找A和B的第m-k/2个元素。</p>
<p>如果B[k/2]越界，B中剩余元素不足k/2个，则A中前k/2个元素一定在前K个中，去掉A的前k/2个元素，继续寻找A和B的第m-k/2个元素。</p>
<p>边界条件判断：</p>
<ol>
<li>nums1中没有元素了,直接返回nums2中的第k个</li>
<li>nums2中没有元素了,直接返回nums1中的第k个</li>
<li>k == 1，递归出口，直接返回min(nums1[start1],nums2[start2])</li>
</ol>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianOfTwoSortedArrays</span> </span>&#123;</div><div class="line">    <span class="comment">//两个sorted array merge 寻找第k大的元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span>[] nums2,<span class="keyword">int</span> k,<span class="keyword">int</span> start1,<span class="keyword">int</span> start2)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> end1 = nums1.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end2 = nums2.length - <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Math.min(nums1[start1],nums2[start2]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums1空了，</span></div><div class="line">        <span class="keyword">if</span>(start1 &gt; end1)&#123;</div><div class="line">            <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums2空了</span></div><div class="line">        <span class="keyword">if</span>(start2 &gt; end2)&#123;</div><div class="line">            <span class="keyword">return</span> nums1[start1 + k -<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums1的前k/2个元素已经超过nums1中剩余的所有元素个数</span></div><div class="line">        <span class="comment">//那么nums2的前k/2个元素都包含在前k个元素中</span></div><div class="line">        <span class="keyword">if</span>(start1 + k/<span class="number">2</span> - <span class="number">1</span> &gt; end1)&#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,nums2,k-k/<span class="number">2</span>,start1,start2+k/<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums2的前k/2个元素已经超过nums2中剩余的所有元素个数</span></div><div class="line">        <span class="comment">//那么nums1的前k/2个元素都包含在前k个元素中</span></div><div class="line">        <span class="keyword">if</span>(start2 + k/<span class="number">2</span> - <span class="number">1</span> &gt; end2)&#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,nums2,k-k/<span class="number">2</span>,start1+k/<span class="number">2</span>,start2);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums和nums2的前k/2个元素都没有超过个字的末尾</span></div><div class="line">        <span class="keyword">if</span>(nums1[start1 + k/<span class="number">2</span> - <span class="number">1</span>] &lt;nums2[start2+k/<span class="number">2</span>-<span class="number">1</span>])&#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,nums2,k-k/<span class="number">2</span>,start1+k/<span class="number">2</span>,start2);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,nums2,k-k/<span class="number">2</span>,start1,start2+k/<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len1 = nums1.length;</div><div class="line">        <span class="keyword">int</span> len2 = nums2.length;</div><div class="line">        <span class="keyword">int</span> k = (len1+len2)/<span class="number">2</span>;<span class="comment">//中位数</span></div><div class="line">        <span class="keyword">if</span>((len1+len2)%<span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">int</span> k1 = findKth(nums1,nums2,k,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">            <span class="keyword">int</span> k2 = findKth(nums1,nums2,k+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) (k1+k2)/<span class="number">2.0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,nums2,k+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        MedianOfTwoSortedArrays test = <span class="keyword">new</span> MedianOfTwoSortedArrays();</div><div class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">2</span>&#125;;</div><div class="line">        <span class="keyword">double</span> res = test.findMedianSortedArrays(nums1,nums2);</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Wood-Cut"><a href="#Wood-Cut" class="headerlink" title="Wood Cut"></a><a href="http://www.lintcode.com/en/problem/wood-cut/" target="_blank" rel="external">Wood Cut</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given n pieces of wood with length <code>L[i]</code> (integer array). Cut them into small pieces to guarantee you could have equal or more than k pieces with the same length. What is the longest length you can get from the n pieces of wood? Given L &amp; k, return the maximum length of the small pieces.</p>
<h5 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h5><p>You couldn’t cut wood into float length.</p>
<p>If you couldn’t get &gt;= <em>k</em> pieces, return <code>0</code>.</p>
<p>Example</p>
<p>For <code>L=[232, 124, 456]</code>, <code>k=7</code>, return <code>114</code>.</p>
</blockquote>
<h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p>给定一些长度为L[i]的木料，将他们据成k段，返回满足条件的最大长度。</p>
<p>先找到木料中最长的那块，长度为m然后对m进行二分法，判断这些木料是否可以据成长度为mid，个数&gt;=k个木料：</p>
<ol>
<li>如果可以，start = mid，进一步二分看是否可以据成更长的</li>
<li>如果不可以，end = mid，进一步二分据成更短的小段</li>
</ol>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * @param L: Given n pieces of wood with length L[i]</span></div><div class="line"><span class="comment">     * @param k: An integer</span></div><div class="line"><span class="comment">     * @return: The maximum length of the small pieces</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] L,<span class="keyword">int</span> len)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;L.length;i++)&#123;</div><div class="line">            sum += L[i]/len;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">woodCut</span><span class="params">(<span class="keyword">int</span>[] L, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="comment">// 找到最长的wood，</span></div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(L[i] &gt; max)&#123;</div><div class="line">                max = L[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//对要切割的wood长度做二分法</span></div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = max;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(count(L,mid) &gt;= k)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(count(L,end) &gt;= k)&#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(count(L,start) &gt;= k)&#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Count-of-Smaller-Numbers-After-Self"><a href="#Count-of-Smaller-Numbers-After-Self" class="headerlink" title="Count of Smaller Numbers After Self"></a><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/" target="_blank" rel="external">Count of Smaller Numbers After Self</a></h3><h3 id="Sqrt-x"><a href="#Sqrt-x" class="headerlink" title=" Sqrt(x)"></a><a href="https://leetcode.com/problems/sqrtx/description/" target="_blank" rel="external"> Sqrt(x)</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Implement <code>int sqrt(int x)</code>.</p>
<p>Compute and return the square root of <em>x</em>.</p>
<p><strong>x</strong> is guaranteed to be a non-negative integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 4</div><div class="line">&gt; Output: 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 8</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>输入数字x，返回根号x，只保留整数部分</p>
<p>思路就是找到最后一个number k，满足条件k^2 &lt; x，则k就是结果</p>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = x;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(mid * mid &lt;= x)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(end*end &lt;= x)&#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Rotate-Array"><a href="#Rotate-Array" class="headerlink" title="Rotate Array"></a><a href="https://leetcode.com/problems/rotate-array/description/" target="_blank" rel="external">Rotate Array</a></h3><blockquote>
<p>Rotate an array of <em>n</em> elements to the right by <em>k</em> steps.</p>
<p>For example, with <em>n</em> = 7 and <em>k</em> = 3, the array <code>[1,2,3,4,5,6,7]</code> is rotated to <code>[5,6,7,1,2,3,4]</code>.</p>
</blockquote>
<h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>三步翻转法：</p>
<ol>
<li><p>翻转左半段</p>
<p>4,3,2,1,5,6,7</p>
</li>
<li><p>翻转右半段</p>
<p>4,3,2,1,7,6,5</p>
</li>
<li><p>翻转整体</p>
<p>5,6,7,1,2,3,4</p>
</li>
</ol>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        k = k % nums.length;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length - k - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> temp = nums[start];</div><div class="line">            nums[start] = nums[end];</div><div class="line">            nums[end] = temp;</div><div class="line">            start++;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        start = nums.length - k;</div><div class="line">        end = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> temp = nums[start];</div><div class="line">            nums[start] = nums[end];</div><div class="line">            nums[end] = temp;</div><div class="line">            start++;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">        start = <span class="number">0</span>;</div><div class="line">        end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> temp = nums[start];</div><div class="line">            nums[start] = nums[end];</div><div class="line">            nums[end] = temp;</div><div class="line">            start++;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Reverse-Words-in-a-String-II"><a href="#Reverse-Words-in-a-String-II" class="headerlink" title="Reverse Words in a String II"></a><a href="https://leetcode.com/problems/reverse-words-in-a-string-ii/description/" target="_blank" rel="external">Reverse Words in a String II</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.</p>
<p>The input string does not contain leading or trailing spaces and the words are always separated by a single space.</p>
<p>For example,<br>Given s = “<code>the sky is blue</code>“,<br>return “<code>blue is sky the</code>“.</p>
<p>Could you do it <em>in-place</em> without allocating extra space?</p>
</blockquote>
<h4 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h4><p>三步翻转法</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(end &lt; str.length)&#123;</div><div class="line">        <span class="keyword">while</span>(end &lt; str.length &amp;&amp; str[end] != <span class="string">' '</span>)&#123;</div><div class="line">            end++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> stop = end-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt;= stop)&#123;</div><div class="line">            <span class="keyword">char</span> temp = str[start];</div><div class="line">            str[start] = str[stop];</div><div class="line">            str[stop] = temp;</div><div class="line">            start++;</div><div class="line">            stop--;</div><div class="line">        &#125;</div><div class="line">        start = end+<span class="number">1</span>;</div><div class="line">        end = end+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    start = <span class="number">0</span>;</div><div class="line">    end = str.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(start &lt;= end)&#123;</div><div class="line">        <span class="keyword">char</span> temp = str[start];</div><div class="line">        str[start] = str[end];</div><div class="line">        str[end] = temp;</div><div class="line">        start++;</div><div class="line">        end--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Find-the-Duplicate-Number"><a href="#Find-the-Duplicate-Number" class="headerlink" title="Find the Duplicate Number"></a><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="external">Find the Duplicate Number</a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array <em>nums</em> containing <em>n</em> + 1 integers where each integer is between 1 and <em>n</em> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p><strong>Note:</strong></p>
<ol>
<li>You <strong>must not</strong> modify the array (assume the array is read only).</li>
<li>You must use only constant, <em>O</em>(1) extra space.</li>
<li>Your runtime complexity should be less than <code>O(n2)</code>.</li>
<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>
</ol>
</blockquote>
<h4 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<p>题目说有个n+1长的数组，里面的元素的范围在1~n，所以必定会有重复的元素，要求我们找出重复的元素。</p>
<ol>
<li><p>baseline：</p>
<p>遍历，时间复杂度<script type="math/tex">O(n^2)</script>，超时</p>
</li>
<li><p>二分法：</p>
<p>start = 1;end = n</p>
<p>mid = (1+n)/2;</p>
<p>遍历数组，记录值&lt;=mid的元素个数sum，分两种情况讨论：</p>
<p>​    a. sum &lt;= mid，在1~mid之间的数组少于mid，说明重复数字在mid+1~len-1里，故令left = mid+1</p>
<p>​    b. sum &gt; mid，在1~mid之间的数组多于mid，说明重复数字在1~mid里，故令right = mid</p>
</li>
</ol>
<p>方法二:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">idx: <span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></div><div class="line">val: <span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">2</span></div><div class="line">实质：用下标idx的正负表示该数字idx是否出现过，如果出现过idx对应的数字为负数，否则为正数</div><div class="line">从左向右遍历，把遇到的数字在数组中的下标标记为负值，当遇到下标对应的值已经为负数时，返回该下标：</div><div class="line">i = <span class="number">0</span> , val = <span class="number">1</span>,将nums[<span class="number">1</span>]标记为负数</div><div class="line">idx: <span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></div><div class="line">val: <span class="number">1</span>	-<span class="number">2</span>	<span class="number">3</span>	<span class="number">2</span></div><div class="line">i = <span class="number">1</span> ，val = abs(-<span class="number">2</span>) = <span class="number">2</span> , 将nums[<span class="number">2</span>]标记为负数</div><div class="line">idx: <span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></div><div class="line">val: <span class="number">1</span>	-<span class="number">2</span>	-<span class="number">3</span>	<span class="number">2</span></div><div class="line">i = <span class="number">2</span> ，val = abs(-<span class="number">3</span>) = <span class="number">3</span> , 将nums[<span class="number">3</span>]标记为负数</div><div class="line">idx: <span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></div><div class="line">val: <span class="number">1</span>	-<span class="number">2</span>	-<span class="number">3</span>	-<span class="number">2</span></div><div class="line">i = <span class="number">3</span> ，val = abs(-<span class="number">2</span>) = <span class="number">2</span> , 此时nums[<span class="number">2</span>] &lt; <span class="number">0</span>，则返回<span class="number">2</span></div><div class="line">idx: <span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></div><div class="line">val: <span class="number">1</span>	-<span class="number">2</span>	-<span class="number">3</span>	-<span class="number">2</span></div></pre></td></tr></table></figure>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> left = <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(left &lt;right)&#123;</div><div class="line">    <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//记录在1~mid之间的数字有多少个</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</div><div class="line">      <span class="keyword">if</span>(i &lt;= mid)&#123;</div><div class="line">        sum++;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//在1~mid之间的数组少于mid，说明重复数字在mid+1~len-1里</span></div><div class="line">    <span class="keyword">if</span>(sum &lt;= mid)&#123;</div><div class="line">      left = mid + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//在1~mid之间的数组多于mid，说明重复数字在1~mid里</span></div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      right = mid;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> left;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Find-K-Closest-Elements"><a href="#Find-K-Closest-Elements" class="headerlink" title="Find K Closest Elements"></a><a href="https://leetcode.com/problems/find-k-closest-elements" target="_blank" rel="external">Find K Closest Elements</a></h3><blockquote>
<p>Given a sorted array, two integers <code>k</code> and <code>x</code>, find the <code>k</code> closest elements to <code>x</code> in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,2,3,4,5], k=4, x=3</div><div class="line">&gt; Output: [1,2,3,4]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,2,3,4,5], k=4, x=-1</div><div class="line">&gt; Output: [1,2,3,4]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定一个递增数组，两个整数k和x，返回数组中里最接近x的k个数</p>
<p>思路：</p>
<p>先用二分法找到数组中&gt;=x的第一个数字，然后向左向右寻找，两个指针向左右移动，直至k次结束，此时将两个指针中间的元素加入结果集即是最终答案。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findClosestElements</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = arr.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(arr[mid] &gt;= x)&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                start = mid+<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//end是第一个&gt;=x的数</span></div><div class="line">        <span class="keyword">int</span> left = end-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> right = end;</div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(num &lt; k)&#123;</div><div class="line">            <span class="keyword">int</span> l_delta = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">int</span> r_delta = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">if</span>(left &gt;= <span class="number">0</span>)&#123;</div><div class="line">                l_delta = Math.abs(x-arr[left]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(right &lt; arr.length)&#123;</div><div class="line">                r_delta = Math.abs(x-arr[right]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(l_delta &lt;= r_delta)&#123;</div><div class="line">                left--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                right++;</div><div class="line">            &#125;</div><div class="line">            num++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left+<span class="number">1</span>;i &lt; right;i++)&#123;</div><div class="line">            res.add(arr[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WAND算法]]></title>
      <url>/2017/12/07/WAND%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-07-14-24-15.png" alt="所致"> </p>
<a id="more"></a>
<p><strong>sort()</strong>：把terms按照posting单钱所指向的documentID排序，比如：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-07-14-30-11.png" alt=""> </p>
<p>图中黄颜色的数字就是posting当前所指的documentID</p>
<p>pTerm：从上到下累加发现大于U的那个term</p>
<p>pivot:pTerm这一行当前所指的documentID</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法基础班】二叉树与分治法]]></title>
      <url>/2017/11/29/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>数组：内存空间连续，支持下标访问，访问时间复杂度<script type="math/tex">O(1)</script></p>
<p>链表：内存空间不联系，不支持下表访问，访问时间复杂度<script type="math/tex">O(n)</script></p>
<h2 id="1-树形分析法求解时间复杂度："><a href="#1-树形分析法求解时间复杂度：" class="headerlink" title="1. 树形分析法求解时间复杂度："></a>1. 树形分析法求解时间复杂度：</h2><script type="math/tex; mode=display">T(n) = T(n/2)+O(1)   ->  O(logn)</script><script type="math/tex; mode=display">T(n) = T(n/2)+O(n) -> O(n)</script><script type="math/tex; mode=display">T(n) = 2T(n/2) + O(1) -> O(n)</script><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">T(n) = <span class="number">2</span>T(n/<span class="number">2</span>) + O(<span class="number">1</span>) -&gt; O(n)</div><div class="line">O(<span class="number">1</span>)：一次拆分所需时间</div><div class="line"> --	 			        n</div><div class="line">  |               ↙             ↘       ················O(<span class="number">1</span>)拆分所需时间</div><div class="line">  |            n/<span class="number">2</span>                n/<span class="number">2</span></div><div class="line">log(n)      ↙       ↘          ↙       ↘	················O(<span class="number">2</span>)</div><div class="line">  |       n/<span class="number">4</span>       n/<span class="number">4</span>       n/<span class="number">4</span>       n/<span class="number">4</span></div><div class="line">  |      ↙  ↘      ↙  ↘     ↙  ↘      ↙  ↘	················O(<span class="number">4</span>)</div><div class="line">  |    n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>   n/<span class="number">8</span>  n/<span class="number">8</span>   			</div><div class="line">  |			················				················O(n)</div><div class="line">  | n/n	n/n	n/n		·············	n/n	n/n	n/n</div><div class="line"> --</div><div class="line"> O(<span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span>+....+n) = O(<span class="number">2</span>n-<span class="number">1</span>) = O(n)</div><div class="line"> 由此如果T(n) = <span class="number">2</span>T(n/<span class="number">2</span>) + O(<span class="number">1</span>)，则时间复杂度为O(n)</div></pre></td></tr></table></figure>
<a id="more"></a>
<script type="math/tex; mode=display">T(n) = 2T(n/2) + O(n) -> O(n*logn)</script><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">T(n) = <span class="number">2</span>T(n/<span class="number">2</span>) + O(n) -&gt; O(n)</div><div class="line">O(n)：一次拆分所需时间</div><div class="line"> --	 			        n</div><div class="line">  |               ↙             ↘       ··············O(n)拆分所需时间</div><div class="line">  |            n/<span class="number">2</span>                n/<span class="number">2</span></div><div class="line">log(n)      ↙       ↘          ↙       ↘	··············O(n/<span class="number">2</span>)*<span class="number">2</span>=O(n)</div><div class="line">  |       n/<span class="number">4</span>       n/<span class="number">4</span>       n/<span class="number">4</span>       n/<span class="number">4</span></div><div class="line">  |      ↙  ↘      ↙  ↘     ↙  ↘      ↙  ↘	·············O(n/<span class="number">4</span>)*<span class="number">4</span>=O(n)</div><div class="line">  |    n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>   n/<span class="number">8</span>  n/<span class="number">8</span>   			</div><div class="line">  |			················				·············O(n/n)*n=O(n)</div><div class="line">  | n/n	n/n	n/n		·············	n/n	n/n	n/n</div><div class="line"> --</div><div class="line"> O(n+n+...+n)*logn = O(nlogn)</div><div class="line"> 由此如果T(n) = <span class="number">2</span>T(n/<span class="number">2</span>) + O(n)，则时间复杂度为O(nlogn)</div></pre></td></tr></table></figure>
<h2 id="2-二叉树的遍历"><a href="#2-二叉树的遍历" class="headerlink" title="2. 二叉树的遍历"></a>2. 二叉树的遍历</h2><p>树的遍历三种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">     <span class="number">1</span></div><div class="line">    ↙ ↘</div><div class="line">  <span class="number">2</span>     <span class="number">3</span></div><div class="line"> ↙ ↘</div><div class="line"><span class="number">4</span>   <span class="number">5</span></div><div class="line">- 前序遍历（根左右）: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">3</span></div><div class="line">- 中序遍历（左根右）: <span class="number">4</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span></div><div class="line">- 后序遍历（左右根）: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span></div></pre></td></tr></table></figure>
<h3 id="2-1-前序遍历Binary-Tree-Preorder-Traversal"><a href="#2-1-前序遍历Binary-Tree-Preorder-Traversal" class="headerlink" title="2.1.前序遍历Binary Tree Preorder Traversal"></a>2.1.前序遍历<a href="https://leetcode.com/problems/binary-tree-preorder-traversal" target="_blank" rel="external">Binary Tree Preorder Traversal</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>[1,null,2,3]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1</div><div class="line">&gt;     \</div><div class="line">&gt;      2</div><div class="line">&gt;     /</div><div class="line">&gt;    3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return <code>[1,2,3]</code>.</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ol>
<li><p>递归法</p>
<p>首先遍历根节点，然后对其左节点做前序遍历，对其右节点做前序遍历。</p>
<p><strong>递归三要素</strong>：</p>
<ul>
<li>定义：要做什么事情，这道题就是先遍历父亲节点，然后左节点、右节点</li>
<li>拆分：差分成同样的问题，但规模变小，本题就是拆成左子树和右子树，对左子树和右字数分别做前序遍历</li>
<li>结束条件：遇到空节点停止。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</div><div class="line">  traverse(root,result);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root,ArrayList&lt;Integer&gt; result)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span>&#123;</div><div class="line">    result.add(root.val);</div><div class="line">    traverse(root.left,result);</div><div class="line">    traverse(root.right,result);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>分治法</p>
<p>分而治之，先分开求结果，再合并</p>
<p>先得到左子树的结果，再得到右子树的结果，然后将左子、右子树、root结果合并得到最终结果。</p>
<p>通常来说，分治法的函数是有返回值的。</p>
<p><strong>分治法三要素：</strong></p>
<ul>
<li>定义：要做什么事情</li>
<li>拆分与合并问题：</li>
<li>结束条件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">divide</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  <span class="comment">//结束条件</span></div><div class="line">  <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</div><div class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//拆分问题，获取子问题结果</span></div><div class="line">  ArrayList&lt;Integer&gt; leftres = divide(root.left);</div><div class="line">  ArrayList&lt;Integer&gt; righttres = divide(root.right);</div><div class="line"></div><div class="line">  <span class="comment">//合并子问题</span></div><div class="line">  ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  result.add(root.val);</div><div class="line">  result.addAll(leftres);</div><div class="line">  result.addAll(righttres);</div><div class="line"></div><div class="line">  <span class="comment">//返回结果</span></div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>非递归方法</p>
<p><strong>阅读理解并背诵</strong></p>
<p>利用stack实现树的前序遍历，每次弹出栈顶元素，先后压入其右孩子和左孩子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">        List&lt;Integer&gt; preorder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> preorder;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//根节点入栈</span></div><div class="line">        stack.push(root);</div><div class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</div><div class="line">            TreeNode node = stack.pop();</div><div class="line">            preorder.add(node.val);</div><div class="line">            <span class="comment">//右孩子入栈</span></div><div class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</div><div class="line">                stack.push(node.right);</div><div class="line">            &#125;</div><div class="line">          <span class="comment">//左孩子入栈</span></div><div class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</div><div class="line">                stack.push(node.left);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> preorder;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-2-中序遍历Binary-Tree-Inorder-Traversal"><a href="#2-2-中序遍历Binary-Tree-Inorder-Traversal" class="headerlink" title="2.2. 中序遍历Binary Tree Inorder Traversal"></a>2.2. 中序遍历<a href="https://leetcode.com/problems/binary-tree-inorder-traversal" target="_blank" rel="external">Binary Tree Inorder Traversal</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>[1,null,2,3]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1</div><div class="line">&gt;     \</div><div class="line">&gt;      2</div><div class="line">&gt;     /</div><div class="line">&gt;    3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return <code>[1,3,2]</code>.</p>
</blockquote>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//递归法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,ArrayList&lt;Integer&gt; result)</span></span>&#123;</div><div class="line">        <span class="comment">//终止条件</span></div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//拆分问题</span></div><div class="line">        helper(root.left,result);</div><div class="line">        result.add(root.val);</div><div class="line">        helper(root.right,result);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</div><div class="line">        helper(root,result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//分治法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="comment">//终止条件</span></div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        &#125;</div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">//拆分</span></div><div class="line">        ArrayList&lt;Integer&gt; leftRes = inorderTraversal(root.left);</div><div class="line">        ArrayList&lt;Integer&gt; rightRes = inorderTraversal(root.right);</div><div class="line"></div><div class="line">        <span class="comment">//合并</span></div><div class="line">        result.addAll(leftRes);</div><div class="line">        result.add(root.val);</div><div class="line">        result.addAll(rightRes);</div><div class="line"></div><div class="line">        <span class="comment">//返回结果</span></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//非递归方法，很重要！！！！！！！！！！！！！！！</span></div><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        TreeNode curt = root;</div><div class="line">        <span class="keyword">while</span> (curt != <span class="keyword">null</span> || !stack.empty()) &#123;</div><div class="line">            <span class="keyword">while</span> (curt != <span class="keyword">null</span>) &#123;</div><div class="line">                stack.add(curt);</div><div class="line">                curt = curt.left;</div><div class="line">            &#125;</div><div class="line">            curt = stack.pop();</div><div class="line">            result.add(curt.val);</div><div class="line">            curt = curt.right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="2-3-后序遍历Binary-Tree-Postorder-Traversal"><a href="#2-3-后序遍历Binary-Tree-Postorder-Traversal" class="headerlink" title="2.3.后序遍历Binary Tree Postorder Traversal"></a>2.3.后序遍历<a href="https://leetcode.com/problems/binary-tree-postorder-traversal" target="_blank" rel="external">Binary Tree Postorder Traversal</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1</div><div class="line">&gt;     \</div><div class="line">&gt;      2</div><div class="line">&gt;     /</div><div class="line">&gt;    3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return <code>[3,2,1]</code>.</p>
</blockquote>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//递归法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,ArrayList&lt;Integer&gt; result)</span></span>&#123;</div><div class="line">  <span class="comment">//终止条件</span></div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//拆分问题</span></div><div class="line">  helper(root.left,result);</div><div class="line">  helper(root.right,result);</div><div class="line">  result.add(root.val);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</div><div class="line">  helper(root,result);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//分治法</span></div><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="comment">//拆分</span></div><div class="line">  ArrayList&lt;Integer&gt; leftRes = postorderTraversal(root.left);</div><div class="line">  ArrayList&lt;Integer&gt; rightRes = postorderTraversal(root.right);</div><div class="line">  <span class="comment">//合并</span></div><div class="line">  result.addAll(leftRes);</div><div class="line">  result.addAll(rightRes);</div><div class="line">  result.add(root.val);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-4-分治法相比于遍历法的优点："><a href="#2-4-分治法相比于遍历法的优点：" class="headerlink" title="2.4.分治法相比于遍历法的优点："></a>2.4.分治法相比于遍历法的优点：</h3><ol>
<li>无需全局变量存储结果，无需helper函数</li>
<li>可并行</li>
</ol>
<h3 id="2-5-二叉树三种遍历的非递归实现"><a href="#2-5-二叉树三种遍历的非递归实现" class="headerlink" title="2.5.二叉树三种遍历的非递归实现"></a>2.5.二叉树三种遍历的非递归实现</h3><h4 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h4><p>三种遍历的非递归解决思路核心思想是一致的：</p>
<ol>
<li>将二叉树分为“左”（包括一路向左，经过的所有实际左+根）、“右”（包括实际的右）两种节点</li>
<li>使用同样的顺序将“左”节点入栈</li>
<li>在合适的时机转向（转向后，“右”节点即成为“左”节点）、访问节点、或出栈</li>
</ol>
<p>比如{1,2,3}，当cur位于节点1时，1、2属于“左”节点，3属于“右”节点。DFS的非递归实现本质上是在协调入栈、出栈和访问，三种操作的顺序。上述统一使得我们不再需要关注入栈顺序，仅需要关注出栈和访问（第3点），随着更详细的分析，你将更加体会到这种简化带来的好处。</p>
<p>将对节点的访问定义为<code>results.add(node.val);</code>，分析如下：</p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>前序遍历的顺序是：根-&gt;左-&gt;右，按照上面提到的思路，可以简化为左-&gt;右</p>
<p>从root节点开始访问，依次向下访问左节点(cur指向当前节点)，此时立即将这些“左”节点输出到结果中，同时把他们压入栈，便于后续访问其右节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">    results.add(cur.val);</div><div class="line">    stack.push(cur);</div><div class="line">    cur = cur.left;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面循环结束意味着我们已经访问过所有的“左”节点，现在需要将这些节点出栈，转到其“右”节点，此时右节点也变成了“左”节点，需要对其进行上面的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (!stack.empty()) &#123;</div><div class="line">    cur = stack.pop();</div><div class="line">    <span class="comment">// 转向</span></div><div class="line">    cur = cur.right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">nonRecursion</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        TreeNode cur = root;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        ArrayList&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.empty())&#123;<span class="comment">//停止条件：栈和cur都为空</span></div><div class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">                results.add(cur.val);<span class="comment">//左节点加入结果集</span></div><div class="line">                stack.push(cur);<span class="comment">//左节点入栈</span></div><div class="line">                cur = cur.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">                cur = stack.pop();</div><div class="line">                cur = cur.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>先序与中序的区别只在于对“左”节点的处理上，前序遍历是先访问实际根，再访问左节点，而中序是先访问实际左节点，再访问实际根节点，所以需要将中序改为出栈时才访问这个节点的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">  stack.push(cur);<span class="comment">//左节点入栈</span></div><div class="line">  cur = cur.left;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">  cur = stack.pop();</div><div class="line">  results.add(cur.val);<span class="comment">//左节点加入结果集</span></div><div class="line">  cur = cur.right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">nonRecursion</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        TreeNode cur = root;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        ArrayList&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.empty())&#123;<span class="comment">//停止条件：栈和cur都为空</span></div><div class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">                stack.push(cur);<span class="comment">//左节点入栈</span></div><div class="line">                cur = cur.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">                cur = stack.pop();</div><div class="line">              	results.add(cur.val);<span class="comment">//左节点加入结果集</span></div><div class="line">                cur = cur.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历的实际访问顺序是：左右根</p>
<p>入栈顺序不变，需考虑转向和出栈时机。</p>
<p>对于实际的根，需要保证先后访问了左子树、右子树之后，才能访问根。实际的右节点、左节点、根节点都会成为“左”节点入栈，所以我们只需要<strong>在出栈之前，将该节点视作实际的根节点，并检查其右子树是否已被访问</strong>即可。如果不存在右子树，或右子树已被访问了，那么可以访问根节点，出栈，并不需要转向；如果还没有访问，就转向，使其“右”节点成为“左”节点，等着它先被访问之后，再来访问根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNodeWithFlag</span> </span>&#123;</div><div class="line">        TreeNode node;</div><div class="line">        <span class="keyword">boolean</span> flag;</div><div class="line">        TreeNodeWithFlag(TreeNode node,<span class="keyword">boolean</span> flag) &#123;</div><div class="line">            <span class="keyword">this</span>.flag = flag;</div><div class="line">            <span class="keyword">this</span>.node = node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        TreeNode cur = root;</div><div class="line">        Stack&lt;TreeNodeWithFlag&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        ArrayList&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.empty())&#123;<span class="comment">//停止条件：栈空或cur空</span></div><div class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">                stack.push(<span class="keyword">new</span> TreeNodeWithFlag(cur,<span class="keyword">false</span>));<span class="comment">//左节点入栈，标记为右子树未访问</span></div><div class="line">                cur = cur.left;<span class="comment">//继续访问左子树</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">                <span class="keyword">if</span>(stack.peek().flag)&#123;<span class="comment">//右子树已经处理过</span></div><div class="line">                    results.add(stack.peek().node.val);<span class="comment">//左节点加入结果集</span></div><div class="line">                    stack.pop();<span class="comment">//弹出</span></div><div class="line">                    cur = <span class="keyword">null</span>;<span class="comment">//左右根节点都已处理过，不转向，继续弹栈</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;<span class="comment">//右子树没有处理过</span></div><div class="line">                    stack.peek().flag = <span class="keyword">true</span>;<span class="comment">//标记为已处理</span></div><div class="line">                    cur = stack.peek().node.right;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//自己写的一个版本</span></div><div class="line">      <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        Stack&lt;TreeNodeWithL&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        TreeNode node = root;</div><div class="line">        <span class="keyword">while</span>(!stack.isEmpty() || node != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</div><div class="line">                stack.push(<span class="keyword">new</span> TreeNodeWithL(node,<span class="keyword">false</span>));</div><div class="line">                node = node.left;</div><div class="line">            &#125;<span class="comment">//跳出時node==null</span></div><div class="line">            TreeNodeWithL temp = stack.pop();</div><div class="line">            <span class="keyword">if</span>(temp.flag)&#123;</div><div class="line">                res.add(temp.node.val);</div><div class="line">                node = <span class="keyword">null</span>;<span class="comment">//左右根节点都已处理过，不转向，继续弹栈</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                temp.flag = <span class="keyword">true</span>;</div><div class="line">                stack.push(temp);</div><div class="line">                node = temp.node.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-相关习题"><a href="#3-相关习题" class="headerlink" title="3.相关习题"></a>3.相关习题</h2><h3 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="external">Maximum Depth of Binary Tree</a></h3><p>题目</p>
<blockquote>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
</blockquote>
<p>给定一个数，求出树的最大深度</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  <span class="comment">//终止条件</span></div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//拆分成求解左子树和右子树的最大深度</span></div><div class="line">  <span class="keyword">int</span> leftDepth = maxDepth(root.left);</div><div class="line">  <span class="keyword">int</span> rihtDepth = maxDepth(root.right);</div><div class="line"></div><div class="line">  <span class="comment">//合并，根节点的最大深度=max(左子树最大深度，右子树最大深度)+1</span></div><div class="line">  <span class="keyword">int</span> res = Math.max(leftDepth,rihtDepth)+<span class="number">1</span>;</div><div class="line">  <span class="comment">//返回结果</span></div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a><a href="https://leetcode.com/problems/balanced-binary-tree" target="_blank" rel="external">Balanced Binary Tree</a></h3><p>题目</p>
<blockquote>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
</blockquote>
<p>判断二叉树是否是平衡二叉树：</p>
<ol>
<li>左右子树平衡</li>
<li>左子树和右子树的高度差不超过1</li>
</ol>
<p>分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">考虑某一个时间成立或者不成立需要考虑多个因素的时候，需要定义一个<span class="class"><span class="keyword">class</span> <span class="title">ResultType</span>把这两个值包进去，存储中间结果。</span></div><div class="line"><span class="class">	//定义<span class="title">resultType</span></span></div><div class="line"><span class="class">	<span class="title">class</span> <span class="title">ResultType</span></span>&#123;</div><div class="line">        <span class="keyword">boolean</span> isBalanced;<span class="comment">//是否平衡</span></div><div class="line">        <span class="keyword">int</span> maxDepth;<span class="comment">//最大深度</span></div><div class="line">        ResultType(<span class="keyword">boolean</span> isBalanced,<span class="keyword">int</span> maxDepth)&#123;</div><div class="line">            <span class="keyword">this</span>.isBalanced = isBalanced;</div><div class="line">            <span class="keyword">this</span>.maxDepth = maxDepth;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ResultType <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="comment">//结束条件</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">true</span>,<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//拆分成分别计算左子树的右子树信息</span></div><div class="line">        ResultType leftRes = helper(root.left);</div><div class="line">        ResultType rightRes = helper(root.right);</div><div class="line">        </div><div class="line">        <span class="comment">//如果左右有一个不是平衡树</span></div><div class="line">        <span class="keyword">if</span>(!leftRes.isBalanced || !rightRes.isBalanced)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>,-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//都是平衡树，但深度差&gt;1</span></div><div class="line">        <span class="keyword">if</span>(Math.abs(leftRes.maxDepth-rightRes.maxDepth) &gt;<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>,-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//都是平衡树，深度差&lt;=1，node节点最大深度=max(左、右子树深度)+1</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">true</span>,Math.max(rightRes.maxDepth,leftRes.maxDepth)+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> helper(root).isBalanced;<span class="comment">//返回根节点是否是平衡。</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法二：不引入额外的结构，利用高度判断，当不平衡时，置高度为-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">     <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">         <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">int</span> leftH = height(root.left);</div><div class="line">     <span class="keyword">int</span> rightH = height(root.right);</div><div class="line">     <span class="keyword">if</span>(leftH == -<span class="number">1</span> || rightH == -<span class="number">1</span> || Math.abs(leftH - rightH) &gt; <span class="number">1</span>)&#123;</div><div class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">else</span>&#123;</div><div class="line">         <span class="keyword">return</span> Math.max(leftH,rightH)+<span class="number">1</span>;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> height(root)!=-<span class="number">1</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree" target="_blank" rel="external">Lowest Common Ancestor of a Binary Tree</a></h3><p>题目</p>
<blockquote>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="external">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;         _______3______</div><div class="line">&gt;        /              \</div><div class="line">&gt;     ___5__          ___1__</div><div class="line">&gt;    /      \        /      \</div><div class="line">&gt;    6      _2       0       8</div><div class="line">&gt;          /  \</div><div class="line">&gt;          7   4</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>For example, the lowest common ancestor (LCA) of nodes <code>5</code> and <code>1</code> is <code>3</code>. Another example is LCA of nodes <code>5</code> and <code>4</code> is <code>5</code>, since a node can be a descendant of itself according to the LCA definition.</p>
</blockquote>
<p>给一棵二叉树和二叉树上的两个点，返回其最近公共祖先</p>
<p>分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">如果二叉树中存储了父亲节点，则可以从两个点出发往上寻找至root:</div><div class="line">比如<span class="number">5</span>和<span class="number">1</span>：</div><div class="line"><span class="number">5</span>:[<span class="number">5</span>,<span class="number">3</span>]</div><div class="line"><span class="number">1</span>:[<span class="number">1</span>,<span class="number">3</span>]</div><div class="line">得到路径之后从后向前遍历，<span class="number">3</span>,<span class="number">3</span>一样，<span class="number">5</span>,<span class="number">1</span>不一样了，所以最近公共祖先是<span class="number">3</span></div><div class="line"></div><div class="line">再比如<span class="number">5</span>和<span class="number">4</span>：</div><div class="line"><span class="number">5</span>:[<span class="number">5</span>,<span class="number">3</span>]</div><div class="line"><span class="number">4</span>:[<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>]</div><div class="line">从后向前遍历，发现<span class="number">3</span>,<span class="number">5</span>之后不一样了，所以公共祖先是<span class="number">5</span></div><div class="line"></div><div class="line">如果没有存储父亲节的信息，给定root节点和两个点n1,n2:</div><div class="line">        _______3______</div><div class="line">       /              \</div><div class="line">    ___5__          ___1__</div><div class="line">   /      \        /      \</div><div class="line">   <span class="number">6</span>      _2       <span class="number">0</span>       <span class="number">8</span></div><div class="line">         /  \</div><div class="line">         <span class="number">7</span>   <span class="number">4</span></div><div class="line">n1和n2的分布情况有以下几种：</div><div class="line"><span class="number">1</span>.其中有一个是root -&gt; 返回root</div><div class="line"><span class="number">2</span>.全在左子树 -&gt; 返回左子树root</div><div class="line"><span class="number">3</span>.全在右子树 -&gt; 返回右子树root</div><div class="line"><span class="number">4</span>.一个在左子树、一个在右子树 -&gt; 返回root</div><div class="line"><span class="number">5</span>.这两个点不在这棵树里 -&gt; 返回<span class="keyword">null</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root == p || root == q)&#123;<span class="comment">//其中有一个是根节点</span></div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//拆分,分别在左、右子树中寻找LCA</span></div><div class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</div><div class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</div><div class="line"></div><div class="line">        <span class="comment">//合并</span></div><div class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;<span class="comment">//一个在左子树，一个在右子树，则LCA为root</span></div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="keyword">null</span>)&#123;<span class="comment">//两个节点都在左子树</span></div><div class="line">            <span class="keyword">return</span> left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right != <span class="keyword">null</span>)&#123;<span class="comment">//两个节点都在右子树</span></div><div class="line">            <span class="keyword">return</span> right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="comment">//左右子树的LCA都是null,都没有这俩节点</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Binary-Tree-Maximum-Path-Sum-II"><a href="#Binary-Tree-Maximum-Path-Sum-II" class="headerlink" title="Binary Tree Maximum Path Sum II"></a>Binary Tree Maximum Path Sum II</h3><p>题目</p>
<p>给定一个二叉树，从根节点root出发，求最大路径和，可以在任一点结束</p>
<p>分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">如果是求从root到leaf的最大路径，就用分治法，从上到下，每个节点的最大路径是其左子树和右子树的最大路径的最大值:</div><div class="line">root.val + Math.max(maxleft,maxright)</div><div class="line">如果二叉树上的节点值有负数，那么最大路径就有可能不到leaf就结束了，所以在计算节点最大路径时，如果其左右子树最大路径的最大值为负数，则该节点到leaf的最大路径长度应该为<span class="number">0</span>：</div><div class="line">root.val + Math.max(<span class="number">0</span>,Math.max(maxleft,maxright))</div></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum2</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> maxleft = maxPathSum2(root.left);</div><div class="line">  <span class="keyword">int</span> maxright = maxPathSum2(root.right);</div><div class="line"></div><div class="line">  <span class="comment">//root-&gt;leaf</span></div><div class="line">  <span class="comment">//return root.val + Math.max(maxleft,maxright);</span></div><div class="line"></div><div class="line">  <span class="comment">//root-&gt;any</span></div><div class="line">  <span class="keyword">return</span> root.val + Math.max(<span class="number">0</span>,Math.max(maxleft,maxright));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前的题目复杂度基本都是O(n)，分析：</p>
<p>一共有多少个点<em>每个点上的时间复杂度 = n </em> O(1) = O(n)</p>
<h3 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum" target="_blank" rel="external">Binary Tree Maximum Path Sum</a></h3><p>题目</p>
<blockquote>
<p>Given a binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p>
<p>For example:<br>Given the below binary tree,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;        1</div><div class="line">&gt;       / \</div><div class="line">&gt;      2   3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Return <code>6</code>.</p>
</blockquote>
<p>分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">跟LCA问题思考方式类似，考虑某一点root的最大路径的位置可能有如下三种情况：</div><div class="line"><span class="number">1</span>.都在左子树中(root.left:any-&gt;any)</div><div class="line"><span class="number">2</span>.都在右子树中(root.right:any-&gt;any)</div><div class="line"><span class="number">3</span>.跨过root节点左右子树中都有(root:any-&gt;any)</div><div class="line">对三种情况取个最大，就是该root节点的最大路径长度</div><div class="line"></div><div class="line">对于第三种情况，可以分为三个子问题：</div><div class="line">A:从左子节点出发的最大路径长度（root.left-&gt;any）</div><div class="line">root</div><div class="line">B:从右子节点出发的最大路径长度（root.right-&gt;any）</div><div class="line">对三个子问题求和，就是跨过此root节点的最大路径长度</div><div class="line"></div><div class="line"></div><div class="line">这里需要同时计算any-&gt;any和root-&gt;any，所以需要定义一个ResultType存储每个节点的any-&gt;any和root-&gt;any</div></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultType</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> root2any;</div><div class="line">    <span class="keyword">int</span> any2any;</div><div class="line">    ResultType(<span class="keyword">int</span> root2any,<span class="keyword">int</span> any2any)&#123;</div><div class="line">        <span class="keyword">this</span>.any2any = any2any;</div><div class="line">        <span class="keyword">this</span>.root2any = root2any;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> ResultType <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">    <span class="comment">//题目要求至少要包含一个node，所以此时不满足条件，应返回负无穷</span></div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultType(Integer.MIN_VALUE,Integer.MIN_VALUE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//divide</span></div><div class="line">    ResultType leftRes = helper(root.left);</div><div class="line">    ResultType rightRes = helper(root.right);</div><div class="line"></div><div class="line">    <span class="comment">//conquer</span></div><div class="line">    <span class="comment">//root到左边或右边</span></div><div class="line">    <span class="keyword">int</span> root2any = Math.max(<span class="number">0</span>,Math.max(leftRes.root2any,rightRes.root2any)) + root.val;</div><div class="line"></div><div class="line">    <span class="comment">//包含完全在左边、完全在右边和跨过root三种情况</span></div><div class="line">    <span class="comment">//完全在左边和完全在右边的情况</span></div><div class="line">    <span class="keyword">int</span> any2any = Math.max(leftRes.any2any,rightRes.any2any);</div><div class="line">    </div><div class="line">    <span class="comment">//跨过root,分别在两边的情况</span></div><div class="line">    any2any = Math.max(any2any,</div><div class="line">            Math.max(<span class="number">0</span>,leftRes.root2any) </div><div class="line">            + Math.max(<span class="number">0</span>,rightRes.root2any)</div><div class="line">            + root.val</div><div class="line">            );</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultType(root2any,any2any);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> helper(root).any2any;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeMaximumPathSum</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxValue;</div><div class="line"></div><div class="line">    <span class="comment">//从某root向下到任意一个节点的最大值，包括本身</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathDown</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>,maxPathDown(root.left));</div><div class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>,maxPathDown(root.right));</div><div class="line">        maxValue = Math.max(maxValue,left+right+root.val);<span class="comment">//更新最大值</span></div><div class="line">        <span class="keyword">return</span> Math.max(left,right)+root.val;<span class="comment">//从当前节点到任意一个节点的路径和最大值</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        maxValue = Integer.MIN_VALUE;</div><div class="line">        maxPathDown(root);</div><div class="line">        <span class="keyword">return</span> maxValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Longest-Univalue-Path"><a href="#Longest-Univalue-Path" class="headerlink" title="Longest Univalue Path"></a><a href="https://leetcode.com/problems/longest-univalue-path/description/" target="_blank" rel="external">Longest Univalue Path</a></h3><blockquote>
<p>Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.</p>
<p><strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</p>
<p><strong>Example 1:</strong></p>
<p>Input:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;               5</div><div class="line">&gt;              / \</div><div class="line">&gt;             4   5</div><div class="line">&gt;            / \   \</div><div class="line">&gt;           1   1   5</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<p>Input:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;               1</div><div class="line">&gt;              / \</div><div class="line">&gt;             4   5</div><div class="line">&gt;            / \   \</div><div class="line">&gt;           4   4   5</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 2</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>求给定二叉树上某一个相同的值的最大路径长度</p>
<p>针对每一个点：</p>
<ol>
<li>计算通过它本身的相同值最大路径长度，更新全局最大长度</li>
<li>返回以它本身为根节点，向下的最大深度</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxLen;</div><div class="line">  <span class="comment">//从root点出发和自己相同值的最长路径长度</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> left = helper(root.left);</div><div class="line">        <span class="keyword">int</span> right = helper(root.right);</div><div class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;<span class="comment">//记录过当前节点的最大路径长度</span></div><div class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;<span class="comment">//记录以当前节点为起点向下的最大路径长度</span></div><div class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.val == root.left.val)&#123;</div><div class="line">            len+=left;</div><div class="line">            res = Math.max(res,left+<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span> &amp;&amp; root.val == root.right.val)&#123;</div><div class="line">            len+=right;</div><div class="line">            res = Math.max(res,right+<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        maxLen = Math.max(maxLen,len);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        maxLen = <span class="number">1</span>;</div><div class="line">        helper(root);</div><div class="line">        <span class="keyword">return</span> maxLen-<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Diameter-of-Binary-Tree"><a href="#Diameter-of-Binary-Tree" class="headerlink" title="Diameter of Binary Tree"></a><a href="https://leetcode.com/problems/diameter-of-binary-tree" target="_blank" rel="external">Diameter of Binary Tree</a></h3><blockquote>
<p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. This path may or may not pass through the root.</p>
<p><strong>Example:</strong><br>Given a binary tree </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;           1</div><div class="line">&gt;          / \</div><div class="line">&gt;         2   3</div><div class="line">&gt;        / \     </div><div class="line">&gt;       4   5    </div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Return <strong>3</strong>, which is the length of the path [4,2,1,3] or [5,2,1,3].</p>
<p><strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</p>
</blockquote>
<p>求二叉树中的最长路径，不一定过root点</p>
<p>思路：</p>
<p>求过每一个点的最长路径，取全局最大值</p>
<p>过某一个点的最长路径=左子树的最大高度+右子树的最大高度</p>
<p>因此需要分治法计算左右子树的最大高度，求和</p>
<p>计算某一个节点的最大高度需要计算其左子树的右子树的最大高度，然后取最大值+1</p>
<p>两个函数整合成一个，同时更新全局最大路径长度和节点高度，代码如下：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="comment">//计算到bottom最长距离</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longest</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> left = longest(root.left);<span class="comment">//左最长</span></div><div class="line">        <span class="keyword">int</span> right = longest(root.right);<span class="comment">//右最长</span></div><div class="line">        max = Math.max(max,left+right);</div><div class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        longest(root);</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Convert-BST-to-Greater-Tree"><a href="#Convert-BST-to-Greater-Tree" class="headerlink" title="Convert BST to Greater Tree"></a><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="external">Convert BST to Greater Tree</a></h3><blockquote>
<p>Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: The root of a Binary Search Tree like this:</div><div class="line">&gt;               5</div><div class="line">&gt;             /   \</div><div class="line">&gt;            2     13</div><div class="line">&gt;</div><div class="line">&gt; Output: The root of a Greater Tree like this:</div><div class="line">&gt;              18</div><div class="line">&gt;             /   \</div><div class="line">&gt;           20     13</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>思路：</p>
<p>按照右根左的顺序遍历二叉树，记录遍历过的节点的值的和，依次修改遍历的节点。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="comment">//右根左遍历求和</span></div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        root.right = convertBST(root.right);</div><div class="line">        sum += root.val;</div><div class="line">        root.val = sum;</div><div class="line">        root.left = convertBST(root.left);</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Subtree-of-Another-Tree"><a href="#Subtree-of-Another-Tree" class="headerlink" title="Subtree of Another Tree"></a><a href="https://leetcode.com/problems/subtree-of-another-tree" target="_blank" rel="external">Subtree of Another Tree</a></h3><blockquote>
<p>Given two non-empty binary trees <strong>s</strong> and <strong>t</strong>, check whether tree <strong>t</strong> has exactly the same structure and node values with a subtree of <strong>s</strong>. A subtree of <strong>s</strong> is a tree consists of a node in <strong>s</strong> and all of this node’s descendants. The tree <strong>s</strong> could also be considered as a subtree of itself.</p>
<p><strong>Example 1:</strong><br>Given tree s:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      3</div><div class="line">&gt;     / \</div><div class="line">&gt;    4   5</div><div class="line">&gt;   / \</div><div class="line">&gt;  1   2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Given tree t:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    4 </div><div class="line">&gt;   / \</div><div class="line">&gt;  1   2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Return </p>
<p>true</p>
<p>, because t has the same structure and node values with a subtree of s.</p>
<p><strong>Example 2:</strong><br>Given tree s:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      3</div><div class="line">&gt;     / \</div><div class="line">&gt;    4   5</div><div class="line">&gt;   / \</div><div class="line">&gt;  1   2</div><div class="line">&gt;     /</div><div class="line">&gt;    0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Given tree t:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    4</div><div class="line">&gt;   / \</div><div class="line">&gt;  1   2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Return  false</p>
</blockquote>
<p>判断t是否是s的子树</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//从树s的s节点开始的子树，是否和t完全一样</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(TreeNode s, TreeNode t)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || t == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(s.val == t.val)&#123;</div><div class="line">        <span class="keyword">return</span> isSame(s.left,t.left) &amp;&amp; isSame(s.right,t.right);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遇到不相等的点直接返回false</span></div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</div><div class="line">    <span class="comment">//如果从s点开始和t完全一样，返回true</span></div><div class="line">    <span class="keyword">if</span>(isSame(s,t))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//否则考察左右节点</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> isSubtree(s.left,t) || isSubtree(s.right,t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Boundary-of-Binary-Tree"><a href="#Boundary-of-Binary-Tree" class="headerlink" title="Boundary of Binary Tree"></a><a href="https://leetcode.com/problems/boundary-of-binary-tree/" target="_blank" rel="external">Boundary of Binary Tree</a></h3><blockquote>
<p>Given a binary tree, return the values of its boundary in <strong>anti-clockwise</strong> direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes.</p>
<p><strong>Left boundary</strong> is defined as the path from root to the <strong>left-most</strong> node. <strong>Right boundary</strong> is defined as the path from root to the <strong>right-most</strong>node. If the root doesn’t have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not applies to any subtrees.</p>
<p>The <strong>left-most</strong> node is defined as a <strong>leaf</strong> node you could reach when you always firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat until you reach a leaf node.</p>
<p>The <strong>right-most</strong> node is also defined by the same way with left and right exchanged.</p>
<p><strong>Example 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:</div><div class="line">&gt;   1</div><div class="line">&gt;    \</div><div class="line">&gt;     2</div><div class="line">&gt;    / \</div><div class="line">&gt;   3   4</div><div class="line">&gt;</div><div class="line">&gt; Ouput:</div><div class="line">&gt; [1, 3, 4, 2]</div><div class="line">&gt;</div><div class="line">&gt; Explanation:</div><div class="line">&gt; The root doesn&apos;t have left subtree, so the root itself is left boundary.</div><div class="line">&gt; The leaves are node 3 and 4.</div><div class="line">&gt; The right boundary are node 1,2,4. Note the anti-clockwise direction means you should output reversed right boundary.</div><div class="line">&gt; So order them in anti-clockwise without duplicates and we have [1,3,4,2].</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:</div><div class="line">&gt;     ____1_____</div><div class="line">&gt;    /          \</div><div class="line">&gt;   2            3</div><div class="line">&gt;  / \          / </div><div class="line">&gt; 4   5        6   </div><div class="line">&gt;    / \      / \</div><div class="line">&gt;   7   8    9  10  </div><div class="line">&gt;        </div><div class="line">&gt; Ouput:</div><div class="line">&gt; [1,2,4,7,8,9,10,6,3]</div><div class="line">&gt;</div><div class="line">&gt; Explanation:</div><div class="line">&gt; The left boundary are node 1,2,4. (4 is the left-most node according to definition)</div><div class="line">&gt; The leaves are node 4,7,8,9,10.</div><div class="line">&gt; The right boundary are node 1,3,6,10. (10 is the right-most node).</div><div class="line">&gt; So order them in anti-clockwise without duplicate nodes we have [1,2,4,7,8,9,10,6,3].</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>思路：</p>
<p>分三部分：</p>
<ol>
<li>找到leftmost节点，过程中将左边界节点加入res</li>
<li>找到叶子节点，加入res</li>
<li>找到rightmost节点，过程中将左边界节点加入res</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">leftMost</span><span class="params">(TreeNode root,List&lt;Integer&gt; left)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;<span class="comment">//找到left-most点</span></div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</div><div class="line">            left.add(root.left.val);</div><div class="line">            <span class="keyword">return</span> leftMost( root.left,left);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            left.add(root.right.val);</div><div class="line">            <span class="keyword">return</span> leftMost( root.right,left);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">rightMost</span><span class="params">(TreeNode root,List&lt;Integer&gt; right)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;<span class="comment">//找到right-most点</span></div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</div><div class="line">            right.add(<span class="number">0</span>,root.right.val);</div><div class="line">            <span class="comment">//System.out.println(root.right.val);</span></div><div class="line">            <span class="keyword">return</span> rightMost( root.right,right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            right.add(<span class="number">0</span>,root.left.val);</div><div class="line">            <span class="keyword">return</span> rightMost( root.left,right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLeaf</span><span class="params">(TreeNode root,List&lt;Integer&gt; leaf,TreeNode leftmost,TreeNode rightmost)</span></span>&#123;</div><div class="line">        <span class="comment">//叶子节点且不是左右轮廓</span></div><div class="line">        <span class="keyword">if</span>(root.right == <span class="keyword">null</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root != leftmost &amp;&amp; root != rightmost)&#123;</div><div class="line">            leaf.add(root.val);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</div><div class="line">            getLeaf(root.left,leaf,leftmost,rightmost);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</div><div class="line">            getLeaf(root.right,leaf,leftmost,rightmost);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">boundaryOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; left = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; right = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; leaf = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> left;</div><div class="line">        &#125;</div><div class="line">        left.add(root.val);</div><div class="line">        TreeNode leftmost = root;</div><div class="line">        TreeNode rightmost = root;</div><div class="line">        <span class="comment">//如果有左孩子，加入左轮廓</span></div><div class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</div><div class="line">            leftmost = leftMost(root,left);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果有右孩子，加入右轮廓</span></div><div class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</div><div class="line">            rightmost = rightMost(root,right);</div><div class="line">        &#125;</div><div class="line">        getLeaf(root,leaf,leftmost,rightmost);</div><div class="line">        <span class="comment">// System.out.println(left);</span></div><div class="line">        <span class="comment">// System.out.println(leaf);</span></div><div class="line">        <span class="comment">// System.out.println(right);</span></div><div class="line">        left.addAll(leaf);</div><div class="line">        left.addAll(right);</div><div class="line">        <span class="keyword">return</span> left;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-二叉搜索树-BST"><a href="#4-二叉搜索树-BST" class="headerlink" title="4.二叉搜索树(BST)"></a>4.二叉搜索树(BST)</h2><h3 id="二叉搜索树的基本性质"><a href="#二叉搜索树的基本性质" class="headerlink" title="二叉搜索树的基本性质"></a>二叉搜索树的基本性质</h3><ol>
<li><p>从定义出发</p>
<p>左子树都比跟节点小</p>
<p>右子树都比根节点大</p>
<p>遇到重复的元素，可以自行定义放在左子树还是右子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">	<span class="number">1</span></div><div class="line">  ↙   ↘ ...... 是BST</div><div class="line"> <span class="number">1</span>     <span class="number">2</span></div><div class="line"></div><div class="line">    <span class="number">1</span></div><div class="line">  ↙   ↘ ......不是BST</div><div class="line"> <span class="number">1</span>     <span class="number">1</span></div><div class="line">因为BST的定义是比根节点小（包括相等）的要么都在左边，要么都在右边</div></pre></td></tr></table></figure>
</li>
<li><p>从效果出发</p>
<p><strong>BST的中序遍历是升序序列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例：</div><div class="line">	<span class="number">2</span></div><div class="line">  ↙   ↘ </div><div class="line"> <span class="number">1</span>     <span class="number">4</span>           中序遍历：<span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span></div><div class="line">   	 ↙   ↘ </div><div class="line">	<span class="number">3</span>     <span class="number">5</span></div></pre></td></tr></table></figure>
<p><strong>利用BST的这个性质，可以做排序：</strong><br>比如给定一个无序序列[2,1,4,3,5]<br>可以构造一个BST，然后再中序遍历，输出序列就是有序序列了</p>
<p>因此，<strong>BST又叫排序二叉树</strong></p>
<p>相关练习题：</p>
<p>Binary Search Tree 的insert、remove等</p>
</li>
<li><p>性质</p>
<ul>
<li><p>如果一棵二叉树的中序遍历不是升序，则一定不是BST</p>
</li>
<li><p>如果一棵二叉树的中序遍历是升序，也未必是BST</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">比如：</div><div class="line">    <span class="number">1</span></div><div class="line">  ↙   ↘ </div><div class="line"> <span class="number">1</span>     <span class="number">1</span></div><div class="line">中序遍历得到[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]，是升序序列，但是不是BST</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>存在重复元素时，要么都在左子树要么都在右子树，不可以两边都有</p>
</li>
</ul>
</li>
</ol>
<h3 id="Validate-Binary-Search-Tree"><a href="#Validate-Binary-Search-Tree" class="headerlink" title="Validate Binary Search Tree"></a><a href="https://leetcode.com/problems/validate-binary-search-tree" target="_blank" rel="external">Validate Binary Search Tree</a></h3><p>题目</p>
<blockquote>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     2</div><div class="line">&gt;    / \</div><div class="line">&gt;   1   3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Binary tree </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [2,1,3]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>, return true.</p>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     1</div><div class="line">&gt;    / \</div><div class="line">&gt;   2   3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Binary tree </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [1,2,3]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>, return false.</p>
</blockquote>
<p>分析</p>
<p>给定一个二叉树，判断是否是二叉搜索树，两种思路:</p>
<ol>
<li>根据二叉搜索树的性质，中序遍历是升序序列，可以对给定二叉树进行中序遍历，输出序列如果是升序序列则是二叉搜索树，可以利用二叉树的非递归中序遍历，每次弹栈时跟前一个元素进行比较，如果小于等于前一个元素就直接返回false。</li>
<li>分治法递归判断，需要存储节点以下是否是BST，以及节点以下部分的最大最小值，和root节点进行比较，是否满足左子树所有元素都小于root,右子树所有节点都大于root。</li>
</ol>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//分治法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultType</span></span>&#123;</div><div class="line">        <span class="keyword">boolean</span> isValid;</div><div class="line">        <span class="keyword">long</span> min;</div><div class="line">        <span class="keyword">long</span> max;</div><div class="line">        ResultType(<span class="keyword">boolean</span> isValid,<span class="keyword">long</span> min,<span class="keyword">long</span> max)&#123;</div><div class="line">            <span class="keyword">this</span>.isValid = isValid;</div><div class="line">            <span class="keyword">this</span>.max = max;</div><div class="line">            <span class="keyword">this</span>.min = min;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> ResultType <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">true</span>,Long.MAX_VALUE,Long.MIN_VALUE);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//拆分</span></div><div class="line">        ResultType leftValid = helper(root.left);</div><div class="line">        ResultType rightValid = helper(root.right);</div><div class="line"></div><div class="line">        <span class="comment">//合并</span></div><div class="line">        <span class="keyword">if</span>(leftValid.isValid &amp;&amp; rightValid.isValid)&#123;<span class="comment">//左右子树都是BST</span></div><div class="line">            <span class="keyword">if</span>(leftValid.max &lt; root.val &amp;&amp; rightValid.min &gt; root.val)&#123;<span class="comment">//左边元素都比root小，右边元素都比root大</span></div><div class="line">                ResultType res = <span class="keyword">new</span> ResultType(<span class="keyword">true</span>,Math.min(leftValid.min,root.val),Math.max(rightValid.max,root.val));</div><div class="line">                <span class="keyword">return</span> res;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>,Math.min(leftValid.min,root.val),Math.max(rightValid.max,root.val));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>,Long.MIN_VALUE,Long.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> helper(root).isValid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//非递归中序遍历</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST2</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> last = Integer.MIN_VALUE;</div><div class="line">        TreeNode cur = root;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> ||!stack.empty())&#123;</div><div class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</div><div class="line">                stack.push(cur);</div><div class="line">                cur = cur.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">                cur = stack.pop();</div><div class="line">                <span class="keyword">if</span>(cur.val &lt;= last)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">                cur = cur.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Binary-Search-Tree-Iterator"><a href="#Binary-Search-Tree-Iterator" class="headerlink" title="Binary Search Tree Iterator"></a><a href="https://leetcode.com/problems/binary-search-tree-iterator" target="_blank" rel="external">Binary Search Tree Iterator</a></h3><p>题目</p>
<blockquote>
<p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling <code>next()</code> will return the next smallest number in the BST.</p>
<p><strong>Note: </strong><code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<em>h</em>) memory, where <em>h</em> is the height of the tree.</p>
</blockquote>
<p>设计实现一个带有下列属性的二叉查找树的迭代器：</p>
<ol>
<li>元素按照递增的顺序被访问（比如中序遍历）</li>
<li>next()和hasNext()的询问操作要求<strong>均摊</strong>时间复杂度是O(1)</li>
</ol>
<p>分析</p>
<p>对于下列二叉查找树，使用迭代器进行中序遍历的结果为 [3, 6, 7, 8, 9, 10, 11, 12]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">     10</div><div class="line">   /    \</div><div class="line">  6      11</div><div class="line"> / \       \</div><div class="line">3   9       12</div><div class="line">   /</div><div class="line">  8</div><div class="line"> /</div><div class="line">7</div></pre></td></tr></table></figure>
<ul>
<li>本题相当于考察了BST的非递归中序遍历</li>
<li>需要maintain一个stack，首先从root开始push入栈直到最左节点<br>初始stack为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">10, 6, 3</div></pre></td></tr></table></figure>
<ul>
<li>在遍历过程中，如果某个节点存在右儿子，则继续从右儿子开始push入栈直到其最左节点<br>result = 3, 6<br>因为6有右儿子，所以6被pop出去之后，从6为root开始push入栈直到最左节点，然后stack为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">10， 9， 8， 7</div></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line"></div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</div><div class="line">            val = x;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</div><div class="line">        TreeNode root;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">		</div><div class="line">  		<span class="comment">//初始化，将root全部left入栈</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.root = root;</div><div class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</div><div class="line">                stack.push(root);</div><div class="line">                root = root.left;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> !stack.empty();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            TreeNode temp = stack.pop();</div><div class="line">            <span class="keyword">int</span> val = temp.val;</div><div class="line">            temp = temp.right;</div><div class="line">			<span class="comment">//如果弹出节点有右节点，右节点视作左节点，全部左孩子入栈</span></div><div class="line">            <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</div><div class="line">                stack.push(temp);</div><div class="line">                temp = temp.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> val;<span class="comment">//返回当前节点值</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Inorder-Successor-in-BST"><a href="#Inorder-Successor-in-BST" class="headerlink" title="Inorder Successor in BST"></a><a href="https://leetcode.com/problems/inorder-successor-in-bst" target="_blank" rel="external">Inorder Successor in BST</a></h3><p>题目</p>
<blockquote>
<p>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</p>
<p><strong>Note</strong>: If the given node has no in-order successor in the tree, return <code>null</code>.</p>
</blockquote>
<p>给定一个二叉搜索树和一个节点p，返回p的后继节点（中序遍历时和p相邻比p大的节点）</p>
<p>分析</p>
<ol>
<li>BST的stack实现，弹栈遇到p节点时标记下，下一次弹栈的节点即是所求</li>
<li>递归实现：<ul>
<li>如果p的值小于root，则在左子树中寻找后继，若没有找到，则root就是p的后继</li>
<li>如果p的值大于root，则在右子树中寻找后继节点</li>
</ul>
</li>
</ol>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//非递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</div><div class="line">  Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">  TreeNode cur = root;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.empty())&#123;</div><div class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</div><div class="line">      stack.push(cur);</div><div class="line">      cur = cur.left;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">      cur = stack.pop();</div><div class="line">      <span class="keyword">if</span>(flag == <span class="keyword">true</span>)&#123;</div><div class="line">        <span class="keyword">return</span> cur;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(cur == p)&#123;</div><div class="line">        flag = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">      cur = cur.right;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//递归</span></div><div class="line"> <span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor2</span><span class="params">(TreeNode root, TreeNode p)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || p == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//后级节点在左子树或root节点中</span></div><div class="line">        <span class="keyword">if</span>(p.val &lt; root.val)&#123;</div><div class="line">            <span class="comment">//后继节点在以左孩子为root的子树中的位置</span></div><div class="line">            TreeNode left = inorderSuccessor2(root.left,p);</div><div class="line">            <span class="comment">//没有刚好比p大一个的，则root就是p的后继节点</span></div><div class="line">          	<span class="keyword">if</span>(left == <span class="keyword">null</span>)&#123;</div><div class="line">                <span class="keyword">return</span>  root;</div><div class="line">            &#125;</div><div class="line">          	<span class="comment">//在左子树中找到了p的后继</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> left;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//后继节点在右子树中</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> inorderSuccessor2(root.right,p);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Search-Range-in-Binary-Search-Tree"><a href="#Search-Range-in-Binary-Search-Tree" class="headerlink" title="Search Range in Binary Search Tree"></a><a href="http://www.lintcode.com/en/problem/search-range-in-binary-search-tree/" target="_blank" rel="external">Search Range in Binary Search Tree</a></h3><p>题目</p>
<blockquote>
<p>Given two values k1 and k2 (where k1 &lt; k2) and a root pointer to a Binary Search Tree. Find all the keys of tree in range k1 to k2. i.e. print all x such that k1&lt;=x&lt;=k2 and x is a key of given BST. Return all the keys in ascending order.</p>
<p>Have you met this question in a real interview?</p>
<p>Yes</p>
<p>Example</p>
<p>If k1 = <code>10</code> and k2 = <code>22</code>, then your function should return <code>[12, 20, 22]</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     20</div><div class="line">&gt;    /  \</div><div class="line">&gt;   8   22</div><div class="line">&gt;  / \</div><div class="line">&gt; 4   12</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定一个二叉搜索树和一个区间，要求升序输出二叉搜索树中在给定区间内的节点</p>
<p>分析</p>
<p>中序遍历BST，将符合条件的结果输出即可</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">searchRange</span><span class="params">(TreeNode root, <span class="keyword">int</span> k1, <span class="keyword">int</span> k2)</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    TreeNode cur = root;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.empty())&#123;</div><div class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(cur);</div><div class="line">            cur = cur.left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">            cur = stack.pop();</div><div class="line">            <span class="keyword">if</span>(cur.val &lt;= k2 &amp;&amp; cur.val &gt;= k1) &#123;</div><div class="line">                results.add(cur.val);</div><div class="line">            &#125;</div><div class="line">            cur = cur.right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Insert-Node-in-Binary-Search-Tree"><a href="#Insert-Node-in-Binary-Search-Tree" class="headerlink" title="Insert Node in Binary Search Tree"></a><a href="http://www.lintcode.com/en/problem/insert-node-in-a-binary-search-tree/" target="_blank" rel="external">Insert Node in Binary Search Tree</a></h3><p>题目</p>
<blockquote>
<p>Given a binary search tree and a new tree node, insert the node into the tree. You should keep the tree still be a valid binary search tree.</p>
<h5 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h5><p>You can assume there is no duplicate values in this tree + node.</p>
<p>Example</p>
<p>Given binary search tree as follow, after Insert node 6, the tree should be:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;   2             2</div><div class="line">&gt;  / \           / \</div><div class="line">&gt; 1   4   --&gt;   1   4</div><div class="line">&gt;    /             / \ </div><div class="line">&gt;   3             3   6</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定一个二叉搜索树和一个新节点，插入新节点，保持二叉树仍然是二叉搜索树</p>
<p>分析</p>
<p>递归实现，判断node的值和root节点的大小关系，返回值是当前root节点：</p>
<pre><code>       1. node小于root，要插在左子树，root.left = insertNode(root.left,node);
        2. node大于root，要插在右子树，root.right= insertNode(root.right,node);
</code></pre><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertNode</span><span class="params">(TreeNode root, TreeNode node)</span> </span>&#123;</div><div class="line">        <span class="comment">// 找到插入位置，插入node节点</span></div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//在左子树</span></div><div class="line">        <span class="keyword">if</span>(node.val &lt; root.val)&#123;</div><div class="line">            root.left = insertNode(root.left,node);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//在右子树</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            root.right = insertNode(root.right,node);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Delete-Node-in-a-BST"><a href="#Delete-Node-in-a-BST" class="headerlink" title="Delete Node in a BST"></a><a href="https://leetcode.com/problems/delete-node-in-a-bst" target="_blank" rel="external">Delete Node in a BST</a></h3><p>题目</p>
<blockquote>
<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<ol>
<li>Search for a node to remove.</li>
<li>If the node is found, delete the node.</li>
</ol>
<p><strong>Note:</strong> Time complexity should be O(height of tree).</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; root = [5,3,6,2,4,null,7]</div><div class="line">&gt; key = 3</div><div class="line">&gt;</div><div class="line">&gt;     5</div><div class="line">&gt;    / \</div><div class="line">&gt;   3   6</div><div class="line">&gt;  / \   \</div><div class="line">&gt; 2   4   7</div><div class="line">&gt;</div><div class="line">&gt; Given key to delete is 3. So we find the node with value 3 and delete it.</div><div class="line">&gt;</div><div class="line">&gt; One valid answer is [5,4,6,2,null,null,7], shown in the following BST.</div><div class="line">&gt;</div><div class="line">&gt;     5</div><div class="line">&gt;    / \</div><div class="line">&gt;   4   6</div><div class="line">&gt;  /     \</div><div class="line">&gt; 2       7</div><div class="line">&gt;</div><div class="line">&gt; Another valid answer is [5,2,6,null,4,null,7].</div><div class="line">&gt;</div><div class="line">&gt;     5</div><div class="line">&gt;    / \</div><div class="line">&gt;   2   6</div><div class="line">&gt;    \   \</div><div class="line">&gt;     4   7</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>分析</p>
<p>首先要找到要删除的节点，然后用它左子树的最大值（或右子树的最小值）的值取代要删除节点的值，再将左子树的最大值（或右子树的最小值）节点删除。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//查找以root为跟的树的最大节点，root非空</span></div><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">findMax</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  <span class="keyword">while</span>(root.right!=<span class="keyword">null</span>)&#123;</div><div class="line">    root= root.right;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//查找并删除节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span>  <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//在左子树</span></div><div class="line">  <span class="keyword">if</span>(root.val &gt; key)&#123;</div><div class="line">    root.left = deleteNode(root.left,key);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//在右子树</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)&#123;</div><div class="line">    root.right = deleteNode(root.right,key);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//要删除的就是root</span></div><div class="line">  <span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;<span class="comment">//如果左节点是空的</span></div><div class="line">      <span class="keyword">return</span> root.right;<span class="comment">//返回右节点</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="keyword">null</span>)&#123;<span class="comment">//左节点非空，右节点为空</span></div><div class="line">      <span class="keyword">return</span> root.left;<span class="comment">//返回左节点</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//左右节点都非空，用左子树最大节点取代当前节点</span></div><div class="line">    root.val = findMax(root.left).val;</div><div class="line">    <span class="comment">//删除左子树最大值节点</span></div><div class="line">    root.left = deleteNode(root.left,root.val);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Count-of-Smaller-Numbers-After-Self"><a href="#Count-of-Smaller-Numbers-After-Self" class="headerlink" title="Count of Smaller Numbers After Self"></a><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="external">Count of Smaller Numbers After Self</a></h3><p>题目</p>
<blockquote>
<p>You are given an integer array <em>nums</em> and you have to return a new <em>counts</em> array. The <em>counts</em> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given nums = [5, 2, 6, 1]</div><div class="line">&gt;</div><div class="line">&gt; To the right of 5 there are 2 smaller elements (2 and 1).</div><div class="line">&gt; To the right of 2 there is only 1 smaller element (1).</div><div class="line">&gt; To the right of 6 there is 1 smaller element (1).</div><div class="line">&gt; To the right of 1 there is 0 smaller element.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Return the array <code>[2, 1, 1, 0]</code>.</p>
</blockquote>
<p>思路</p>
<ol>
<li><p>baseline：插入排序+二分优化</p>
<p>开一个新的数组，从后向前遍历原数组，将数字插入新数组的合适位置，该位置就是原数组中在其右侧小于其的数字个数。插入过程采用二分查找。</p>
</li>
<li><p>BST</p>
<p>构建一个BST，节点记录当前出现的比自己小的元素个数，对于每个节点分三种情况讨论：</p>
<ol>
<li>val &lt; root.val，递归向root.left插入节点，同时root的smallerNum++</li>
<li>val == root.val，递归向root.right插入节点，其smallerNum = root.smallerNum+insert(root.right,val)</li>
<li>val &gt; root.val，递归向root.right插入节点，其smallerNum = root.smallerNum+1+insert(root.right,val)</li>
</ol>
</li>
</ol>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        <span class="keyword">int</span> num;<span class="comment">//记录比val小的所有数字数目</span></div><div class="line">        Node left;</div><div class="line">        Node right;</div><div class="line">        Node(<span class="keyword">int</span> val,<span class="keyword">int</span> num)&#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">            <span class="keyword">this</span>.num = num;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//构建BST</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(Node root,<span class="keyword">int</span> val)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(val == root.val)&#123;</div><div class="line">            <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)&#123;</div><div class="line">                root.right = <span class="keyword">new</span> Node(val,<span class="number">0</span>);</div><div class="line">                <span class="keyword">return</span> root.num;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> insert(root.right,val) + root.num;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(val &gt; root.val)&#123;</div><div class="line">            <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)&#123;</div><div class="line">                root.right = <span class="keyword">new</span> Node(val,<span class="number">0</span>);</div><div class="line">                <span class="keyword">return</span> root.num + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> insert(root.right,val) + root.num + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            root.num++;</div><div class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;</div><div class="line">                root.left = <span class="keyword">new</span> Node(val,<span class="number">0</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> insert(root.left,val);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        Node root = <span class="keyword">new</span> Node(nums[nums.length-<span class="number">1</span>],<span class="number">0</span>);</div><div class="line">        res.add(<span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length-<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</div><div class="line">            res.add(<span class="number">0</span>,insert(root,nums[i]));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时间可以再写一写这道题，还不是很好</p>
<h3 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a><a href="https://leetcode.com/problems/unique-binary-search-trees" target="_blank" rel="external">Unique Binary Search Trees</a></h3><p><strong>题目：</strong></p>
<blockquote>
<p>Given <em>n</em>, how many structurally unique <strong>BST’s</strong> (binary search trees) that store values 1…<em>n</em>?</p>
<p>For example,<br>Given <em>n</em> = 3, there are a total of 5 unique BST’s.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1         3     3      2      1</div><div class="line">&gt;     \       /     /      / \      \</div><div class="line">&gt;      3     2     1      1   3      2</div><div class="line">&gt;     /     /       \                 \</div><div class="line">&gt;    2     1         2                 3</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定数组n，返回1-n共n个节点一共可以构成多少个独一无二的BST</p>
<p><strong>分析：</strong></p>
<p>DP</p>
<p>遍历1-n个节点，一次选取一个k作为root,则其左边有1…k-1共k-1个节点，右边有k+1…n共n-k个节点，因此数量是两边BST数量的乘积，则这种情况共有dp[k-1]*dp[n-k]种不同的BST</p>
<p>因此dp[n] = dp[0]dp[n-1] + dp[1]dp[n-2]+…+dp[n-1]dp[0]</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n;i ++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++)&#123;</div><div class="line">                dp[i] += dp[j] * dp[i-j-<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[n];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Unique-Binary-Search-Trees-II"><a href="#Unique-Binary-Search-Trees-II" class="headerlink" title="Unique Binary Search Trees II"></a><a href="https://leetcode.com/problems/unique-binary-search-trees-ii" target="_blank" rel="external">Unique Binary Search Trees II</a></h3><p><strong>题目</strong></p>
<blockquote>
<p>Given an integer <em>n</em>, generate all structurally unique <strong>BST’s</strong> (binary search trees) that store values 1…<em>n</em>.</p>
<p>For example,<br>Given <em>n</em> = 3, your program should return all 5 unique BST’s shown below.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1         3     3      2      1</div><div class="line">&gt;     \       /     /      / \      \</div><div class="line">&gt;      3     2     1      1   3      2</div><div class="line">&gt;     /     /       \                 \</div><div class="line">&gt;    2     1         2                 3</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定数组n，返回1-n共n个节点构成的所有独一无二的BST</p>
<p><strong>分析</strong></p>
<p>遍历每一个节点k，以该节点为root的BST可以由其左、右子树所有可能的情况构成</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">create</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    List&lt;TreeNode&gt; results = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">if</span>(start &gt; end)&#123;</div><div class="line">        results.add(<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end;i++)&#123;</div><div class="line">        List&lt;TreeNode&gt; left = create(start,i-<span class="number">1</span>);<span class="comment">//计算左子树所有可能情况</span></div><div class="line">        List&lt;TreeNode&gt; right = create(i+<span class="number">1</span>,end);<span class="comment">//计算右子树所有可能情况</span></div><div class="line">      <span class="comment">//遍历左右子树所有情况，以当前节点为root，构造BST加入当前结果集</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; left.size();j++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; right.size() ; k++)&#123;</div><div class="line">                TreeNode root = <span class="keyword">new</span> TreeNode(i);</div><div class="line">                root.left = left.get(j);</div><div class="line">                root.right = right.get(k);</div><div class="line">                results.add(root);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;<span class="comment">//返回当前层所有BST</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> create(<span class="number">1</span>,n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-二叉树的层序遍历"><a href="#5-二叉树的层序遍历" class="headerlink" title="5.二叉树的层序遍历"></a>5.二叉树的层序遍历</h2><h3 id="Binary-Tree-Level-Order-Traversal"><a href="#Binary-Tree-Level-Order-Traversal" class="headerlink" title="Binary Tree Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal" target="_blank" rel="external">Binary Tree Level Order Traversal</a></h3><p>题目</p>
<blockquote>
<p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     3</div><div class="line">&gt;    / \</div><div class="line">&gt;   9  20</div><div class="line">&gt;     /  \</div><div class="line">&gt;    15   7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return its level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [3],</div><div class="line">&gt;   [9,20],</div><div class="line">&gt;   [15,7]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>分析</p>
<p><strong>广度优先搜索</strong>，利用<code>Queue</code>，先进先出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">-----|--------|-------</div><div class="line">&lt;- <span class="number">3</span> | <span class="number">9</span>   <span class="number">20</span> | <span class="number">15</span>   <span class="number">7</span> </div><div class="line">-----|--------|-------</div></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  queue.add(root);</div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ;i++)&#123;</div><div class="line">      TreeNode temp = queue.poll();</div><div class="line">      res.add(temp.val);</div><div class="line">      <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">        queue.add(temp.left);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">        queue.add(temp.right);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    results.add(res);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>宽度优先搜索最常用的数据结构是队列和hash表，但是在二叉树的问题中不会用到hash表，只会用到Queue队列</p>
<h3 id="Binary-Tree-Level-Order-Traversal-II"><a href="#Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="Binary Tree Level Order Traversal II"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii" target="_blank" rel="external">Binary Tree Level Order Traversal II</a></h3><p>题目</p>
<blockquote>
<p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     3</div><div class="line">&gt;    / \</div><div class="line">&gt;   9  20</div><div class="line">&gt;     /  \</div><div class="line">&gt;    15   7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return its bottom-up level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [15,7],</div><div class="line">&gt;   [9,20],</div><div class="line">&gt;   [3]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>分析</p>
<p>跟上一题的差别是层与层之间的顺序是反的，每层元素的顺序不变，所以只需要插入最终的结果集的时候反序插入，所以可以利用LinkedList，每次将每层的结果在前面插入。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LinkedList&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div><div class="line"></div><div class="line">queue.add(root);</div><div class="line"><span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">  List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">int</span> size = queue.size();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ;i++)&#123;</div><div class="line">    TreeNode temp = queue.poll();</div><div class="line">    res.add(temp.val);</div><div class="line">    <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">      queue.add(temp.left);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">      queue.add(temp.right);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  results.addFirst(res);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> results;</div></pre></td></tr></table></figure>
<h3 id="Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="Binary Tree Zigzag Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal" target="_blank" rel="external">Binary Tree Zigzag Level Order Traversal</a></h3><p>题目</p>
<blockquote>
<p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     3</div><div class="line">&gt;    / \</div><div class="line">&gt;   9  20</div><div class="line">&gt;     /  \</div><div class="line">&gt;    15   7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return its zigzag level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [3],</div><div class="line">&gt;   [20,9],</div><div class="line">&gt;   [15,7]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>分析</p>
<p>这道题是每一层交替正反序输出，层与层之间的顺序不变，所以result可以使用ArratList，但是每一层的子res要是用LinkedList，额外立flag取定是从前插入还是从后插入。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  queue.add(root);</div><div class="line">  <span class="keyword">int</span> flag = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ;i++)&#123;</div><div class="line">      TreeNode temp = queue.poll();</div><div class="line">      <span class="keyword">if</span>(flag%<span class="number">2</span> == <span class="number">1</span>)&#123;</div><div class="line">        res.addFirst(temp.val);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        res.addLast(temp.val);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">        queue.add(temp.left);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">        queue.add(temp.right);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    flag++;</div><div class="line">    results.add(res);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Serialize-and-Deserialize-Binary-Tree"><a href="#Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="Serialize and Deserialize Binary Tree"></a><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree" target="_blank" rel="external">Serialize and Deserialize Binary Tree</a></h3><p>题目</p>
<blockquote>
<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>For example, you may serialize the following tree</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     1</div><div class="line">&gt;    / \</div><div class="line">&gt;   2   3</div><div class="line">&gt;      / \</div><div class="line">&gt;     4   5</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>as <code>&quot;[1,2,3,null,null,4,5]&quot;</code>, just the same as <a href="https://leetcode.com/faq/#binary-tree" target="_blank" rel="external">how LeetCode OJ serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>
</blockquote>
<p>思路</p>
<p>序列化so easy，用queue层序遍历即可</p>
<p><strong>反序列化也要用queue，将root节点放入队列，然后数组中的前两个元素是其左右孩子，依次加入队列。。。。</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> res.toString();</div><div class="line">        &#125;</div><div class="line">        queue.add(root);</div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            TreeNode temp = queue.poll();</div><div class="line">            <span class="keyword">if</span>(temp != <span class="keyword">null</span>)&#123;</div><div class="line">                res.append(temp.val+<span class="string">","</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                res.append(<span class="string">"null,"</span>);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            queue.add(temp.left);</div><div class="line">            queue.add(temp.right);</div><div class="line">        &#125;</div><div class="line">        res.subSequence(<span class="number">0</span>,res.length()-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> res.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Decodes your encoded data to tree.</span></div><div class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(data.length() == <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            String[] nums = data.split(<span class="string">","</span>);</div><div class="line">            Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(nums[<span class="number">0</span>]));</div><div class="line">            queue.add(root);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length;i++)&#123;</div><div class="line">                TreeNode parent = queue.poll();</div><div class="line">                <span class="keyword">if</span>(!nums[i].equals(<span class="string">"null"</span>))&#123;</div><div class="line">                    parent.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(nums[i]));</div><div class="line">                    queue.add(parent.left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(!nums[++i].equals(<span class="string">"null"</span>))&#123;</div><div class="line">                    parent.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(nums[i]));</div><div class="line">                    queue.add(parent.right);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></div><div class="line"><span class="comment">// Codec codec = new Codec();</span></div><div class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></div></pre></td></tr></table></figure>
<h2 id="6-二叉树的深度优先遍历"><a href="#6-二叉树的深度优先遍历" class="headerlink" title="6.二叉树的深度优先遍历"></a>6.二叉树的深度优先遍历</h2><p>DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</p>
<p>当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。</p>
<p>如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-20-21-52-42.png" alt=""> </p>
<p>如上图的例子，DFS访问数组为：ABDECFG。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>分析一下，在遍历了根结点后，就开始遍历左子树，最后才是右子树。</p>
<p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，</p>
<p>这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>思路比较简单，就是从root开始，先将root值加入结果集，然后先对其做左节点递归调用做DFS，然后是对右节点DFS。当遇到空节点时，返回上层。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDFS</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line"></div><div class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSRecurtionHelper</span><span class="params">(TreeNode root,List&lt;Integer&gt; results)</span></span>&#123;</div><div class="line">        <span class="comment">//遇到空节点，返回</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//root放入results,递归处理左右节点</span></div><div class="line">        results.add(root.val);</div><div class="line">        DFSRecurtion(root.left);</div><div class="line">        DFSRecurtion(root.right);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSRecurtion</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        DFSRecurtionHelper(root,results);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="非递归（栈）"><a href="#非递归（栈）" class="headerlink" title="非递归（栈）"></a>非递归（栈）</h4><p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSwithStack</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    stack.push(root);</div><div class="line">    <span class="keyword">while</span> (!stack.empty())&#123;</div><div class="line">        TreeNode temp = stack.pop();</div><div class="line">        results.add(temp.val);</div><div class="line">        <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.left);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="7-完全二叉树"><a href="#7-完全二叉树" class="headerlink" title="7.完全二叉树"></a>7.完全二叉树</h2><h3 id="Count-Complete-Tree-Nodes"><a href="#Count-Complete-Tree-Nodes" class="headerlink" title="Count Complete Tree Nodes"></a><a href="https://leetcode.com/problems/count-complete-tree-nodes/" target="_blank" rel="external">Count Complete Tree Nodes</a></h3><p>给定一棵完全二叉树，求树中的节点个数</p>
<p>完全二叉树只有最后一层的节点可能是不满的，所以对于树中的任意一个节点来说，其左右子节点的高度只有两种情况：</p>
<ol>
<li>高度相等，说明该节点左子树是一个满二叉树，其节点个数为<script type="math/tex">2^h-1</script> ，仍需对其右子树递归求解节点个数</li>
<li>右节点高度比左节点高度小1，说明右节点是满二叉树，节点个数为<script type="math/tex">2^{h-1}-1</script> ,仍需对其左子树递归求解节点个数</li>
</ol>
<p>这里的高度计算的是到最左侧叶子节点的高度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountCompleteTreeNodes</span> </span>&#123;</div><div class="line">    <span class="comment">//计算树高，root非空</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> height = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(root.left != <span class="keyword">null</span>)&#123;</div><div class="line">            height++;</div><div class="line">            root = root.left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> height;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> leftheight = height(root.left);</div><div class="line">        <span class="keyword">int</span> rightheight = height(root.right);</div><div class="line">        <span class="comment">//如果左右节点高度一致</span></div><div class="line">        <span class="keyword">if</span>(leftheight == rightheight)&#123;</div><div class="line">            count = count + (<span class="number">1</span>&lt;&lt;leftheight) - <span class="number">1</span>;</div><div class="line">            count += countNodes(root.right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            count = count + (<span class="number">1</span>&lt;&lt;rightheight) - <span class="number">1</span>;</div><div class="line">            count += countNodes(root.left);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>递归是深度优先搜索（DFS）的一种实现形式<ul>
<li>递归也可以用非递归方式实现</li>
</ul>
</li>
<li>二叉树上的递归<ul>
<li>遍历法</li>
<li>分治法</li>
</ul>
</li>
<li>二叉搜索树<ul>
<li>性质：中序遍历是升序序列</li>
<li>功能：O(h)的时间复杂度查找、删除、插入，h为BST高度</li>
</ul>
</li>
<li>二叉树上的宽度优先遍历<ul>
<li>利用队列实现宽度优先搜索</li>
<li>如何实现分层遍历</li>
</ul>
</li>
<li>必背程序<ul>
<li>二叉树的前序、中序遍历的非递归实现</li>
<li>二叉树的层序遍历</li>
</ul>
</li>
<li>二叉树的深度优先遍历DFS<ol>
<li>递归实现</li>
<li>非递归实现（stack）</li>
</ol>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/59e3fde451882578c20858a5" target="_blank" rel="external"><a href="https://link.juejin.im/?target=mailto%3Amonkeysayhi7%40gmail.com" target="_blank" rel="external">猴子007的博客</a></a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bid Optimizing and Inventory Scoring in Targeted Online论文笔记]]></title>
      <url>/2017/11/27/Bid-Optimizing-and-Inventory-Scoring-in-Targeted-Online%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="Bid-Optimizing-and-Inventory-Scoring-in-Targeted-Online-Advertising"><a href="#Bid-Optimizing-and-Inventory-Scoring-in-Targeted-Online-Advertising" class="headerlink" title="Bid Optimizing and Inventory Scoring in Targeted Online Advertising"></a>Bid Optimizing and Inventory Scoring in Targeted Online Advertising</h2><p>这篇文章来自美国一家很优秀的DSP公司——M6D,介绍了DSP的工作流程和其中的一个核心技术：real-time bidding(实时竞价技术)</p>
<p>实时竞价：找准正确的广告信息和广告位信息，以一个能够反映真实价格的竞拍价格参与广告展示机会的竞价</p>
<a id="more"></a>
<h2 id="M6D竞价流程"><a href="#M6D竞价流程" class="headerlink" title="M6D竞价流程"></a>M6D竞价流程</h2><ol>
<li><strong>追踪用户行为</strong>：DSP公司通常会在广告主的网站上埋点（即放上一个1x1的不可见像素），这样当互联网用户第一次访问广告主的网站时，就会得到DSP公司的一个cookie，这样DSP公司就可以追踪到这个网民的在广告主网站上的行为了(这些数据也叫action data)。DSP公司还会和第三方的网站合作（例如：新浪，腾讯），在他们的网站上也埋点，或者向DMP购买网民行为数据，这样就可以追踪到网民在这些网站上的行为了(这些数据也叫mapping data)。这里值得一提的是，DSP公司对某一个用户记录的cookie和第三方网站或DMP或exchange记录的cookie是不一样的，这里需要一个叫Cookie Mapping的过程，这不是本文重点，以下假设DSP已经做好了Cookie Mapping，每个用户有一个唯一的id标识。</li>
<li>受众选择（audience selection）: m6d对每一个campaign(即每一个广告主的每个推广活动), 训练一个audience selection model, 该模型以在广告主的网站上发生转化行为（转化行为可以是注册成为用户，点击某个特定页面，购买产品。每个广告主对转化的定义不一样）的用户为正例，没有发生转化行为的用户为负例（是的，正负例很不均匀，通常要做采样和结果修正）。得到模型后，对所有的用户预估对这个campaign的转化概率p(c | u),即该用户u有多大的概率会在广告主的网站上发生转化行为（c表示conversion），去掉大多数转化概率非常小的用户，将目标用户根据转化概率高低分到不同的segments中。这样我们对每个campaign就找到了很多的目标用户，而且这些用户根据他们的质量高低，被分别放在不同的segments中。</li>
<li>通知exchange: DSP将这些目标用户的cookie告诉exchange，这样当有这些cookie的请求来的时候，exchange才会来向DSP的服务器发送请求。</li>
<li>Segment管理： 通常DSP公司会有账户管理员（运营人员），他们人工来对每个campaign的做一些设定。他们根据每个campaign所属的行业特点，经济状况，决定开启哪些segments，关掉哪些segments。例如：对没钱的小公司的campaign, 那些用户转化概率小一些的segment就不要投广告了。他们还需要对每个segment设定一个基础出价（base price）。账户管理员可以拿到每个segment的平均预估转化概率，来辅助他们设定基础出价。这一步也是人工影响投放策略最主要的地方。</li>
<li>进行实时竞价：当exchange把请求发过来的时候，DSP会拿到以下信息：当前广告位的信息，当前用户的cookie和基本信息。DSP需要在100ms内，根据对当前用户的理解，并且考虑当前广告位，根据自己的bidding算法，来要决定是否要买这次展现，投放哪个campaign的广告，出价是多少（bidding），并向exchange返回出价信息？如果超过时间DSP没有响应，则exchange默认DSP放弃这次竞价。</li>
<li>展现广告：如果赢得了展现机会，则DSP返回创意，用户就会在该广告位看到该创意。</li>
<li>追踪转化：因为DSP在广告主的网站上埋了点，就能知道用户是否在这次展现之后进行了转化行为。根据这些数据统计转化率，每个转化平均成本等指标，汇总成报告给广告主。</li>
</ol>
<h2 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h2><p>当exchange发送请求时，DSP会接受到当前用户的cookie和一些最基本的用户信息，以及当前广告位的信息。DSP则需要找到这个用户所属的所有segments，而这些segments可能会对应多个campaign。那么应该出哪个campaign的广告呢？这里有一个内部竞价的过程。</p>
<p>m6d是这么做的，首先要把一些不合适出广告的campaign根据规则过去掉。主要的规则有，如果一个用户之前已经被展现了这个campaign的广告数达到一定的个数了，那么就不要再浪费广告费了（这个次数限制通常叫frequency cap）。另外一个主要规则是，如果一个campaign已经达到了它的每日，或者每周，或者每月预算限制了，那么也不再为它投放广告了。对于剩下的campaign候选，DSP会对他们都根据算法计算出最合适的出价，然后简单地选取出价最高的那个（出价反映了当前用户对该campaign的价值）。</p>
<p>下面介绍下对于某一个campaign, 如何计算对当前展现机会的出价。</p>
<p>前面的audience selection部分，我们已经对每个用户划分了segments，然后账户管理员又对每个segment给出了基础出价（base price），当时这个出价考虑的是这个用户和这个campaign的适合程度，并没有考虑当前广告位是否适合这个campaign投广告，是否适合这个用户。因此m6d的算法，以基础出价为基准，根据当前广告位计算出一个调整因子$\phi$，最后的出价就是$baseprice * \phi$ 。因此我们全部的工作就是要计算这个$\phi$。</p>
<h4 id="计算调整因子-phi-的依据"><a href="#计算调整因子-phi-的依据" class="headerlink" title="计算调整因子$\phi$的依据"></a>计算调整因子$\phi$的依据</h4><p>在实时竞价中，一次展示机会的价值可以由其带来的真正效益来衡量，我们用转化率*转化价值来表示</p>
<p><img src="https://ooo.0o0.ooo/2017/05/09/59113178e5863.png" alt=""> </p>
<p>由于转化价值不好估计，我们就在转化率上面做文章。<br>对于同一个campaign来说，如果我们知道一个展现的转化率是另外一个展现的2倍，那么前面那个展现的出价应该是后面那个展现的出价的2倍。这就是M6D设计的竞价函数的依据。</p>
<h4 id="调整因子-phi-计算"><a href="#调整因子-phi-计算" class="headerlink" title="调整因子$\phi$计算"></a>调整因子$\phi$计算</h4><p>按照上面的逻辑，既然我们为segments出了一个平均价格baseprice，当一个展现机会的的转化率是这个segments中用户的平均转化率的$\phi$倍，我们应该为这个展现出$baseprice * \phi$的出价。因此有：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/09/591132bf75168.png" alt=""> </p>
<p>其中，u指的是用户，i是当前的广告位(inventory)，c指的是转化，a指某一具体的广告。分母计算的是在所有广告位（用j指代）上的平均转化率。这个分母要计算起来很复杂，我们要遍历所有的广告位(inventory)。但我们知道：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/09/591133298b64a.png" alt=""> </p>
<p>因此最终调整因子的计算化简为：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/09/59113394b3a89.png" alt=""> </p>
<p>所以m6d的bidding算法的最核心部分，就是为每个campaign都建立两个模型来分别预估p(c|u,i)和p(c|u)。考虑到每个campaign的转化数据很少，这2个模型的训练数据很少，要训练这两个模型太难了。因此m6d将同一个segment中的用户不做区分，从而可以把上式变为</p>
<p><img src="https://ooo.0o0.ooo/2017/05/09/5911344436942.png" alt=""> </p>
<p>其中，s是segment。这样就只需要训练p(c|s,i)和p(c|s)。因为s的个数远小于u的个数，这2个模型的特征空间显著变小了，模型更容易得到更好的结果。</p>
<h4 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h4><p>以上就是m6d对bidding的建模过程了，剩下的工作就是如何训练得到这两个模型。</p>
<p><strong>p(c|s,i)模型</strong>:  要得到这个模型的训练数据，还有一个冷启动的过程。必须事先对这些segments在这些inventories上投放，然后把那些最终带来转化的展现标记为正例，没有最终带来转化的展现标记为负例。m6d认为一次转化是由之前7天内该用户见到的最后一次展现带来的。这个模型的特征只有两类，一类就是segment id, 另外一类就是inventory id。也就是说，每一个样本只有两个非0的特征，一个是segment id对应的那个特征，另外一个是inventory id对应的那个特征。m6d没有组合segment和inventory特征，这样做的结果是：不管对于哪个segment，某个特定的inventory对最后预估值的贡献都是一样的。这个假设可以认为在大多数情况下是合理的。而且如果真要把这些组合特征加入模型，特征空间一下子又大了不少，对于少得可怜的训练数据来说，很容易就过拟合了。</p>
<p><strong>p(c|s)模型</strong>：和p(c|s,i)模型基本一样，区别就是特征只有segment id。</p>
<p>这两个模型的正例比例都非常低，因此训练过程中进行了采样（sampling）和修正（recalibration）。</p>
<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p>考虑了广告位（inventory）和不考虑广告位对转化率的预估由有多大的影响呢？以下的图展示了区别：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/09/59113a88e1b2f.png" alt=""> </p>
<p>具体看个例子。对于一个hotel广告主的一个campaign，不同的广告位预估出来的$\phi$值也很不相同，旅游类的预估值最高，社会媒体的最低。说明这个模型还是有一定区分度的。</p>
<p><img src="https://ooo.0o0.ooo/2017/05/09/59113a558161d.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> RTB </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[搜索引擎Top-k快速检索问题]]></title>
      <url>/2017/11/22/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8ETop-k%E5%BF%AB%E9%80%9F%E6%A3%80%E7%B4%A2%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="Fagin’s-Algorithm-and-Threshold-Algorithm"><a href="#Fagin’s-Algorithm-and-Threshold-Algorithm" class="headerlink" title="Fagin’s Algorithm and Threshold Algorithm"></a>Fagin’s Algorithm and Threshold Algorithm</h2><p>Fagin算法和Threshold算法都是Top-K排序领域的经典算法(K代表只要对前K个值排序值)，不同于传统Top-k对一维数组前K个值排序，Fargin和Threshhold算法适用于<strong>参考多个排序指标时对前k个物品排序</strong>。</p>
<a id="more"></a>
<p>比如说我要去旅游，选酒店的时候我有两个指标：</p>
<ol>
<li>价格合适</li>
<li>好评率</li>
</ol>
<p>那么我在网站上得到了下面的酒店信息：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-38-01.png" alt=""> </p>
<p>能够想到的一种常规的做法是对两种评价指标分别赋予一个权重<script type="math/tex">w_1,w_2</script>，然后计算两种指标的加权得分:</p>
<script type="math/tex; mode=display">score = w_1*Cheapness+w_2*Rating</script><p>然后按照score排序取TOP-k个作为结果。</p>
<p>这样的做法存在一个问题，就是当候选集合比较大时（酒店数目较多），我们对所有的候选都计算出得分进行排序比较会浪费大量的计算资源，时间开销也很大，而我们真正所关注的就只有很少的K个最优的Hotel，Fagin’s Algorithm就是针对这样的问题的一种Top-k检索算法。</p>
<h3 id="Fagin’s-Algorithm"><a href="#Fagin’s-Algorithm" class="headerlink" title="Fagin’s Algorithm"></a>Fagin’s Algorithm</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-50-01.png" alt=""> </p>
<p>Fagin’s Algorithm的策略如下：</p>
<p>每一轮在不同的指标中依次选取排名最靠前的候选，直到从多个指标序列中选出的候选中有K个已经被送所有的指标列表中选出来了，这K个就是最终给的TOP-k结果。</p>
<p>结合上面选酒店的例子，假设我们要选top-3的酒店：</p>
<ul>
<li>第一轮，选取两个列表中最靠前的：</li>
</ul>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-50-20.png" alt=""> </p>
<ul>
<li>第二轮，选取两个列表中第二靠前的：</li>
</ul>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-50-33.png" alt=""> </p>
<ul>
<li>第三轮，选取两个列表中第三靠前的，此时，已经有一个候选Hotel——Novotel在所有的评价指标（列表）中被选中了：</li>
</ul>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-50-43.png" alt=""> </p>
<ul>
<li>第四轮，选取两个列表中第四靠前的：</li>
</ul>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-50-57.png" alt=""> </p>
<ul>
<li>第五轮，选取两个列表中第五靠前的，此时，有三个候选Hotel——Novotel、Hilton、Ibis在所有的评价指标（列表）中被选中了，结束：</li>
</ul>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-51-06.png" alt=""> </p>
<p>因此最终通过Fagin’s Algorithm计算出来的TOP-3的Hotel结果就是：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-56-54.png" alt=""> </p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-57-07.png" alt=""> </p>
<p>再对比一下之前的方式，可以看出对于后面的大量不可能成为结果的候选集节省了计算和时间开销。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-51-45.png" alt=""> </p>
<h3 id="Fagin’s-Threshold-Algorithm"><a href="#Fagin’s-Threshold-Algorithm" class="headerlink" title="Fagin’s Threshold Algorithm"></a>Fagin’s Threshold Algorithm</h3><p>在上面的算法基础之上，提出了更为严谨的Fagin’s Threshold Algorithm：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-17-09-34.png" alt=""> </p>
<p>还是上面的例子：</p>
<p>将初始threshold设置为无穷大</p>
<ul>
<li><p>第一轮，在Cheapness和Rating表中选取最高的，计算其在所有评价指标下的综合得分，放入Top-k列表中，并计算第一行的threshold：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-17-16-24.png" alt=""> </p>
<p>根据Fagin’s Threshold算法，如果当前的th值已经小于top表中的所有值，就认为后面不可能再出现比top表中更好的候选了，即可停止计算，此时还不能够停止。</p>
</li>
<li><p>第二轮，在Cheapness和Rating表中选取第二高的，计算其在所有评价指标下的综合得分，更新Top-k表，计算threshold，还不能够停止计算</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-17-18-09.png" alt=""> </p>
</li>
<li><p>第三轮，</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-17-19-01.png" alt=""> </p>
</li>
<li><p>第四轮，</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-17-20-03.png" alt=""> </p>
<p>此时threshold已经低于所有的top-k候选了，后面不能再有更好的候选了，因此停止计算，得到结果。</p>
</li>
</ul>
<h3 id="海量数据TOP-k查询"><a href="#海量数据TOP-k查询" class="headerlink" title="海量数据TOP-k查询"></a>海量数据TOP-k查询</h3><p>top K问题很适合采用MapReduce框架解决，用户只需编写一个Map函数和两个Reduce 函数，然后提交到Hadoop（采用Mapchain和Reducechain）上即可解决该问题。具体而言，就是首先根据数据值或者把数据hash(MD5)后的值按照范围划分到不同的机器上，最好可以让数据划分后一次读入内存，这样不同的机器负责处理不同的数值范围，实际上就是Map。得到结果后，各个机器只需拿出各自出现次数最多的前N个数据，然后汇总，选出所有的数据中出现次数最多的前N个数据，这实际上就是Reduce过程。对于Map函数，采用Hash算法，将Hash值相同的数据交给同一个Reduce task；对于第一个Reduce函数，采用HashMap统计出每个词出现的频率，对于第二个Reduce 函数，统计所有Reduce task，输出数据中的top K即可。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【RTB论文笔记】]]></title>
      <url>/2017/11/20/%E3%80%90RTB%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%91/</url>
      <content type="html"><![CDATA[<h3 id="Bidding-Strategies"><a href="#Bidding-Strategies" class="headerlink" title="Bidding Strategies"></a>Bidding Strategies</h3><ul>
<li><p><a href="https://arxiv.org/pdf/1707.06409.pdf" target="_blank" rel="external">Attribution Modeling Increases Efficiency of Bidding in Display Advertising</a> by Eustache Diemert et al. ADKDD 2017.</p>
</li>
<li><p><a href="https://arxiv.org/pdf/1706.01614.pdf" target="_blank" rel="external">Profit Maximization for Online Advertising Demand-Side Platforms</a> by Paul Grigas et al. ArXiv 2017.</p>
</li>
<li><p><a href="http://wnzhang.net/papers/rlb.pdf" target="_blank" rel="external">Real-Time Bidding by Reinforcement Learning in Display Advertising</a> by Han Cai et al. WSDM 2017.</p>
</li>
<li><p><a href="http://wnzhang.net/papers/risk-bid.pdf" target="_blank" rel="external">Managing Risk of Bidding in Display Advertising</a> by Haifeng Zhang et al. WSDM 2017.</p>
</li>
<li><p><a href="https://arxiv.org/pdf/1703.02091.pdf" target="_blank" rel="external">Optimized Cost per Click in Taobao Display Advertising</a> by Han Zhu et al. ArXiv 2017.</p>
</li>
<li><p><a href="http://wnzhang.net/share/rtb-papers/two-pred-bid.pdf" target="_blank" rel="external">Combining Powers of Two Predictors in Optimizing Real-Time Bidding Strategy under Constrained Budget</a> by Chi-Chun Lin et al. CIKM 2016.</p>
</li>
<li><p><a href="http://www.kdd.org/kdd2016/papers/files/adp0722-geyikA.pdf" target="_blank" rel="external">Joint Optimization of Multiple Performance Metrics in Online Video Advertising</a> by Sahin Cem Geyik et al. KDD 2016.</p>
<a id="more"></a>
</li>
<li><p><a href="http://discovery.ucl.ac.uk/1496878/1/weinan-zhang-phd-2016.pdf" target="_blank" rel="external">Optimal Real-Time Bidding for Display Advertising</a> by Weinan Zhang. PhD Thesis 2016.</p>
</li>
<li><p><a href="http://wnzhang.net/papers/unbias-kdd.pdf" target="_blank" rel="external">Bid-aware Gradient Descent for Unbiased Learning with Censored Data in Display Advertising</a> by Weinan Zhang, Tianxiong Zhou, Jun Wang, Jian Xu. KDD 2016.</p>
</li>
<li><p><a href="http://wnzhang.net/share/rtb-papers/lift-bidding.pdf" target="_blank" rel="external">Lift-Based Bidding in Ad Selection</a> by Jian Xu et al. AAAI 2016.</p>
</li>
<li><p><a href="http://wnzhang.net/papers/fc-wsdm.pdf" target="_blank" rel="external">Feedback Control of Real-Time Display Advertising</a> by Weinan Zhang et al. WSDM 2016.</p>
</li>
<li><p><a href="http://arxiv.org/abs/1511.08409" target="_blank" rel="external">Optimal Real-Time Bidding Strategies</a> by Joaquin Fernandez-Tapia, Olivier Guéant, Jean-Michel Lasry. ArXiv 2015.</p>
</li>
<li><p><a href="http://wnzhang.net/share/rtb-papers/bid-drawbridge.pdf" target="_blank" rel="external">Programmatic Buying Bidding Strategies with Win Rate and Winning Price Estimation in Real Time Mobile Advertising</a> by Xiang Li and Devin Guan. PAKDD 2014.</p>
</li>
<li><p><a href="https://www.researchgate.net/publication/283579660_Statistical_modeling_of_Vickrey_auctions_and_applications_to_automated_bidding_strategies" target="_blank" rel="external">Statistical modeling of Vickrey auctions and applications to automated bidding strategies</a> by Joaquin Fernandez-Tapia. Working paper.</p>
</li>
<li><p><del><a href="http://wnzhang.net/share/rtb-papers/rtb-arbitrage.pdf" target="_blank" rel="external">Statistical Arbitrage Mining for Display Advertising</a> by Weinan Zhang, Jun Wang. KDD 2015.非线性出价函数，优化目标：DSP净利润</del></p>
</li>
<li><p><a href="http://wnzhang.net/share/rtb-papers/opt-prog-buy.pdf" target="_blank" rel="external">Real-Time Bidding rules of thumb: analytically optimizing the programmatic buying of ad-inventory</a> by Joaquin Fernandez-Tapia. SSRN 2015.</p>
</li>
<li><p><del><a href="http://wnzhang.net/share/rtb-papers/optimal-rtb.pdf" target="_blank" rel="external">Optimal Real-Time Bidding for Display Advertising</a> by Weinan Zhang, Shuai Yuan, Jun Wang. KDD 2014.非线性出价函数，优化目标：点击数</del></p>
</li>
<li><p><del><a href="http://wnzhang.net/share/rtb-papers/lin-bid.pdf" target="_blank" rel="external">Bid Optimizing and Inventory Scoring in Targeted Online Advertising</a> by Claudia Perlich et al. KDD 2012.M6d线性出价函数</del></p>
</li>
<li><p><a href="http://wnzhang.net/share/rtb-papers/rtb-perf-bid.pdf" target="_blank" rel="external">Real-Time Bidding Algorithms for Performance-Based Display Ad Allocation</a> by Ye Chen et al. KDD 2011</p>
</li>
</ul>
<h3 id="CTR-CVR-Estimation"><a href="#CTR-CVR-Estimation" class="headerlink" title="CTR/CVR Estimation"></a>CTR/CVR Estimation</h3><ul>
<li><a href="https://arxiv.org/pdf/1708.05123.pdf" target="_blank" rel="external">Deep &amp; Cross Network for Ad Click Predictions</a> by Ruoxi Wang et al. AdKDD &amp; TargetAd 2017.</li>
<li><a href="https://arxiv.org/pdf/1706.06978.pdf" target="_blank" rel="external">Deep Interest Network for Click-Through Rate Prediction</a> by Guorui Zhou et al. ArXiv 2017.</li>
<li><a href="https://arxiv.org/pdf/1703.04247.pdf" target="_blank" rel="external">DeepFM: A Factorization-Machine based Neural Network for CTR Prediction</a> by Huifeng Guo et al. IJCAI 2017</li>
<li><a href="https://arxiv.org/pdf/1704.05194.pdf" target="_blank" rel="external">Learning Piece-wise Linear Models from Large Scale Data for Ad Click Prediction</a> by Kun Gai, Xiaoqiang Zhu, Han Li, et al. Arxiv 2017.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/softmax-ensemble.pdf" target="_blank" rel="external">SEM: A Softmax-based Ensemble Model for CTR Estimation in Real-Time Bidding Advertising</a> by Wen-Yuan Zhu et al. BigComp 2017.</li>
<li><a href="https://arxiv.org/pdf/1702.00855v1.pdf" target="_blank" rel="external">Neural Feature Embedding for User Response Prediction in Real-Time Bidding (RTB)</a> by Enno Shioji, Masayuki Arai. ArXiv 2017.</li>
<li><a href="https://arxiv.org/pdf/1701.04099.pdf" target="_blank" rel="external">Field-aware Factorization Machines in a Real-world Online Advertising System</a> by Yuchin Juan, Damien Lefortier, Olivier Chapelle. ArXiv 2017.</li>
<li><a href="https://arxiv.org/pdf/1611.00144.pdf" target="_blank" rel="external">Product-based Neural Networks for User Response Prediction</a> by Yanru Qu et al. ICDM 2016.</li>
<li><a href="http://staff.ustc.edu.cn/~cheneh/paper_pdf/2016/Zhen-Pan-ICDM.pdf" target="_blank" rel="external">Sparse Factorization Machines for Click-through Rate Prediction</a> by Zhen Pan et al. ICDM 2016.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/deep-ctr-display.pdf" target="_blank" rel="external">Deep CTR Prediction in Display Advertising</a> by Junxuan Chen et al. MM 2016.</li>
<li><a href="http://wnzhang.net/papers/unbias-kdd.pdf" target="_blank" rel="external">Bid-aware Gradient Descent for Unbiased Learning with Censored Data in Display Advertising</a> by Weinan Zhang, Tianxiong Zhou, Jun Wang, Jian Xu. KDD 2016.</li>
<li><a href="http://proceedings.mlr.press/v53/yang16.pdf" target="_blank" rel="external">Large Scale CVR Prediction through Dynamic Transfer Learning of Global and Local Features</a> by Hongxia Yang et al. BIGMINE 2016.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/fctf.pdf" target="_blank" rel="external">Predicting ad click-through rates via feature-based fully coupled interaction tensor factorization</a> by Lili Shan, Lei Lin, Chengjie Sun, Xiaolong Wang. Electronic Commerce Research and Applications 2016.<ul>
<li><a href="http://wnzhang.net/share/rtb-papers/ctr-chapelle.pdf" target="_blank" rel="external">Simple and Scalable Response Prediction for Display Advertising</a> by Olivier ChapelleCriteo, Eren Manavoglu, Romer Rosales. ACM TIST 2014.</li>
</ul>
</li>
<li><a href="https://arxiv.org/pdf/1603.03713.pdf" target="_blank" rel="external">Cost-sensitive Learning for Utility Optimization in Online Advertising Auctions</a> by Flavian Vasile, Damien Lefortier, Olivier Chapelle. Extension under-review of the paper presented at the Workshop on E-Commerce, NIPS 2015.</li>
<li><a href="http://apex.sjtu.edu.cn/public/files/members/20161024/opt-ctr-bid.pdf" target="_blank" rel="external">User Response Learning for Directly Optimizing Campaign Performance in Display Advertising</a> by Kan Ren, Weinan Zhang, Yifei Rong, Haifeng Zhang, Yong Yu, Jun Wang. CIKM 2016.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/cnn-ctr.pdf" target="_blank" rel="external">A Convolutional Click Prediction Model</a> by Qiang Liu, Feng Yu, Shu Wu, Liang Wang. CIKM 2015.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/fm-ftrl.pdf" target="_blank" rel="external">Factorization Machines with Follow-The-Regularized-Leader for CTR prediction in Display Advertising</a> by Anh-Phuong Ta. BigData 2015.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/deep-ctr.pdf" target="_blank" rel="external">Deep Learning over Multi-field Categorical Data: A Case Study on User Response Prediction</a> by Weinan Zhang, Tianming Du, Jun Wang. ECIR 2016.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/ctr-bid.pdf" target="_blank" rel="external">Offline Evaluation of Response Prediction in Online Advertising Auctions</a> by Olivier Chapelle. WWW 2015.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/fm-ctr.pdf" target="_blank" rel="external">Predicting Response in Mobile Advertising with Hierarchical Importance-Aware Factorization Machine</a> by Richard J. Oentaryo et al. WSDM 2014.</li>
<li><a href="https://pdfs.semanticscholar.org/fc11/8ce8cf852ccd10cae0fcf031cb5c238f69c0.pdf" target="_blank" rel="external">Scalable Hierarchical Multitask Learning Algorithms for Conversion Optimization in Display Advertising</a> by Amr Ahmed et al. WSDM 2014.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/cvr-est.pdf" target="_blank" rel="external">Estimating Conversion Rate in Display Advertising from Past Performance Data</a> by Kuang-chih Lee et al. KDD 2012.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/transfer-ctr.pdf" target="_blank" rel="external">Scalable Hands-Free Transfer Learning for Online Advertising</a> by Brian Dalessandro et al. KDD 2014.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/forget-click.pdf" target="_blank" rel="external">Evaluating and Optimizing Online Advertising: Forget the click, but there are good proxies</a> by Brian Dalessandro et al. SSRN 2012.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/delayed-feedback.pdf" target="_blank" rel="external">Modeling Delayed Feedback in Display Advertising</a> by Olivier Chapelle. KDD 2014.</li>
<li><a href="https://www.eecs.tufts.edu/~dsculley/papers/ad-click-prediction.pdf" target="_blank" rel="external">Ad Click Prediction: a View from the Trenches</a> by H. Brendan McMahan. KDD 2013.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/fb-ad-ctr.pdf" target="_blank" rel="external">Practical Lessons from Predicting Clicks on Ads at Facebook</a> by Xinran He et al. ADKDD 2014.</li>
</ul>
<h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><h3 id="Attribution-Modeling-Increases-Efficiency-of-Bidding-in-Display-Advertising-by-Eustache-Diemert-et-al-ADKDD-2017"><a href="#Attribution-Modeling-Increases-Efficiency-of-Bidding-in-Display-Advertising-by-Eustache-Diemert-et-al-ADKDD-2017" class="headerlink" title="Attribution Modeling Increases Efficiency of Bidding in Display Advertising by Eustache Diemert et al. ADKDD 2017."></a><a href="https://arxiv.org/pdf/1707.06409.pdf" target="_blank" rel="external">Attribution Modeling Increases Efficiency of Bidding in Display Advertising</a> by Eustache Diemert et al. ADKDD 2017.</h3><p>归属模型提高展示广告竞价效率</p>
<p>数据集：Criteo、Facebook真实场景</p>
<p>offline数据结：<a href="http://research.criteo.com/criteo-attribution-modeling-bidding-dataset/" target="_blank" rel="external">http://research.criteo.com/criteo-attribution-modeling-bidding-dataset/</a></p>
<h4 id="Abstra"><a href="#Abstra" class="headerlink" title="Abstra"></a>Abstra</h4><p>ct以往算法将转化率预估和转化行为归因于哪次广告行为（展示或者点击）分开研究，是两个独立的问题，但是作者发现，归因模型有助于提高竞价的效果，因此将转化行为归因于哪次广告活动加入竞价策略中，提高竞价效率。</p>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>衡量展示广告效果基于广告展示带来的价值，目前主要的两种方式：CPC，CPA（cost per action）,工业界中归因转化的标准是：归因于转化之前30天之内最后一次点击行为。</p>
<p>对于广告引擎和平台来说，目前最先进的出价策略是：Expected Value Bidder (EVB),也就是根据展示机会的预期价值来出价。预期价值是广告主payment*预测的转化率</p>
<p>在博弈论和经济学领域，转化归因已有深入研究，已经有一些机制被提出去较好地衡量广告主的payment，尤其是在多个广告点击或者转化行为同时发生或多个渠道同时存在的情况下。</p>
<p>考虑一个广告行为序列，合理的出价方式是后面的展示行为都应该比第一次展示的价值低，因为第二次点击行为能够导致转化的可能性不高。在之前的EVB策略中，是没有这方面考虑的，因为它既不能跟踪也不能预测归因转化率，所以为了改进实时竞价策略，我们建议利用一个归因模型来修改投标策略。</p>
<h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><p>把转化归因于最后一次点击行为适用于CPM结算方式，但不是很适合CPCorCPA方式。</p>
<p>从数据中学习归因关系，假设广告投放平台可以访问其广告主客户的转化归属标签，（该广告主通过其他广告投放平台的转化归主标签不可访问）</p>
<p>将归属关系表达成间隔时间的负指数函数，竞价策略为CPA*归属概率。</p>
<h4 id="Data-description"><a href="#Data-description" class="headerlink" title="Data description"></a>Data description</h4><p>This dataset represents a sample of 30 days of Criteo live traffic data. Each line corresponds to one impression (a banner) that was displayed to a user. For each banner we have detailed information about the context, if it was clicked, if it led to a conversion and if it led to a conversion that was attributed to Criteo or not. Data has been sub-sampled and anonymized so as not to disclose proprietary elements.</p>
<p>Here is a detailed description of the fields (they are tab-separated in the file):</p>
<ul>
<li><strong>timestamp</strong>: timestamp of the impression (starting from 0 for the first impression). The dataset is sorted according to timestamp.</li>
<li><strong>uid</strong> a unique user identifier</li>
<li><strong>campaign</strong> a unique identifier for the campaign</li>
<li><strong>conversion</strong> 1 if there was a conversion in the 30 days after the impression (independently of whether this impression was last click or not)</li>
<li><strong>conversion_timestamp</strong> the timestamp of the conversion or -1 if no conversion was observed</li>
<li><strong>conversion_id</strong> a unique identifier for each conversion (so that timelines can be reconstructed if needed). -1 if there was no conversion</li>
<li><strong>attribution</strong> 1 if the conversion was attributed to Criteo, 0 otherwise</li>
<li><strong>click</strong> 1 if the impression was clicked, 0 otherwise</li>
<li><strong>click_pos</strong> the position of the click before a conversion (0 for first-click)</li>
<li><strong>click_nb</strong> number of clicks. More than 1 if there was several clicks before a conversion</li>
<li><strong>cost</strong> the price paid by Criteo for this display (<strong>disclaimer:</strong> not the real price, only a transformed version of it)</li>
<li><strong>cpo</strong> the cost-per-order in case of attributed conversion (<strong>disclaimer:</strong> not the real price, only a transformed version of it)</li>
<li><strong>time_since_last_click</strong> the time since the last click (in s) for the given impression</li>
<li><strong>cat[1-9]</strong> contextual features associated to the display. Can be used to learn the click/conversion models. We do not disclose the meaning of these features but it is not relevant for this study. Each column is a categorical variable. In the experiments, they are mapped to a fixed dimensionality space using the Hashing Trick (see paper for reference).</li>
</ul>
<h3 id="Criteo-Data"><a href="#Criteo-Data" class="headerlink" title="Criteo Data"></a>Criteo Data</h3><ul>
<li><strong>timestamp</strong>: 时间戳</li>
<li><strong>uid</strong> 用户id</li>
<li><strong>campaign</strong> 推广计划id</li>
<li><strong>conversion</strong> 转化</li>
<li><strong>conversion_timestamp </strong>转化时间</li>
<li><strong>conversion_id</strong> 转化id</li>
<li><strong>attribution</strong> 转化归属关系</li>
<li><strong>click</strong> 点击</li>
<li><strong>click_pos</strong> 点击次序</li>
<li><strong>click_nb</strong> 点击数量</li>
<li><strong>cost</strong> 成本价格，Criteo赢得展示所支付的费用</li>
<li><strong>cpo</strong> the cost-per-order in case of attributed conversion (<strong>disclaimer:</strong> not the real price, only a transformed version of it)</li>
<li><strong>time_since_last_click</strong> 最后一次点击时间到转化的间隔时间</li>
<li><strong>cat[1-9]</strong>  上下文特征，hash过。</li>
</ul>
<h3 id="Managing-Risk-of-Bidding-in-Display-Advertising-by-Haifeng-Zhang-et-al-WSDM-2017"><a href="#Managing-Risk-of-Bidding-in-Display-Advertising-by-Haifeng-Zhang-et-al-WSDM-2017" class="headerlink" title="Managing Risk of Bidding in Display Advertising by Haifeng Zhang et al. WSDM 2017."></a><a href="http://wnzhang.net/papers/risk-bid.pdf" target="_blank" rel="external">Managing Risk of Bidding in Display Advertising</a> by Haifeng Zhang et al. WSDM 2017.</h3><p>数据集：iPinyou</p>
<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>广告主投放广告就像是金融投资一样，也具有风险，本文中我们明确地给出用户点击率估计的模型和竞价竞争模型来控制风险，我们从金融学引入一个idea，形成两个风险感知的竞价策略，惩罚具有风险的广告展示机会，更多地关注高收益、低风险的广告。</p>
<h4 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h4><p>提到了一些DSP平台：ipinyou,YOYI,Fikisu,广告市场的交易量已经超过了金融市场。</p>
<p>竞价策略依赖于点击率或者转化率的预估，但是点击率预估的不准确可能会导致价值估计的严重不准确，会带来巨大利润估计风险。本文中我们脱离传统的ctr预估，而是对每一个广告展示机会潜在的风险进行建模。</p>
<h3 id="Real-Time-Bidding-rules-of-thumb-analytically-optimizing-the-programmatic-buying-of-ad-inventory-by-Joaquin-Fernandez-Tapia-SSRN-2015"><a href="#Real-Time-Bidding-rules-of-thumb-analytically-optimizing-the-programmatic-buying-of-ad-inventory-by-Joaquin-Fernandez-Tapia-SSRN-2015" class="headerlink" title="Real-Time Bidding rules of thumb: analytically optimizing the programmatic buying of ad-inventory by Joaquin Fernandez-Tapia. SSRN 2015."></a><a href="http://wnzhang.net/share/rtb-papers/opt-prog-buy.pdf" target="_blank" rel="external">Real-Time Bidding rules of thumb: analytically optimizing the programmatic buying of ad-inventory</a> by Joaquin Fernandez-Tapia. SSRN 2015.</h3><p>优化目标：一定预算约束下，实现广告位采买最大化</p>
<p>比较关注的三种技术：</p>
<ol>
<li>静态宏观变量对广告活动的运作十分重要</li>
<li>针对不同广告位的竞价优化</li>
<li>预算步进优化</li>
</ol>
<h4 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h4><ol>
<li><p>工业背景：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-28-17-14-20.png" alt=""> </p>
</li>
<li><p>不同规模的模型：</p>
<p>一次广告竞价是微观的过程，但是衡量其表现却是宏观过程，比如衡量其一个月、一天的收益</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-28-17-15-00.png" alt=""> </p>
</li>
<li><p>假设</p>
<p>​</p>
</li>
<li><p>优化问题</p>
</li>
<li><p>本文提纲和贡献</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 广告 </category>
            
            <category> RTB </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法基础班】动态规划]]></title>
      <url>/2017/11/18/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<h2 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a><a href="https://leetcode.com/problems/triangle" target="_blank" rel="external">Triangle</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;      [<span class="number">2</span>],</div><div class="line">&gt;     [<span class="number">3</span>,<span class="number">4</span>],</div><div class="line">&gt;    [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</div><div class="line">&gt;   [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The minimum path sum from top to bottom is <code>11</code> (i.e., 2 + 3 + 5 + 1 = 11).</p>
</blockquote>
<p>题目是说，从三角形的最上层走到最下层，每次只走到下一层的相邻元素，求从顶点走到最下层的最短路径长度。</p>
<h3 id="方法1：DFS遍历"><a href="#方法1：DFS遍历" class="headerlink" title="方法1：DFS遍历"></a>方法1：DFS遍历</h3><p>从上往下深度优先遍历搜索，记录所有情况之中最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> best = Integer.MAX_VALUE;;</div><div class="line"></div><div class="line"><span class="comment">//sum为走到当前节点但不包含当前节点的路径和</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">  <span class="comment">//搜索结束条件：走过了最下面一层</span></div><div class="line">  <span class="keyword">int</span> height = triangle.size();</div><div class="line">  <span class="keyword">if</span>(i==height)&#123;</div><div class="line">    best = Math.min(best,sum);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  dfs(triangle,i+<span class="number">1</span>,j,sum+triangle.get(i).get(j));</div><div class="line">  dfs(triangle,i+<span class="number">1</span>,j+<span class="number">1</span>,sum+triangle.get(i).get(j));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangles)</span> </span>&#123;</div><div class="line">  dfs(triangles,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> best;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度<script type="math/tex">O(2^n)</script></p>
<a id="more"></a>
<h3 id="方法2：分治法"><a href="#方法2：分治法" class="headerlink" title="方法2：分治法"></a>方法2：分治法</h3><p>从最底层走到某个点[i,j]的最短路径长度可以分解为两个子问题：</p>
<ol>
<li>这个点自身的路径 长度+下一层左边节点路径长度</li>
<li>这个点自身的路径 长度+下一层左右边节点路径长度</li>
</ol>
<p>最终的结果需要取这两种情况的最小值。</p>
<p><strong>边界条件</strong>：最下面一层的最小路径长度是1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangles,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">  <span class="comment">//边界条件：最下面一层的路径长度是0</span></div><div class="line">  <span class="keyword">int</span> height = triangles.size();</div><div class="line">  <span class="keyword">if</span>(x==height)</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  <span class="comment">//其余点的路径长度是下一层左右两个路径长度+自身长度的最小值。</span></div><div class="line">  <span class="keyword">return</span> triangles.get(x).get(y) + Math.min(</div><div class="line">    divide(triangles,x+<span class="number">1</span>,y),</div><div class="line">    divide(triangles,x+<span class="number">1</span>,y+<span class="number">1</span>)</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度<script type="math/tex">O(2^n)</script></p>
<h3 id="方法3：记忆化搜索"><a href="#方法3：记忆化搜索" class="headerlink" title="方法3：记忆化搜索"></a>方法3：记忆化搜索</h3><p>显然上面的方法有很多重复计算的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">  [x,y]</div><div class="line">    ↓    ↘</div><div class="line">[x+1,y] [x+1,y+1]</div><div class="line">   ↓      ↘ ↓       ↘</div><div class="line">[x+2,y] [x+2,y+1] [x+2,y+2]</div><div class="line">**/</div></pre></td></tr></table></figure>
<p>其中[x+2,y+1]就被重复计算了两次。</p>
<p>可以将这些多次重复计算的值存下来，计算过一次之后后面再用到就可以避免重复计算了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> best = Integer.MAX_VALUE;</div><div class="line">List&lt;List&lt;Integer&gt;&gt; tri = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">int</span>[][] hash;<span class="comment">//存储已经计算过的节点值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">memorySearch</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(x == tri.size()-<span class="number">1</span>)&#123;</div><div class="line">    hash[x][y]=tri.get(x).get(y);</div><div class="line">    <span class="keyword">return</span> hash[x][y];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(hash[x][y]!= Integer.MAX_VALUE)&#123;</div><div class="line">    <span class="keyword">return</span> hash[x][y];</div><div class="line">  &#125;</div><div class="line">  hash[x][y] = tri.get(x).get(y)+Math.min(</div><div class="line">    memorySearch(x+<span class="number">1</span>,y),</div><div class="line">    memorySearch(x+<span class="number">1</span>,y+<span class="number">1</span>)</div><div class="line">  );</div><div class="line">  <span class="keyword">return</span> hash[x][y];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangles)</span> </span>&#123;</div><div class="line">  hash = <span class="keyword">new</span> <span class="keyword">int</span>[triangles.size()][triangles.get(triangles.size()-<span class="number">1</span>).size()];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hash.length;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangles.get(i).size();j++)&#123;</div><div class="line">      hash[i][j] = Integer.MAX_VALUE;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> memorySearch(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">  <span class="comment">//return best;</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度<script type="math/tex">O(n^2)</script></p>
<h3 id="方法4：多重循环"><a href="#方法4：多重循环" class="headerlink" title="方法4：多重循环"></a>方法4：多重循环</h3><h4 id="实现方式1：自底向上"><a href="#实现方式1：自底向上" class="headerlink" title="实现方式1：自底向上"></a>实现方式1：自底向上</h4><p>从终点（最下面一层）出发，逐层向上至终点。</p>
<p><strong>状态：</strong>f[i,j]表示从最下面一层到点[i,j]最短路径长度</p>
<p><strong>方程：</strong>f[i,j] = a[i,j]+min(f[i+1,j],f[i+1,j+1])</p>
<p><strong>初始化：</strong>f[i,j] = a[i,j],其中i是最下面一行</p>
<p><strong>答案：</strong>f[0,0]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dpUp</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangles)</span></span>&#123;</div><div class="line">  hash = <span class="keyword">new</span> <span class="keyword">int</span>[triangles.size()][triangles.get(triangles.size()-<span class="number">1</span>).size()];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; triangles.size();i++)&#123;</div><div class="line">    hash[triangles.size()-<span class="number">1</span>][i] = triangles.get(triangles.size()-<span class="number">1</span>).get(i);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =triangles.size()-<span class="number">2</span>; i &gt;= <span class="number">0</span> ;i--)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt;i+<span class="number">1</span>;j++)&#123;</div><div class="line">      hash[i][j] = triangles.get(i).get(j) + Math.min(hash[i+<span class="number">1</span>][j],hash[i+<span class="number">1</span>][j+<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> hash[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="实现方式2：自顶向下"><a href="#实现方式2：自顶向下" class="headerlink" title="实现方式2：自顶向下"></a>实现方式2：自顶向下</h4><p>从起点（顶点）出发，逐层向下至最后一层。</p>
<p><strong>状态：</strong>f[i,j]表示从最顶点到点[i,j]最短路径长度</p>
<p><strong>方程：</strong>f[i,j] = a[i,j]+min(f[i-1,j-1],f[i-1,j])</p>
<p><strong>初始化：</strong>f[0,0] = a[0,0]</p>
<p><strong>答案：</strong>min(f[i,j]),其中i是最下面一层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dpDown</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangles)</span></span>&#123;</div><div class="line">  hash = <span class="keyword">new</span> <span class="keyword">int</span>[triangles.size()][triangles.get(triangles.size()-<span class="number">1</span>).size()];</div><div class="line">  hash[<span class="number">0</span>][<span class="number">0</span>] = triangles.get(<span class="number">0</span>).get(<span class="number">0</span>);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; triangles.size();i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt;i+<span class="number">1</span>;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</div><div class="line">        hash[i][j] = triangles.get(i).get(j) + hash[i-<span class="number">1</span>][j];</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(j == i)&#123;</div><div class="line">        hash[i][j] = triangles.get(i).get(j) + hash[i-<span class="number">1</span>][j-<span class="number">1</span>];</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        hash[i][j] = triangles.get(i).get(j)+Math.min(hash[i-<span class="number">1</span>][j-<span class="number">1</span>],hash[i-<span class="number">1</span>][j]);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; triangles.get(triangles.size()-<span class="number">1</span>).size();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(hash[triangles.size()-<span class="number">1</span>][i] &lt; min)&#123;</div><div class="line">      min = hash[triangles.size()-<span class="number">1</span>][i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><h3 id="什么时候用DP"><a href="#什么时候用DP" class="headerlink" title="什么时候用DP"></a>什么时候用DP</h3><p>三个条件满足其一则极有可能是需要用DP求解：</p>
<ol>
<li>求最大、最小值</li>
<li>判断是否可行</li>
<li>统计方案个数</li>
</ol>
<h3 id="什么时候不用DP"><a href="#什么时候不用DP" class="headerlink" title="什么时候不用DP"></a>什么时候不用DP</h3><p>三个条件满足其一则极不可能用DP：</p>
<ol>
<li>输出所有方案</li>
<li>给得是集合，不是序列（元素顺序不可换）</li>
<li>暴力算法的时间复杂度已经是多项式复杂度了（n^2,n^3）,dp擅长将指数复杂度优化到多相似复杂度</li>
</ol>
<h2 id="动态规划四要素："><a href="#动态规划四要素：" class="headerlink" title="动态规划四要素："></a>动态规划四要素：</h2><p><strong>状态</strong>：<code>f[][]</code>的含义，<strong>最难</strong>！</p>
<p><strong>方程</strong>：状态之间的联系，怎么用小状态算大状态</p>
<p><strong>初始化</strong>：最小状态是什么，起点</p>
<p><strong>答案</strong>：最大状态是什么，终点</p>
<p><strong>两种方法：</strong></p>
<ol>
<li>自顶向下：从起点出发到终点</li>
<li>自底向上：从终点出发，反推至起点</li>
</ol>
<p><strong>VS递归三要素</strong></p>
<ul>
<li>定义（状态）<ul>
<li>接受了什么参数</li>
<li>做了什么事情</li>
<li>返回了什么值</li>
</ul>
</li>
<li>拆解（方程）<ul>
<li>符合将参数变小</li>
</ul>
</li>
<li>出口（初始化）<ul>
<li>什么时候可以直接return</li>
</ul>
</li>
</ul>
<h2 id="坐标型动态规划"><a href="#坐标型动态规划" class="headerlink" title="坐标型动态规划"></a>坐标型动态规划</h2><h2 id="Minimum-Path-Sum"><a href="#Minimum-Path-Sum" class="headerlink" title="Minimum Path Sum"></a><a href="https://leetcode.com/problems/minimum-path-sum" target="_blank" rel="external">Minimum Path Sum</a></h2><blockquote>
<p>Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p>
<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [[1,3,1],</div><div class="line">&gt;  [1,5,1],</div><div class="line">&gt;  [4,2,1]]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Given the above grid map, return </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 7</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>. Because the path 1→3→1→1→1 minimizes the sum.</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>坐标性动态规划</p>
<p><strong>状态：</strong>f[i,j]表示从(0,0)出发走到(i,j)的路径长度</p>
<p><strong>方程：</strong>f[i,j] = a[i,j] + min(f[i-1,j],f[i,j-1]),只能从左边和上边走过来</p>
<p><strong>初始化：</strong>初始化二维数组时，初始化第0行和第0列</p>
<p><strong>答案：</strong>f[end,end]</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</div><div class="line">        path[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid[<span class="number">0</span>].length;i++)&#123;</div><div class="line">            path[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i] + path[<span class="number">0</span>][i-<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid.length;j++)&#123;</div><div class="line">            path[j][<span class="number">0</span>] = grid[j][<span class="number">0</span>] + path[j-<span class="number">1</span>][<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.length;i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</div><div class="line">                path[i][j] = grid[i][j] + Math.min(path[i - <span class="number">1</span>][j], path[i][j - <span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> path[grid.length-<span class="number">1</span>][grid[<span class="number">0</span>].length-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Unique-Paths"><a href="#Unique-Paths" class="headerlink" title="Unique Paths"></a><a href="https://leetcode.com/problems/unique-paths" target="_blank" rel="external">Unique Paths</a></h2><blockquote>
<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img src="https://leetcode.com/static/images/problemset/robot_maze.png" alt="img"></p>
</blockquote>
<p>求从左上角走到右下角的方案个数，到右下角可能从上面或者左边的点过来。</p>
<p><strong>状态</strong>：f[i,j]：从(0,0)到(i,j)的方案个数</p>
<p><strong>方程：</strong>f[i,j] = f[i-1,j]+f[i,j-1]，走到[i,j]有两种方式，从[i-1,j]和从[i,j-1]，两种方式方案数加和为走到[i,j]点的总方案数</p>
<p><strong>初始化：</strong>第0行和第0列的方案数为1，f[i,0]=f[0,j]=1</p>
<p><strong>结果：</strong>f[m,n]，右下角元素的状态值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniquePath</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] nums= <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)&#123;</div><div class="line">            nums[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</div><div class="line">            nums[<span class="number">0</span>][i] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//计算f[i][j]</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n;j++)&#123;</div><div class="line">                nums[i][j] = nums[i-<span class="number">1</span>][j] + nums[i][j-<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums[m-<span class="number">1</span>][n-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        UniquePath test = <span class="keyword">new</span> UniquePath();</div><div class="line">        <span class="keyword">int</span> m = <span class="number">1</span>;<span class="keyword">int</span> n = <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> res = test.uniquePaths(m,n);</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Unique-Paths-II"><a href="#Unique-Paths-II" class="headerlink" title="Unique Paths II"></a><a href="https://leetcode.com/problems/unique-paths-ii" target="_blank" rel="external">Unique Paths II</a></h2><blockquote>
<p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p>
<p>For example,</p>
<p>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [0,0,0],</div><div class="line">&gt;   [0,1,0],</div><div class="line">&gt;   [0,0,0]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The total number of unique paths is <code>2</code>.</p>
</blockquote>
<p>在上一题的基础上设置了一些障碍点，所以只需要对障碍点进行判断即可。遇到障碍点时方案数设置为1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniquePath2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</div><div class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] nums= <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            nums[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;i++)&#123;</div><div class="line">                <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>]!=<span class="number">1</span>)&#123;</div><div class="line">                    nums[i][<span class="number">0</span>] = nums[i-<span class="number">1</span>][<span class="number">0</span>];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    nums[i][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</div><div class="line">                <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][i]!=<span class="number">1</span>)&#123;</div><div class="line">                    nums[<span class="number">0</span>][i] = nums[<span class="number">0</span>][i-<span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    nums[<span class="number">0</span>][i] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//计算f[i][j]</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n;j++)&#123;</div><div class="line">                    <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                        nums[i][j] = <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span>&#123;</div><div class="line">                        nums[i][j] = nums[i-<span class="number">1</span>][j] + nums[i][j-<span class="number">1</span>];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> nums[m-<span class="number">1</span>][n-<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Climbing-Stairs"><a href="#Climbing-Stairs" class="headerlink" title="Climbing Stairs"></a><a href="https://leetcode.com/problems/climbing-stairs" target="_blank" rel="external">Climbing Stairs</a></h2><blockquote>
<p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 2</div><div class="line">&gt; Output:  2</div><div class="line">&gt; Explanation:  There are two ways to climb to the top.</div><div class="line">&gt;</div><div class="line">&gt; 1. 1 step + 1 step</div><div class="line">&gt; 2. 2 steps</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 3</div><div class="line">&gt; Output:  3</div><div class="line">&gt; Explanation:  There are three ways to climb to the top.</div><div class="line">&gt;</div><div class="line">&gt; 1. 1 step + 1 step + 1 step</div><div class="line">&gt; 2. 1 step + 2 steps</div><div class="line">&gt; 3. 2 steps + 1 step</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>看成是一维数组，从起点走到终点，每次只能走1或2步。</p>
<p><strong>状态：</strong>f[i]走到i点的方案数</p>
<p><strong>转移方程：</strong>f[i] = f[i-1]+f[i-1]，因为只能走一步或者两步，所以只能从前一个或者两个格子过来。</p>
<p><strong>初始化：</strong>f[0] = 1;f[1] = 1;f[2] = 2</p>
<p><strong>结果：</strong>f[n]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">if</span>(n==<span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  res[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">  res[<span class="number">1</span>] = <span class="number">2</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</div><div class="line">    res[i] = res[i-<span class="number">1</span>] +  res[i-<span class="number">2</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res[n-<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a><a href="https://leetcode.com/problems/jump-game" target="_blank" rel="external">Jump Game</a></h2><p>动态规划可以做，但是贪心法是最优方法</p>
<blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>For example:<br>A = <code>[2,3,1,1,4]</code>, return <code>true</code>.</p>
<p>A = <code>[3,2,1,0,4]</code>, return <code>false</code>.</p>
</blockquote>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>数组中的数字表示当前点能够跳跃的最大步长，判断是否可以跳到最后一步：是否有可行方案问题</p>
<p>坐标型动态规划，一维坐标</p>
<p><strong>状态：</strong>s[i]，是否能从起点跳到i点</p>
<p>取决于前面是否存在点j：</p>
<ol>
<li>从起点是否能跳到j点：s[j]</li>
<li>从j是否能跳到i：j+s[j]&gt;=i</li>
</ol>
<p><strong>转移方程：</strong>s[i] = s[j] &amp;&amp; j+s[j]&gt;=i（j&lt;i）</p>
<p><strong>初始化：</strong>s[0]=1</p>
<p><strong>答案：</strong>s[m]，最后一个元素的状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">boolean</span>[] canJump = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">  canJump[<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(canJump[j] &amp;&amp; j+nums[j]&gt;=i)&#123;</div><div class="line">        canJump[i] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> canJump[nums.length-<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度：<script type="math/tex">O(n^2)</script>，提交后超时。</p>
<p>贪心法：</p>
<p>两个指针，一个从头向尾移动，另一个计算能够到达的最远距离。</p>
<p>需要注意的是：左侧指针向右移动时不能超过记录最远到达距离的指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> farthest = nums[<span class="number">0</span>];</div><div class="line">  <span class="keyword">while</span>(farthest&lt;nums.length-<span class="number">1</span> &amp;&amp; i &lt; nums.length-<span class="number">1</span> &amp;&amp; i &lt;= farthest)&#123;</div><div class="line">    farthest = Math.max(farthest,i + nums[i]);</div><div class="line">    i++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> farthest &gt;= nums.length-<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Jump-Game-II"><a href="#Jump-Game-II" class="headerlink" title="Jump Game II"></a><a href="https://leetcode.com/problems/jump-game-ii" target="_blank" rel="external">Jump Game II</a></h2><blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>For example:<br>Given array A = <code>[2,3,1,1,4]</code></p>
<p>The minimum number of jumps to reach the last index is <code>2</code>. (Jump <code>1</code> step from index 0 to 1, then <code>3</code> steps to the last index.)</p>
</blockquote>
<p>数组中的数字表示当前点能够跳跃的最大步长，求从起点到终点跳跃最少的方案跳跃次数</p>
<p>求最小，坐标型动态规划</p>
<p><strong>状态：</strong>s[i]从起点出发跳到i点需要步数</p>
<p><strong>转移方程：</strong>s[i] = min(s[j]+1),j满足条件可以一步跳到i，加个判断</p>
<p><strong>初始化：</strong>s[0] = 0</p>
<p><strong>答案：</strong>s[m]，最后一个元素状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span>[] minStep = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">  minStep[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; nums.length;i++)&#123;</div><div class="line">    minStep[i] = Integer.MAX_VALUE;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(j + nums[j] &gt;= i)&#123;</div><div class="line">        minStep[i] = Math.min(minStep[i],minStep[j]+<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> minStep[nums.length-<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度：<script type="math/tex">O(n^2)</script>，提交后超时。</p>
<p>贪心法：</p>
<p>两个指针，一个从头向尾移动，另一个计算能够到达的最远距离。</p>
<p>需要注意的是：左侧指针向右移动时不能超过记录最远到达距离的指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> farthest = nums[<span class="number">0</span>];</div><div class="line">  <span class="keyword">while</span>(farthest&lt;nums.length-<span class="number">1</span> &amp;&amp; i &lt; nums.length-<span class="number">1</span> &amp;&amp; i &lt;= farthest)&#123;</div><div class="line">    farthest = Math.max(farthest,i + nums[i]);</div><div class="line">    i++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> farthest &gt;= nums.length-<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence" target="_blank" rel="external">Longest Increasing Subsequence</a></h2><blockquote>
<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>For example,<br>Given <code>[10, 9, 2, 5, 3, 7, 101, 18]</code>,<br>The longest increasing subsequence is <code>[2, 3, 7, 101]</code>, therefore the length is <code>4</code>. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p>
<p>Your algorithm should run in O(<em>n2</em>) complexity.</p>
</blockquote>
<p>subqequence：子序列，可以跳着取</p>
<p>substring：子串，相连的，不可以跳着取</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>DP和二分法</p>
<p>判断是否使用DP：</p>
<ol>
<li>求最长</li>
<li>一维序列，元素位置不可交换</li>
<li>暴力复杂度是O(2^n)</li>
</ol>
<p>看成是小人跳木桩，数组的值为木桩的高度，小人每次踩一个更高的木桩</p>
<h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><p><strong>状态：</strong>f[i]表示从任意一个木桩出发，从低到高，跳到i点，最多踩过多少个木桩</p>
<p><strong>转移方程：</strong>f[i] = max(f[j]+1) j满足：j&lt;i &amp;&amp; nums[j]&lt;nums[i]</p>
<p><strong>初始化：</strong>f[0] = f[1] = …= f[n-1] = 1 从前面的任何一个点出发跳到此处要经过多少根木桩，初始化时，只经过自己跳到自己踩过的木桩树为1。</p>
<p><strong>结果：</strong>max(f[1],f[2],….,f[n-1]) 因为递增子序列不一定以最后一个元素为结尾，这道题要求的是最长的子序列，所以需要在所有的点里面找到最大的值返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[] length = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">    length[i] = <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</div><div class="line">        length[i] = Math.max(length[j]+<span class="number">1</span>,length[i]);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> max = length[<span class="number">0</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; length.length;i++)&#123;</div><div class="line">    max = Math.max(max,length[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度<script type="math/tex">O(n^2)</script></p>
<h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">tail[i] -&gt; 用于记录长度为i+<span class="number">1</span>个的LIS的子序列中末尾的【最小】值</div><div class="line">size -&gt; 用于记录最大长度。</div><div class="line"></div><div class="line">对于相同长度的LIS子序列，记录末尾值的最小值是因为以该最小值为末尾的子序列更有可能在后续过程中增加长度。</div><div class="line"></div><div class="line">以nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>]为例：</div><div class="line">len = <span class="number">1</span>   :      [<span class="number">4</span>], [<span class="number">5</span>], [<span class="number">6</span>], [<span class="number">3</span>]   =&gt; tails[<span class="number">0</span>] = <span class="number">3</span></div><div class="line">								<span class="comment">//长度为1的子序列中末尾值最小的是3</span></div><div class="line">len = <span class="number">2</span>   :      [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">5</span>, <span class="number">6</span>]       =&gt; tails[<span class="number">1</span>] = <span class="number">5</span></div><div class="line">								<span class="comment">//长度为2的子序列中末尾值最小的是5</span></div><div class="line">len = <span class="number">3</span>   :      [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]            =&gt; tails[<span class="number">2</span>] = <span class="number">6</span></div><div class="line">								<span class="comment">//长度为3的子序列中末尾值最小的是6</span></div><div class="line"></div><div class="line">此时如果后面又来了一个x</div><div class="line">(<span class="number">1</span>) 如果x大于所有tails，那么此时会有长度更长的子序列，以x结尾。那就把这个x放在这个里面，并把长度+<span class="number">1</span></div><div class="line">(<span class="number">2</span>) 如果tails[i-<span class="number">1</span>] &lt; x &lt;= tails[i], 此时不会有长度更长的子序列，但是对于长度为i的子序列，选择x和tails[i]作为结尾相比而言，选择x作为结尾在后续过程中增加长度的可能性更大，所以我们用x更新 tails[i]</div><div class="line">size -&gt; 当前最长序列长度</div><div class="line">序[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</div><div class="line">以[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>]为例：</div><div class="line">i = <span class="number">0</span> --&gt; x = <span class="number">2</span>, tail = [<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">1</span></div><div class="line">[<span class="number">2</span>]   --&gt; 子序列 <span class="number">2</span></div><div class="line">  </div><div class="line">i = <span class="number">1</span> --&gt; x = <span class="number">1</span>, tail = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">1</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>] --&gt; 子序列[<span class="number">1</span>]</div><div class="line">i = <span class="number">2</span>   --&gt; x = <span class="number">5</span>, tail = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">2</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">5</span>]</div><div class="line">i = <span class="number">3</span>    --&gt; x = <span class="number">3</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">2</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>]</div><div class="line">i = <span class="number">4</span>       --&gt; x = <span class="number">6</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">3</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]</div><div class="line">i = <span class="number">5</span>         --&gt; x = <span class="number">4</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">3</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</div><div class="line">i = <span class="number">6</span>           --&gt; x = <span class="number">8</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">4</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>]</div><div class="line">i = <span class="number">7</span>             --&gt; x = <span class="number">9</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">4</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line">i = <span class="number">8</span>               --&gt; x = <span class="number">7</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">4</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span>[] tail = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span> , end = size;</div><div class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span> ;</div><div class="line">            <span class="keyword">if</span>(tail[mid]&lt;nums[i])&#123;</div><div class="line">                start = mid+<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        tail[start] = nums[i];</div><div class="line">        <span class="keyword">if</span> (start == size) &#123;</div><div class="line">            size++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="序列型动态规划"><a href="#序列型动态规划" class="headerlink" title="序列型动态规划"></a>序列型动态规划</h2><p>状态：f[i]表示<strong>前i个</strong>位置/数字/字符，第i个…</p>
<p>方程：f[i] = g(f[j]),j是i前面的位置</p>
<p>初始化：f[0]</p>
<p>结果：f[n]</p>
<h3 id="Word-Break"><a href="#Word-Break" class="headerlink" title="Word Break"></a><a href="https://leetcode.com/problems/word-break" target="_blank" rel="external">Word Break</a></h3><blockquote>
<p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.</p>
<p>For example, given<br><em>s</em> = <code>&quot;leetcode&quot;</code>,<br><em>dict</em> = <code>[&quot;leet&quot;, &quot;code&quot;]</code>.</p>
<p>Return true because <code>&quot;leetcode&quot;</code> can be segmented as <code>&quot;leet code&quot;</code>.</p>
</blockquote>
<p>给一串字母和单词表，判断是否可以被切分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">状态：f[i]表示前i个字母是否可以被切分。</div><div class="line"></div><div class="line">转移方程：</div><div class="line"></div><div class="line">初始化：</div><div class="line"></div><div class="line">在单词的开始加“^”标记</div><div class="line"></div><div class="line">idx: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></div><div class="line">ch:  ^ l i n t c o d e</div><div class="line">f:   T f f f T f f f T</div><div class="line"></div><div class="line">初始化：</div><div class="line">idx: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></div><div class="line">ch:  ^ l i n t c o d e</div><div class="line">f:   T f f f </div><div class="line"></div><div class="line">计算f[<span class="number">4</span>]时将f[<span class="number">0</span>~<span class="number">4</span>]的字符串^ l i n t切割成如下几种方案：</div><div class="line">^ l i n|t  -&gt;  lin和t不在单词表</div><div class="line">^ l i|n t  -&gt;  li和nt不在单词表</div><div class="line">^ l|i n t  -&gt;  l和<span class="keyword">int</span>不在单词表</div><div class="line">^|l i nt   -&gt;  ^和lint不在单词表-&gt;f[<span class="number">4</span>] = T</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span>[] f;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; n;i++)&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</div><div class="line">      <span class="keyword">if</span>(f[j] &amp;&amp; substring[j,i] in dict)&#123;</div><div class="line">          f[i] = <span class="keyword">true</span>;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">时间复杂度：O(n^<span class="number">2</span>^L),n为字符串长度，L为词典里的单词个数。</div><div class="line"></div><div class="line">优化：</div><div class="line">单词的长度一般不会特别长，设单词表里单词的最大长度为MAXL所以从后往前切割，切割MAXL次即可，如果此时没有答案的话，再继续往前切割也没有必要了。</div><div class="line">优化后的时间复杂度为： O(n^L^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<h3 id="Palindrome-Partitioning-II"><a href="#Palindrome-Partitioning-II" class="headerlink" title="Palindrome Partitioning II"></a><a href="https://leetcode.com/problems/palindrome-partitioning-ii" target="_blank" rel="external">Palindrome Partitioning II</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Given a string s, partition s such that every substring of the partition is a palindrome.</div><div class="line"></div><div class="line">Return the minimum cuts needed <span class="keyword">for</span> a palindrome partitioning of s.</div><div class="line"></div><div class="line">For example, given s = <span class="string">"aab"</span>,</div><div class="line">Return <span class="number">1</span> since the palindrome partitioning [<span class="string">"aa"</span>,<span class="string">"b"</span>] could be produced using <span class="number">1</span> cut.</div></pre></td></tr></table></figure>
<p>将字符串切分使得每一段都是回文串，求最少要切几刀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">状态：f[i]，从<span class="number">0</span>到</div><div class="line">方程：</div><div class="line">初始化：</div><div class="line">结果</div><div class="line"></div><div class="line">例子：<span class="string">"aabaa"</span></div><div class="line"></div><div class="line">关于初始化：</div><div class="line">在极端情况下，长度为n的字符串切n-<span class="number">1</span>刀，每一段都可以是回文串，长度为<span class="number">1</span>的字符串切<span class="number">0</span>刀，长度为<span class="number">0</span>的字符串切-<span class="number">1</span>刀</div><div class="line">所以f[<span class="number">0</span>] = -<span class="number">1</span></div><div class="line"></div><div class="line">关于f[i]的计算：</div><div class="line">对于从<span class="number">0</span>到i的子串的划分，可以划分成如下形式：</div><div class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,...,i-<span class="number">1</span>|i</div><div class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,...j,j+<span class="number">1</span>,...,i</div><div class="line"></div><div class="line"></div><div class="line">用一个二维数组f[i][j]存储字符串中从i到j是否是一个回文串</div></pre></td></tr></table></figure>
<h3 id="双序列型动态规划"><a href="#双序列型动态规划" class="headerlink" title="双序列型动态规划"></a>双序列型动态规划</h3><p>给两个序列</p>
<p>状态：f[i,j]表示第一个字符串的前i个，第二个字符串的前j个</p>
<p>转移方程：</p>
<p>初始化：f[i,0],f[0,j]</p>
<p>结果：f[n,m]</p>
<h3 id="例题1：最长公共子串"><a href="#例题1：最长公共子串" class="headerlink" title="例题1：最长公共子串"></a>例题1：最长公共子串</h3><blockquote>
<p>给出两个字符串，找到最长公共子串，并返回其长度。</p>
<p>样例</p>
<p>给出A=<strong>“ABCD”</strong>，B=<strong>“CBCE”</strong>，返回 2</p>
</blockquote>
<p>分析：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();</div><div class="line">        <span class="keyword">if</span>(A.length() == <span class="number">0</span> || B.length() == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[lenA][lenB];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lenA;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(A.charAt(i) == B.charAt(<span class="number">0</span>))&#123;</div><div class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">                max = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lenB;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(A.charAt(<span class="number">0</span>) == B.charAt(i))&#123;</div><div class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span>;</div><div class="line">                max = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; lenA;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; lenB;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(A.charAt(i) == B.charAt(j))&#123;</div><div class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</div><div class="line">                    max = Math.max(max,dp[i][j]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="例题2：最长公共子序列"><a href="#例题2：最长公共子序列" class="headerlink" title="例题2：最长公共子序列"></a>例题2：最长公共子序列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a b c d </div><div class="line">a c d e</div><div class="line"></div><div class="line">f[abcd][acde] = max(f[abc][acde],f[abcd][acd])</div><div class="line"></div><div class="line">如果最后一个字母不相等，</div><div class="line">a[i-1]!=b[i-1]:</div><div class="line">f[i][j] = max(f[i-1][j],f[i][j-1])</div><div class="line"></div><div class="line">如果最后一个字母相等，则这个字母已经是公共子序列了，只需在前面的子序列基础之上+1即可</div><div class="line">a[i-1] == b[i-1]:</div><div class="line">f[i][j] = f[i-1][j-1]+1</div></pre></td></tr></table></figure>
<h3 id="Edit-Distance"><a href="#Edit-Distance" class="headerlink" title="Edit Distance"></a><a href="https://leetcode.com/problems/edit-distance" target="_blank" rel="external">Edit Distance</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of steps required to convert <em>word1</em> to <em>word2</em>. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
</blockquote>
<p>给定两个字符串，最少经过多少次修改可以使第一个字符串和诶二哥字符串一样。</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">s1 = mart</div><div class="line">s2 = karma</div><div class="line"></div><div class="line">f[i][j]表示使得s1的前i个字符与s2的前j个字符相等的最少改动次数 </div><div class="line">共有三种操作方式</div><div class="line"></div><div class="line">用上面的例子说明：</div><div class="line"></div><div class="line">f[<span class="number">4</span>][<span class="number">5</span>]，为了使得s1的前<span class="number">4</span>个字符与s2的前<span class="number">5</span>个字符相等有三种操作方式：</div><div class="line"><span class="number">1</span>. f[<span class="number">3</span>][<span class="number">4</span>] + <span class="number">1</span> replace，替换s1的最后一个字符串，需要s1的前<span class="number">3</span>个字符串和s2的前<span class="number">4</span>个字符串相等的修改次数，加上replace的一次操作。</div><div class="line"><span class="number">2</span>. f[<span class="number">4</span>][<span class="number">4</span>] + <span class="number">1</span> insert，在s1后面插入一个字符<span class="string">'a'</span>，此时s1和s2的最后一个字符相等乐，需要将使得s1的前四个字符和s2的前<span class="number">4</span>个字符相等的操作数，加上insert的一次操作</div><div class="line"><span class="number">3</span>. f[<span class="number">3</span>][<span class="number">5</span>]+<span class="number">1</span> delete，将s1的最后一个字符串删除，需要s1的前三个字符串和s2的前<span class="number">5</span>个字符串相等的操作数加上删除的一次操作</div><div class="line"></div><div class="line">然后需要对上面三种情况取最小值。</div><div class="line"></div><div class="line"></div><div class="line">综上，</div><div class="line">状态：f[i][j]表示使得s1的前i个字符与s2的前j个字符相等的最少改动次数 </div><div class="line">转移方程为：</div><div class="line">f[i][j] = max(f[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>,f[i][j-<span class="number">1</span>]+<span class="number">1</span>,f[-<span class="number">1</span>][j]+<span class="number">1</span>)</div><div class="line">初始化：f[i][<span class="number">0</span>] = i,f[<span class="number">0</span>][j] = j</div><div class="line">答案：f[n][m]</div></pre></td></tr></table></figure>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span>[][] dis = <span class="keyword">new</span> <span class="keyword">int</span>[word1.length()+<span class="number">1</span>][word2.length()+<span class="number">1</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word1.length();i++)&#123;</div><div class="line">    dis[i][<span class="number">0</span>] = i;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word2.length();i++)&#123;</div><div class="line">    dis[<span class="number">0</span>][i] = i;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i &lt;= word1.length();i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.length();j++)&#123;</div><div class="line">      <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))&#123;</div><div class="line">        dis[i][j] = dis[i-<span class="number">1</span>][j-<span class="number">1</span>];</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        dis[i][j] = Math.min(</div><div class="line">          dis[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>,<span class="comment">//替换</span></div><div class="line">          Math.min(dis[i][j-<span class="number">1</span>]+<span class="number">1</span>,<span class="comment">//插入,</span></div><div class="line">                   dis[i-<span class="number">1</span>][j]+<span class="number">1</span>)<span class="comment">//删除</span></div><div class="line">        );</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dis[word1.length()][word2.length()];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Distinct-Subsequences"><a href="#Distinct-Subsequences" class="headerlink" title="Distinct Subsequences"></a><a href="https://leetcode.com/problems/distinct-subsequences" target="_blank" rel="external">Distinct Subsequences</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>S</strong> which equals <strong>T</strong>.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p>
<p>Here is an example:<br><strong>S</strong> = <code>&quot;rabbbit&quot;</code>, <strong>T</strong> = <code>&quot;rabbit&quot;</code></p>
<p>Return <code>3</code>.</p>
</blockquote>
<p>从S中挑出T有多少种方法</p>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">状态：f[i][j] -&gt; 从S的前i个字母中挑出T的前j个字母的方案数</div><div class="line"></div><div class="line">比如F[<span class="number">4</span>][<span class="number">3</span>]:</div><div class="line">从S的前<span class="number">4</span>个子母中选出T的前<span class="number">3</span>个字母有多少种方案：</div><div class="line">rabb</div><div class="line">rab</div><div class="line">此时最后一个字母相等，有两种选择方案：</div><div class="line"><span class="number">1</span>. 选择最后一个字母，则还需在S的前<span class="number">3</span>个中选择T的前<span class="number">2</span>个，此时方案数=F[<span class="number">3</span>][<span class="number">2</span>]</div><div class="line"><span class="number">2</span>. 不选择最后一个字母，则需要在S的前<span class="number">3</span>个中选择<span class="number">3</span>个，此时方案数=F[<span class="number">3</span>][<span class="number">3</span>]</div><div class="line">所以这种情况最终的方案数F[<span class="number">4</span>][<span class="number">3</span>] = F[<span class="number">3</span>][<span class="number">2</span>]+F[<span class="number">3</span>][<span class="number">3</span>]</div><div class="line"></div><div class="line">比如F[<span class="number">5</span>][<span class="number">5</span>]:</div><div class="line">rabbb</div><div class="line">rabbi</div><div class="line">此时最后一个字母不相等，那么此时无法选择最后一个字母，则方案数就等于从S的前<span class="number">4</span>个子母中挑出T的前<span class="number">5</span>个，即方案数F[<span class="number">5</span>][<span class="number">5</span>]=F[<span class="number">4</span>][<span class="number">5</span>]</div><div class="line"></div><div class="line">由此转移方程为：</div><div class="line">如果最后一个不相等，那就在S的前i-<span class="number">1</span>个字母中挑出T的前j个</div><div class="line">f[i][j] = f[i-<span class="number">1</span>][j]</div><div class="line">如果最后一个相等，可以在</div><div class="line">f[i][j] = f[i-<span class="number">1</span>][j-<span class="number">1</span>]+f[i-<span class="number">1</span>][j]</div><div class="line"></div><div class="line">初始化：f[<span class="number">0</span>][i] = <span class="number">0</span>,f[i][<span class="number">0</span>] = <span class="number">0</span></div><div class="line">结果：f[m][n]</div></pre></td></tr></table></figure>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>][t.length()+<span class="number">1</span>];</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  nums[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length();i++)&#123;</div><div class="line">    nums[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length();i++)&#123;</div><div class="line">    nums[<span class="number">0</span>][i] = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s.length();i++)&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= t.length();j++)&#123;</div><div class="line">      <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==t.charAt(j-<span class="number">1</span>))&#123;</div><div class="line">        nums[i][j] = nums[i-<span class="number">1</span>][j-<span class="number">1</span>]+nums[i-<span class="number">1</span>][j];</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        nums[i][j] = nums[i-<span class="number">1</span>][j];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> nums[s.length()][t.length()];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Interleaving-String"><a href="#Interleaving-String" class="headerlink" title="Interleaving String"></a><a href="https://leetcode.com/problems/interleaving-string" target="_blank" rel="external">Interleaving String</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given <em>s1</em>, <em>s2</em>, <em>s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.</p>
<p>For example,<br>Given:<br><em>s1</em> = <code>&quot;aabcc&quot;</code>,<br><em>s2</em> = <code>&quot;dbbca&quot;</code>,</p>
<p>When <em>s3</em> = <code>&quot;aadbbcbcac&quot;</code>, return true.<br>When <em>s3</em> = <code>&quot;aadbbbaccc&quot;</code>, return false.</p>
</blockquote>
<p>三个字符串s1,s2,s3，判断s3是否可以由s1,s2交替组成（顺序不变，交替着选）</p>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">状态：</div><div class="line">f[i][j][k]:s1的前i个和s2的前j个是否能够交替组成s3的前k个</div><div class="line">k = i + j</div><div class="line">状态可以简化为：</div><div class="line">f[i][j]:s1的前i个和s2的前j个是否能够交替组成s3的前i+j个</div><div class="line"></div><div class="line">转移方程推导：</div><div class="line">f[i][j]=<span class="keyword">true</span>有如下两种情况：</div><div class="line"><span class="number">1</span>. 最后一个字母来自s1,s1的前i-<span class="number">1</span>个字母和s2的前j个字母能够交替组成s3的前i+j-<span class="number">1</span>个，即:s1[i]==s3[i+j] &amp;&amp; f[i-<span class="number">1</span>][j]==<span class="keyword">true</span></div><div class="line"><span class="number">2</span>. 最后一个字母来自s2,s2的前j-<span class="number">1</span>个字母和s1的前i个字母能够交替组成s3的前i+j-<span class="number">1</span>个，即:s2[i]==s3[i+j] &amp;&amp; f[i][j-<span class="number">1</span>]==<span class="keyword">true</span></div><div class="line"></div><div class="line">综上，转移方程为：</div><div class="line">f[i][j] = (f[i-<span class="number">1</span>][j] &amp;&amp; s1[i-<span class="number">1</span>] == s3[i+j-<span class="number">1</span>])||</div><div class="line">			(f[i][j-<span class="number">1</span>] &amp;&amp; s2[j-<span class="number">1</span>]==s3[i+j-<span class="number">1</span>])</div><div class="line"></div><div class="line">初始化：f[i][<span class="number">0</span>] = (s1[<span class="number">0</span>...i-<span class="number">1</span>] == s3[<span class="number">0</span>...i-<span class="number">1</span>])前半段都用s1</div><div class="line">		f[<span class="number">0</span>][j] = (s2[<span class="number">0</span>...j-<span class="number">1</span>] == s3[<span class="number">0</span>...j-<span class="number">1</span>])前半段都用s2</div><div class="line"></div><div class="line">结果：f[n][m]</div></pre></td></tr></table></figure>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s1.length()+s2.length() != s3.length())</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s1.length()+<span class="number">1</span>][s2.length()+<span class="number">1</span>];</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ; i &lt;= s1.length();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(flag)&#123;</div><div class="line">      <span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s3.charAt(i-<span class="number">1</span>))&#123;</div><div class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">false</span>;</div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      dp[i][<span class="number">0</span>] = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">boolean</span> flag2 = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ; i &lt;= s2.length();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(flag2)&#123;</div><div class="line">      <span class="keyword">if</span>(s2.charAt(i-<span class="number">1</span>)==s3.charAt(i-<span class="number">1</span>))&#123;</div><div class="line">        dp[<span class="number">0</span>][i] = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        dp[<span class="number">0</span>][i] = <span class="keyword">false</span>;</div><div class="line">        flag2 = <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      dp[<span class="number">0</span>][i] = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s1.length();i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s2.length();j++)&#123;</div><div class="line">      dp[i][j] = (dp[i-<span class="number">1</span>][j] &amp;&amp; s1.charAt(i-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>) ||</div><div class="line">                  (dp[i][j-<span class="number">1</span>] &amp;&amp; s2.charAt(j-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>)));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dp[s1.length()][s2.length()];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班】堆Heap&双端队列Dequeue]]></title>
      <url>/2017/11/18/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E5%A0%86Heap/</url>
      <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><ul>
<li><p>支持操作：Add <script type="math/tex">O(logN)</script>/Remove<script type="math/tex">O(logN)</script>/Min or Max<script type="math/tex">O(1)</script></p>
</li>
<li><p>heap可以用来求最大值或者最小值，不能同时求最大和最小值。</p>
</li>
<li><p>Heap结构：</p>
<p>一颗尽量填满的二叉树，每次插入节点时，插到最后一行的最左端的空余位置，如果本层没有空余位置了，另起一行。因此节点数目为N的堆对应的二叉树高度为<script type="math/tex">O(logN)</script></p>
</li>
</ul>
<ul>
<li><p>MaxHeap vs MinHeap</p>
<ul>
<li>MaxHeap：父亲节点比左右孩子都大</li>
<li>MinHeap：父亲节点比左右孩子都小</li>
</ul>
<p>因此当取最大或最小时，将root值取出即可，因此getMin/Max的时间复杂度为<script type="math/tex">O(1)</script></p>
</li>
<li><p>堆的存储</p>
<p>由于我们需要频繁的对堆进行增加删除，所以一般堆的底层都是通过数组来实现（而不能用链表，因为链表需要频繁new 或 delete对象，非常慢）</p>
<p>对于元素A[i]：</p>
<ul>
<li>父节点：A[i-2/2] (右移1)</li>
<li>左孩子：A[2i+1] (左移1，可得到2i)</li>
<li>右孩子：A[2i+2] (左移1，低位+1，可得到2i+1)</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>插入操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例子：在最小堆中插入元素：</div><div class="line">	<span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">2</span>		<span class="number">3</span></div><div class="line">插入<span class="number">0</span>，因为第二行已经满了，加入到第三行最左边：</div><div class="line">	<span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">2</span>		<span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">0</span></div><div class="line">此时这个堆已经不满足最小堆的条件（父亲节点都比孩子小）了，因此，先交换<span class="number">0</span>和<span class="number">2</span>：</div><div class="line">	<span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">0</span>		<span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">2</span></div><div class="line">此时仍然不满足最小堆条件，继续交换：</div><div class="line">	<span class="number">0</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">1</span>		<span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">2</span></div><div class="line">此时满足最小堆条件了，因此，需要交换最多 O(logN)次，插入的时间复杂度为O(logN)</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>删除操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例子：在最小堆中删除元素：</div><div class="line">     	 <span class="number">1</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>			<span class="number">2</span></div><div class="line"> ↙  ↘       ↙  	↘</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">10</span>		<span class="number">100</span></div><div class="line">删除堆顶元素<span class="number">1</span>，用堆中最后一个节点替换堆顶元素：</div><div class="line">     	<span class="number">100</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>			<span class="number">2</span></div><div class="line"> ↙  ↘       ↙  	</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">10</span>		</div><div class="line">此时这个堆已经不满足最小堆的条件（父亲节点都比孩子小）了，因此将堆顶元素下沉，选择左右孩子中较小的交换：</div><div class="line">     	 <span class="number">2</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>		  <span class="number">100</span></div><div class="line"> ↙  ↘       ↙  	</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">10</span>	</div><div class="line">此时仍然不满足最小堆条件，继续交换：</div><div class="line">     	 <span class="number">2</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>		  <span class="number">10</span></div><div class="line"> ↙  ↘       ↙  	</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">100</span>	</div><div class="line"></div><div class="line">好了，删好了</div></pre></td></tr></table></figure>
<p>PriorityQueue支持<script type="math/tex">O(logN)</script> 删除堆顶元素，但对于删除除root外的任意一点的操作，PriorityQueue的时间复杂度会降到<script type="math/tex">O(N)</script></p>
<p>Java中还有另外一种数据结构TreeMap，支持<script type="math/tex">O(logN)</script> 删除任意元素，而且支持同时获取最大和最小。</p>
<p>TreeMap是一平衡二叉搜索树，因此插入和删除任意元素的时间复杂度都是<script type="math/tex">O(logN)</script></p>
<p>|               | 用    | 原理          | 实现   |<br>| ——————- | —— | —————- | —— |<br>| TreeMap       | 必会   | 平衡二叉搜索树，红黑树 | 不需要  |<br>| PriorityQueue | 必会   | heap，二叉树    | 选做   |</p>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="构建堆，堆维护"><a href="#构建堆，堆维护" class="headerlink" title="构建堆，堆维护"></a>构建堆，堆维护</h4><p>上面提到了增加和删除节点的操作，下面通过实例说明如何从一个数组开始<strong>构建一个堆</strong>：</p>
<p>假设我们有数组<code>4,1,3,2,16,9,10,14,8,7</code></p>
<p>它的形状为：</p>
<p><a href="https://ooo.0o0.ooo/2017/11/03/59fc1f33088db.png" target="_blank" rel="external"><img src="https://ooo.0o0.ooo/2017/11/03/59fc1f33088db.png" alt="img"></a></p>
<p>当然最暴力的方式就是从最后一个元素【7】开始，向上以此对树进行维护。但事实上由于后[n/2]个元素都是根节点，不需要进行维护。因此我们只需要维护前[n/2]个节点。</p>
<p>具体步骤如下图所示：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2017-11-13-22-13-17.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-13-22-13-17.png" alt="img"></a></p>
<p>伪代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">BUILD-MAX-HEAP(A)</div><div class="line">	A.heap.size = A.length</div><div class="line">	for i = [A.length/2] downto 1</div><div class="line">      MAX-HEAPIFTY(A,i)</div></pre></td></tr></table></figure>
<p>根据上面的方法，我们可以将一个数组构建成一个堆，堆顶的元素是最大的。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHeap</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] A;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heapSize;</div><div class="line"></div><div class="line">    <span class="comment">//构造函数</span></div><div class="line">    MyHeap(<span class="keyword">int</span>[] a)&#123;</div><div class="line">        <span class="keyword">this</span>.A = a;</div><div class="line">        heapSize = a.length;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//交换堆中元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = A[i];</div><div class="line">        A[i] = A[j];</div><div class="line">        A[j] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//堆维护（最大堆）</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">        <span class="comment">//计算左孩子和右孩子在数组中的坐标。</span></div><div class="line">        <span class="keyword">int</span> leftChild = <span class="number">2</span>*i+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> rightChild = <span class="number">2</span>*i+<span class="number">2</span>;</div><div class="line"></div><div class="line">        <span class="comment">//找到左右孩子和该节点本身中最大的</span></div><div class="line">        <span class="keyword">int</span> largest = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(leftChild &lt; heapSize &amp;&amp; A[i] &lt; A[leftChild])&#123;<span class="comment">//如果有左孩子而且左孩子比父亲大</span></div><div class="line">            largest = leftChild;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            largest = i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(rightChild &lt; heapSize &amp;&amp; A[largest] &lt; A[rightChild])&#123;<span class="comment">//如果有右孩子而且左孩子比当前最大的大</span></div><div class="line">            largest = rightChild;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(largest!= i)&#123;<span class="comment">//如果最大的不是该节点，是其孩子，则需要交换，维护</span></div><div class="line">            swap(i,largest);</div><div class="line">            heapify(largest);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//构建最大堆</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (heapSize-<span class="number">2</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">            heapify(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</div><div class="line">        MyHeap test = <span class="keyword">new</span> MyHeap(nums);</div><div class="line">        test.build();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</div><div class="line">            System.out.print(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>时间复杂度分析:</strong></p>
<p>在高度为h的结点上运行MAX-HEAPIFY的代价是O(h)O(h)，因此建树的总代价为：</p>
<script type="math/tex; mode=display">\sum_{h=0}^{lgn}O(h)=O(n\sum_{h=0}^{lgn}\frac{h}{2^h})=O(n)</script><p>因此堆排序的时间复杂度为<script type="math/tex">O(n)</script></p>
<h4 id="删除节点POP"><a href="#删除节点POP" class="headerlink" title="删除节点POP"></a>删除节点POP</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//删除节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Poll</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> top = A[<span class="number">0</span>];</div><div class="line">    swap(<span class="number">0</span>, heapSize-<span class="number">1</span>);<span class="comment">//交换第一个和最后一个节点</span></div><div class="line">    heapSize--;</div><div class="line">    heapify(<span class="number">0</span>);<span class="comment">//shiftdown 维护</span></div><div class="line">    <span class="keyword">return</span> top;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//插入之后向上shift</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> parentID = (i-<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(parentID &gt; -<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(A[i] &gt; A[parentID])&#123;</div><div class="line">            swap(i,parentID);</div><div class="line">            shiftUp(parentID);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//插入节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    A[heapSize] = i;</div><div class="line">    heapSize++;</div><div class="line">    shiftUp(heapSize);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序就是利用堆的性质，依次将堆顶元素出堆，每次堆顶元素出堆之后堆会自动维护，所以可以保证弹出的节点是有序的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//堆排序</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] HeapSort()&#123;</div><div class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heapSize];</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> size = heapSize;</div><div class="line">    <span class="keyword">while</span>(i &lt; size)&#123;</div><div class="line">        res[i] = Poll();<span class="comment">//堆顶元素出堆</span></div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度：<script type="math/tex">O(nlogn)</script></p>
<p>n次出堆，每次出堆维护时间logn</p>
<h2 id="HashHeap"><a href="#HashHeap" class="headerlink" title="HashHeap"></a>HashHeap</h2><p>哈希堆，Hashheap是用一个hashMap优化了的heap，方便快速定位某个值在heap中的位置。与heap相比，HashHeap多了一个用来指示元素位置的索引。</p>
<p>HashHeap的结构有点特殊，很神奇，需要多看几遍，其中包括两个结构heap和hashmap:</p>
<ol>
<li>heap存储元素的值</li>
<li>HashMap存储元素在heap中<strong>对应的位置和出现的次数</strong></li>
</ol>
<p>这里存储出现次数是因为，有些时候，堆中可能会有重复的元素，如果只存储其位置的话，某个值就会在多个位置上，需要用一个链表来存储所有的位置，这样不仅存储起来不方便，计算也很不方便，所以很巧妙地，我们将同一个值的元素都放到heap中的同一个位置，在hashmap中存储该位置有多少个该元素，这样堆中的每个节点元素的值也不相同了，各种计算操作起来也方便了，完美~</p>
<p>java实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.function.BinaryOperator;</div><div class="line"></div><div class="line"><span class="comment">//hashheap实现，以最大堆为例</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashHeap</span> </span>&#123;</div><div class="line">    HashMap&lt;Integer,Node&gt; map;<span class="comment">//存储元素值和在堆中的索引</span></div><div class="line">    ArrayList&lt;Integer&gt; heap;</div><div class="line">    <span class="keyword">int</span> heapSize;</div><div class="line">    <span class="keyword">boolean</span> isMaxHeap;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> idx;<span class="comment">//节点在堆中的位置</span></div><div class="line">        <span class="keyword">int</span> count;<span class="comment">//该数值出现次数</span></div><div class="line">        Node(<span class="keyword">int</span> idx,<span class="keyword">int</span> count)&#123;</div><div class="line">            <span class="keyword">this</span>.idx = idx;</div><div class="line">            <span class="keyword">this</span>.count = count;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(heapSize == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    HashHeap(<span class="keyword">boolean</span> isMaxHeap)&#123;</div><div class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">this</span>.heap = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">this</span>.isMaxHeap = isMaxHeap;</div><div class="line">        <span class="keyword">this</span>.heapSize = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//由数组构建最大堆</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</div><div class="line">            System.out.println(counter);</div><div class="line">            add(i);</div><div class="line">            counter ++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//交换堆中节点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="comment">//获取ij在堆中指向的元素值</span></div><div class="line">        <span class="keyword">int</span> vali = heap.get(i);</div><div class="line">        <span class="keyword">int</span> valj = heap.get(j);</div><div class="line"></div><div class="line">        <span class="comment">//获取两个值在map中的个数</span></div><div class="line">        <span class="keyword">int</span> counti = map.get(vali).count;</div><div class="line">        <span class="keyword">int</span> countj = map.get(valj).count;</div><div class="line"></div><div class="line">        <span class="comment">//修改hashmap，把两个值对应的位置互换，count不变</span></div><div class="line">        map.put(vali,<span class="keyword">new</span> Node(j,counti));</div><div class="line">        map.put(valj,<span class="keyword">new</span> Node(i,countj));</div><div class="line"></div><div class="line">        <span class="comment">//交换堆中的节点值</span></div><div class="line">        heap.set(i,valj);</div><div class="line">        heap.set(j,vali);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//向上交换</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShiftUp</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> parentIdx = (idx-<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(parentIdx &gt; -<span class="number">1</span> &amp;&amp; idx &lt; heapSize)&#123;</div><div class="line">            <span class="comment">//如果是最大堆而且孩子&gt;父亲 || 是最小堆而且孩子&lt;父亲,需要向上shift</span></div><div class="line">            <span class="keyword">if</span>((isMaxHeap &amp;&amp; heap.get(parentIdx) &lt; heap.get(idx)) ||</div><div class="line">                   !isMaxHeap &amp;&amp; heap.get(parentIdx) &gt; heap.get(idx) )&#123;</div><div class="line">                swap(idx,parentIdx);</div><div class="line">                ShiftUp(parentIdx);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//向下交换</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShiftDown</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> leftChildIdx = <span class="number">2</span> * idx+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> rightChildIdx = <span class="number">2</span> * idx+<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> largestIdx = idx;</div><div class="line">        <span class="keyword">if</span>(leftChildIdx &lt; heapSize)&#123;</div><div class="line">            <span class="comment">//如果是最大堆而且父亲节点小于孩子</span></div><div class="line">            <span class="keyword">if</span>((isMaxHeap &amp;&amp; heap.get(idx) &lt; heap.get(leftChildIdx)) ||</div><div class="line">                    (!isMaxHeap &amp;&amp; heap.get(idx) &gt; heap.get(leftChildIdx)))&#123;</div><div class="line">                largestIdx = leftChildIdx;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(rightChildIdx &lt; heapSize)&#123;</div><div class="line">            <span class="keyword">if</span>((isMaxHeap &amp;&amp; heap.get(largestIdx) &lt; heap.get(rightChildIdx)) ||</div><div class="line">                    (!isMaxHeap &amp;&amp; heap.get(largestIdx) &gt; heap.get(rightChildIdx)))&#123;</div><div class="line">                largestIdx = rightChildIdx;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(largestIdx != idx)&#123;</div><div class="line">            swap(idx,largestIdx);</div><div class="line">            ShiftDown(largestIdx);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//插入元素，值为n</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="comment">//如果堆中已经有该元素了,放在原来的位置，heap不用动，map计数+1</span></div><div class="line">        <span class="keyword">if</span>(map.containsKey(n))&#123;</div><div class="line">            map.put(n,<span class="keyword">new</span> Node(map.get(n).idx,map.get(n).count+<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果堆中没有该元素</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            map.put(n,<span class="keyword">new</span> Node(heapSize,<span class="number">1</span>));</div><div class="line">            heap.add(n);</div><div class="line">            heapSize++;</div><div class="line">            ShiftUp(heapSize-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//删除节点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> idx = map.get(n).idx;</div><div class="line">        <span class="keyword">int</span> count = map.get(n).count;</div><div class="line">        <span class="comment">//如果该值的节点只有一个</span></div><div class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</div><div class="line">            swap(idx,heapSize-<span class="number">1</span>);</div><div class="line">            map.remove(n);<span class="comment">///在map中删除</span></div><div class="line">            heap.remove(heap.size()-<span class="number">1</span>);</div><div class="line">            heapSize--;</div><div class="line">            ShiftUp(idx);</div><div class="line">            ShiftDown(idx);<span class="comment">//交换之后需要向下维护</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果该值的节点有多个，heap不用动，map里count-1</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            map.put(n, <span class="keyword">new</span> Node(idx, count - <span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//弹出节点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> peakVal = heap.get(<span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> idx = map.get(peakVal).idx;</div><div class="line">        <span class="keyword">int</span> count = map.get(peakVal).count;</div><div class="line">        <span class="comment">//如果堆中只有一个该节点,需要与最后一个交换后维护，</span></div><div class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</div><div class="line">            <span class="comment">//与最后一个交换</span></div><div class="line">            swap(<span class="number">0</span>,heapSize-<span class="number">1</span>);</div><div class="line">            heap.remove(heap.size()-<span class="number">1</span>);</div><div class="line">            heapSize--;</div><div class="line">            ShiftDown(<span class="number">0</span>);</div><div class="line">            map.remove(peakVal);<span class="comment">//在map中删除</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果堆中有多个，heap不用变，map中对应count--；</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            map.put(peakVal,<span class="keyword">new</span> Node(idx,count-<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> peakVal;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//获取堆顶元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> heap.get(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//堆排序</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">HeapSort</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> size = heapSize;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; size)&#123;</div><div class="line">            res.add(poll());</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        HashHeap test = <span class="keyword">new</span> HashHeap(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">855249355</span>,<span class="number">67860114</span>,<span class="number">4098019</span>,<span class="number">948907207</span>,<span class="number">69865427</span>,<span class="number">347655258</span>,<span class="number">886401366</span>,<span class="number">446677701</span>,<span class="number">502269373</span>&#125;;<span class="comment">//int[] nums = &#123;-2147483648,-2147483648,2147483647,-2147483648,-2147483648,-2147483648,2147483647,2147483647,2147483647,2147483647,-2147483648,2147483647,-2147483648&#125;;</span></div><div class="line">        test.Build(nums);</div><div class="line">        test.add(<span class="number">8</span>);</div><div class="line">        test.remove(<span class="number">3</span>);</div><div class="line">        List&lt;Integer&gt; res = test.HeapSort();</div><div class="line">        System.out.print(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="leetcode-相关习题"><a href="#leetcode-相关习题" class="headerlink" title="leetcode 相关习题"></a>leetcode 相关习题</h2><h3 id="Trapping-Rain-Water"><a href="#Trapping-Rain-Water" class="headerlink" title="Trapping Rain Water"></a><a href="https://leetcode.com/problems/trapping-rain-water" target="_blank" rel="external">Trapping Rain Water</a></h3><blockquote>
<p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example,<br>Given <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>, return <code>6</code>.</p>
<p><img src="http://www.leetcode.com/static/images/problemset/rainwatertrap.png" alt="img"></p>
</blockquote>
<p>向柱子中灌水，求能够灌水的总量。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>可以从边缘向内灌水，灌水的高度不会超过边缘柱子的高度的最小值，所以说：<strong>边缘高度奠定了灌水的基调</strong></p>
<p>从低的一边（高度为h）向内灌水，能够灌水的量为（h-h_temp），遇到更高的柱子时，更新边缘。</p>
<p>显然，这是一个<strong>双指针</strong>问题。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-31-18.png" alt=""> </p>
<p>开始时，令总水量sum=0，双指针指向边缘，左选择较小的向内移动，假如选择左边指针。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-32-16.png" alt=""> </p>
<p>sum += 1，指针继续向右移动</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-33-23.png" alt=""> </p>
<p>此时左边指针遇到了跟高的边缘，右边指针开始向内移动</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-34-14.png" alt=""> </p>
<p>右边指针也同样遇到了更高的柱子，此时再从左右两边指针中选择一个较小的向内移动，假如选的依然是左边的，向内移动，更新sum，知道遇到更高的柱子</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-35-36.png" alt=""> </p>
<p>右侧指针左移，直到两指针相遇。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> right = height.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</div><div class="line">        <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</div><div class="line">            <span class="keyword">int</span> min = height[left];</div><div class="line">            left++;</div><div class="line">            <span class="keyword">while</span>(height[left]&lt;=min &amp;&amp; left &lt; right)&#123;</div><div class="line">                sum+=min-height[left];</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">int</span> min = height[right];</div><div class="line">            right--;</div><div class="line">            <span class="keyword">while</span>(height[right]&lt;=min &amp;&amp; left &lt; right)&#123;</div><div class="line">                sum+=min-height[right];</div><div class="line">                right--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Trapping-Rain-Water-II"><a href="#Trapping-Rain-Water-II" class="headerlink" title="Trapping Rain Water II"></a><a href="https://leetcode.com/problems/trapping-rain-water-ii" target="_blank" rel="external">Trapping Rain Water II</a></h3><blockquote>
<p>Given an <code>m x n</code> matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.</p>
<p><strong>Note:</strong><br>Both <em>m</em> and <em>n</em> are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given the following 3x6 height map:</div><div class="line">&gt; [</div><div class="line">&gt;   [1,4,3,1,3,2],</div><div class="line">&gt;   [3,2,1,3,2,4],</div><div class="line">&gt;   [2,3,3,2,3,1]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt; Return 4.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><img src="https://leetcode.com/static/images/problemset/rainwater_empty.png" alt="img"><br>The above image represents the elevation map <code>[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</code> before the rain.</p>
<p><img src="https://leetcode.com/static/images/problemset/rainwater_fill.png" alt="img"><br>After the rain, water are trapped between the blocks. The total volume of water trapped is 4.</p>
</blockquote>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>这一题是上一题在二维空间上的扩展。</p>
<p>对比上一题的思路，上一题的围墙是左右两边的柱子，而这道题的围墙是矩阵四周一圈的墙。我们可以从最矮的墙头向内灌水，然后将被灌水的位置加入围墙。</p>
<p>有两个要解决的点：</p>
<ol>
<li>找到围墙中最矮的墙头</li>
<li>从最矮的墙头向围墙内灌水，要知道那边是围墙“内”</li>
</ol>
<p>对于第1点，要求围墙中最矮的墙头，且墙头是动态插入的，可以维护一个最小堆，每次出堆元素即为最小的。</p>
<p>对于第2点，可以额外维护一个标记数组，记录是否已经被访问过，每次入堆就将该点对应的位置标记，若某一点没有被标记则是在围墙内。</p>
<p>以上图为例：</p>
<p>首先将四周设为围墙，将围墙元素入堆[1,4,3,1,3,2,3,4,2,3,3,2,3,1]</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-30-45.png" alt=""> </p>
<p>选取围墙中最小的，向内灌水，比如：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-53-16.png" alt=""> </p>
<p>由于3&gt;1，不能灌水，将3所在位置加入围墙[<del>1</del>,4,3,1,3,2,3,4,2,3,3,2,3,1, 3]</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-55-43.png" alt=""> </p>
<p>然后依次选取高度为1的其他几个围墙作为最矮的围墙，发现都不能够往里灌水，接下来选择高度为2的围墙，发现也不能向内灌水了，选取高度为3的围墙，比如：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-56-45.png" alt=""> </p>
<p>发现可以灌水量为2，然后将此点灌水后的高度加入围墙，[<del>1</del>,4,<del>3</del>,<del>1,</del>3,<del>2</del>,3,4,<del>2</del>,3,3,<del>2</del>,3,<del>1</del>,3,  3]：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-11-03-13.png" alt=""> </p>
<p>继续重复上边的步骤，知道堆为空</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"><span class="keyword">import</span> java.util.Queue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrappingRain2</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="keyword">int</span> y;</div><div class="line">        Node(<span class="keyword">int</span> val,<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">            <span class="keyword">this</span>.x = x;</div><div class="line">            <span class="keyword">this</span>.y = y;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> Comparator&lt;Node&gt; cmp = <span class="keyword">new</span> Comparator&lt;Node&gt;()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node e1,Node e2)</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> e1.val-e2.val;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(heightMap.length == <span class="number">0</span> || heightMap[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[heightMap.length][heightMap[<span class="number">0</span>].length];</div><div class="line">        Queue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Node&gt;(cmp);</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="comment">//初始边界入堆</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heightMap.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; heightMap[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span> || i == heightMap.length-<span class="number">1</span> || j == heightMap[<span class="number">0</span>].length-<span class="number">1</span>)&#123;</div><div class="line">                    heap.add(<span class="keyword">new</span> Node(heightMap[i][j],i,j));</div><div class="line">                    visited[i][j] = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!heap.isEmpty())&#123;</div><div class="line">            Node top =  heap.peek();</div><div class="line">            heap.remove();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</div><div class="line">                <span class="keyword">int</span> x_new = top.x+x_delta[i];</div><div class="line">                <span class="keyword">int</span> y_new = top.y+y_delta[i];</div><div class="line">                <span class="keyword">if</span>(x_new &gt;=<span class="number">0</span> &amp;&amp; x_new &lt; heightMap.length &amp;&amp; y_new &gt;= <span class="number">0</span> &amp;&amp; y_new &lt; heightMap[<span class="number">0</span>].length &amp;&amp; !visited[x_new][y_new])&#123;</div><div class="line">                    <span class="keyword">if</span>(heightMap[x_new][y_new] &lt; top.val)&#123;</div><div class="line">                        sum += top.val-heightMap[x_new][y_new];</div><div class="line">                        heap.add(<span class="keyword">new</span> Node(top.val,x_new,y_new));</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span>&#123;</div><div class="line">                        heap.add(<span class="keyword">new</span> Node(heightMap[x_new][y_new],x_new,y_new));</div><div class="line">                    &#125;</div><div class="line">                    visited[x_new][y_new] = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>  sum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        TrappingRain2 test = <span class="keyword">new</span> TrappingRain2();</div><div class="line">        <span class="keyword">int</span>[][] heightMap = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;&#125;;</div><div class="line">        <span class="keyword">int</span> sum = test.trapRainWater(heightMap);</div><div class="line">        System.out.println(sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Top-K-Frequent-Words"><a href="#Top-K-Frequent-Words" class="headerlink" title="Top K Frequent Words"></a><a href="https://leetcode.com/problems/top-k-frequent-words/" target="_blank" rel="external">Top K Frequent Words</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a non-empty list of words, return the <em>k</em> most frequent elements.</p>
<p>Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2</div><div class="line">&gt; Output: [&quot;i&quot;, &quot;love&quot;]</div><div class="line">&gt; Explanation: &quot;i&quot; and &quot;love&quot; are the two most frequent words.</div><div class="line">&gt;     Note that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4</div><div class="line">&gt; Output: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]</div><div class="line">&gt; Explanation: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words,</div><div class="line">&gt;     with the number of occurrence being 4, 3, 2 and 1 respectively.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>You may assume <em>k</em> is always valid, 1 ≤ <em>k</em> ≤ number of unique elements.</li>
<li>Input words contain only lowercase letters.</li>
</ol>
<p><strong>Follow up:</strong></p>
<ol>
<li>Try to solve it in <em>O</em>(<em>n</em> log <em>k</em>) time and <em>O</em>(<em>n</em>) extra space.</li>
</ol>
</blockquote>
<p>给定一个字符串数组，要求返回出现次数最多的前K个字符串，如果遇到多个字符串年出现次数相同时，则优先取字典序小的字符串。</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>正常的能够想到的思路是用一个hashmap记录每个单词出现的次数，然后放入一个堆中，堆的排序依据是出现次数多的排在前面，出现次数一样多的，字典序小的排在前面，将全部字符放入堆之后弹出前K个，就得到了出现次数最多的前K个，复杂度:<script type="math/tex">O(nlogn)</script></p>
<p><strong>follow up</strong> : 要求我们用时<script type="math/tex">O(nlogn)</script> ，也就是说我们只需要维护大小为K的堆，因此，我们应该采用“最小堆”而非“最大堆”，堆顶元素是当前出现次数最小的，所以当下一次有新元素加进来的时候，如果堆的大小超过了k，就可以把堆顶这个出现次数最少的元素弹掉了，这样一来，最后堆中剩下的k个元素都是出现次数最多得了，是不是很神奇~！！！！</p>
<p>所以这道题我们的堆应该是这样的：</p>
<ol>
<li>出现次数少的优先出堆</li>
<li>出现次数一样的，字典序大的优先出队</li>
<li>堆的大小为k,当堆中元素个数超过k时，手动poll出堆</li>
</ol>
<p>这样一来，堆的大小就一直都只有K，时间复杂度就降到<script type="math/tex">O(klogn)</script> 了。这在数据量很大的情况下是十分有必要的！！比如我们要在100亿个数字中找到最大的K个，如果用之前的建堆方法就要建一个100亿大的堆。。。超恐怖，但现在，无论多少数据，我们的堆也只有k那么大了<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">ps: 这里还学到了一个**比较器的神奇写法**，见注释，可以在比较器中调用map中的count来进行比较诶，这样heap里面就可以只存String了。</div><div class="line"></div><div class="line">#### 代码</div><div class="line"></div><div class="line">```java</div><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class TopKFrequentWords &#123;</div><div class="line">    class Node&#123;</div><div class="line">        String word;</div><div class="line">        int count;</div><div class="line">        Node(String word,int count)&#123;</div><div class="line">            this.count = count;</div><div class="line">            this.word = word;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public List&lt;String&gt; topKFrequent(String[] words, int k) &#123;</div><div class="line">        HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;();</div><div class="line">        Comparator&lt;Node&gt; cmp = new Comparator&lt;Node&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public int compare(Node o1, Node o2) &#123;</div><div class="line">                if(o1.count!= o2.count) return o1.count-o2.count;//出现次数少的排在前面</div><div class="line">                else &#123;</div><div class="line">                    if(o1.word.compareTo(o2.word) &lt; 0)&#123;//在字母表中位置靠后的排在前面</div><div class="line">                        return 1;</div><div class="line">                    &#125;</div><div class="line">                    else return -1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">//        Comparator&lt;String&gt; cmp2 = new Comparator&lt;String&gt;() &#123;</div><div class="line">//            @Override</div><div class="line">//            public int compare(String o1, String o2) &#123;</div><div class="line">//                int o1Count = map.get(o1), o2Count = map.get(o2);</div><div class="line">//                if(o1Count!= o2Count) return o1Count-o2Count;//出现次数少的排在前面</div><div class="line">//                else &#123;</div><div class="line">//                    return o2.compareTo(o1);</div><div class="line">//                &#125;</div><div class="line">//            &#125;</div><div class="line">//        &#125;;</div><div class="line">        PriorityQueue&lt;Node&gt; heap = new PriorityQueue&lt;&gt;(cmp);</div><div class="line">        for(String word : words)&#123;</div><div class="line">            map.put(word,map.getOrDefault(word,0)+1);</div><div class="line">        &#125;</div><div class="line">        for(String word:map.keySet())&#123;</div><div class="line">            heap.add(new Node(word,map.get(word)));</div><div class="line">            //手动控制heap大小</div><div class="line">            if(heap.size() &gt; k)&#123;</div><div class="line">                heap.poll();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        List&lt;String&gt; res = new ArrayList&lt;&gt;();</div><div class="line">        while (!heap.isEmpty())&#123;</div><div class="line">            res.add(heap.poll().word);</div><div class="line">        &#125;</div><div class="line">        Collections.reverse(res);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">```</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">### [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)</div><div class="line"></div><div class="line">#### 题目</div><div class="line"></div><div class="line">&gt; Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</div><div class="line">&gt;</div><div class="line">&gt; Examples: </div><div class="line">&gt;</div><div class="line">&gt; `[2,3,4]` , the median is `3`</div><div class="line">&gt;</div><div class="line">&gt; `[2,3]`, the median is `(2 + 3) / 2 = 2.5`</div><div class="line">&gt;</div><div class="line">&gt; Design a data structure that supports the following two operations:</div><div class="line">&gt;</div><div class="line">&gt; - void addNum(int num) - Add a integer number from the data stream to the data structure.</div><div class="line">&gt; - double findMedian() - Return the median of all elements so far.</div><div class="line">&gt;</div><div class="line">&gt; For example:</div><div class="line">&gt;</div><div class="line">&gt; ```</div><div class="line">&gt; addNum(1)</div><div class="line">&gt; addNum(2)</div><div class="line">&gt; findMedian() -&gt; 1.5</div><div class="line">&gt; addNum(3) </div><div class="line">&gt; findMedian() -&gt; 2</div><div class="line">&gt; ```</div><div class="line"></div><div class="line">数据以流的方式给出，实现加入数字和获取中位数的方法。</div><div class="line"></div><div class="line">#### 分析</div><div class="line"></div><div class="line">baseline:每次加入数字之后排序，然后计算中位数，时间复杂度：$$O(n^2logn)$$</div><div class="line"></div><div class="line">**优化：**</div><div class="line"></div><div class="line">中位数：将元素分成两堆，一堆比中位数小，一堆比中位数大</div><div class="line"></div><div class="line">在中位数左右设置两个堆，每次进来一个元素，和中位数比较，如果大于中位数，放到右边的堆中（小顶堆），比中位数小放到左边堆中（大顶堆）。</div><div class="line"></div><div class="line">入堆之后，需要比较左右两个堆的元素个数，当两边数字个之差超过2时，则需要将多的一遍的元素挪出一个去另一边，以保证两边元素个数之差&lt;=1</div><div class="line"></div><div class="line">另外，每次需更新中位数，当左右两堆元素个数相等时，中位数为两个堆顶元素均值；当左右两堆元素个数相差一时，中位数为多的那个堆的堆顶元素</div><div class="line"></div><div class="line">时间复杂度：$$O(nlogn)$$ ,n个元素入堆，入堆操作$$O(logn)$$</div><div class="line"></div><div class="line">#### 代码</div><div class="line"></div><div class="line">```java</div><div class="line">import java.util.Comparator;</div><div class="line">import java.util.PriorityQueue;</div><div class="line"></div><div class="line">public class MedianFinder &#123;</div><div class="line">    PriorityQueue&lt;Integer&gt; maxHeap;//左边最大对</div><div class="line">    PriorityQueue&lt;Integer&gt; minHeap;//右边最小堆</div><div class="line">    int leftSum;</div><div class="line">    int rightSum;</div><div class="line">    double median;</div><div class="line"></div><div class="line">    /** initialize your data structure here. */</div><div class="line">    public MedianFinder() &#123;</div><div class="line">        Comparator&lt;Integer&gt; maxCmp = new Comparator&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public int compare(Integer o1, Integer o2) &#123;</div><div class="line">                return o2-o1;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        maxHeap = new PriorityQueue&lt;&gt;(maxCmp);</div><div class="line">        minHeap = new PriorityQueue&lt;&gt;();</div><div class="line">        leftSum = 0;</div><div class="line">        rightSum = 0;</div><div class="line">        median = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void addNum(int num) &#123;</div><div class="line">        //如果两个堆都是空的,默认先放到右边堆中</div><div class="line">        if(minHeap.isEmpty() &amp;&amp; maxHeap.isEmpty())&#123;</div><div class="line">            minHeap.add(num);</div><div class="line">            rightSum++;</div><div class="line">            median = num;</div><div class="line">        &#125;</div><div class="line">        //加入的值大于中位数，放入右边的堆</div><div class="line">        else if(num &gt; median)&#123;</div><div class="line">            minHeap.add(num);</div><div class="line">            rightSum++;</div><div class="line">            //如果右边比左边多两个了，需要挪出一个去左边</div><div class="line">            if(rightSum-leftSum == 2)&#123;</div><div class="line">                maxHeap.add(minHeap.poll());</div><div class="line">                leftSum++;</div><div class="line">                rightSum--;</div><div class="line">            &#125;//此时两边元素相等或者右边比左边多一个</div><div class="line">            if(rightSum &gt; leftSum)&#123;</div><div class="line">                median = minHeap.peek();</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                median = (minHeap.peek() + maxHeap.peek())/2.0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //否则，放入左边的堆</div><div class="line">        else &#123;</div><div class="line">            maxHeap.add(num);</div><div class="line">            leftSum++;</div><div class="line">            //如果右边比左边多两个了，需要挪出一个去左边</div><div class="line">            if(leftSum-rightSum == 2)&#123;</div><div class="line">                minHeap.add(maxHeap.poll());</div><div class="line">                leftSum--;</div><div class="line">                rightSum++;</div><div class="line">            &#125;//此时两边元素相等或者右边比左边多一个</div><div class="line">            if(leftSum &gt; rightSum)&#123;</div><div class="line">                median = maxHeap.peek();</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                median = (minHeap.peek() + maxHeap.peek())/2.0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public double findMedian() &#123;</div><div class="line">        return median;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Your MedianFinder object will be instantiated and called as such:</div><div class="line"> * MedianFinder obj = new MedianFinder();</div><div class="line"> * obj.addNum(num);</div><div class="line"> * double param_2 = obj.findMedian();</div><div class="line"> */</div><div class="line">```</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">### [Sliding Window Median](https://leetcode.com/problems/sliding-window-median)   </div><div class="line"></div><div class="line">上一题的follow up</div><div class="line"></div><div class="line">#### 题目</div><div class="line"></div><div class="line">&gt; Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</div><div class="line">&gt;</div><div class="line">&gt; Examples: </div><div class="line">&gt;</div><div class="line">&gt; `[2,3,4]` , the median is `3`</div><div class="line">&gt;</div><div class="line">&gt; `[2,3]`, the median is `(2 + 3) / 2 = 2.5`</div><div class="line">&gt;</div><div class="line">&gt; Given an array *nums*, there is a sliding window of size *k* which is moving from the very left of the array to the very right. You can only see the *k* numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.</div><div class="line">&gt;</div><div class="line">&gt; For example,</div><div class="line">&gt; Given *nums* = `[1,3,-1,-3,5,3,6,7]`, and *k* = 3.</div><div class="line">&gt;</div><div class="line">&gt; ```</div><div class="line">&gt; Window position                Median</div><div class="line">&gt; ---------------               -----</div><div class="line">&gt; [1  3  -1] -3  5  3  6  7       1</div><div class="line">&gt;  1 [3  -1  -3] 5  3  6  7       -1</div><div class="line">&gt;  1  3 [-1  -3  5] 3  6  7       -1</div><div class="line">&gt;  1  3  -1 [-3  5  3] 6  7       3</div><div class="line">&gt;  1  3  -1  -3 [5  3  6] 7       5</div><div class="line">&gt;  1  3  -1  -3  5 [3  6  7]      6</div><div class="line">&gt;</div><div class="line">&gt; ```</div><div class="line">&gt;</div><div class="line">&gt; Therefore, return the median sliding window as `[1,-1,-1,3,5,6]`.</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 分析</div><div class="line"></div><div class="line">阿西吧，做了一晚上==</div><div class="line"></div><div class="line">跟上一题相比，这道题是个滑动窗口问题，滑窗问题可以拆解为：</div><div class="line"></div><div class="line">1. 加一个元素</div><div class="line">2. 删一个元素</div><div class="line"></div><div class="line">所以跟上一题一样的思路，但每次需要删除窗口错过的那个元素，那么如何找到要删除的这个元素在左边还是右边呢？</div><div class="line"></div><div class="line">1. 如果元素&gt;median，则一定在右堆</div><div class="line">2. 如果元素&lt;median，则一定在左堆</div><div class="line">3. 如果元素==median，则一定在两堆的堆顶</div><div class="line"></div><div class="line">先用PriorityQueue写了一版，90ms</div><div class="line"></div><div class="line">PriorityQueue中remove操作的时间复杂度是$$O(n)$$ ,鼓起勇气手码了个hashheap优化下，hashheap中remove操作时间复杂度是$$O(logn)$$ ,写了一晚上，186ms，想哭。。。。</div><div class="line"></div><div class="line">看了比较快的解法，用TreeSet，之后弄懂了再来写</div></pre></td></tr></table></figure></p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>PriorityQueue: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">        PriorityQueue&lt;Integer&gt; maxHeap;<span class="comment">//左边最大对</span></div><div class="line">        PriorityQueue&lt;Integer&gt; minHeap;<span class="comment">//右边最小堆</span></div><div class="line">        <span class="keyword">int</span> leftSum;</div><div class="line">        <span class="keyword">int</span> rightSum;</div><div class="line">        <span class="keyword">double</span> median;</div><div class="line"></div><div class="line">        <span class="comment">/** initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span></span>&#123;</div><div class="line">            Comparator&lt;Integer&gt; maxCmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> Integer.compare(o2,o1);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(maxCmp);</div><div class="line">            minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</div><div class="line">            leftSum = <span class="number">0</span>;</div><div class="line">            rightSum = <span class="number">0</span>;</div><div class="line">            median = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">            <span class="comment">//如果两个堆都是空的,默认先放到右边堆中</span></div><div class="line">            <span class="keyword">if</span>(minHeap.isEmpty() &amp;&amp; maxHeap.isEmpty())&#123;</div><div class="line">                minHeap.add(num);</div><div class="line">                rightSum++;</div><div class="line">                median = num;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//加入的值大于中位数，放入右边的堆</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; median)&#123;</div><div class="line">                minHeap.add(num);</div><div class="line">                rightSum++;</div><div class="line">                <span class="comment">//如果右边比左边多两个了，需要挪出一个去左边</span></div><div class="line">                <span class="keyword">if</span>(rightSum-leftSum == <span class="number">2</span>)&#123;</div><div class="line">                    maxHeap.add(minHeap.poll());</div><div class="line">                    leftSum++;</div><div class="line">                    rightSum--;</div><div class="line">                &#125;<span class="comment">//此时两边元素相等或者右边比左边多一个</span></div><div class="line">                <span class="keyword">if</span>(rightSum &gt; leftSum)&#123;</div><div class="line">                    median = minHeap.peek();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    median = minHeap.peek()/<span class="number">2.0</span> + maxHeap.peek()/<span class="number">2.0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//否则，放入左边的堆</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                maxHeap.add(num);</div><div class="line">                leftSum++;</div><div class="line">                <span class="comment">//如果右边比左边多两个了，需要挪出一个去左边</span></div><div class="line">                <span class="keyword">if</span>(leftSum-rightSum == <span class="number">2</span>)&#123;</div><div class="line">                    minHeap.add(maxHeap.poll());</div><div class="line">                    leftSum--;</div><div class="line">                    rightSum++;</div><div class="line">                &#125;<span class="comment">//此时两边元素相等或者右边比左边多一个</span></div><div class="line">                <span class="keyword">if</span>(leftSum &gt; rightSum)&#123;</div><div class="line">                    median = maxHeap.peek();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    median = minHeap.peek()/<span class="number">2.0</span> + maxHeap.peek()/<span class="number">2.0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">            <span class="comment">//如果要删除的在右边</span></div><div class="line">            <span class="keyword">if</span> ((num == median &amp;&amp; minHeap.peek() == num)|| num &gt; median) &#123;</div><div class="line">                minHeap.remove(num);</div><div class="line">                rightSum--;</div><div class="line">                <span class="comment">//删完两边元素相等</span></div><div class="line">                <span class="keyword">if</span>(rightSum == leftSum)&#123;</div><div class="line">                    median = minHeap.peek()/<span class="number">2.0</span> + maxHeap.peek()/<span class="number">2.0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//删完右边比左边少一个</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rightSum+<span class="number">1</span> == leftSum)&#123;</div><div class="line">                    median = maxHeap.peek();</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//删完右边比左边少两个</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    minHeap.add(maxHeap.poll());</div><div class="line">                    rightSum++;</div><div class="line">                    leftSum--;</div><div class="line">                    median = minHeap.peek()/<span class="number">2.0</span> + maxHeap.peek()/<span class="number">2.0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果要删除的在左边</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                maxHeap.remove(num);</div><div class="line">                leftSum--;</div><div class="line">                <span class="keyword">if</span>(rightSum == leftSum)&#123;</div><div class="line">                    median = minHeap.peek()/<span class="number">2.0</span> + maxHeap.peek()/<span class="number">2.0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//删完左边比右边少一个</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(leftSum+<span class="number">1</span> == rightSum)&#123;</div><div class="line">                    median = minHeap.peek();</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//删完左边比右边少两个</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    maxHeap.add(minHeap.poll());</div><div class="line">                    rightSum--;</div><div class="line">                    leftSum++;</div><div class="line">                    median = minHeap.peek()/<span class="number">2.0</span> + maxHeap.peek()/<span class="number">2.0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> median;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] medianSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</div><div class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[nums.length-k+<span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;i++)&#123;</div><div class="line">            addNum(nums[i]);</div><div class="line">        &#125;</div><div class="line">        res[<span class="number">0</span>] = findMedian();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i &lt; nums.length;i++)&#123;</div><div class="line">            addNum(nums[i]);</div><div class="line">            remove(nums[i-k]);</div><div class="line">            res[i-k+<span class="number">1</span>] = findMedian();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HashHeap：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HashHeap</span> </span>&#123;</div><div class="line">    HashMap&lt;Integer,Node&gt; map;<span class="comment">//存储元素值和在堆中的索引</span></div><div class="line">    ArrayList&lt;Integer&gt; heap;</div><div class="line">    <span class="keyword">int</span> heapSize;</div><div class="line">    <span class="keyword">boolean</span> isMaxHeap;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> idx;<span class="comment">//节点在堆中的位置</span></div><div class="line">        <span class="keyword">int</span> count;<span class="comment">//该数值出现次数</span></div><div class="line">        Node(<span class="keyword">int</span> idx,<span class="keyword">int</span> count)&#123;</div><div class="line">            <span class="keyword">this</span>.idx = idx;</div><div class="line">            <span class="keyword">this</span>.count = count;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(heapSize == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    HashHeap(<span class="keyword">boolean</span> isMaxHeap)&#123;</div><div class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">this</span>.heap = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">this</span>.isMaxHeap = isMaxHeap;</div><div class="line">        <span class="keyword">this</span>.heapSize = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//由数组构建最大堆</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</div><div class="line">            System.out.println(counter);</div><div class="line">            add(i);</div><div class="line">            counter ++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//交换堆中节点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="comment">//获取ij在堆中指向的元素值</span></div><div class="line">        <span class="keyword">int</span> vali = heap.get(i);</div><div class="line">        <span class="keyword">int</span> valj = heap.get(j);</div><div class="line"></div><div class="line">        <span class="comment">//获取两个值在map中的个数</span></div><div class="line">        <span class="keyword">int</span> counti = map.get(vali).count;</div><div class="line">        <span class="keyword">int</span> countj = map.get(valj).count;</div><div class="line"></div><div class="line">        <span class="comment">//修改hashmap，把两个值对应的位置互换，count不变</span></div><div class="line">        map.put(vali,<span class="keyword">new</span> Node(j,counti));</div><div class="line">        map.put(valj,<span class="keyword">new</span> Node(i,countj));</div><div class="line"></div><div class="line">        <span class="comment">//交换堆中的节点值</span></div><div class="line">        heap.set(i,valj);</div><div class="line">        heap.set(j,vali);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//向上交换</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShiftUp</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> parentIdx = (idx-<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(parentIdx &gt; -<span class="number">1</span> &amp;&amp; idx &lt; heapSize)&#123;</div><div class="line">            <span class="comment">//如果是最大堆而且孩子&gt;父亲 || 是最小堆而且孩子&lt;父亲,需要向上shift</span></div><div class="line">            <span class="keyword">if</span>((isMaxHeap &amp;&amp; heap.get(parentIdx) &lt; heap.get(idx)) ||</div><div class="line">                   !isMaxHeap &amp;&amp; heap.get(parentIdx) &gt; heap.get(idx) )&#123;</div><div class="line">                swap(idx,parentIdx);</div><div class="line">                ShiftUp(parentIdx);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//向下交换</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShiftDown</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> leftChildIdx = <span class="number">2</span> * idx+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> rightChildIdx = <span class="number">2</span> * idx+<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> largestIdx = idx;</div><div class="line">        <span class="keyword">if</span>(leftChildIdx &lt; heapSize)&#123;</div><div class="line">            <span class="comment">//如果是最大堆而且父亲节点小于孩子</span></div><div class="line">            <span class="keyword">if</span>((isMaxHeap &amp;&amp; heap.get(idx) &lt; heap.get(leftChildIdx)) ||</div><div class="line">                    (!isMaxHeap &amp;&amp; heap.get(idx) &gt; heap.get(leftChildIdx)))&#123;</div><div class="line">                largestIdx = leftChildIdx;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(rightChildIdx &lt; heapSize)&#123;</div><div class="line">            <span class="keyword">if</span>((isMaxHeap &amp;&amp; heap.get(largestIdx) &lt; heap.get(rightChildIdx)) ||</div><div class="line">                    (!isMaxHeap &amp;&amp; heap.get(largestIdx) &gt; heap.get(rightChildIdx)))&#123;</div><div class="line">                largestIdx = rightChildIdx;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(largestIdx != idx)&#123;</div><div class="line">            swap(idx,largestIdx);</div><div class="line">            ShiftDown(largestIdx);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//插入元素，值为n</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="comment">//如果堆中已经有该元素了,放在原来的位置，heap不用动，map计数+1</span></div><div class="line">        <span class="keyword">if</span>(map.containsKey(n))&#123;</div><div class="line">            map.put(n,<span class="keyword">new</span> Node(map.get(n).idx,map.get(n).count+<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果堆中没有该元素</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            map.put(n,<span class="keyword">new</span> Node(heapSize,<span class="number">1</span>));</div><div class="line">            heap.add(n);</div><div class="line">            heapSize++;</div><div class="line">            ShiftUp(heapSize-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//删除节点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> idx = map.get(n).idx;</div><div class="line">        <span class="keyword">int</span> count = map.get(n).count;</div><div class="line">        <span class="comment">//如果该值的节点只有一个</span></div><div class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</div><div class="line">            swap(idx,heapSize-<span class="number">1</span>);</div><div class="line">            map.remove(n);<span class="comment">///在map中删除</span></div><div class="line">            heap.remove(heap.size()-<span class="number">1</span>);</div><div class="line">            heapSize--;</div><div class="line">            <span class="comment">//不知道</span></div><div class="line">            ShiftUp(idx);</div><div class="line">            ShiftDown(idx);<span class="comment">//交换之后需要向下维护</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果该值的节点有多个，heap不用动，map里count-1</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            map.put(n, <span class="keyword">new</span> Node(idx, count - <span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//弹出节点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> peakVal = heap.get(<span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> idx = map.get(peakVal).idx;</div><div class="line">        <span class="keyword">int</span> count = map.get(peakVal).count;</div><div class="line">        <span class="comment">//如果堆中只有一个该节点,需要与最后一个交换后维护，</span></div><div class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</div><div class="line">            <span class="comment">//与最后一个交换</span></div><div class="line">            swap(<span class="number">0</span>,heapSize-<span class="number">1</span>);</div><div class="line">            heap.remove(heap.size()-<span class="number">1</span>);</div><div class="line">            heapSize--;</div><div class="line">            ShiftUp(<span class="number">0</span>);</div><div class="line">            ShiftDown(<span class="number">0</span>);</div><div class="line">            map.remove(peakVal);<span class="comment">//在map中删除</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果堆中有多个，heap不用变，map中对应count--；</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            map.put(peakVal,<span class="keyword">new</span> Node(idx,count-<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> peakVal;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//获取堆顶元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> heap.get(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">        HashHeap maxHeap;<span class="comment">//左边最大对</span></div><div class="line">        HashHeap minHeap;<span class="comment">//右边最小堆</span></div><div class="line">        <span class="keyword">int</span> leftSum;</div><div class="line">        <span class="keyword">int</span> rightSum;</div><div class="line">        <span class="keyword">double</span> median;</div><div class="line"></div><div class="line">        <span class="comment">/** initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span></span>&#123;</div><div class="line">            Comparator&lt;Integer&gt; maxCmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> Integer.compare(o2,o1);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            maxHeap = <span class="keyword">new</span> HashHeap(<span class="keyword">true</span>);</div><div class="line">            minHeap = <span class="keyword">new</span> HashHeap(<span class="keyword">false</span>);</div><div class="line">            leftSum = <span class="number">0</span>;</div><div class="line">            rightSum = <span class="number">0</span>;</div><div class="line">            median = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">            <span class="comment">//如果两个堆都是空的,默认先放到右边堆中</span></div><div class="line">            <span class="keyword">if</span>(minHeap.isEmpty() &amp;&amp; maxHeap.isEmpty())&#123;</div><div class="line">                minHeap.add(num);</div><div class="line">                rightSum++;</div><div class="line">                median = num;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//加入的值大于中位数，放入右边的堆</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; median)&#123;</div><div class="line">                minHeap.add(num);</div><div class="line">                rightSum++;</div><div class="line">                <span class="comment">//如果右边比左边多两个了，需要挪出一个去左边</span></div><div class="line">                <span class="keyword">if</span>(rightSum-leftSum == <span class="number">2</span>)&#123;</div><div class="line">                    maxHeap.add(minHeap.poll());</div><div class="line">                    leftSum++;</div><div class="line">                    rightSum--;</div><div class="line">                &#125;<span class="comment">//此时两边元素相等或者右边比左边多一个</span></div><div class="line">                <span class="keyword">if</span>(rightSum &gt; leftSum)&#123;</div><div class="line">                    median = minHeap.peek();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    median = minHeap.peek()/<span class="number">2.0</span> + maxHeap.peek()/<span class="number">2.0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//否则，放入左边的堆</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                maxHeap.add(num);</div><div class="line">                leftSum++;</div><div class="line">                <span class="comment">//如果右边比左边多两个了，需要挪出一个去左边</span></div><div class="line">                <span class="keyword">if</span>(leftSum-rightSum == <span class="number">2</span>)&#123;</div><div class="line">                    minHeap.add(maxHeap.poll());</div><div class="line">                    leftSum--;</div><div class="line">                    rightSum++;</div><div class="line">                &#125;<span class="comment">//此时两边元素相等或者右边比左边多一个</span></div><div class="line">                <span class="keyword">if</span>(leftSum &gt; rightSum)&#123;</div><div class="line">                    median = maxHeap.peek();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                   median = minHeap.peek()/<span class="number">2.0</span> + maxHeap.peek()/<span class="number">2.0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">            <span class="comment">//如果要删除的在左边</span></div><div class="line">            <span class="keyword">if</span>(maxHeap.map.containsKey(num))&#123;</div><div class="line">                maxHeap.remove(num);</div><div class="line">                leftSum--;</div><div class="line">                <span class="comment">//删完相等</span></div><div class="line">                <span class="keyword">if</span>(leftSum == rightSum)&#123;</div><div class="line">                    median = minHeap.peek()/<span class="number">2.0</span> + maxHeap.peek()/<span class="number">2.0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(leftSum+<span class="number">1</span> == rightSum)&#123;</div><div class="line">                    median = minHeap.peek();</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//删完左边比右边少两个</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    maxHeap.add(minHeap.poll());</div><div class="line">                    rightSum--;</div><div class="line">                    leftSum++;</div><div class="line">                    median = minHeap.peek()/<span class="number">2.0</span> + maxHeap.peek()/<span class="number">2.0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//要删除的在右边</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                minHeap.remove(num);</div><div class="line">                rightSum--;</div><div class="line">                <span class="comment">//删完两边元素相等</span></div><div class="line">                <span class="keyword">if</span>(rightSum == leftSum)&#123;</div><div class="line">                    median = minHeap.peek()/<span class="number">2.0</span> + maxHeap.peek()/<span class="number">2.0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//删完右边比左边少一个</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rightSum+<span class="number">1</span> == leftSum)&#123;</div><div class="line">                    </div><div class="line">                    median = maxHeap.peek();</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//删完右边比左边少2个，要从左边挪一个过来</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    minHeap.add(maxHeap.poll());</div><div class="line">                    leftSum--;</div><div class="line">                    rightSum++;</div><div class="line">                    median = minHeap.peek()/<span class="number">2.0</span> + maxHeap.peek()/<span class="number">2.0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> median;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] medianSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</div><div class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[nums.length-k+<span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;i++)&#123;</div><div class="line">            addNum(nums[i]);</div><div class="line">        &#125;</div><div class="line">        res[<span class="number">0</span>] = findMedian();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i &lt; nums.length;i++)&#123;</div><div class="line">            addNum(nums[i]);</div><div class="line">            remove(nums[i-k]);</div><div class="line">            res[i-k+<span class="number">1</span>] = findMedian();</div><div class="line">            System.out.print(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Deque双端队列"><a href="#Deque双端队列" class="headerlink" title="Deque双端队列"></a>Deque双端队列</h1><p>可以从两端进行插入和删除</p>
<h3 id="Sliding-Window-Maximum"><a href="#Sliding-Window-Maximum" class="headerlink" title="Sliding Window Maximum"></a><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="external">Sliding Window Maximum</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array <em>nums</em>, there is a sliding window of size <em>k</em> which is moving from the very left of the array to the very right. You can only see the <em>k</em> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>For example,<br>Given <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <em>k</em> = 3.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Window position                Max</div><div class="line">&gt; ---------------               -----</div><div class="line">&gt; [1  3  -1] -3  5  3  6  7       3</div><div class="line">&gt;  1 [3  -1  -3] 5  3  6  7       3</div><div class="line">&gt;  1  3 [-1  -3  5] 3  6  7       5</div><div class="line">&gt;  1  3  -1 [-3  5  3] 6  7       5</div><div class="line">&gt;  1  3  -1  -3 [5  3  6] 7       6</div><div class="line">&gt;  1  3  -1  -3  5 [3  6  7]      7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Therefore, return the max sliding window as <code>[3,3,5,5,6,7]</code>.</p>
</blockquote>
<p>给定数组和窗口大小，要求返回窗口滑动过程中每一个位置的最大值。</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<p>两层循环，找窗口k内的最大值，时间复杂度<script type="math/tex">O(n*k)</script></p>
<p>方法二：</p>
<p>维护一个heap，窗口向前滑动时，加一个元素，减一个元素，堆顶元素即为窗口内最大元素，时间复杂度：<script type="math/tex">O(nlogk)</script></p>
<p>方法三：双端队列Deque</p>
<p>我们用双向队列可以在O(N)时间内解决这题。当我们遇到新的数时，将新的数和双向队列的末尾比较，如果末尾比新数小，则把末尾扔掉，直到该队列的末尾比新数大或者队列为空的时候才住手。这样，我们可以保证队列里的元素是从头到尾降序的，由于队列里只有窗口内的数，所以他们其实就是窗口内第一大，第二大，第三大…的数。保持队列里只有窗口内数的方法和上个解法一样，也是每来一个新的把窗口最左边的扔掉，然后把新的加进去。然而由于我们在加新数的时候，已经把很多没用的数给扔了，这样队列头部的数并不一定是窗口最左边的数。这里的技巧是，我们队列中存的是那个数在原数组中的下标，这样我们既可以直到这个数的值，也可以知道该数是不是窗口最左边的数。这里为什么时间复杂度是O(N)呢？因为每个数只可能被操作最多两次，一次是加入队列的时候，一次是因为有别的更大数在后面，所以被扔掉，或者因为出了窗口而被扔掉。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</div><div class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length-k+<span class="number">1</span>];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//窗口尾后移</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            <span class="comment">//窗口第一个元素超过窗口，弹出</span></div><div class="line">            <span class="keyword">if</span>(!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt; i-k+<span class="number">1</span>)&#123;</div><div class="line">                deque.poll();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果目前元素大于deque中队尾元素，将队尾元素弹出</span></div><div class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i])&#123;</div><div class="line">                deque.pollLast();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//加入idx</span></div><div class="line">            deque.addLast(i);</div><div class="line">            <span class="comment">//每次窗口滑动之后将最大元素加入结果集合</span></div><div class="line">            <span class="keyword">if</span>(i &gt;= k-<span class="number">1</span>)&#123;</div><div class="line">                res[i-k+<span class="number">1</span>] = nums[deque.peekFirst()];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Heap </tag>
            
            <tag> Dequeue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班】课程笔记2——扫描线]]></title>
      <url>/2017/11/17/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E6%89%AB%E6%8F%8F%E7%BA%BF/</url>
      <content type="html"><![CDATA[<h1 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h1><h2 id="lintcode391-数飞机"><a href="#lintcode391-数飞机" class="headerlink" title="lintcode391. 数飞机"></a><a href="http://www.lintcode.com/zh-cn/problem/number-of-airplanes-in-the-sky/" target="_blank" rel="external">lintcode391. 数飞机</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>给出飞机的起飞和降落时间的列表，用 interval 序列表示. 请计算出天上同时最多有多少架飞机？</p>
<p>样例</p>
<p>对于每架飞机的起降时间列表：<code>[[1,10],[2,3],[5,8],[4,7]]</code>, 返回<code>3</code>。</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-17-20-40-58.png" alt=""> </p>
<p>计算空中的飞机个数，可以看成用一个线从左到右扫描的过程，计算每一时刻空中飞机的数量。</p>
<p>优化：只计算所有线段起始位置时天上的飞机即可，因为只有起始点是可能发生变化的点。遇到起点，天上的飞机数+1，遇到终点则-1。</p>
<p>因此，我们先将所有线段的起点、终点排序，并标记是起点还是终点，然后从小到大遍历这些点，遇到起点则+1，遇到终点-1，返回过程中最大的数值即为空中飞机数的最大值。</p>
<p><strong>需要注意的是</strong>：在同一点上会同时有开始点和结尾点，此时应该把结尾点放在前面，否则会出现多计算的情况。</p>
<a id="more"></a>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> com.sun.org.apache.xpath.internal.operations.Bool;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">airplane_count</span> </span>&#123;</div><div class="line">    <span class="comment">//Definition of Interval:</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span></span>&#123;</div><div class="line">        Integer start, end;</div><div class="line">        Interval(Integer start, Integer end) &#123;</div><div class="line">            <span class="keyword">this</span>.start = start;</div><div class="line">            <span class="keyword">this</span>.end = end;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Definition of node:</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</div><div class="line">        Integer val;</div><div class="line">        <span class="keyword">boolean</span> isstart;</div><div class="line">        Node(Integer val, <span class="keyword">boolean</span> isstart) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">            <span class="keyword">this</span>.isstart = isstart;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//定义排序接口</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node Other)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.val == Other.val)&#123;<span class="comment">//如果连个节点位置相同，把结束点排在前面</span></div><div class="line">                <span class="keyword">return</span> Boolean.compare(<span class="keyword">this</span>.isstart,Other.isstart);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.val, Other.val);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countOfAirplanes</span><span class="params">(List&lt;Interval&gt; airplanes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> size = airplanes.size();</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="comment">//插入元素</span></div><div class="line">        Node[] array = <span class="keyword">new</span> Node[<span class="number">2</span> * size];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; airplanes.size(); i++) &#123;</div><div class="line">            array[<span class="number">2</span> * i] = (<span class="keyword">new</span> Node(airplanes.get(i).start, <span class="keyword">true</span>));</div><div class="line">            array[<span class="number">2</span> * i + <span class="number">1</span>] = (<span class="keyword">new</span> Node(airplanes.get(i).end, <span class="keyword">false</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//排序</span></div><div class="line">        Arrays.sort(array);</div><div class="line">        <span class="comment">//遍历</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (array[i].isstart) &#123;</div><div class="line">                count++;</div><div class="line">                <span class="keyword">if</span> (count &gt; max) &#123;</div><div class="line">                    max = count;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                count--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="252-Meeting-Rooms"><a href="#252-Meeting-Rooms" class="headerlink" title="252.Meeting Rooms"></a><a href="https://leetcode.com/problems/meeting-rooms/" target="_blank" rel="external">252.Meeting Rooms</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), determine if a person could attend all meetings.</p>
<p>For example,<br>Given <code>[[0, 30],[5, 10],[15, 20]]</code>,<br>return <code>false</code>.</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目是说判断一个人是否可以参加给出的所有的会议，可以沿用扫描线的思路：同一时刻最多只有一个会议正在召开，就可以参加所有会议。</p>
<p>还有另外一种更快的思路：</p>
<p>如果每一个会议的开始都在上一个会议结束之后，那么就不会有时间冲突的会议，就可以都参加了，所以可以将给出的所有会议的开始时间和结束时间分别放入两个数组中，分别排序，然后判断是否所有的时间满足：starts[i]&gt;ends[i-1]。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for an interval.</span></div><div class="line"><span class="comment"> * public class Interval &#123;</span></div><div class="line"><span class="comment"> *     int start;</span></div><div class="line"><span class="comment"> *     int end;</span></div><div class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></div><div class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAttendMeetings</span><span class="params">(Interval[] airplanes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span>[] starts = <span class="keyword">new</span> <span class="keyword">int</span>[airplanes.length];</div><div class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[airplanes.length];</div><div class="line"></div><div class="line">        <span class="comment">//插入元素</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; airplanes.length; i++) &#123;</div><div class="line">            starts[i] = airplanes[i].start;</div><div class="line">            ends[i] = airplanes[i].end;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//排序</span></div><div class="line">        Arrays.sort(starts);</div><div class="line">        Arrays.sort(ends);</div><div class="line"></div><div class="line">        <span class="comment">//遍历</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; starts.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (starts[i]&lt;ends[i-<span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="253-Meeting-Rooms-II"><a href="#253-Meeting-Rooms-II" class="headerlink" title="253.Meeting Rooms II"></a><a href="https://leetcode.com/problems/meeting-rooms-ii" target="_blank" rel="external">253.Meeting Rooms II</a></h2><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), find the minimum number of conference rooms required.</p>
<p>For example,<br>Given <code>[[0, 30],[5, 10],[15, 20]]</code>,<br>return <code>2</code>.</p>
</blockquote>
<p>给定一系列会议的开始和结束时间，返回所需的最大会议室数量</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<p>用扫描线模拟扫描过程，计算扫描线最多同时扫描几个区间。</p>
<p>方法二：</p>
<p>分别对会议开始和结束的时间排序，两个指针ij分别指向开始数组和结束数组，当start[i] &lt; end[j]时，i++;sum++;</p>
<p>否则j++,记录最大的sum。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>方法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for an interval.</span></div><div class="line"><span class="comment"> * public class Interval &#123;</span></div><div class="line"><span class="comment"> *     int start;</span></div><div class="line"><span class="comment"> *     int end;</span></div><div class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></div><div class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> time;</div><div class="line">        <span class="keyword">boolean</span> isStart;</div><div class="line">        Node(<span class="keyword">int</span> time,<span class="keyword">boolean</span> isStart)&#123;</div><div class="line">            <span class="keyword">this</span>.time = time;</div><div class="line">            <span class="keyword">this</span>.isStart = isStart;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</div><div class="line">        Comparator&lt;Node&gt; tmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span>(o1.time != o2.time) <span class="keyword">return</span> o1.time - o2.time;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">if</span>(o1.isStart == <span class="keyword">true</span>)&#123;</div><div class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(tmp);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intervals.length;i++)&#123;</div><div class="line">            heap.add(<span class="keyword">new</span> Node(intervals[i].start,<span class="keyword">true</span>));</div><div class="line">            heap.add(<span class="keyword">new</span> Node(intervals[i].end,<span class="keyword">false</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(!heap.isEmpty())&#123;</div><div class="line">            <span class="keyword">if</span>(heap.poll().isStart)&#123;</div><div class="line">                sum++;</div><div class="line">                max = Math.max(max,sum);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;sum--;&#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Array;</div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeetingRoomsII</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] starts = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</div><div class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intervals.length;i++)&#123;</div><div class="line">            starts[i] = intervals[i].start;</div><div class="line">            ends[i] = intervals[i].end;</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(starts);</div><div class="line">        Arrays.sort(ends);</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; starts.length &amp;&amp; j &lt; ends.length)&#123;</div><div class="line">            <span class="keyword">if</span>(starts[i] &lt; ends[j])&#123;</div><div class="line">                sum++;</div><div class="line">                i++;</div><div class="line">                max = Math.max(max,sum);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                j++;</div><div class="line">                sum--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="218-The-Skyline-Problem"><a href="#218-The-Skyline-Problem" class="headerlink" title="218.The Skyline Problem"></a><a href="https://leetcode.com/problems/the-skyline-problem" target="_blank" rel="external">218.The Skyline Problem</a></h2><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<hr>
<p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are <strong>given the locations and height of all the buildings</strong> as shown on a cityscape photo (Figure A), write a program to <strong>output the skyline</strong> formed by these buildings collectively (Figure B).</p>
<p><img src="https://leetcode.com/static/images/problemset/skyline1.jpg" alt="Buildings"> </p>
<p><img src="https://leetcode.com/static/images/problemset/skyline2.jpg" alt="Skyline Contour"></p>
<p>The geometric information of each building is represented by a triplet of integers <code>[Li, Ri, Hi]</code>, where <code>Li</code> and <code>Ri</code> are the x coordinates of the left and right edge of the ith building, respectively, and <code>Hi</code> is its height. It is guaranteed that <code>0 ≤ Li, Ri ≤ INT_MAX</code>, <code>0 &lt; Hi ≤ INT_MAX</code>, and <code>Ri - Li &gt; 0</code>. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p>
<p>For instance, the dimensions of all buildings in Figure A are recorded as: <code>[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ]</code>.</p>
<p>The output is a list of “<strong>key points</strong>“ (red dots in Figure B) in the format of <code>[ [x1,y1], [x2, y2], [x3, y3], ... ]</code> that uniquely defines a skyline. <strong>A key point is the left endpoint of a horizontal line segment</strong>. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</p>
<p>For instance, the skyline in Figure B should be represented as:<code>[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]</code>.</p>
</blockquote>
<p>题目给定每一个建筑的起始结束位置和其高度，返回建筑物构成的轮廓的拐点坐标。</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>根据观察，可以用扫描线的思路解决。</p>
<p>首先需要将建筑物的开始和结束节点及其对应的高度加入堆heap中，按照坐标从小到大进行排序，当坐标一致的时候，将结束点排在前面。</p>
<p>另外，还需要一个堆heightTemp来维护当前扫描线扫过的建筑的高度，以便迅速知道当前的最大高度。</p>
<p>接下来，将节点依次出堆模拟扫描线扫描的过程，分下面两种情况：</p>
<ol>
<li>遇到起始点:<ol>
<li>该点的高度大于当前最大高度，需要将该点坐标以及高度加入结果集，同时将高度加入heightTemp</li>
<li>该点的高度不大于当前最大高度，则只需将该点高度加入heightTemp，无需加入结果集。</li>
</ol>
</li>
<li>遇到结束点：<ol>
<li>该点高度就是当前最大高度，则需要将最大高度从heightTemp中pop出去，然后将该点坐标和pop之后的当前最大高度加入结果集。</li>
<li>该点高度小于当前最大高度，只需将该点高度从heightTemp中pop出去。</li>
</ol>
</li>
</ol>
<p>实现上面的算法之后，还不够，因为忽略了在同一个位置有多个点出现的情况，比如某个位置即是A建筑的结束也是B建筑的开始位置，将它们都加入的结果集，显然是重复的，需要筛选掉只剩一个，分如下两种情况：</p>
<ol>
<li>在某个点有多个建筑结束  —&gt; 取最后一个结束的，也就是高度最低的</li>
<li>在某个点有多个建筑开始  —&gt;  取高度最高的</li>
<li>在某个点既有建筑开始也有建筑结束，但前后高度不一样  —&gt; 取开始高度最高的</li>
<li>在某个点既有建筑开始也有建筑结束，但前后高度一样  —&gt; 不加入最终结果集</li>
</ol>
<p>基于上面的思路，可以开始写代码了</p>
<p>据说这道题还可以用线段树做，待学习。。。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheSkylineProblem</span> </span>&#123;</div><div class="line">  <span class="comment">//节点，包含坐标，高度，开始点or结束点</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> loc;</div><div class="line">        <span class="keyword">int</span> height;</div><div class="line">        <span class="keyword">boolean</span> isStart;</div><div class="line">        Node(<span class="keyword">int</span> loc,<span class="keyword">int</span> height,<span class="keyword">boolean</span> isStart) &#123;</div><div class="line">            <span class="keyword">this</span>.loc = loc;</div><div class="line">            <span class="keyword">this</span>.height = height;</div><div class="line">            <span class="keyword">this</span>.isStart = isStart;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getSkyline(<span class="keyword">int</span>[][] buildings) &#123;</div><div class="line">        List&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">      <span class="comment">//Node堆，排序依据：坐标小的优先，坐标相同的结束点优先，起始和结束相同的高度高的优先。</span></div><div class="line">       Comparator&lt;Node&gt; cmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span>(o1.loc != o2.loc)<span class="keyword">return</span> o1.loc - o2.loc;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span>(o1.isStart == o2.isStart)&#123;</div><div class="line">                        <span class="keyword">return</span> o1.height - o2.height;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">if</span>(o1.isStart==<span class="keyword">true</span>)&#123;</div><div class="line">                         <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">	<span class="comment">//最大堆，用于存放扫描线扫过的建筑的高度</span></div><div class="line">        Comparator&lt;Integer&gt; MaxCmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o2-o1;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">      <span class="comment">//堆声明</span></div><div class="line">        PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(cmp);</div><div class="line">        PriorityQueue&lt;Integer&gt; heightTemp = <span class="keyword">new</span> PriorityQueue&lt;&gt;(MaxCmp);</div><div class="line">      <span class="comment">//将给定数据点入堆</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; buildings.length;i++)&#123;</div><div class="line">            heap.add(<span class="keyword">new</span> Node(buildings[i][<span class="number">0</span>],buildings[i][<span class="number">2</span>],<span class="keyword">true</span>));</div><div class="line">            heap.add(<span class="keyword">new</span> Node(buildings[i][<span class="number">1</span>],buildings[i][<span class="number">2</span>],<span class="keyword">false</span>));</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//数据点出堆，模拟扫描过程</span></div><div class="line">        <span class="keyword">while</span> (!heap.isEmpty())&#123;</div><div class="line">            Node node = heap.poll();<span class="comment">//出堆</span></div><div class="line">            <span class="comment">//是开始节点</span></div><div class="line">            <span class="keyword">if</span>(node.isStart)&#123;</div><div class="line">                <span class="comment">//如果高于当前最大高度，将坐标和对应高度加入结果集，同时标记为开始节点</span></div><div class="line">                <span class="keyword">if</span>(heightTemp.isEmpty() || node.height &gt; heightTemp.peek())&#123;</div><div class="line">                    result.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;node.loc,node.height,<span class="number">1</span>&#125;);</div><div class="line">                    heightTemp.add(node.height);</div><div class="line">                &#125;</div><div class="line">              <span class="comment">//如果没有高于当前最大高度，仅加入当前高度对，不加入结果集</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    heightTemp.add(node.height);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//是结束节点</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//如果该节点对应的高度就是当前最大高度</span></div><div class="line">                <span class="keyword">if</span>(!heightTemp.isEmpty() &amp;&amp; node.height == heightTemp.peek())&#123;</div><div class="line">                    <span class="comment">//将最大高度从当前高度堆中弹出</span></div><div class="line">                    heightTemp.poll();</div><div class="line">                    <span class="keyword">if</span>(heightTemp.isEmpty())&#123;</div><div class="line">                        <span class="comment">//结果集中加入当前剩余的最大高度</span></div><div class="line">                        result.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;node.loc,<span class="number">0</span>,<span class="number">0</span>&#125;);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">//结果集中加入当前剩余的最大高度</span></div><div class="line">                        result.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;node.loc,heightTemp.peek(),<span class="number">0</span>&#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果该节点对应的高度小于当前最大高度，则将该高度从当前高度对中移除</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    heightTemp.remove(node.height);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//对结果集中节点进行处理，主要处理两种情况:</span></div><div class="line">      <span class="comment">//1.同一位置有多个点，包括开始点和结束点</span></div><div class="line">      <span class="comment">//2.在某一位置，有结束点和开始点，但前后高度一样</span></div><div class="line">        List&lt;<span class="keyword">int</span>[]&gt; result2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; result.size() &amp;&amp; j &lt; result.size())&#123;</div><div class="line">            <span class="keyword">int</span> maxTemp = result.get(i)[<span class="number">1</span>];</div><div class="line">          <span class="comment">//相同位置有多个节点情况</span></div><div class="line">            <span class="keyword">while</span> (j &lt; result.size() &amp;&amp; result.get(i)[<span class="number">0</span>] == result.get(j)[<span class="number">0</span>])&#123;</div><div class="line">                <span class="comment">//在结束节点中选最低的</span></div><div class="line">                <span class="keyword">if</span>(result.get(j)[<span class="number">2</span>] == <span class="number">0</span>)&#123;</div><div class="line">                    maxTemp = Math.min(maxTemp,result.get(j)[<span class="number">1</span>]);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//在开始节点中选最高的</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    maxTemp = Math.max(maxTemp,result.get(j)[<span class="number">1</span>]);</div><div class="line">                &#125;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">          <span class="comment">//如果跟前一个高度不一致，才加入最终结果集</span></div><div class="line">            <span class="keyword">if</span>(result2.isEmpty() || result2.get(result2.size()-<span class="number">1</span>)[<span class="number">1</span>] != maxTemp)&#123;</div><div class="line">                result2.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;result.get(i)[<span class="number">0</span>],maxTemp&#125;);</div><div class="line">            &#125;</div><div class="line">            i = j;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//返回最终结果集</span></div><div class="line">        <span class="keyword">return</span> result2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> sweep_line </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2017/11/16/%E3%80%90leetcode%E3%80%91%E9%A2%98%E7%9B%AE%E6%91%98%E8%A6%81/</url>
      <content type="html"><![CDATA[<p>leetcode刷题总结</p>
<a id="more"></a>
<div class="table-container">
<table>
<thead>
<tr>
<th>题目</th>
<th>题意</th>
<th>知识点</th>
<th>思路</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="external">208.Implement Trie (Prefix Tree)</a></td>
<td>实现一个Trie树模板，支持插入、搜索、前缀搜索操作</td>
<td>Trie</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="external">211.Add and Search Word - Data structure design</a></td>
<td>实现Trie树的插入、搜索，支持搜索”a.b”格式，”.”表示通配符</td>
<td>Trie+DFS</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/map-sum-pairs/" target="_blank" rel="external">677.Map Sum Pairs</a></td>
<td>单词有权重，输入前缀词，给出所有以此为前缀的词的权重之和</td>
<td>Trie+DFS</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="external">200.Number of Islands</a></td>
<td>统计中有0,1，相邻1为island，统计island个数(连通子图)</td>
<td>并查集、DFS</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/number-of-islands-ii/" target="_blank" rel="external">305.Number of Islands II</a></td>
<td>初始矩阵为0，每次随机将某一位改变成1，统计每一时刻island个数</td>
<td>并查集</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="external">130.Surrounded Regions</a></td>
<td>“XXOO”将被X包围的O改成X，处于边界的O不算被包围</td>
<td>DFS、并查集</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/graph-valid-tree/" target="_blank" rel="external">261.Graph Valid Tree</a></td>
<td>给定点集和边集，判断此图是否为树</td>
<td>并查集</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/" target="_blank" rel="external">323.Number of Connected Components in an Undirected Graph</a></td>
<td>给定点集和边集，返回连通子图个数</td>
<td>并查集</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/word-search" target="_blank" rel="external">79.Word Search</a></td>
<td>给一个字母矩阵和一个单词，查找字母矩阵中是否有该单词</td>
<td>回溯+BFS</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="external">212.Word Search II</a></td>
<td>给一个字母矩阵和一个单词数组，返回数组，里面包含出现在矩阵中的所有单词</td>
<td>Trie+DFS</td>
<td></td>
</tr>
<tr>
<td><a href="http://www.lintcode.com/zh-cn/problem/number-of-airplanes-in-the-sky/" target="_blank" rel="external">lintcode391. 数飞机</a></td>
<td>给定一些区间，求同一时刻空中最多有多少飞机</td>
<td>扫描线</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/meeting-rooms/" target="_blank" rel="external">252.Meeting Rooms</a></td>
<td>给定一些区间，判断是否可以参加所有会议（所有会议没有冲突）</td>
<td>排序扫描/扫描线</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/meeting-rooms-ii" target="_blank" rel="external">253.Meeting Rooms II</a></td>
<td>给定一些区间，求最多需要多少间会议室（最多有多少会议同时开）</td>
<td>扫描线</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/trapping-rain-water" target="_blank" rel="external">42.Trapping Rain Water</a></td>
<td>一维接雨水</td>
<td>双指针</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/trapping-rain-water-ii" target="_blank" rel="external">407.Trapping Rain Water II</a></td>
<td>二维接雨水</td>
<td>堆</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/unique-paths" target="_blank" rel="external">62.Unique Paths</a></td>
<td>从网格左上角走到右下角有多少种方案</td>
<td>DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/unique-paths-ii" target="_blank" rel="external">63.Unique Paths II</a></td>
<td>从网格左上角走到右下角有多少种方案，有一些障碍点</td>
<td>DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/triangle" target="_blank" rel="external">120.Triangle</a></td>
<td>给定一个三角形，求从顶端走到最下面的最短路径</td>
<td>DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/climbing-stairs" target="_blank" rel="external">70.Climbing Stairs</a></td>
<td>爬楼梯，每次只可以爬一步或者两步，求爬到顶有多少种方案</td>
<td>DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/jump-game" target="_blank" rel="external">55.Jump Game</a></td>
<td></td>
<td>贪心法</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/jump-game-ii" target="_blank" rel="external">45.Jump Game II</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="external">145.Binary Tree Postorder Traversal</a></td>
<td>二叉树的后续遍历</td>
<td>DFS、递归、回溯</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="external">94.Binary Tree Inorder Traversal</a></td>
<td>二叉树的中续遍历</td>
<td>DFS、递归、回溯</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="external">144.Binary Tree Preorder Traversal</a></td>
<td>二叉树的前续遍历</td>
<td>DFS、递归、回溯</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="external">226.Invert Binary Tree</a></td>
<td>二叉树对称翻转</td>
<td>分治法、递归</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="external">100.Same Tree</a></td>
<td>判断两个二叉树是否相同</td>
<td>递归</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="external">236.Lowest Common Ancestor of a Binary Tree</a></td>
<td>求二叉树中两个节点的最近公共祖先</td>
<td>分治法、递归</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="external">110.Balanced Binary Tree</a></td>
<td>给定一个二叉树，判断是否是平衡二叉树</td>
<td>递归</td>
<td>额外resultTypt判断是否平衡以及最大深度差</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="external">104.Maximum Depth of Binary Tree</a></td>
<td>给定二叉树，求其最大深度</td>
<td>分治法、递归</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/interleaving-string/" target="_blank" rel="external">97.Interleaving String</a></td>
<td>给定三个字符串s1,s2,s3,返回s3是否能够由s1和s2组成，s1,s2中字母顺序不变</td>
<td>序列型DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/distinct-subsequences/" target="_blank" rel="external">115.Distinct Subsequences</a></td>
<td>给定字符串S和T，从S中选取字母构成T共有多少种方案</td>
<td>序列型DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="external">72.Edit Distance</a></td>
<td>给定两字符串s1,s2和三种操作：插入、删除、替换，最少经过多少步操作可以使得s1和s2一样</td>
<td>序列型DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/palindromic-substrings/" target="_blank" rel="external">647.Palindromic Substrings</a></td>
<td>给定一个字符串，返回其中回文串个数</td>
<td>序列型DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/palindrome-partitioning-ii/" target="_blank" rel="external">132.Palindrome Partitioning II</a></td>
<td>给定一个字符串，最少切几刀可以使每一段都是回文串</td>
<td>序列型DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/word-break/" target="_blank" rel="external">139.Word Break</a></td>
<td>给定一个字符串和一个单词表，返回字符串是否可以切割成全部由单词表中的单词组成</td>
<td>序列型DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/increasing-triplet-subsequence/" target="_blank" rel="external">334.Increasing Triplet Subsequence</a></td>
<td>给定一个数组，返回是否有递增的三元组</td>
<td>两指针</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="external">300.Longest Increasing Subsequence</a></td>
<td>给定一个序列，求其最长递增子序列的长度</td>
<td>坐标型DP</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><div class="table-container">
<table>
<thead>
<tr>
<th>题目</th>
<th>题意</th>
<th>知识点</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.com/problems/powx-n" target="_blank" rel="external">50.Pow(x, n)</a></td>
<td>求x的n次方</td>
<td>二分法+递归</td>
<td>int -&gt;long</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/divide-two-integers/" target="_blank" rel="external">29.Divide Two Integers</a></td>
<td>求两个数相除a/b</td>
<td>二分搜索。找到最大的x：x*b &lt;= a</td>
<td>边界条件-2147483648/-1</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="external">287.Find the Duplicate Number</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><div class="table-container">
<table>
<thead>
<tr>
<th>题目</th>
<th>题意</th>
<th>知识点</th>
<th>思路</th>
<th>难易</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="external">328.Odd Even Linked List</a></td>
<td>给定链表，将偶数位放置在链表后，奇数位偶数位数字相对位置保持不变</td>
<td>链表</td>
<td></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="external">234Palindrome Linked List</a></td>
<td>判断链表是否是回文串</td>
<td>回文，链表</td>
<td>1.找到链表中位数，将后半段反转，对比前后元素是否一致<br>2.利用stack，将前一半存起来，继续 向后扫描与stack中元素对比</td>
<td>难</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="external">160.Intersection of Two Linked Lists</a></td>
<td>找到两链表AA和B相交的位置</td>
<td>链表</td>
<td>两个指针分别遍历，一个先A后B，一个先B后A，两指针指向节点相等即为相交处</td>
<td>技巧题</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/insertion-sort-list/" target="_blank" rel="external">147.Insertion Sort List</a></td>
<td>链表的插入排序</td>
<td>链表、插入排序</td>
<td>建dummy节点，原链表元素按序插入dummy节点开头的链表</td>
<td>技巧+中等</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="external">24.Swap Nodes in Pairs</a></td>
<td>从前向后，两两交换链表节点</td>
<td>链表、交换</td>
<td>从前向后遍历，两两交换</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/remove-linked-list-elements/" target="_blank" rel="external">203.Remove Linked List Elements</a></td>
<td>给定链表和val，删除链表中所有值为val的元素</td>
<td>链表、删除节点</td>
<td>遍历，删除</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="external">2.Add Two Numbers</a></td>
<td>给定两个链表表示两个数字，位数由低到高，返回链表表示两个链表的和</td>
<td>链表</td>
<td>遍历相加，记录进位</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/add-two-numbers-ii/" target="_blank" rel="external">445.Add Two Numbers II</a></td>
<td>给定两个链表表示两个数字，位数由高到低，返回链表表示两个链表的和</td>
<td>链表、反转</td>
<td>反转-&gt;相加-&gt;反转</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="external">109.Convert Sorted List to Binary Search Tree</a></td>
<td></td>
<td></td>
<td></td>
<td>难</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/plus-one-linked-list/" target="_blank" rel="external">369.Plus One Linked List</a></td>
<td>给定链表代表一个数字，由高位到低位，返回该数字+1链表</td>
<td>链表、反转</td>
<td>1.反转-&gt;相加-&gt;反转<br>2.递归<br>3.技巧：找从后向前第一个不为9的元素+1，后面9置0</td>
<td>简单+技巧</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/split-linked-list-in-parts/" target="_blank" rel="external">725.Split Linked List in Parts</a></td>
<td>给定一个链表和数字k，将链表分为k段，每段长度差不大于1，长的放前面</td>
<td>链表</td>
<td>1.求链表长度len<br>2.m = len/k,n = len%k<br>3.前n个链表长度为m+1，其余长度为m</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="external">25.Reverse Nodes in k-Group</a></td>
<td>给定链表和数字k，将链表分组，每组k个元素，按组反转</td>
<td>链表、反转</td>
<td>两指针指向分组头和尾，将头和尾之间的链表反转</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="external">109.Convert Sorted List to Binary Search Tree</a></td>
<td>链表转为高度平衡搜索二叉树</td>
<td>链表、二叉搜索树</td>
<td>递归，中点做为root，对左链表和右链表递归调用构建BST</td>
<td>中等</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><div class="table-container">
<table>
<thead>
<tr>
<th>题目</th>
<th>题意</th>
<th>知识点</th>
<th>思路</th>
<th>难易</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.com/problems/merge-sorted-array" target="_blank" rel="external">88.Merge Sorted Array</a></td>
<td>合并两个有序数组到第一个数组</td>
<td>数组</td>
<td>从后向前遍历，比较大小依次从后向前插入nums1</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/intersection-of-two-arrays" target="_blank" rel="external">349.Intersection of Two Arrays</a></td>
<td>找两个数组交集，去重</td>
<td>排序、hashmap</td>
<td>1.排序<br>2.两指针遍历</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii" target="_blank" rel="external">350.Intersection of Two Arrays II</a></td>
<td>找两个数组交集</td>
<td>排序、hashmap</td>
<td>1.排序<br>2.两指针遍历</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/sparse-matrix-multiplication" target="_blank" rel="external">311.Sparse Matrix Multiplication</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h1 id="Two-Pointers"><a href="#Two-Pointers" class="headerlink" title="Two Pointers"></a>Two Pointers</h1><div class="table-container">
<table>
<thead>
<tr>
<th>题目</th>
<th>题意</th>
<th>知识点</th>
<th>思路</th>
<th>难易</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.com/problems/sort-transformed-array/" target="_blank" rel="external">360.Sort Transformed Array</a></td>
<td>给定有序数组，计算ax^2+bx+c，返回结果依然有序</td>
<td>two pointers</td>
<td>根据二次函数性质，a&gt;0先减后增，比较两指针，从后向前插入，a&lt;0反之</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/max-consecutive-ones" target="_blank" rel="external">485.Max Consecutive Ones</a></td>
<td>给定数组有0有1，返回连续1的最大长度</td>
<td>two pointers</td>
<td>两指针滑窗，记录当前最大长度，遇到0跳过重新开始</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/max-consecutive-ones-ii" target="_blank" rel="external">487.Max Consecutive Ones II</a></td>
<td>给定数组有0有1，最多可以把一个0变成1，返回连续1的最大长度</td>
<td>two pointers</td>
<td>两指针滑窗，记录窗口内0的个数，超过1缩小窗口大小，记录滑窗最大长度</td>
<td>简单</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班】课程笔记2——Trie树]]></title>
      <url>/2017/11/14/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91Trie%E6%A0%91/</url>
      <content type="html"><![CDATA[<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="leetcode相关题目"><a href="#leetcode相关题目" class="headerlink" title="leetcode相关题目"></a>leetcode相关题目</h2><ul>
<li><del><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="external">Add and Search Word - Data structure design</a></del></li>
<li><del><a href="https://leetcode.com/problems/map-sum-pairs/" target="_blank" rel="external">Map Sum Pairs</a></del></li>
<li><del><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="external">Word Search II</a></del></li>
<li>​</li>
</ul>
<h2 id="Trie字典树"><a href="#Trie字典树" class="headerlink" title="Trie字典树"></a>Trie字典树</h2><p>源自单词：retrieve</p>
<p>Trie树，即字典树/前缀树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。</p>
<p>假设有[b，abc，abd，bcd，abcd，efg，hii ]这6个单词 , 查找abc 在不在字典里面</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-17-49-17.png" alt=""> </p>
<p>将单词插入Trie树，只在跟之前的字符串出现分歧时分裂，对最后一个字母做标记，这样查找的时候，根据最后一个字母的标记，即可判断出该单词是否出现过。</p>
<p>这里有一个巧妙的操作，可以让插入和查询操作同时完成，所以查询的时间复杂度简化为所要查询的单词的长度，即<script type="math/tex">O(1)</script>。</p>
<a id="more"></a>
<p>它有3个基本性质：</p>
<ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<h2 id="hash和trie的比较"><a href="#hash和trie的比较" class="headerlink" title="hash和trie的比较"></a>hash和trie的比较</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>hash_table</th>
<th>TIRE树</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找时间复杂度</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td></td>
<td>优于hash_table</td>
</tr>
</tbody>
</table>
</div>
<p>对于a,aa,aaa,aaaa的情况</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>hash</th>
<th>trie</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储</td>
<td>10个a</td>
<td>5个a节点</td>
</tr>
<tr>
<td>可用操作</td>
<td>有/无/查询</td>
<td>有/无/前缀查询</td>
</tr>
<tr>
<td></td>
<td>1行</td>
<td>75~100行</td>
</tr>
</tbody>
</table>
</div>
<p>所以选择hash原因是代码量小, 但是涉及到前缀查询的时候, 考虑trie树</p>
<h2 id="什么时候更适合用trie树"><a href="#什么时候更适合用trie树" class="headerlink" title="什么时候更适合用trie树"></a>什么时候更适合用trie树</h2><p>一个一个字符串遍历的时候。</p>
<p>需要节约空间</p>
<p>查找前缀</p>
<h2 id="Trie模板"><a href="#Trie模板" class="headerlink" title="Trie模板"></a>Trie模板</h2><p>有两种方式来实现Trie树，对于存储char类型的Trie树，因为只有26个字母，故可采用映射的方式将字母映射到长度为26的数组上，而下标就是字母。</p>
<p>而对于其他类型，比如int数目未知，可以考虑用hashmap的方式来实现。</p>
<h3 id="1-hashmap实现Trie树"><a href="#1-hashmap实现Trie树" class="headerlink" title="1. hashmap实现Trie树"></a>1. hashmap实现Trie树</h3><p>c++版：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">char</span> ch;</div><div class="line">	<span class="keyword">bool</span> istail;</div><div class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childern;</div><div class="line"></div><div class="line">	TrieNode() &#123;</div><div class="line">		childern = <span class="keyword">new</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;();</div><div class="line">		<span class="comment">//childern = NULL;</span></div><div class="line">		istail = <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	TrieNode(<span class="keyword">char</span> c) &#123;</div><div class="line">		ch = c;</div><div class="line">		childern = <span class="keyword">new</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;();</div><div class="line">		<span class="comment">//childern = NULL;</span></div><div class="line">		istail = <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	TrieNode* root;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="comment">/** Initialize your data structure here. */</span></div><div class="line">	Trie() &#123;</div><div class="line">		root = <span class="keyword">new</span> TrieNode();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/** Inserts a word into the trie. */</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</div><div class="line">		TrieNode* node = <span class="keyword">this</span>-&gt;root;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++) &#123;</div><div class="line">			<span class="keyword">char</span> chtemp = word[i];</div><div class="line">			<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childrenmap = node-&gt;childern;</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (!(*childrenmap).empty()) &#123;</div><div class="line">				<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;::iterator iter;</div><div class="line">				iter = (*childrenmap).find(chtemp);</div><div class="line">				<span class="keyword">if</span> (iter != (*childrenmap).end()) &#123;<span class="comment">//包含此字母</span></div><div class="line">					node = iter-&gt;second;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					TrieNode* newnode = <span class="keyword">new</span> TrieNode(chtemp);</div><div class="line">					(*childrenmap).insert(make_pair(chtemp, newnode));</div><div class="line">					node = newnode;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt; newmap;</div><div class="line">				TrieNode *newnode = <span class="keyword">new</span> TrieNode(chtemp);</div><div class="line">				(*childrenmap).insert(make_pair(chtemp, newnode));</div><div class="line">				node = newnode;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		node-&gt;istail = <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/** Returns if the word is in the trie. */</span></div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (word.size() == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">		TrieNode* node = root;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++) &#123;</div><div class="line">			<span class="keyword">char</span> chtemp = word[i];</div><div class="line">			<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childrenmap = node-&gt;childern;</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (!(*childrenmap).empty()) &#123;</div><div class="line">				<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;::iterator iter;</div><div class="line">				iter = (*childrenmap).find(chtemp);</div><div class="line">				<span class="keyword">if</span> (iter != (*childrenmap).end()) &#123;<span class="comment">//包含此字母</span></div><div class="line">					node = iter-&gt;second;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;<span class="comment">//不包含此字母</span></div><div class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;<span class="comment">//children为空</span></div><div class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (node-&gt;ch == word[word.size() - <span class="number">1</span>] &amp;&amp; node-&gt;istail) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</div><div class="line">		TrieNode* node = root;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.size(); i++) &#123;</div><div class="line">			<span class="keyword">char</span> chtemp = prefix[i];</div><div class="line">			<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childrenmap = node-&gt;childern;</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (!(*childrenmap).empty()) &#123;</div><div class="line">				<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;::iterator iter;</div><div class="line">				iter = (*childrenmap).find(chtemp);</div><div class="line">				<span class="keyword">if</span> (iter != (*childrenmap).end()) &#123;<span class="comment">//包含此字母</span></div><div class="line">					node = iter-&gt;second;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;<span class="comment">//不包含此字母</span></div><div class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;<span class="comment">//children空</span></div><div class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>java版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        HashMap&lt;Character,TrieNode&gt; children;</div><div class="line">        <span class="keyword">boolean</span> istail;</div><div class="line">        TrieNode()&#123;</div><div class="line">            children = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            <span class="keyword">this</span>.istail=<span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</div><div class="line">        TrieNode root;</div><div class="line">        Trie()&#123;</div><div class="line">            root = <span class="keyword">new</span> TrieNode();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</div><div class="line">            TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt;word.length();i++) &#123;</div><div class="line">                <span class="keyword">char</span> chtemp = word.charAt(i);</div><div class="line">                <span class="keyword">if</span> (node.children.containsKey(chtemp)) &#123;<span class="comment">//已经包含此字母</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//不包含此字母</span></div><div class="line">                    node.children.put(chtemp, <span class="keyword">new</span> TrieNode());</div><div class="line">                &#125;</div><div class="line">                node = node.children.get(chtemp);</div><div class="line">            &#125;</div><div class="line">            node.istail=<span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(word.isEmpty())&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; word.length();i++)&#123;</div><div class="line">                <span class="keyword">char</span> chtemp = word.charAt(i);</div><div class="line">                <span class="keyword">if</span>(node.children.containsKey(chtemp)) &#123;<span class="comment">//包含此字母</span></div><div class="line">                    node = node.children.get(chtemp);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(node.istail)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span> (prefix.isEmpty())&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prefix.length();i++)&#123;</div><div class="line">                <span class="keyword">if</span>(node.children.containsKey(prefix.charAt(i)))&#123;</div><div class="line">                    node = node.children.get(prefix.charAt(i));</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<h3 id="2-数组实现Trie树"><a href="#2-数组实现Trie树" class="headerlink" title="2. 数组实现Trie树"></a>2. 数组实现Trie树</h3><p>对于char类型的数据，只有26个字母，所以，可以用一个长度为26的数组存储后续的节点，数组index对应的就是字母的顺序：a~z</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="keyword">boolean</span> istail;<span class="comment">//记录是否是某个单词的末尾</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="keyword">this</span>.istail=<span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[word.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.istail=<span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(node.istail) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; prefix.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[prefix.charAt(i)-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[prefix.charAt(i)-<span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="leetcode相关题目-1"><a href="#leetcode相关题目-1" class="headerlink" title="leetcode相关题目"></a>leetcode相关题目</h2><h3 id="Add-and-Search-Word-Data-structure-design"><a href="#Add-and-Search-Word-Data-structure-design" class="headerlink" title="Add and Search Word - Data structure design"></a><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="external">Add and Search Word - Data structure design</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Design a data structure that supports the following two operations:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; void addWord(word)</div><div class="line">&gt; bool search(word)</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>search(word) can search a literal word or a regular expression string containing only letters <code>a-z</code> or <code>.</code>. A <code>.</code> means it can represent any one letter.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; addWord(&quot;bad&quot;)</div><div class="line">&gt; addWord(&quot;dad&quot;)</div><div class="line">&gt; addWord(&quot;mad&quot;)</div><div class="line">&gt; search(&quot;pad&quot;) -&gt; false</div><div class="line">&gt; search(&quot;bad&quot;) -&gt; true</div><div class="line">&gt; search(&quot;.ad&quot;) -&gt; true</div><div class="line">&gt; search(&quot;b..&quot;) -&gt; true</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用Tire树，搜索时遇到”.”对所有节点进行DFS</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="keyword">boolean</span> istail;<span class="comment">//记录是否是某个单词的末尾</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="keyword">this</span>.istail=<span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root;</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDictionary</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Adds a word into the data structure. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[word.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.istail=<span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchHelper</span><span class="params">(String word,<span class="keyword">int</span> startIdx,TrieNode node)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIdx ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(word.charAt(i) == <span class="string">'.'</span>)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>;j++) &#123;</div><div class="line">                    <span class="keyword">if</span> (node.children[j] != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">//TrieNode nodetemp = node.children[j];</span></div><div class="line">                        <span class="keyword">boolean</span> has = searchHelper(word, i + <span class="number">1</span>, node.children[j]);</div><div class="line">                        <span class="keyword">if</span> (has) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                        <span class="keyword">else</span> <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(node.istail) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> searchHelper(word,<span class="number">0</span>,<span class="keyword">this</span>.root);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * WordDictionary obj = new WordDictionary();</span></div><div class="line"><span class="comment"> * obj.addWord(word);</span></div><div class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure>
<h3 id="Map-Sum-Pairs"><a href="#Map-Sum-Pairs" class="headerlink" title="Map Sum Pairs"></a><a href="https://leetcode.com/problems/map-sum-pairs/" target="_blank" rel="external">Map Sum Pairs</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Implement a MapSum class with <code>insert</code>, and <code>sum</code> methods.</p>
<p>For the method <code>insert</code>, you’ll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.</p>
<p>For the method <code>sum</code>, you’ll be given a string representing the prefix, and you need to return the sum of all the pairs’ value whose key starts with the prefix.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: insert(&quot;apple&quot;, 3), Output: Null</div><div class="line">&gt; Input: sum(&quot;ap&quot;), Output: 3</div><div class="line">&gt; Input: insert(&quot;app&quot;, 2), Output: Null</div><div class="line">&gt; Input: sum(&quot;ap&quot;), Output: 5</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>建立Trie树，将原来的标记是否为单词结尾的bool型属性改为int型权重属性，单词结尾的字母值为该单词的权重值，其余字母权重设为0，找到前缀所在分支之后，DFS该前缀词下面的所有节点，累加权重值。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="keyword">int</span> weight;<span class="comment">//记录是否是某个单词的末尾</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="keyword">this</span>.weight = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root;</div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; key.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[key.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[key.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[key.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.weight=val;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TrieNode node)</span></span>&#123;</div><div class="line">        res = res+node.weight;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[i]!=<span class="keyword">null</span>)&#123;</div><div class="line">                dfs(node.children[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; prefix.length();i++) &#123;</div><div class="line">            <span class="keyword">if</span> (node.children[prefix.charAt(i) - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[prefix.charAt(i) - <span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        res=<span class="number">0</span>;</div><div class="line">        dfs(node);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your MapSum object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * MapSum obj = new MapSum();</span></div><div class="line"><span class="comment"> * obj.insert(key,val);</span></div><div class="line"><span class="comment"> * int param_2 = obj.sum(prefix);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure>
<h3 id="Word-Search-II"><a href="#Word-Search-II" class="headerlink" title="Word Search II"></a><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="external">Word Search II</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>
<p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<p>For example,<br>Given <strong>words</strong> = <code>[&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</code> and <strong>board</strong> =</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;],</div><div class="line">&gt;   [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;],</div><div class="line">&gt;   [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;],</div><div class="line">&gt;   [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Return </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [&quot;eat&quot;,&quot;oath&quot;]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>Word Search 1要求我们返回某一个单词是否在矩阵中，Word Search 2作为升级版。给出了一串单词，搜索是否在矩阵中，如果一个一个搜索效率会很低，尤其是在要搜索的单词序列中有大量相同的前缀时，所以，考虑<strong>将搜索的单词序列构建Trie树，然后再在字母矩阵中用DFS的方式搜索</strong>。</p>
<p>然而想到了思路，要想完整地写出这道题，也十分艰难。</p>
<p>这里有几个需要注意的点：</p>
<ol>
<li><p>要将能够搜索到的单词加入最终的结果表中，可以适当修改Trie的结构，在叶子节点存储该条路径对应的word，方便后续找到路径之后将该单词加入结果表</p>
</li>
<li><p>已经用过的字母不能用第二次，所以要对字母矩阵中遍历过的字母做标记，DFS搜索结束后要恢复标记，后面还可以继续使用。这里我一开始用的方法是额外建立一个boolean型矩阵进行存储，看了大神的代码发现可以直接在原字母矩阵中进行标记即可。</p>
</li>
<li><p>在矩阵中某点周围寻找下一个字母是否存在时，我一开始采用的方式是：</p>
<p>在Trie树中遍历下一层node中的字母然后再去字母矩阵中某点周围四个点搜索，这样遍历下一层node判断是否还有字母，每次需要遍历26个字母，看了大神的代码有更好的方式：</p>
<p>从矩阵当前点周围的四个点入手，获取周围四个点的字母（实际上最多是三个，因为至少已经有一个被访问了），然后再去node中直接获取下层节是否存在该字母即可。</p>
</li>
</ol>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="comment">//boolean istail;//记录是否是某个单词的末尾</span></div><div class="line">        String word;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="comment">//this.istail=false;</span></div><div class="line">            <span class="keyword">this</span>.word = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root = <span class="keyword">new</span> TrieNode();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[word.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.word = word;</div><div class="line">        <span class="comment">//node.istail=true;</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchBoard</span><span class="params">(<span class="keyword">char</span>[][] board, TrieNode node,<span class="keyword">int</span> x_idx,<span class="keyword">int</span> y_idx,List&lt;String&gt; result)</span></span>&#123;</div><div class="line">        <span class="keyword">char</span> ch = board[x_idx][y_idx];</div><div class="line">        <span class="keyword">if</span>(ch == <span class="string">'#'</span> || node.children[ch-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        node = node.children[ch-<span class="string">'a'</span>];</div><div class="line">        <span class="keyword">if</span>(node.word != <span class="keyword">null</span>)&#123;</div><div class="line">            result.add(node.word);</div><div class="line">            node.word = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        board[x_idx][y_idx] = <span class="string">'#'</span>;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">4</span>;i++)&#123;</div><div class="line">            <span class="keyword">int</span> x = x_idx+x_delta[i];</div><div class="line">            <span class="keyword">int</span> y = y_idx+y_delta[i];</div><div class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt; board.length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].length)&#123;</div><div class="line">                searchBoard(board,node,x,y,result);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        board[x_idx][y_idx] = ch;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length;i++)&#123;</div><div class="line">            insert(words[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board.length;j++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; board[<span class="number">0</span>].length;k++)&#123;</div><div class="line">                searchBoard(board,root,j,k,result);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Trie </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Logistic Regression相关]]></title>
      <url>/2017/11/06/Logistic-Regression%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>LR真的很基础而且也非常非常重要，算法面试必考，啃了好多遍，总结一下，希望能够经常复习。</p>
<p>暑假去头条面试，一面的面试官问到：</p>
<ol>
<li>推导一下LR吧</li>
<li>为什么要用sigmod函数</li>
<li>如何优化求解（梯度下降）</li>
<li>代码实现一下</li>
</ol>
<a id="more"></a>
<h2 id="LR模型推导"><a href="#LR模型推导" class="headerlink" title="LR模型推导"></a>LR模型推导</h2><h2 id="梯度下降求解LR"><a href="#梯度下降求解LR" class="headerlink" title="梯度下降求解LR"></a>梯度下降求解LR</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2>]]></content>
      
        <categories>
            
            <category> machine learning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LR </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【神经网络和深度学习】课程笔记1]]></title>
      <url>/2017/11/06/%E3%80%90%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班】课程笔记2——并查集]]></title>
      <url>/2017/11/05/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      <content type="html"><![CDATA[<h1 id="Union-Find并查集"><a href="#Union-Find并查集" class="headerlink" title="Union Find并查集"></a>Union Find并查集</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><strong>一种用来解决集合查询合并的数据结构</strong></p>
<p>假如A、B、C三人在Microsoft工作，D、E、F、G四人在Linkedin工作，给七个人都分发一个工牌，上面写着自己的公司名字，告诉他们自己的老大是哪家公司，则可以表示成如下形式。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-10-31.png" alt=""></p>
<p>如果A遇到F，看一眼对方的工牌，跟自己是不是一个boss，就知道对方是不是跟自己是同一家公司的人了。</p>
<p>如果有一天M公司把L公司收购了，那么此时，需要对两个公司的员工进行合并操作，给员工分发新的工牌，为了减少重新分配的麻烦，就把L的boss指向M，此时L下面的员工最大的boss是M了，那么A和E就在一个阵营了。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-15-16.png" alt=""></p>
<p>如果在M公司三个员工和L公司四个员工中分别选出一个作为该公司的boss，可以表示成如下形式：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-14-34.png" alt=""></p>
<p>那么合并之后，J的boss设置为B，此时大家都是一个阵营的了。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-14-45.png" alt=""></p>
 <a id="more"></a>
<h2 id="并查集的精髓"><a href="#并查集的精髓" class="headerlink" title="并查集的精髓"></a><strong>并查集的精髓</strong></h2><p>一共包含三个操作</p>
<ol>
<li><p>初始化</p>
<p>初始化操作中，每个元素的boss指向自己.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">HashMap&lt;Integer,Integer&gt; father = <span class="keyword">new</span> HashMap&lt;integer,integer&gt;();</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">    father.put(nums[i],nums[i]);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>查找</p>
<p>查找元素所在的集合，也就是最大的boss。</p>
<p>如果要判断两个点是否属于同一个集合，就看这两个点的boss是否是同一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> parent = x;</div><div class="line">  <span class="keyword">while</span>(parent!=father.get(parent))&#123;</div><div class="line">    parent = fater.get(parent);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> parent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度：<script type="math/tex">O(n)</script></p>
</li>
<li><p>合并</p>
<p>两个不想交的集合，其中一个的大boss认另一个为boss。</p>
<p>找到两个元素的boss，如果不是同一个，就把一个的boss指向另一个的boss。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> fa_x = find(x);</div><div class="line">  <span class="keyword">int</span> fa_y = find(y);</div><div class="line">  <span class="keyword">if</span>(fa_x != f_y)&#123;</div><div class="line">    father.put(fa_X,fa_y);<span class="comment">//合并两个boss</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度：<script type="math/tex">O(n)</script></p>
</li>
</ol>
<h2 id="并查集的优化"><a href="#并查集的优化" class="headerlink" title="并查集的优化"></a><strong>并查集的优化</strong></h2><p>baseline的find流程：</p>
<p>如果有这样一条路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">A--&gt;B--&gt;C--&gt;D--&gt;E--&gt;F</div></pre></td></tr></table></figure>
<p>查找A的boss时，需要遍历整个路径，寻找B、C、D时还需要再遍历一次，这显然是大量重复的工作，所以我们可以把一次遍历途中经过的节点都直接指向boss，下次再查询的时候，时间复杂的就是<script type="math/tex">O(1)</script>了，这就是<strong>带路径压缩的并查集</strong>的查找：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-41-32.png" alt=""></p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-42-34.png" alt=""></p>
<p>平均时间复杂度降至<script type="math/tex">O(1)</script></p>
<h2 id="并查集模板-c-版"><a href="#并查集模板-c-版" class="headerlink" title="并查集模板(c++版)"></a>并查集模板(c++版)</h2><ol>
<li><p>hash_map实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; father;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">//初始化并查集</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; elements)</span></span>&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; elements.size();i++)&#123;</div><div class="line">                father.insert(make_pair(elements[i],elements[i]));</div><div class="line">            &#125;    </div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//并查集中插入操作，不支持删除</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> x_fa)</span></span>&#123;</div><div class="line">            father.insert(make_pair(x,x_fa));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//在并查集中查找元素的boss</span></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findfather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> parent = x;</div><div class="line">            <span class="keyword">while</span>(father[parent] != parent)&#123;</div><div class="line">                parent = father[parent];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//带路径压缩的并查集</span></div><div class="line">            <span class="keyword">while</span>(father.find(x)-&gt;second != x)&#123;</div><div class="line">                x = father[x];</div><div class="line">                father[x] = parent;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> parent;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//合并两个元素</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionset</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> x_father = findfather(x);</div><div class="line">            <span class="keyword">int</span> y_father = findfather(y);</div><div class="line">            <span class="keyword">if</span>(x_father != y_father)&#123;</div><div class="line">                father[y_father] = x_father;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//计算并查集中有多少个不想交的子集合</span></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">countsets</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; father_set;</div><div class="line">            <span class="keyword">for</span>(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator iter = father.begin();iter != father.end();iter++)&#123;</div><div class="line">                <span class="keyword">int</span> parent = findfather(iter-&gt;first);</div><div class="line">                iter-&gt;second = parent;</div><div class="line">                father_set.insert(parent);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> father_set.size();</div><div class="line">        &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>vector实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//用vector定义并查集，index就是元素值</div><div class="line">class UnionFind&#123;</div><div class="line">    private:</div><div class="line">        vector&lt;int&gt; father;</div><div class="line">    public:</div><div class="line">        //初始化并查集</div><div class="line">        void initial(int n)&#123;</div><div class="line">            father.resize(n,-1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //并查集中更新操作</div><div class="line">        void fresh(int x,int x_fa)&#123;</div><div class="line">            father[x] = x_fa;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //在并查集中查找元素的boss</div><div class="line">        int findfather(int x)&#123;</div><div class="line">            int parent = x;</div><div class="line">            while(father[parent] != parent)&#123;</div><div class="line">                parent = father[parent];</div><div class="line">            &#125;</div><div class="line">            //带路径压缩的并查集</div><div class="line">            while(father[x] != x)&#123;</div><div class="line">                father[x] = parent;</div><div class="line">                x = father[x];</div><div class="line">            &#125;</div><div class="line">            return parent;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //合并两个元素</div><div class="line">        void unionset(int x,int y)&#123;</div><div class="line">            int x_father = findfather(x);</div><div class="line">            int y_father = findfather(y);</div><div class="line">            if(x_father != y_father)&#123;</div><div class="line">                father[y_father] = x_father;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //计算并查集中有多少个不想交的子集合</div><div class="line">        int countsets()&#123;</div><div class="line">            unordered_set&lt;int&gt; father_set;</div><div class="line">            for(int i = 0; i &lt; father.size();i++)&#123;</div><div class="line">                if(father[i]!=-1)&#123;</div><div class="line">                    int fathertemp = findfather(father[i]);</div><div class="line">                    if(fathertemp!=-1)&#123;</div><div class="line">                        father_set.insert(fathertemp);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return father_set.size();</div><div class="line">        &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>用vector会比hashmap快，但如果数据很稀疏，空间复杂度会比较高。</p>
</li>
</ol>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul>
<li><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="external"><del>leetcode200. Number of Islands</del></a></li>
<li><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/description/" target="_blank" rel="external"><del>leetcode323. Number of Connected Components in an Undirected Graph</del></a></li>
<li><a href="https://leetcode.com/problems/number-of-islands-ii/description/" target="_blank" rel="external"><del>leetcode305. Number of Islands II</del></a></li>
<li><a href="https://leetcode.com/problems/graph-valid-tree/description/" target="_blank" rel="external"><del>leetcode261. Graph Valid Tree</del></a></li>
<li><a href="https://leetcode.com/problems/surrounded-regions/description/" target="_blank" rel="external"><del>leetcode130. Surrounded Regions</del></a></li>
<li><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="external">leetcode128. Longest Consecutive Sequence</a></li>
<li><a href="https://leetcode.com/problems/friend-circles/" target="_blank" rel="external">leetcode547. Friend Circles</a></li>
</ul>
<h3 id="leetcode200-Number-of-Islands"><a href="#leetcode200-Number-of-Islands" class="headerlink" title="leetcode200. Number of Islands"></a>leetcode200. Number of Islands</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 11110</div><div class="line">&gt; 11010</div><div class="line">&gt; 11000</div><div class="line">&gt; 00000</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Answer: 1</p>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 11000</div><div class="line">&gt; 11000</div><div class="line">&gt; 00100</div><div class="line">&gt; 00011</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Answer: 3</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题目的意思是说矩阵中的1代表陆地，0代表海洋，如果某个1的上或下或左或右也是1的话，就是属于同一片陆地，要求矩阵中陆地的个数。也就是找出矩阵中连接子图的个数。</p>
<p>有两种思路：</p>
<ol>
<li><p>并查集</p>
<p>找出矩阵中子图的个数，可以利用并查集，在每个点附近做查找和合并操作，如果其周围有1，就讲其归为一类，最后返回并查集的集合个数就是所求的。</p>
<p>并查集处理二维矩阵时索引比较麻烦，所以这里需要先将二维坐标转化为一维并查集坐标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">矩阵维度：m*n</div><div class="line">二维坐标：(i,j) --&gt; 一维坐标：x*n+j</div><div class="line">一维坐标：idx     --&gt; 二维坐标：(idx/m,idx%m)</div></pre></td></tr></table></figure>
<p>经过坐标转化，可以使用并查集进行计算了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = grid.size();</div><div class="line">    <span class="keyword">if</span>(rows==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cols = grid[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(cols==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    UnionFind unionfindset;<span class="comment">//声明并查集</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; island;<span class="comment">//存储是1的元素</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isseen(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//记录是否遍历过</span></div><div class="line">    <span class="comment">//初始化,插入元素</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; cols;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;</div><div class="line">                <span class="comment">//father.insert(make_pair(i*cols+j,i*cols+j));</span></div><div class="line">                unionfindset.add(i*cols+j,i*cols+j);</div><div class="line">                island.push_back(&#123;i,j&#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遍历边</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; island.size();i++)&#123;</div><div class="line">        <span class="keyword">int</span> x_idx = island[i][<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> y_idx = island[i][<span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> idx = x_idx*cols+y_idx;</div><div class="line">        <span class="keyword">if</span>(isseen[x_idx][y_idx]==<span class="number">0</span>)&#123;</div><div class="line">            isseen[x_idx][y_idx] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(x_idx<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x_idx<span class="number">-1</span>][y_idx]==<span class="string">'1'</span>)&#123;<span class="comment">//上</span></div><div class="line">                isseen[x_idx<span class="number">-1</span>][y_idx] = <span class="number">1</span>;</div><div class="line">                unionfindset.unionset(idx-cols,idx);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(y_idx<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x_idx][y_idx<span class="number">-1</span>]==<span class="string">'1'</span>)&#123;<span class="comment">//左</span></div><div class="line">                isseen[x_idx][y_idx<span class="number">-1</span>] = <span class="number">1</span>;</div><div class="line">                unionfindset.unionset(idx<span class="number">-1</span>,idx);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> unionfindset.countsets();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>BFS/DFS</p>
<p>从矩阵中的一个1开始做深度或广度优先遍历，其周围能够遍历到的1都是跟其属于同片陆地的，把遍历过的陆地标记为0，并把count++；然后继续从下一个出现1的地方开始遍历，跟前面的操作一样，最后就可以得到count就是矩阵中陆地的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> x_idx,<span class="keyword">int</span> y_idx,<span class="keyword">int</span>&amp; rows,<span class="keyword">int</span>&amp; cols)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(x_idx&lt;<span class="number">0</span> || x_idx &gt;=rows || y_idx&lt;<span class="number">0</span> || y_idx &gt;= cols || grid[x_idx][y_idx]==<span class="string">'0'</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    grid[x_idx][y_idx]=<span class="string">'0'</span>;</div><div class="line">    bfs(grid,x_idx,y_idx<span class="number">-1</span>,rows,cols);</div><div class="line">    bfs(grid,x_idx<span class="number">-1</span>,y_idx,rows,cols);</div><div class="line">    bfs(grid,x_idx,y_idx+<span class="number">1</span>,rows,cols);</div><div class="line">    bfs(grid,x_idx+<span class="number">1</span>,y_idx,rows,cols);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>int numIslands(vector<vector<char>&gt;&amp; grid) {</vector<char></p>
<pre><code>int rows = grid.size();
if(rows==0){
    return 0;
}
int cols = grid[0].size();
if(cols==0){
    return 0;
}
//unordered_map&lt;int,int&gt; father;//并查集
//vector&lt;vector&lt;int&gt;&gt; island;//存储是1的元素
int count = 0;
for(int i = 0; i &lt; rows;i++){
    for(int j = 0 ; j &lt; cols;j++){
        if(grid[i][j]==&#39;1&#39;){
            count++;
            bfs(grid,i,j,rows,cols);
        }
    }
}
return count;
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">### leetcode305.Number of Islands II </div><div class="line"></div><div class="line">#### 题目</div><div class="line">&gt; A 2d grid map of `m` rows and `n` columns is initially filled with water. We may perform an *addLand* operation which turns the water at position (row, col) into a land. Given a list of positions to operate, **count the number of islands after each addLand operation**. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</div><div class="line">&gt;</div><div class="line">&gt; **Example:**</div><div class="line">&gt;</div><div class="line">&gt; Given `m = 3, n = 3`, `positions = [[0,0], [0,1], [1,2], [2,1]]`.</div><div class="line">&gt; Initially, the 2d grid `grid` is filled with water. (Assume 0 represents water and 1 represents land).</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>0 0 0<br>0 0 0<br>0 0 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>1 0 0<br>0 0 0   Number of islands = 1<br>0 0 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #2: addLand(0, 1) turns the water at grid[0][1] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>1 1 0<br>0 0 0   Number of islands = 1<br>0 0 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>1 1 0<br>0 0 1   Number of islands = 2<br>0 0 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #4: addLand(2, 1) turns the water at grid[2][1] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>1 1 0<br>0 0 1   Number of islands = 3<br>0 1 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; We return the result as an array: `[1, 1, 2, 3]`</div><div class="line"></div><div class="line">一个矩阵，元素都是0，代表海洋，每次选择一个元素标记为1，代表陆地，输出每轮矩阵中的island个数。</div><div class="line"></div><div class="line">#### 思路</div><div class="line"></div><div class="line">这道题目跟上面题目不同的地方在于这次是每次选择一个点进行更新，所以如果每次用DFS/BFS遍历的话，会有大量重复的运算，如果用并查集，则只需要每次对于新加入的island对其周围进行检查然后对并查集进行更新即可。</div><div class="line"></div><div class="line">#### 代码</div><div class="line"></div><div class="line">​```c++</div><div class="line">//用vector定义并查集，index就是元素值</div><div class="line">class UnionFind&#123;</div><div class="line">    private:</div><div class="line">        vector&lt;int&gt; father;</div><div class="line">    public:</div><div class="line">        //初始化并查集</div><div class="line">        void initial(int n)&#123;</div><div class="line">            father.resize(n,-1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //并查集中更新操作</div><div class="line">        void fresh(int x,int x_fa)&#123;</div><div class="line">            father[x] = x_fa;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //在并查集中查找元素的boss</div><div class="line">        int findfather(int x)&#123;</div><div class="line">            int parent = x;</div><div class="line">            while(father[parent] != parent)&#123;</div><div class="line">                parent = father[parent];</div><div class="line">            &#125;</div><div class="line">            //带路径压缩的并查集</div><div class="line">            while(father[x] != x)&#123;</div><div class="line">                father[x] = parent;</div><div class="line">                x = father[x];</div><div class="line">            &#125;</div><div class="line">            return parent;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //合并两个元素</div><div class="line">        void unionset(int x,int y)&#123;</div><div class="line">            int x_father = findfather(x);</div><div class="line">            int y_father = findfather(y);</div><div class="line">            if(x_father != y_father)&#123;</div><div class="line">                father[y_father] = x_father;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //计算并查集中有多少个不想交的子集合</div><div class="line">        int countsets()&#123;</div><div class="line">            unordered_set&lt;int&gt; father_set;</div><div class="line">            for(int i = 0; i &lt; father.size();i++)&#123;</div><div class="line">                if(father[i]!=-1)&#123;</div><div class="line">                    int fathertemp = findfather(father[i]);</div><div class="line">                    if(fathertemp!=-1)&#123;</div><div class="line">                        father_set.insert(fathertemp);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return father_set.size();</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">public:</div><div class="line">vector&lt;int&gt; numIslands2(int m, int n, vector&lt;pair&lt;int, int&gt;&gt;&amp; positions) &#123;</div><div class="line">    int count = 0;</div><div class="line">    vector&lt;int&gt; results;</div><div class="line">    UnionFind UnionFindset;</div><div class="line">    vector&lt;int&gt; x_add = &#123;0,0,1,-1&#125;;</div><div class="line">    vector&lt;int&gt; y_add = &#123;1,-1,0,0&#125;;</div><div class="line">    //初始化地图</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; mapmatrix(m,vector&lt;int&gt;(n,0));</div><div class="line">    for(int i = 0; i &lt; positions.size();i++)&#123;</div><div class="line">        int x = positions[i].first;</div><div class="line">        int y = positions[i].second;</div><div class="line">        mapmatrix[x][y] = 1;</div><div class="line">        int idx_demension_one = x*n+y;</div><div class="line">        UnionFindset.add(idx_demension_one,idx_demension_one);//加入并查集</div><div class="line">        count++;</div><div class="line">        for(int j = 0 ; j &lt; 4;j++)&#123;</div><div class="line">            //相邻元素的坐标</div><div class="line">            int x_neighbor = x+x_add[j];</div><div class="line">            int y_neighbor = y+y_add[j];</div><div class="line">            int idx_demension_one_neighbor = x_neighbor*n+y_neighbor;</div><div class="line">            //如果相邻元素还在地图中，而且是陆地（val=1）</div><div class="line">            if(x_neighbor&gt;=0 &amp;&amp; x_neighbor&lt;m &amp;&amp; y_neighbor&gt;=0 &amp;&amp; y_neighbor&lt;n &amp;&amp; mapmatrix[x_neighbor][y_neighbor]==1 &amp;&amp; UnionFindset.findfather(idx_demension_one) != UnionFindset.findfather(idx_demension_one_neighbor))&#123;</div><div class="line">                UnionFindset.unionset(idx_demension_one,idx_demension_one_neighbor);</div><div class="line">                count--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        results.push_back(count);</div><div class="line">    &#125;</div><div class="line">    return results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<h3 id="leetcode261-Graph-Valid-Tree"><a href="#leetcode261-Graph-Valid-Tree" class="headerlink" title="leetcode261. Graph Valid Tree"></a>leetcode261. Graph Valid Tree</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p>
<p>For example:</p>
<p>Given <code>n = 5</code> and <code>edges = [[0, 1], [0, 2], [0, 3], [1, 4]]</code>, return <code>true</code>.</p>
<p>Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]</code>, return <code>false</code>.</p>
<p><strong>Note</strong>: you can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code>and thus will not appear together in <code>edges</code>.</p>
</blockquote>
<p>给定n个节点和节点之间的边集，判断由这些节点和边集是否能够构成树。</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>给定n个几点和边集构成树的条件有两个：</p>
<ol>
<li>所有的点都在一个并查集中，也就是都属于一个root节点</li>
<li>不能有环</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</div><div class="line">    UnionFind UnionFindgraph;</div><div class="line">    UnionFindgraph.initial(n);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n;i++)&#123;</div><div class="line">        UnionFindgraph.fresh(i,i);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遍历边</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; edges.size();i++)&#123;</div><div class="line">        <span class="keyword">int</span> start = edges[i].first;</div><div class="line">        <span class="keyword">int</span> end = edges[i].second;</div><div class="line">        <span class="keyword">int</span> start_fa = UnionFindgraph.findfather(start);</div><div class="line">        <span class="keyword">int</span> end_fa = UnionFindgraph.findfather(end);</div><div class="line">        <span class="keyword">if</span>(start_fa == end_fa)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            UnionFindgraph.unionset(start_fa,end_fa);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(UnionFindgraph.countsets()==<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="leetcode323-Number-of-Connected-Components-in-an-Undirected-Graph"><a href="#leetcode323-Number-of-Connected-Components-in-an-Undirected-Graph" class="headerlink" title="leetcode323. Number of Connected Components in an Undirected Graph"></a>leetcode323. Number of Connected Components in an Undirected Graph</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      0          3</div><div class="line">&gt;      |          |</div><div class="line">&gt;      1 --- 2    4</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [3, 4]]</code>, return <code>2</code>.</p>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      0           4</div><div class="line">&gt;      |           |</div><div class="line">&gt;      1 --- 2 --- 3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [2, 3], [3, 4]]</code>, return <code>1</code>.</p>
</blockquote>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>判断矩阵中联通子图图的个数，遍历边集，将边首尾节点合并，最终的并查集boss数就是联通子图的个数。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</div><div class="line">    UnionFind UnionFindgraph;</div><div class="line">    UnionFindgraph.initial(n);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n;i++)&#123;</div><div class="line">        UnionFindgraph.fresh(i,i);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遍历边</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; edges.size();i++)&#123;</div><div class="line">        <span class="keyword">int</span> start = edges[i].first;</div><div class="line">        <span class="keyword">int</span> end = edges[i].second;</div><div class="line">        UnionFindgraph.unionset(start,end);</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> UnionFindgraph.countsets();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="leetcode130-Surrounded-Regions"><a href="#leetcode130-Surrounded-Regions" class="headerlink" title="leetcode130. Surrounded Regions"></a>leetcode130. Surrounded Regions</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (the <strong>letter</strong> O), capture all regions surrounded by <code>&#39;X&#39;</code>.</p>
<p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; X X X X</div><div class="line">&gt; X O O X</div><div class="line">&gt; X X O X</div><div class="line">&gt; X O X X</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>After running your function, the board should be:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; X X X X</div><div class="line">&gt; X X X X</div><div class="line">&gt; X X X X</div><div class="line">&gt; X O X X</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>将被X围住的O标记为X。</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>通过分析可知，就是要将所有以O组成、但没有连通到网格边缘的区域变为X。</p>
<ol>
<li>BFS/DFS：沿着四个边向内找O，找到每一个O就把相连的都变成N，因为 他们都是要保留的，最后遍历二维数组，遇到O变成X，遇到N变回O</li>
<li>并查集：将区域内的O合并，组成集合，如果有元素在边界，就将该集合的father设为N，最后遍历所有的0，如果其father为N，就标记为O，否则标记为X。</li>
</ol>
<p>显然，1会比较快，下面使用BFS实现的.</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols)</span></span>&#123;</div><div class="line">    <span class="comment">// if(x&lt;0 || x &gt;= rows || y&lt;0 || y &gt;= cols || board[x][y]=='X')&#123;</span></div><div class="line">    <span class="comment">//     return;</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y &lt; cols &amp;&amp; board[x][y]==<span class="string">'O'</span>)&#123;</div><div class="line">        board[x][y]=<span class="string">'N'</span>;</div><div class="line">        dfs(board,x<span class="number">-1</span>,y,rows,cols);</div><div class="line">        dfs(board,x+<span class="number">1</span>,y,rows,cols);</div><div class="line">        dfs(board,x,y<span class="number">-1</span>,rows,cols);</div><div class="line">        dfs(board,x,y+<span class="number">1</span>,rows,cols);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123; </div><div class="line">    <span class="keyword">int</span> rows = board.size();</div><div class="line">    <span class="keyword">if</span>(rows==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(cols==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//上下边框</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cols;i++)&#123;</div><div class="line">        dfs(board,<span class="number">0</span>,i,rows,cols);</div><div class="line">        dfs(board,rows<span class="number">-1</span>,i,rows,cols);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//左右边框</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">        dfs(board,i,<span class="number">0</span>,rows,cols);</div><div class="line">        dfs(board,i,cols<span class="number">-1</span>,rows,cols);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'N'</span>)&#123;</div><div class="line">                board[i][j] = <span class="string">'O'</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</div><div class="line">                board[i][j] = <span class="string">'X'</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>什么时候用并查集？</p>
<ul>
<li>集合合并</li>
<li>判断两个点是否在同一个集合内</li>
</ul>
<h1 id="trie字典树"><a href="#trie字典树" class="headerlink" title="trie字典树"></a>trie字典树</h1><h2 id="Trie字典树"><a href="#Trie字典树" class="headerlink" title="Trie字典树"></a>Trie字典树</h2><p>源自单词：retrieve</p>
<p>假设有[b，abc，abd，bcd，abcd，efg，hii ]这6个单词 , 查找abc 在不在字典里面</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-17-49-17.png" alt=""> </p>
<h2 id="hash和trie的比较"><a href="#hash和trie的比较" class="headerlink" title="hash和trie的比较"></a>hash和trie的比较</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>hash_table</th>
<th>TIRE树</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找时间复杂度</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td></td>
<td>优于hash_table</td>
</tr>
</tbody>
</table>
</div>
<p>对于a,aa,aaa,aaaa的情况</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>hash</th>
<th>trie</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储</td>
<td>10个a</td>
<td>5个a节点</td>
</tr>
<tr>
<td>可用操作</td>
<td>有/无/查询</td>
<td>有/无/前缀查询</td>
</tr>
<tr>
<td></td>
<td>1行</td>
<td>75~100行</td>
</tr>
</tbody>
</table>
</div>
<p>所以选择hash原因是代码量小, 但是涉及到前缀查询的时候, 考虑trie树</p>
<h2 id="什么时候更适合用trie树"><a href="#什么时候更适合用trie树" class="headerlink" title="什么时候更适合用trie树"></a>什么时候更适合用trie树</h2><p>一个一个字符串遍历的时候。</p>
<p>需要节约空间</p>
<p>查找前缀</p>
<h2 id="Trie模板"><a href="#Trie模板" class="headerlink" title="Trie模板"></a>Trie模板</h2><p>例题：</p>
<p>Word search II</p>
<h1 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://stomachache007.wordpress.com/2017/10/23/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E9%AB%98%E7%BA%A7%E7%8F%AD%E7%AC%94%E8%AE%B02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/" target="_blank" rel="external">stomachache007的blog</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> UnionFind </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班习题集】]]></title>
      <url>/2017/11/05/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E4%B9%A0%E9%A2%98%E9%9B%86%E3%80%91/</url>
      <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 请输入文章密码！ "/> <label for="pass"> 请输入文章密码！ </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX1/EJ1p6w0/4kCfv2O8swW5VXlu2fBeb4G+ZppTVVNWseGdkK2TvNmPe+2G41sYy9LuVwiavJOofVB97kNBawyR6OWNzHT1cIlL/x1I5HyXgy76NTpI2/C5UYMyWmNZKQVBJW9ONo+5PsfgpWQnSJXXMx2mRPEO1lZxyKNVrk0R77cQ1sR9YD9zk4WJxQEg5YTTBZNLgMaFxTDgU49NIF9TS1X6HVaZvv4R3Rwb4kbYZ8JAVwey3z2glIZjG1fY/mkRKpARnWY2TcM/LpIsS8HXi9BwR2hUMeq0tmiV5YHS1l+cPzkvbTmtbDE1OWBE9ZsMS4SJWinA4uE/yn9blwG6TEpSxfb1lps9V87t3m5abNfmM9k+LUvi8aCvgRV+q2LJ5/Ehy+MgCgqDxYjXm+LvojJe14LUHSliTo8qSau+K4KNQC4thx+Bn7q5cH+ddWzupfVycOn0chcFXiZkQTBqUgWFPSgfLmoXPuGyX9upUTAknV55D2AfBfQbiRiDVdVNDtETZm2UmwNJsvuoEXogg6s9xil9BKZb88W0E8x99yQJGF3j/xmhVQtJFMZssJESwZB93gePChXXbSQrBqKq80eOZk0TQaiUIQuzU0FmS8Z3OuyoNtjAh4BYCumuKfd8WbQRJe++iqgdBpo+mY2ZKOOuPuwSLXZXJLdGjeIIe4K5l5j/TP9lRD88ACQuiP8IGkXQPBk2jFSG3xYH4TXqkZLLJjH5zFvPQEThVgjdklMGx26TA1I/sJR0X8N+Qiq8mMB2ZCfcuqoUIGonWuYbZMfH2hlygoOSIF7j/op8EEWYo+sIwBd2j+pqLJg0g7EGHVFvOBzNzgIbRFJkuQdHIoNAh21r8uW+BEWFBdlu0NmPviyOCchYEhfsZ/cOKsrnEdgKTSUmm2ZrueDuZ60q7PvVbmnq5WuicfALDOVsjZD5R3fQ7SWK4AFVHp7/EGZdPT51u2gzcgyEJTWc+UIGWufXYM/jWL40qlbaCvBtwEPXonp2vlvtidXhqPD2NrgfxdzHDGWDOycrMSpGeJr4N6Dk8ibBCcVvx8jqtUjRd92s3ZIqgclYb5svpyJONgRc+opYshVhv+AsMVKdzdahA3bbIUOEFw5Wq+HNwXOHq1E2RO+MbyQPi7C0wiFZ3vB1sA7C+OCsh/loD3/FQe1Im4s9CZjFozN4Ttv1FnmxG97BwkMREDIEQCNC2d5kf+BmTDtVv+3jKPYVghp1vi+teSQA0lio7upEFjqrkZB/MsWT/NJeEm45kO33azBf8w+Vd9Gagxcz99aB9wcBzxLCKEeODKfYkS9ILkCQYzGaqxlEYvvSQT6yGC3s1BMaRFnaiTXELoS4x1BNflH3uT2rAOtXXmOnNBde/9tyoObNjPtIEQtx97vWEjEcnat+nslWzZiYpP5Js1FKC2Yx3DTc3AZEFXldJZwEDDXrUeYi/UHr+/DOIIf0wMF/4k0T7V79Yby+7LPyFIKR5IsVPaVGqNuA9zHZ+dSsuv+eNLQ475BUGu5uWYq9zdW8y3aRluLmgSFaqYKJocLa3fA+xYXlcc9mUenoX8CKqthQwIYXVI2aNHT3KYLquJWZekI68XsmZpvHsXAdd0efxOJOvrE5a+Bx9qdRJ5Nd2cCQFQDyXTtHWo6zPGAOcD/g83IhZde/jVUQ7fItcVKxMq+yPBWrVZEYtmA3ojgdB/09sB3msLnSADjNt0y3T+OUhPI3PiOna9WYzpCVeodeoo96RPLHz3cZEWfwtoxnZJqnNbd1C6p0dqM+X70dCuMbqQR1VoJ0poWvsJAaFucJ1PE2AKPnVeZypovpKFhy591yJIJLQ0gQACSg6I/z1DrZ5NyWAw6DLPPwa4qUpDkOllbiMy5D/PAHQGyF9Vubup3OSR/VqqR60oD7FTyFjc2UpCACXp/R2vdmDdC+xQMv1BI5BxsU4pwuTuSwjYX4TnHOjLkSjLhTKoUAiQGyv1vmtXNhjGz87Qg++B+N6NvQDQQiiIEgxHFfB3WyAdGO1Rk1W1Kzp77PYogajDfpCyTA3TcvGpoZVrGe2gPP/P2aUbCo206v21JDl0IDY6MGQ2hFQ1nW72sfVGqxb6FBFHHfzoYSFn8+b7wJqDHXvPBsN2rgwM2ag5IEWiNwI6by38Y57c5u+ysV43t6ACX/qLHKHmH9lQd0RnWKVUG7DVC4m4coK2J4k8vch94t5kqR4sPaYUe1qwRHDiQ8n/SwT/CnFNvwtyoWjuNvIzKPf4ig/1QXuOK3gmN2NM55AeOdY048hR3zFPvIkitSWzFL8usVb9kIVYcCjrQ+Hw7cMgNFsCoUttzhjjYrwGXSz8SyV5lmdzMsq9z32FA/WupIRkcYEHOa8wIvwM10MZnNIba1gnq20nzvOCZCE5+bRYSZhxRQS1gTAVuU5QL8kscufL3XPzJxZyd4kxx9oJSEIxk2atsOSIzd8zsC/QpJN0ygtcC0vHIKIBolrWoTEcQoi3Nz/ICBZDTI/M47feNHRwTahynW028IIilMuQ6TJbLeCq5c6/4mEqWk6xfo5xP5YGkL6oj4Ygo3lDutVQNpEr/SoesMF9cpj07ThFUnwWW4LRkqxrri8HkZgHu6SMQA1EKO4tes1I3SNByIZiY6k4CSAvUAnG195WFzUecxunp5QiRNyuANPa0L1RayNloCMTMbjlBfdALzYXmpGvdAqMswHzXdbZG6JSlrcitXeLDnKEl5NU8MpVHvn91Xe3LCuPenwgAHC7/V9NahVUtBNubok+7jmhla/lmbq5yaKnDDKQJWJch7MJgSozWfrNLi8wWNB5+wCFs+f97lbF2YhlJN30f2DvyCSVns038zNdBHizHliBjZReBwL9viEtOLrTxLOuVmiW3ZeCdONmljpKwIfiXrqyNyExlY4xSQ2o+P9kn+36aG4CKvieJMQHtcfxjCEqMDhI//rhWDexAT/HVDG1NwZRhhWpgDebEd5hkGQFHqvwCouQuvKEv5nQUQGRIWKT9N9at/BxM5I3YUqdFe2KD8Uvrlwts3CF1BgYdcPxmOehPTxTBWjDlviKveuz4gkYC9X0YPWA5LISIA4mmGLhWCOEp5mQFJfWDchxa/Hgd4OnzOwKiPK/4UoiiDsep+hwPtBY2480O+K2heBjxoFNXJ2dlQBVZRXHlunJKfB3EAMf2XdsJU21gZ7eyBBuOt/d1Ird1VJiIybc1T9H36HuyhLnfpgodu/lTa+15U3p8vlk4pBx7brIklH4hOB/MsgVIKTEf11p8SuID6LeowRJhKJDymIj3TAolKkIK6gtGKRKGY395H9MYkPGfM2ehOZf9zpQ3AHRVowVNOV5/pzncanUJCJLU/6wenTxCT3jbYBfCDfDnp6Pl/wMzJMZzPWSrSzVqfOxvIkN71b4udtLPEaXvrisjWZ6cO+UwEGwVFQXz8oy+XACQiv+2+34sso4ca8ZRqBNSnLwkLZ3LNmMBP77TSIhF95U7Y07zMZ740MFhd3E+2gJmZ7rplAkmioHwubwZDFP6jyXtwF8NNwk6+RPlbFJlStL6YOSWFf7dzo4FuQjGkQkGbD7EOqUESNOnRYTqpzXmK0qXxA+URCHhE4Glxj/tW/GMuXz3ewKz0a4b8KgR6gR3TO0ejn6kIg5pdp4pFuetmFwh3o/Wcp+Om293CyPdYu4lajGFFcrX3/VzdApnB6bTG80mugHLLF6pfePx10MM/CMH1H8iVb/2bpEip1X2vEX0k+VQhm1swwON1+m8v2D6rMThBMaa8DVmYZ61+pdtYHrNMYTR1UM/F4V1WPbUYsyZTeGbyY21x99G/mePba50FBqfeJb18RnX+S3WgLFMVoAy1+umooFA/hI2H/ZQv1d24oEW9GVV397RIgF6P8xHAwcaburjyRsauCbUnrEVytBq07kg1MVb3IMabj2R0hIjSrpAjwoWo+V5M0LuKy2UUHgzAhQuvOu3YRIGQF3mXdiIuY+Pr+RTwmqUnm3TjVJRUh/TZ8+EV5i9LQilDR4E9CDznOQfZtxEmgmwjiiCAQSOjaztKmxAPhqnPW1yYkXToLtOt5Fx5UHx18jAUUIKUfFDfrZB4JmOPPOYOBic9HguAs+N+VCh0DCWIC6YaLA6RbtXMc0fzn7abCZUm/CRdo15NMvvp8DQ4VQCdFTlJZW8PYtfVx4GwdL76XeyZT1VYTo0IRGNC9VHVPospsL7u+/iKlTWXeQ5b5EesUaPwtHtW0L38PntYYv+9p2rN+0KqiObqF3LHaEClIcT6rAs1qRRNwsTYAtVdANSDGNFmpIkeSmZdVntrkonUQIt4KdBKCqNsWrFRkBgXOi9hkWnaNH5SaRv6Di4GocoGRFJP6tOuKcK+IMVc26TcExhW49S0J7fVWgCmQLMDif1jMhGjM2TR7Oes/UArOARPEHkDvSoBpQiVNFV0mExQN6PA47lS/XA7S5iv4LCbLeuzse4NxaKeON7chARlOHDNTRjfDX/ICykQrQk6aIYhDeTiUf4aA4TPxr5xO+E30hoxUFAI8ckxnvoC9MV1DpryxETm2HrKBm+6Khk9wXg19IuqoZlJ549q/NCr50I+DyEeSm+4p9JyP7/KkgTdfrmMGEzMFbd1SLvEtn+rgSoDBKVOZxf4dRy4RmXN6+DuN1jAHFV9bytZ4NMIVhxVTRDE9HFbZMtx2948SM261dC8n3ddcTCJuyDYBY1aRcxE+mtRSqvske7WogoXP2c25HrMbT+O1Zj63VR/2rHIuZBRJxMOW6xALRHvMlya11ahdaJZtAxmM/jdt/v9HR7smiWhmNFFrQoIeiYP43LACqYcefZQuWFgRKJsfQHuBJYqRPnZtlW+PcXre6xl0RB6qpS3UnTXoVasIyhGk6vDh44bdm22j1x5Oy/di2KchWwGGy5C46jJfQOFyqCmCf1fUXkv5p/qLF59AEN/+43Qyj6HuSzvzRVFMFo4opg7kfWxQz1r7JDIzs9BsNLKbdaN6A7GYUlppvYLX+BAQQPBpCoty3GazGbWCICXA4FqOSpZmHTmah/N9uq+1Zsspnhig1tNBcvFOozkp2QryslYD8LFhQcwBvwpvRXlHZZxbyBYUU63lxkEqgu5VGHrUkrqe9TqQhZaXOzAy7X6OvbK5FtTNo1oqaDA5tBWiFd5pooXckj6wt9vA2RPUSHbu8IS2mq4Fx6u7BrsEZAM8e+vsLPP8fwE5/ssLpcnaMEQhOylJiGpd14aihK57BWxwapX2ofjERNF81k/Y3I+rVk2DSlL2ALwpr9pQxfwzqmnMq7TYoZ0lk3PTHNuvsWWzvitl2XuT5xvA38wgLtVxjRGmNdHA3hIJ+juPOVpu61Pibd4cQftteBtIE3Gpl49Ed0FUBTfpyKCkrKNZ6+2IWiS0ro5fG0FVLxOcGKiaCoZf/JlvFcFU0iTaNTBc/h3jet64cLpUtZc727VLAvuctyAYrxatza3kFHMY3NUxA0BmUkxRivDyGxiBWj0kYoOVe60uE2hEpDLInPTQ520D7fobgHqHdZ9xrFeQAAVDRknLVt4EaFZY+4f9HRyzpUG7m8+pIaVV7pWWRJcmILCtgGS1CkK2dD/VJThQV175Pm9FWgZ13FNrot8AgleY1JTgfSu5JN+tIVLBkxhxdEQGRCelfkq9Q4DLXBkT/i8KHaLXunfdrJvfTbqqPbmlF5BCqqypfOpUZr2YBcn2dFpz2ARxmMqDLkiCkp9BBaKpV68Vx2CwKXsGZ9svNbumU4hPBF2ko6qfZNJsGb8h5HvAd3o380YI6q1wtEPvG6ZmHRJaCcOUY6Jw2hntHc6v+brD655dCRkJ+NZpg71S9q68VjajDq/lURJn0wh5qBVxYXwYCLGlt6y6ptSIvA7Ij7fm3uPoG2Szs1kqWep4JZpiVKW/nsurozb2JCglWGj6U2qFB587CSzrrfgsseQKYB7TSfY0RzwY3Gi5J/WtKvE2DAHuMS7+6kpbPHBRGVLtyvZFiL2nA12AVuM99QIgXJc9kHeE7PufJrbcv7WHwL/tumuQzyySUh+kdeNOQ+H1KpHozMuHsR/I9Qvb/qDo9OihwRJfWJQ80dMpwdWsKuxjX/m7bGEAS+CL66BnHORXU7k3ltXplDbieyT7XWRQWYXHgWl+F7aDnD9L8zuO4Teb2X7KcwGtP6MhcZYqBeZ/n+rfa0DW5HP1DO+lFxey3RXM2tIf1oOFTVWj2x+1Prh0JdlHMedMJTJ4Gj9LwhsSRtuZNPQvpG8DR8UAgD7inlLqkcq1hWlgt7rv/cZHuBWfpmz24FITcTI+3kvYf3X1xW+Po7CYYxXVnK3M0fDjJOelm208uVWaGxgPTUAgKkAHdBdo1bs30iakJgXLAJDL8mYGc85vOCHBJfkB6K8ui9F6BiAvERwdJ+w8t2MLeK6aohQR0gxUekss86DyauftuZ6YLEb661qKSEJ8W37W8V+qPa6GpDG6OCgDdakjJvFbolYep2F3I4jODnxuDmqJvcDavKnJ0wMkcQSY4r6U1Zy9Zj9tgW0yrVyAPMzMHRmWiRqZEfRu3EjhKAtn/9wIYJGcwDZ6xMmYKydTxMvppDYegNyLeyONdMPyU2ZejdqJyvYBrq6G1i3zOxBYGNOV0PCJQgM97IDnIDij3w/oYANtxz1kRGqi9dN+Bbhk1ZfA0cUK/ixY5IdHf6pcFQlxsNWO0eNu4y4LI/RdXXBkcoVj7wGy5IYSybC3fGsPQh0MlZBkZF08AB6TTAeEw3/77A5jHxjjWE/PBor4GnPaoeNMNB0sVJ52MGId7oqSuD1WyAg02OjmWyExsIDnTQ/NbhWhXkbdahqRO5YBkttn2O9FMxtB14ifmRIb+MSr6pT2IZgJRw0rvQ525C/10TDP1+QhYmF5T/ACPP0DhGMYNGq1OYauNWGEPb5ixi7G7IzollK9uzTqfe4xYGmtZJZiBPzGIf5iAL97ZFHrGBs+4WaLS6ijM3LjyMJFVf6Kmc7IhrGSQFDtwJMmYUOqV9FZj2Pzbs2yLTCV9Jq3lgxsszNbTVAsMSWRr3rRBoxj8WkCrTUz/SOLKYEXSAbDsEdSsm2NCsn86YHAR8M76AKgezHGvoO5RvExP+5IszO8LGzoLDasmfuMb2DeB9FZzbkj4hGxmJ5fxiZvE3KNexZSZTM3e3KLfaFjGL6nxrYt+1jacIaof2gA+RFgCaYY9z7/HQgx74SBlGnblOej24k6Nat1PzFIuxnlNLaUWVCZVNx9hswIq6788tmo/d2DrplOnFF0PLL5ZyyraNS0cATguC6H+yn2AR7r0xWj5rH/PWgJMJss/8MuXYex5bpxWndY//kQfBYKd1IDf+V/6TlpQvc9MMdSSuBKoXTYZt0FMwXsg91ZLkieJBlkO14G4kRZAExaLMZzr8hzrz1/jTbiKYbXvFmUb3p2myVevOuzSal1/zolpmhLnKZMeWZ8NQ3MxeD3pJx3/ubVBASKHRWBjtgOMMNKsyhVblU5sWr8lbHR1ExYz80DDpz4WlVvHigHyGwrhZlM/CdbSzD7g2IJkMrUPexQsJWYclGXpwomuAMyLQfq3+CAX1yviz37Dl7dpR2KnJU7WoN3PeAz7Z6NtwgQN0EyK+xO0XuhTwlCr3r7s9y8DiQPjchGLKpgI+/OOZ/9KEwaaHC7CoBgVG5cSFwPcAkpA3YT9sC8XCP6o3SrP2DYipyI4UFr7RqJsXCLwFSkM98odow9PGLLHMS5ZMkP/UdyunR+LNpAW6zIORCHQnwrQEWbaAwzEUDvTdAgyp/NjzA6y5sAMqGw1/EjiJtR19PINffAT5JYqSYIpy2JcMoX+gxS1P/Wu2amQ/tldAW6zp86/SfKLAnw1kA4enaZXv1rBiBa9ASNqJpWA8cwrDr1VshJP/YnGppm8pkOp7BPcWzR2fMKfmGsWrjTDiYWVqa0m1DyiW2kG3Cpe9MP+vYevFAYliPVmAYZCEQpqO1R8okK2bOIbqyKxO6FvTm9ypjPuhgUivrN1mA+O5wJB8WoH5dOGb2LqXruoe7cZ6VV8KxvBJ6mDX+WO0rK0eDJoSRD+fPmNtFskbrVJc4wz4V6Lrs53nRADct8/3mmvTQcoSZVEQhySbNGpzfNjTDOWx7QTNsTdZbIW0HczXaamiElIVhg1JBdVHqorrrcDYwGTsYMeH/iPV4vsLcpFeZzXf1L67uF2AdWw+tiK63OiSjMV3z7sV5Lw2z+ucsueDPEGXWTGN1okh4YDH1wIHXmqFvdu0Kkty3jFwDlo27o3xjIYAHE/O/BVQvjTBZeRI7R2Pz5s8mKL88S7me4j3lYb7ok3rXeUS8mkENbqfDFcvmNs4liAEEe55n5+jFZkW5X5xJTdvqXxufy/OKf5wxVxfsZ/Y2yolXEVanSAXNnzWuyVeNMFNfC/WkzkmBOlGA63Sd0jsNCK9mszPhbBNUXZkWypzSDCnaPDg1KV/kZEjZW4HaIpZnxhffd48+k+L2+uTnhpxxMfq1kWinu3iWVXqkyd3egjiIUJ4NwA5O7fKF+Isw5OBfcRVz9SLGXkQ8MpAfLgarwwT31SyhzP86Zow+mt/tVngYL2iRWUejVpVzEW+0EaWZCdOza/GuUEFyFXnn2xcU63JczHIpC1wEsHL1GDqlfdugr2cLLJ7m2+IpE5C4sPdxNlGWj9VBMS7KnRLLSxR5kfeSSH71pw/J84RWoQ+frZ2jIiLqAjHziX/ZzEoA1Z+HTKETASKRGTf11IeopzfyLCKP9zbUAZPWLUw4c3tmM1Zxo/v0Lo8aVtvCt+28kH9CkMbNQSqd1gX9QAC1TdG62raUOidJkGGcoSbMVZLCUgJ24/jwLMNfsd543rsQXdC+Cm2qXIeD6yEBgHBVDSdOJ14U74WuybTtBDDRhG3Dt+M+ZZw7Me3/C6H59d43mREnYfYHWXTEP4U2tVq+RC9Qfm7ZvZetpYFFgnYtU3c1t8ucV5r1veOmcw9B7DdqAZ2RjmEeQuU/ab3kBeHL0DJN7EzU5rz/3WAtRvkVJ1Gz3/ycRWfNkEBdtzDAA80sxIIuhFSwcvnBnZ4aeqZmMOzMDT9fB1PHAM8uCqzZY0YbZDaww7iQpwNRjS62NlM0hkyY3TfOPfyEas9XEl+jxSq5SIfIr7eP/9RdOWOlcvGi6GhRRWwwddaT3bHcKwDn0dbsDIosB8p4XAl4PGVQnqt+0eIhZN3CSQPg8QQLM1+auNJ7L0UsHiFI4HsmHNLPz2dNsSKo2UAyXHCb9nfeH1MTfy9rlqNnECUO5DOcZILU7QlKLzJq8+Rl26L7koiI5pbJBQOFofQf/C7Bw3m+DNHIYQ/2twIIr/RShg/aghPhp5hVuQJLw7MGqmmoMYiy2wwex6I7mvG0EJJmTFW/G+zwKtI+8YLdoOF4KhxSk0zqQQgZCC44eaVrXxtOqUdY4PRG6dCB91mw4xwoM/dtc1ZRd9TlGYKnHl4TUmSVZwz73LSstCVg1rLRt3jU67JgFwjqfxntlFDR33nGejrXwiY96sbJF/UyCq8DlC4KYdIiRh4Q5DlBXZtmWSnZ5pgtMuW7R+CF29B/kwDdO0UqPcNmJuEVeDc6OYfdARhj/wVTWeJhN+cCq6EvxBx0IOfULZnNnsQfGSsLJlqIeMflhQ4U96F55Y/hew35d7WnkB5nX/FdXOIwD6Y0fn7cys5bHM8SHPETZI9seh2a42L7fXNDdnVxxhODzpWRo98wLNAium/35XCvKqflOGzHJvRfbrOoyxHzgiUnZWrRUy22Uqr8ip24f1jfmKlzXXipSQN/Bo6LbrHSFNHIRmY3lrgPsd7K6MDkNFWmhOKpryPv1ug8xK/pweIYloI+wPuU1//rMWGMVvMX+kC4q282OKxAcu+pyds6dMuluu8p5H5Nsxul4qX+EdeonLsOVrU0rexQSWM9RrcM5uHRwq2vd6Alc43B7NI169EXBP6Ou+Cg8t/7uv/Y0vkHyWHB9JK87A8Uy04qy2X7ilIkh/75elXUQl9RZGFYY7FyxGHr2U1Zg22C75018VpWPVai/egaZms46bWDL/SgMJ0ZN7hQZCzLz3/SJKOuIXE5H3sVbZJmIrlcXiqSsVGLXxZJLvhnpBqCW9vJonwR45Qkj1lbENXSN6/igWlsOlGJRpeoeWZt7Q8EkAyi6vdExgE8Z6j+ZC+6kahycZeCAMbZd4mtHc+6ps+OCe2g0EbYnFcbcGGYfvDEuLBjIJwTy6h36+F6Opk1Khw6tLewxR8CEpXiDEKQS3NSjt/B0z0SP0Chc7IKF1gjclJtdY53FSVXQ1Nrv72x876BLA+ebewqttK2BDfNWvQxaA3uSbaI0dgTe6Grpea7328Jhecy1B2VFiyToEMNg5EWwD8ffSPODZ28maMSrNAYUVUjYtwU+0axtfIg/2/8hV5fqGbwt96sKsfbEogQq5R80VCg5qUi2yh3EBYiRHAWbRft88Q+9QClFJ0y8uFATbwhZNhqr6paha0YBLb8bt3KvQrr9G3OoYynnOJj2bEwNFDtqpYOvcKaifAUcTdKROuRS5fqBmIlCclcNBG887XE1q5jSDdNp+BlffVbxk89lulePMpX4Jur5O36xkcgHQNwEfyyS+az5nWCKo0s0ewE9k0UlQziRKrdHlLaEbpNY1KXdikYJlHp94yFBkpOxyZEyDR/Wc7MrITKM2Ib//O6fODaMvIn/9qMJxKBZK8qudCsxTjRZRhz+JTt7CUvpvu6F54Ep3Z5Tl10+/tbMqWobdbTrz3940GnZY35zLd95NAbx9rPjzZ19ryQufpyC9pmz3cdUoMi9QUVgFqS6EehXcl2vfG3YTFFm5oiQ9X9T9mfyodBEOklPfjTg5i35E+Hm1yGH1nvls49QJz51FmuoAlW1vc7U1Fv4wR7t8F0CZjmhZiGgCmGMjb2AAOyPONToWI+dlJGHgNZMhBWUnhoWV5tNIg94xHa3yonvUamlfAivIhV2yzYZZug3V21HigDv/3LWwOUXddgyzNGZn1zJF2/VIHBKIMfzNXg9PUy0/pr3Q46OrQz9mtVstSUJVOmhUqZ42EL0a8lWUPGVWjIXF+yVZaPiEWiH/h2loORSOXgqRqg4z5phV/7LbuKT8UL0P6ADnbvpnNM+xZIG0zlQlrZPf/CgwOpmt9Cw29zWFImmIdFrt/AbVwXacPRUG7UjKh1KH7M6tJOz4TME0ntOOn8AsWuOHGnO9yuHXvqbhiRz43h3bloMA0vkh7W/cCyPEmGNYFHdwP3gtfZ4oJ7kVD/4prEhC2LWtXpngmTkThRgPcBG5DUmr5VnvTFapLgC8YLU304pW2nFWckt3vadlE5KZl/i5uf/dTwemHCddTxDDTcvENzzHkwC1CI5Jsg9w3FGnlFOCdCCOOnpEWjf6SaVhw0/P9gB04HtNOy1pyxptMXKd4iCmO6LcGPegAN7Mdl1LCq7aU/Mgbown9xrbP90GFS4ViclzNaLg8zCS1KlDnot5HDrr9aDvi4HGi8l4pFmJB10kR11YtI3ZTGGKjWMK4Wlpn2GqiokUWZfKBs2IoOYxkuHPt481bDnzWQl+iicaN0DCfU1tM5TTR3T/aKFY3kdlBGEhJV3vl24v1/Y9ish6VGvfvt93SJ2Xn11Fm8P98Q+XMDW47gteKoVZ8TYwJxh9Byz8lTsSjSNywc4fTKsQTV7efiUgb6GsVsC3ocGMLvNBxUEoqB1dVg0oG8E6A6j19USXwz2NHajDkllgz4pQ2IGUO98W570oG5g4QupzbCTo1PQS8MrgvaELls9AzFwBXu2FuhmLG7yXe7wdiHGpmOR6o9ti3wYLL8o2lLOpzRmfqyaQKFhpkROIoJFN8EYpktZWOo0BstS88FuK6m06MH5jpR3OPJtMp836I+U2TU9OrCod4dDtiiiFZIP7+UJB0iM1oEo/Xlo+o/awXtywEdrVergxnn+fSI977tnwkY4ZngcuJgw3bRlwBbF+gVFdg262l3IUi6lrTK9XSQfUjjBRElTSdQ2m0WIk6S4NGqWKYH5DlfYJDy6QMRH8YmEqNGZ0zdRDgxKVTwcq6Bo7ks+QAUENzZhZYcmX05DzAQi5zaTAEp/5sIl7AL+v9azvxzLV7tF+rVoT4rcFdKHWrUCQiYnJ3NkL1hLHFWveCxYm+ZOPnUA63W+xK63QdSjnRUgpdvVUmBxn+pMZp7k/0NlPpBsZi5vjWuW5GJ3cRaJnlBD7ReOqTLXHhHW3kDa/nIL8WUoNdshKa/qufZdtKapzyIx1zrWNpU/L/lPDIcD2Bow3eqyqda1JJ1SunlwKOK8kZj/hhXx7+CA1VRApHLSsjfBIt4XT9TO3g6y1/koVWSs5rqmaGdca29BELFQAxvmS4DNzLO7v0dMEb1ZzD0r+NXF+knJ6dEotBIibR+CSuYNchFL0588J7SZWJSUlroD2v0WMAJgKPmN2ll4FLenHYjij9SZVtdUYrQjnlxln6Eh4RR7sRmbxZhLI1Ec9HUzKbUvyyt3/8tJglwU4KPh0UcgpuMO+lNiYDmv7X8Ubq+6/c3Feqtl2PS/Bun/LuzoKLbnXMU79tKLP1YRAgQK3CTl8Zo0vYq8pXZV/pO9pJpBDTWKAXq2c9I7jLnBLBeYx/uiqz69q9BzJcIPF0hNBB7AiQ7hQ/DhBKis2lUfyRHTJ/ieR1ZAc8LEzdVOxxJj5C6lLJiyjL7JWDWaYmBXI5x1xgpaLAvNkkyD81IMu2ZqnPg+v/rjNnIHQVvWe1kJB1dqNb+L4ajgxQ0liVRgcJW58uPfVGY7tgtnnsOjKUsOb4X8M195x2CdP8VTfFuFUna26+A0KHfkmJy0elW1kJcOQSQRCavM5brHIoZgt7QLW6skUKQ+kFFqc9Foy5eeTvU744E/qBu6Onn5X2PY47t9zyBMapzFGvSWBVK3brs/mtkXV08Vli+zBTLfVqZhvyG4vm/z6laa5GeSXrxRt6iWL2Bo4/0BvKn77BfQ3vo6RxFYelRXYvmYSrc0lpgj/hqREZeooti6GWWDocBbPjGAxwI05ibDphu8uckhRMRhV4m7ivItxeiRyed1yOpZ/blfAZqLIsxx+/tpbRAnhnd6NK2qnt3h/0KaDIDb8OywMp+N7SJ9NTuRjEHsKXvNu7VzS184zA08IstN8SOSNye0ijOaiaGDywmdOSw2zFS6u8kNpMxbzca/bApwwdQH4NwD9GtPSrMiRtMsz3ggz6rYAy5JjRI+kAuSknO5lUgJkVIRWF4a9MNIxYbd9qth3Hc28hRzHq1iK10bXwqttAlOPXopTHRWFmFMzQJYCPrH6Q28jA8AT+n63+eHvPWKkcRewpUrwD0GO8k073J8raGLLNBFMyUhgLNkiJcuLlWK7+wNxdDrYdyWf9NCbYMdesK1Zj6npMW51c0831Mn6UpT1zNQlvMT3ltWEXp0PN0ZeQU7vZYCm4Cebv/tAdos3JzOW3hOgoHAyz8p/esD+NA8iZB/uyt4mxpEjhJGN7QeYjojpgkjA+V7IlTtm8xLbKcUcmH0el+WJW33TGo+6G13RbNS9E2R0QYAl5RrfQoi2JnH06lj0HYaoCvJmaGxJgyEWpBvLKCiTzPwp9lT/1z8QMop8ZPpKkE1Y2Hpe7ZG/YU9VX3243ulxzTWN/TV/c30MHlzuznamdP9FtVkxjfzqs4F5QWUqLzA+9HZrCEaQsTpWz2LkPtf+Tb9cWsE/Wz1hohsG1eUaVp2YnaLdw161CAtKnC3+p6ojY3isNhjhBOusrzSL1dsQnzqFpwhjBdeI1ztsrWgXmAgtm3gbTUsKB0ck3JgoJYa99HZ8Lp5KKfFxs6TyF8dpn7euj5Vr7rT3zJ+ybR4xrfkIJ8llKJ7hFQw4hp8d8mh/HQgAbULtOjLTqimGxd1OGNWxdfPRgWiDAZp/3czxPcU7w2p7XOMOG51Hstx/ST+CmElfJideFEokMH3IbgQ9BWrI+xor9EIxwNPLD4bJdfDO1aDKeokGHxZUiH0iRkr7V15LvVhzlXFUZn+PTott9K45IV0VgclwTpJ4hdOoa9WAu6NBMRJh0UPLscm7N4LzGFZjXC9Z73PnkdMk4Z9HlK3v4dEHp9jYK1O5cVc3WkXpP57h8C0IibrG0jAKIq8MfxChKcXFfGNAMAP5L3PqpK5UWXDTa7RFz0M+QtQmNeZzX3lddSMJwZBhOsSpEeqeT2E7rzcaEWLT2QG/5nCaFmD5KgHRkf7EftrSCuoDnF75EEZI/oINmlkWlw3MEr89i9/vK3nYme/UtXcYVffm3hR2h4ZOGC+RT1XFArg5F2O+sCQ21EcProaQ8SyFzftz2w41kaj608sLnlpzgtYgu83g4/VuBOodGSAuMKtP1Aky7GHPlOWr4JivOK7qK05RGkxbqhyCau4yUcI+kY79Id84G3+7MEPUJA56URJoRnfeleZuaMnPAAq/Kos0WyX </div>]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[c++中struct的一些操作]]></title>
      <url>/2017/11/04/c-%E4%B8%ADstruct%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>c++中class和struct的构造函数方式相同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  <span class="keyword">int</span> y;;</div><div class="line">  <span class="keyword">int</span> val;</div><div class="line">  Node()：x(<span class="number">0</span>),y(<span class="number">0</span>),z(<span class="number">0</span>)&#123;&#125;;<span class="comment">//无参构造函数</span></div><div class="line">  Node(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k):x(i),y(j),val(k)&#123;&#125;<span class="comment">//有参构造函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[c++STL中vector的一些操作]]></title>
      <url>/2017/11/04/c-STL%E4%B8%ADvector%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>记录c++STL中vector的一些操作</p>
<h2 id="指定长度vector声明"><a href="#指定长度vector声明" class="headerlink" title="指定长度vector声明"></a>指定长度vector声明</h2><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n);<span class="comment">//长度为n</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n,t);<span class="comment">//长度为n,值为t</span></div></pre></td></tr></table></figure>
<h2 id="指定长度二维vector声明"><a href="#指定长度二维vector声明" class="headerlink" title="指定长度二维vector声明"></a>指定长度二维vector声明</h2><p>声明一个<script type="math/tex">m*n</script>维的矩阵：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));<span class="comment">//所有元素都是0</span></div></pre></td></tr></table></figure>
<h2 id="vector排序"><a href="#vector排序" class="headerlink" title="vector排序"></a>vector排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line">sort(vec.begin(),vec.end());</div></pre></td></tr></table></figure>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><p>resize()可以用来重新定义vector的大小，也可以用在声明数组时指定数组的长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n)</span></span>;<span class="comment">//重定义vector的长度</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n, value_type val)</span></span>;<span class="comment">//重定义vector的长度和数值</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
            <tag> vetcor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[回溯法、【leetcode】51.52 N-Queens]]></title>
      <url>/2017/11/04/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="什么是回溯"><a href="#什么是回溯" class="headerlink" title="什么是回溯"></a>什么是回溯</h2><p>回溯是一种穷举，但与brute force有一些区别，回溯带了两点脑子的，并不多，brute force一点也没带。<br>如果用爬山来比喻：<br>第一点脑子是回溯知道回头；相反如果是brute force,发现走不通立刻跳下山摔死，换第二条命从头换一条路走。<br>第二点脑子是回溯知道剪枝；如果有一条岔路走不通，那这条路我们不走，就可以少走很多不必要走的路。</p>
<h2 id="识别回溯问题"><a href="#识别回溯问题" class="headerlink" title="识别回溯问题"></a>识别回溯问题</h2><p>判断回溯很简单，拿到一个问题，你感觉如果不穷举一下就没法知道答案，那就可以开始回溯了。<br>一般回溯的问题有三种：</p>
<ol>
<li>Find a path to success 有没有解</li>
<li>Find all paths to success 求所有解<ol>
<li>求所有解的个数</li>
<li>求所有解的具体信息</li>
</ol>
</li>
</ol>
<ol>
<li>Find the best path to success 求最优解</li>
</ol>
<p>还有一些爱混淆的概念：递归，回溯，DFS。<br>回溯是一种找路方法，搜索的时候走不通就回头换路接着走，直到走通了或者发现此山根本不通。<br>DFS是一种开路策略，就是一条道先走到头，再往回走一步换一条路走到头，这也是回溯用到的策略。在树和图上回溯时人们叫它DFS。<br>递归是一种行为，回溯和递归如出一辙，都是一言不合就回到来时的路，所以一般回溯用递归实现；当然也可以不用，用栈。</p>
<p>关于回溯的三种问题，模板略有不同，<br>第一种，返回值是true/false。<br>第二种，求个数，设全局counter，返回值是void；求所有解信息，设result，返回值void。<br>第三种，设个全局变量best，返回值是void。</p>
<h2 id="求解模板"><a href="#求解模板" class="headerlink" title="求解模板"></a>求解模板</h2><p>第一种，有没有解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">boolean solve(Node n) &#123;</div><div class="line">    if n is a leaf node &#123;</div><div class="line">        if the leaf is a goal node, return true</div><div class="line">        else return false</div><div class="line">    &#125; else &#123;</div><div class="line">        for each child c of n &#123;</div><div class="line">            if solve(c) succeeds, return true</div><div class="line">        &#125;</div><div class="line">        return false</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种，求所有的解：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void solve(Node n) &#123;</div><div class="line">    if n is a leaf node &#123;</div><div class="line">        if the leaf is a goal node, count++, return;</div><div class="line">        else return</div><div class="line">    &#125; else &#123;</div><div class="line">        for each child c of n &#123;</div><div class="line">            solve(c)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第三种，求最优解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void solve(Node n) &#123;</div><div class="line">    if n is a leaf node &#123;</div><div class="line">        if the leaf is a goal node, update best result, return;</div><div class="line">        else return</div><div class="line">    &#125; else &#123;</div><div class="line">        for each child c of n &#123;</div><div class="line">            solve(c)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><p>八皇后问题是大数学家高斯于1850年提出来的。该问题是在8×8的国际象棋棋盘上放置8个皇后，使得没有一个皇后能“吃掉”任何其他一个皇后，即没有任何两个皇后被放置在棋盘的同一行、同一列或同一斜线上。</p>
<p>扩展到一般情况就是：在n*n的棋盘上放置n和棋子，使得没有任何两个棋子在同一行、同一列或同一对角线上</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了更好的理解回溯法，把这个问题分解成三个子问题：</p>
<ol>
<li>是否有这样的安放方法，满足游戏规则</li>
<li>如果有，有多少个安放方式[leetcode 52]</li>
<li>输出所有的安放方式[leetcode 51]</li>
</ol>
<p>因为任何两个皇后不可能在同一行，所以我们可以采用如下的策略：<br><strong>一行一行地安放皇后，每次放置皇后时需要确保此次放置的皇后跟之前已经放置的皇后没有处于同行、同列、同对角线上</strong></p>
<p>需要下面两个函数：</p>
<ol>
<li>递归调用安放皇后（回溯法）<br>逐个遍历可以安放皇后的位置，并递归调用取定下一层可以安放皇后的位置。直到最后一行的元素存在合法的放置位置，说明这是一种合理的安放情况。</li>
</ol>
<ol>
<li>判断在某一点放queen是否合法</li>
</ol>
<p>因为是一行一行放，所以可以保证不在一行上，需要判断同一列是否已经有皇后，以及左上方和右上方对角线方向是否已经有皇后。</p>
<p>另外还需要一个额外的空间标记当前皇后们安放的位置</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>三个子问题的函数2，判断某一点是否可以放置皇后的函数一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//判断是否可以放置</div><div class="line">bool isvalid(vector&lt;vector&lt;int&gt;&gt;&amp; vec,int n, int k,int i)&#123;</div><div class="line">     //k为当前行，i为当前列</div><div class="line">    //判断左上方对角线是否有皇后</div><div class="line">    int left = i;</div><div class="line">    int up = k;</div><div class="line">    while(left&gt;=0&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][left]==1)</div><div class="line">            return false;</div><div class="line">        left--;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    //判断右上方对角线是否有皇后</div><div class="line">    int right = i;</div><div class="line">    up = k;</div><div class="line">    while(right&lt;=n-1&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][right]==1)</div><div class="line">            return false;</div><div class="line">        right++;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    //判断同列是否有元素</div><div class="line">    for(int j = 0; j &lt; k ;j++)&#123;</div><div class="line">        if(vec[j][i]==1)</div><div class="line">            return false;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>vector&lt;vector&lt;int&gt;&gt;&amp; vec</code>是用来存放当前棋盘上放置的皇后位置。</p>
<p>差别在于回溯函数：</p>
<h4 id="1-是否存在"><a href="#1-是否存在" class="headerlink" title="1. 是否存在"></a>1. 是否存在</h4><p>只需要找到一个满足条件的放置方案即可，逐行放置皇后，遇到不满足条件的情况就回退到上一层，继续寻找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//递归调用，判断皇后放置字当前点之后是否存在合法路径</div><div class="line">void solve(vector&lt;vector&lt;int&gt;&gt;&amp; vec,int n,int k,int l)&#123;</div><div class="line">    //k为当前行，l为上一个的列</div><div class="line">    //判断下一行是否有位置放置queen</div><div class="line">    if(k==n-1)&#123;//最后一行，安放最后一个皇后</div><div class="line">        for(int i=0;i &lt;n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;//如果存在合法安放情况，返回true</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;//该点合理，将皇后放到该点，递归调用，判断下一层是否存在合法方案</div><div class="line">                vec[k][i]=1;//房子皇后，标记皇后位置</div><div class="line">                if (solve(vec,n,k+1,i))//下一层存在合法方案。返回true 否则回退，将皇后从该点移除</div><div class="line">                    return true;</div><div class="line">                vec[k][i]=0;//取消皇后位置标记</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool ifNQueens(int n) &#123;</div><div class="line">    if(n==1)</div><div class="line">        return true;</div><div class="line">    if(n&lt;4)</div><div class="line">        return false</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; vec(n,vector&lt;int&gt;(n,0));//存储当前棋盘皇后位置</div><div class="line">    //遍历首行放置皇后</div><div class="line">    for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">        vec[0][i]=1;</div><div class="line">        if(solve(vec,n,1,i))//找到一条合法放置方式，返回true</div><div class="line">            return true</div><div class="line">        vec[0][i]=0;//否则恢复该点未被选中的棋盘，继续遍历下一个点</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-存在多少种安放方式-leetcode-51"><a href="#2-存在多少种安放方式-leetcode-51" class="headerlink" title="2. 存在多少种安放方式 [leetcode] 51"></a>2. 存在多少种安放方式 [leetcode] 51</h4><p>在上面存在的基础之上，引入一个count计数变量，记录合法方案的数量，也就是没找到一个合法的安放方式就+1，知道遍历完所有的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> resultNum = <span class="number">0</span>;</div><div class="line"><span class="keyword">char</span>[][] map;</div><div class="line"><span class="comment">//判断当前点是否合理</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line"><span class="comment">//上方是否有点</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> line = <span class="number">0</span>;line &lt; i;line++)&#123;</div><div class="line"><span class="keyword">if</span>(map[line][j] == <span class="string">'Q'</span>)&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//左上对角线是否有Q</span></div><div class="line"><span class="keyword">int</span> line = i-<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> col = j-<span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (line &gt;= <span class="number">0</span> &amp;&amp; col &gt;=<span class="number">0</span>)&#123;</div><div class="line"><span class="keyword">if</span>(map[line][col] == <span class="string">'Q'</span>)&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">line--;</div><div class="line">col--;</div><div class="line">&#125;</div><div class="line"><span class="comment">//右上方是否有Q</span></div><div class="line">line = i-<span class="number">1</span>;</div><div class="line">col = j+<span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (line &gt;= <span class="number">0</span> &amp;&amp; col &lt;map.length)&#123;</div><div class="line"><span class="keyword">if</span>(map[line][col] == <span class="string">'Q'</span>)&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">line--;</div><div class="line">col++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> row)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(row == map.length)&#123;</div><div class="line">resultNum += <span class="number">1</span>;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; map.length;j++)&#123;</div><div class="line"><span class="keyword">if</span>(isValid(row,j))&#123;</div><div class="line">map[row][j] = <span class="string">'Q'</span>;</div><div class="line">solve(row+<span class="number">1</span>);</div><div class="line">map[row][j] = <span class="string">'.'</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"><span class="comment">//初始化map</span></div><div class="line"><span class="keyword">this</span>.map = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n;i++)&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ;j ++)&#123;</div><div class="line">map[i][j] = <span class="string">'.'</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">solve(<span class="number">0</span>);</div><div class="line"><span class="keyword">return</span> resultNum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-输出所有的安放方式-leetcode-51"><a href="#3-输出所有的安放方式-leetcode-51" class="headerlink" title="3.输出所有的安放方式 [leetcode] 51"></a>3.输出所有的安放方式 [leetcode] 51</h4><p>这次需要我们将所有合法的安放方式都输出，也就当找到一条合法安放方式时，就把当前的皇后放置情况输出到结果集。</p>
<p>另外根据题目输出结果格式要求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[</div><div class="line"> [&quot;.Q..&quot;,  // Solution 1</div><div class="line">  &quot;...Q&quot;,</div><div class="line">  &quot;Q...&quot;,</div><div class="line">  &quot;..Q.&quot;],</div><div class="line"></div><div class="line"> [&quot;..Q.&quot;,  // Solution 2</div><div class="line">  &quot;Q...&quot;,</div><div class="line">  &quot;...Q&quot;,</div><div class="line">  &quot;.Q..&quot;]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>对保存安放情况的变量类型作出修改：由原来的<code>vector&lt;vector&lt;int&gt;&gt;&amp; vec</code> 变为<code>vector&lt;string&gt;&amp; vec</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class NQueen &#123;</div><div class="line">    char[][] map;</div><div class="line">    //判断当前点是否合理</div><div class="line">    public boolean isValid(int i,int j)&#123;</div><div class="line">        //上方是否有点</div><div class="line">        for(int line = 0;line &lt; i;line++)&#123;</div><div class="line">            if(map[line][j] == &apos;Q&apos;)&#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //左上对角线是否有Q</div><div class="line">        int line = i-1;</div><div class="line">        int col = j-1;</div><div class="line">        while (line &gt;= 0 &amp;&amp; col &gt;=0)&#123;</div><div class="line">            if(map[line][col] == &apos;Q&apos;)&#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            line--;</div><div class="line">            col--;</div><div class="line">        &#125;</div><div class="line">        //右上方是否有Q</div><div class="line">        line = i-1;</div><div class="line">        col = j+1;</div><div class="line">        while (line &gt;= 0 &amp;&amp; col &lt;map.length)&#123;</div><div class="line">            if(map[line][col] == &apos;Q&apos;)&#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            line--;</div><div class="line">            col++;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void solve(List&lt;List&lt;String&gt;&gt; results,int row)&#123;</div><div class="line">        if(row == map.length)&#123;</div><div class="line">            //map转化为结果存入result</div><div class="line">            List&lt;String&gt; res = new ArrayList&lt;&gt;();</div><div class="line">            for(int i = 0 ;i &lt; map.length;i++)&#123;</div><div class="line">                String s = new String();</div><div class="line">                for(int j = 0 ; j &lt; map.length;j++)&#123;</div><div class="line">                    s += map[i][j];</div><div class="line">                &#125;</div><div class="line">                res.add(s);</div><div class="line">            &#125;</div><div class="line">            results.add(res);</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            for(int j = 0; j &lt; map.length;j++)&#123;</div><div class="line">                if(isValid(row,j))&#123;</div><div class="line">                    map[row][j] = &apos;Q&apos;;</div><div class="line">                    solve(results,row+1);</div><div class="line">                    map[row][j] = &apos;.&apos;;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</div><div class="line">        List&lt;List&lt;String&gt;&gt; results = new ArrayList&lt;&gt;();</div><div class="line">        //初始化map</div><div class="line">        this.map = new char[n][n];</div><div class="line">        for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">            for(int j = 0; j &lt; n ;j ++)&#123;</div><div class="line">                map[i][j] = &apos;.&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        solve(results,0);</div><div class="line">        return results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="leetcode相关问题"><a href="#leetcode相关问题" class="headerlink" title="leetcode相关问题"></a>leetcode相关问题</h1><h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><h3 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a><a href="https://leetcode.com/problems/permutations/" target="_blank" rel="external">Permutations</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a collection of <strong>distinct</strong> numbers, return all possible permutations.</p>
<p>For example,<br><code>[1,2,3]</code> have the following permutations:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1,2,3],</div><div class="line">&gt;   [1,3,2],</div><div class="line">&gt;   [2,1,3],</div><div class="line">&gt;   [2,3,1],</div><div class="line">&gt;   [3,1,2],</div><div class="line">&gt;   [3,2,1]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>求给定数组中元素的排列组合，元素无重复</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>分析元素排列的全部可能，典型的回溯，按照上面的模板做就好</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutations</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] hasVisit;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; results;</div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (n == nums.length)&#123;</div><div class="line">            <span class="comment">//结果放入results</span></div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">                <span class="comment">//该元素没有中出现过,放入result</span></div><div class="line">                <span class="keyword">if</span>(!hasVisit[i])&#123;</div><div class="line">                    hasVisit[i] = <span class="keyword">true</span>;</div><div class="line">                    result.add(nums[i]);</div><div class="line">                    solve(n+<span class="number">1</span>,nums);</div><div class="line">                    hasVisit[i] = <span class="keyword">false</span>;</div><div class="line">                    result.remove(result.size()-<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        <span class="keyword">this</span>.results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">this</span>.hasVisit = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line"></div><div class="line">        solve(<span class="number">0</span>,nums);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<p><strong>固定-交换法</strong></p>
<p>还有一种思路，这个更好理解一丢丢：</p>
<p>n个数的全排列，一共有n!n!种情况. （n个位置，第一个位置有n种，当第一个位置固定下来之后，第二个位置有n-1种情况…）</p>
<p>全排列的过程：</p>
<ul>
<li>选择第一个字符</li>
<li>获得第一个字符固定下来之后的所有的全排列<ul>
<li>选择第二个字符</li>
<li>获得第一+ 二个字符固定下来之后的所有的全排列</li>
</ul>
</li>
</ul>
<p>从这个过程可见，这是一个递归的过程。</p>
<p>所以这种方式也是通过固定一个元素，进行剩余元素的交换。缺点是，每次交换过后需要再次交换以回到上一层数组。</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2017-12-23-21-01-06.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-23-21-01-06.png" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">permutationsSwitch</span> </span>&#123;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = nums[i];</div><div class="line">        nums[i] = nums[j];</div><div class="line">        nums[j] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> fixed)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(fixed == nums.length)&#123;</div><div class="line">            List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)&#123;</div><div class="line">                result.add(e);</div><div class="line">            &#125;</div><div class="line">            results.add(result);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = fixed;i &lt; nums.length;i++) &#123;</div><div class="line">                swap(nums,fixed,i);</div><div class="line">                helper(nums,fixed +<span class="number">1</span>);</div><div class="line">                swap(nums,fixed,i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        helper(nums,<span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Permutations-II"><a href="#Permutations-II" class="headerlink" title="Permutations II"></a><a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="external">Permutations II</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,<br><code>[1,1,2]</code> have the following unique permutations:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1,1,2],</div><div class="line">&gt;   [1,2,1],</div><div class="line">&gt;   [2,1,1]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>相比上一题，有重复元素</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>遇到重复元素先排序，排序之后按照上题的思路，</p>
<p>注意：选取同一位置上的元素时，需要跳过重复元素</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermutationsII</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] hasVisit;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; results;</div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (n == nums.length)&#123;</div><div class="line">            <span class="comment">//结果放入results</span></div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> last = Integer.MIN_VALUE;<span class="comment">//用以就该位置当前元素，下一轮遇到重复时需要跳过</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">                <span class="keyword">if</span>(hasVisit[i] || (i != <span class="number">0</span> &amp;&amp; nums[i] == last))&#123;<span class="comment">//这里不可以用nums[i] == nums[i-1]</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    hasVisit[i] = <span class="keyword">true</span>;</div><div class="line">                    result.add(nums[i]);</div><div class="line">                    solve(n+<span class="number">1</span>,nums);</div><div class="line">                    hasVisit[i] = <span class="keyword">false</span>;</div><div class="line">                    result.remove(result.size()-<span class="number">1</span>);</div><div class="line">                    last = nums[i];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        <span class="keyword">this</span>.results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">this</span>.hasVisit = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">        Arrays.sort(nums);</div><div class="line">        solve(<span class="number">0</span>,nums);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Permutation-Sequence"><a href="#Permutation-Sequence" class="headerlink" title="Permutation Sequence"></a><a href="https://leetcode.com/problems/permutation-sequence/" target="_blank" rel="external">Permutation Sequence</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>The set <code>[1,2,3,…,*n*]</code> contains a total of <em>n</em>! unique permutations.</p>
<p>By listing and labeling all of the permutations in order,<br>We get the following sequence (ie, for <em>n</em> = 3):</p>
<ol>
<li><code>&quot;123&quot;</code></li>
<li><code>&quot;132&quot;</code></li>
<li><code>&quot;213&quot;</code></li>
<li><code>&quot;231&quot;</code></li>
<li><code>&quot;312&quot;</code></li>
<li><code>&quot;321&quot;</code></li>
</ol>
<p>Given <em>n</em> and <em>k</em>, return the <em>k</em>th permutation sequence.</p>
<p><strong>Note:</strong> Given <em>n</em> will be between 1 and 9 inclusive.</p>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>对于<code>n</code>个字符组成的字符串<code>{1,2,3,...,n}</code>，取第<code>k</code>个数时，首先可以求出第一个数，即<code>(k-1)/(n-1)!</code>。</p>
<p>按照这样的方法依次求出每一位的数字。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span>[] hasVisit;</div><div class="line">String result = <span class="keyword">new</span> String();</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calProduct</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> result = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</div><div class="line">    result *= n;</div><div class="line">    n--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(n == nums.length)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//要找到第nn个数字放到这里</span></div><div class="line">  <span class="keyword">int</span> nn = (k-<span class="number">1</span>)/calProduct(nums.length-n-<span class="number">1</span>);</div><div class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(j &lt; nums.length &amp;&amp; num &lt; nn)&#123;</div><div class="line">    <span class="comment">//如果nums[j]已经被用过了</span></div><div class="line">    <span class="keyword">while</span>(hasVisit[j])&#123;</div><div class="line">      j++;</div><div class="line">    &#125;</div><div class="line">    num++;</div><div class="line">    j++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span>(hasVisit[j])&#123;</div><div class="line">    j++;</div><div class="line">  &#125;</div><div class="line">  result += nums[j];</div><div class="line">  hasVisit[j] = <span class="keyword">true</span>;</div><div class="line">  solve(n+<span class="number">1</span>,nums,k - (nn)*calProduct(nums.length-n-<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</div><div class="line">    nums[i-<span class="number">1</span>] = i;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.hasVisit = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">  solve(<span class="number">0</span>,nums,k);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Binary-Watch"><a href="#Binary-Watch" class="headerlink" title="Binary Watch"></a><a href="https://leetcode.com/problems/binary-watch/" target="_blank" rel="external">Binary Watch</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>A binary watch has 4 LEDs on the top which represent the <strong>hours</strong> (<strong>0-11</strong>), and the 6 LEDs on the bottom represent the <strong>minutes</strong> (<strong>0-59</strong>).</p>
<p>Each LED represents a zero or one, with the least significant bit on the right.</p>
<p>For example, the above binary watch reads “3:25”.</p>
<p>Given a non-negative integer <em>n</em> which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: n = 1</div><div class="line">&gt; Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>The order of output does not matter.</li>
<li>The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.</li>
<li>The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.</li>
</ul>
</blockquote>
<p>一个二进制手表，第一行有4个灯代表小时，第二行有6个灯代表分钟，给定一个num表示总共可以亮的灯的数量，返回所有可能的时间</p>
<p>注意：时间表示范围为0-11:59</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>方法一：</p>
<p>分别对小时和分钟进行回溯，把num分配到两行上，计算小时和分钟的可能值，再进行组合输出</p>
<p>方法二：</p>
<p>利用<code>Integer.bitCount()</code> 函数计算二进制表示的1的个数，遍历00:00-11:59所有的时间，当小时和分钟的二进制表示中1的个数和为0时输出到结果集合。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryWatch</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; HorM;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; HHs;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; MMs;</div><div class="line"></div><div class="line">    <span class="comment">//计算时间,转化为字符串</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">calTime</span><span class="params">(List&lt;Integer&gt; hour,List&lt;Integer&gt; minute)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] hh = &#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] mm = &#123;<span class="number">32</span>,<span class="number">16</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</div><div class="line">        String res = <span class="keyword">new</span> String();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>;i++)&#123;</div><div class="line">            h += hour.get(i) * hh[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>;i++)&#123;</div><div class="line">            m += minute.get(i) * mm[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(h &lt;<span class="number">12</span> &amp;&amp; m &lt; <span class="number">60</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(m&lt;<span class="number">10</span>)&#123;</div><div class="line">                res = Integer.toString(h) + <span class="string">":0"</span> + Integer.toString(m);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                res = Integer.toString(h) + <span class="string">":"</span> + Integer.toString(m);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//计算小时或者分钟</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> oneSum,List&lt;Integer&gt; HorM,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(HorM.size() == n &amp;&amp; oneSum == <span class="number">0</span>)&#123;</div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(HorM);</div><div class="line">            <span class="keyword">if</span>(n==<span class="number">4</span>)&#123;</div><div class="line">                HHs.add(temp);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                MMs.add(temp);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(HorM.size() == n &amp;&amp; oneSum != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            HorM.add(<span class="number">0</span>);</div><div class="line">            solve(oneSum,HorM,n);</div><div class="line">            HorM.remove(HorM.size()-<span class="number">1</span>);</div><div class="line">            HorM.add(<span class="number">1</span>);</div><div class="line">            solve(oneSum - <span class="number">1</span>,HorM,n);</div><div class="line">            HorM.remove(HorM.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">//计算第一行最少和最多放置几个元素</span></div><div class="line">        <span class="keyword">int</span> min = Math.min(<span class="number">0</span>,Math.max(<span class="number">0</span>,num-<span class="number">8</span>));</div><div class="line">        <span class="keyword">int</span> max = Math.min(<span class="number">4</span>,num);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = min ; i &lt;= max;i++)&#123;</div><div class="line">            HHs = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            MMs = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            HorM = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="comment">//i为第一行放置个数</span></div><div class="line">            <span class="comment">//计算小时数组</span></div><div class="line">            solve(i,HorM,<span class="number">4</span>);</div><div class="line">            <span class="comment">//计算分钟数组</span></div><div class="line">            HorM = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            solve(num - i,HorM,<span class="number">6</span>);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; HHs.size();ii++)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> jj = <span class="number">0</span> ; jj &lt; MMs.size();jj++)&#123;</div><div class="line">                    String res = calTime(HHs.get(ii),MMs.get(jj));</div><div class="line">                    <span class="keyword">if</span>(!res.isEmpty())&#123;</div><div class="line">                        result.add(res);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        BinaryWatch test = <span class="keyword">new</span> BinaryWatch();</div><div class="line">        List&lt;String&gt; result = test.readBinaryWatch(<span class="number">2</span>);</div><div class="line">        System.out.print(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">12</span>; h ++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">60</span>; m ++) &#123;</div><div class="line">                <span class="keyword">if</span> (Integer.bitCount(h) + Integer.bitCount(m) == num) &#123;</div><div class="line">                    <span class="keyword">if</span> (m &lt; <span class="number">10</span>) &#123;</div><div class="line">                        res.add(h + <span class="string">":"</span> + <span class="string">"0"</span> + m);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        res.add(h + <span class="string">":"</span> + m);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Next-Permutation"><a href="#Next-Permutation" class="headerlink" title="Next Permutation"></a><a href="https://leetcode.com/problems/next-permutation" target="_blank" rel="external">Next Permutation</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p>
</blockquote>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>如果数组是降序的，则这几个数组的组合中，后面没有了：</p>
<p>比如[9,7,6,5,4]，这几个数字是降序的，由这几个数字组成的排列中没有序号大于这个组合方式的了。</p>
<p>当数组中出现升序位置时，说明后面有编号大于此排列的排列情况</p>
<p><img src="https://leetcode.com/media/original_images/31_Next_Permutation.gif" alt="Next Permutation"></p>
<p>步骤：</p>
<ol>
<li>找到第一处升序数组[4,7]</li>
<li>将升序位置与后面数组中最后一个大于该元素的位置交换[4,5]</li>
<li>此时原来5位置的后面都比4小，前面都比4大，而且是降序，所以将后半段数组倒置即可。</li>
</ol>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//交换两个位置</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> temp = nums[i];</div><div class="line">  nums[i] = nums[j];</div><div class="line">  nums[j] = temp;</div><div class="line">&#125;</div><div class="line"><span class="comment">//数组反转</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">  <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">    <span class="keyword">int</span> temp = nums[i];</div><div class="line">    nums[i] = nums[j];</div><div class="line">    nums[j] = temp;</div><div class="line">    i++;</div><div class="line">    j--;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="comment">//找第一次出现升序的地方</span></div><div class="line">  <span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    i--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</div><div class="line">    reverse(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//找到第一个比nums[i-1]小的数字</span></div><div class="line">    <span class="keyword">int</span> j = i+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> target = nums[i-<span class="number">1</span>];</div><div class="line">    <span class="keyword">while</span>(j &lt; nums.length)&#123;</div><div class="line">      <span class="keyword">if</span>(nums[j] &lt;= target)&#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      j++;</div><div class="line">    &#125;</div><div class="line">    swap(nums,i-<span class="number">1</span>,j-<span class="number">1</span>);</div><div class="line">    reverse(nums,i,nums.length-<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><h3 id="Combinations"><a href="#Combinations" class="headerlink" title="Combinations"></a><a href="https://leetcode.com/problems/combinations/" target="_blank" rel="external">Combinations</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 … <em>n</em>.</p>
<p>For example,<br>If <em>n</em> = 4 and <em>k</em> = 2, a solution is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [2,4],</div><div class="line">&gt;   [3,4],</div><div class="line">&gt;   [2,3],</div><div class="line">&gt;   [1,2],</div><div class="line">&gt;   [1,3],</div><div class="line">&gt;   [1,4],</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定n和k，给出<script type="math/tex">C(n,k)</script> 的全部组合方式</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>非常典型的回溯问题</p>
<p>思路就是从n个里面选择1个，然后再剩余的n-1个里面选择k-1个</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">//一共1-n和数字，从start开始，选择k个</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> start,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">  <span class="comment">//k个都选完了，加入结果</span></div><div class="line">  <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</div><div class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    temp.addAll(result);</div><div class="line">    results.add(temp);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//遍历到最后了，但是没选够k个，返回</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(start == n+<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//遍历从start右边的元素，选取一个，在剩下的元素中选取k-1个</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= n;i++)&#123;</div><div class="line">      result.add(i);</div><div class="line">      solve(n,i+<span class="number">1</span>,k-<span class="number">1</span>);</div><div class="line">      result.remove(result.size()-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</div><div class="line">  solve(n,<span class="number">1</span>,k);</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Combination-Sum"><a href="#Combination-Sum" class="headerlink" title="Combination Sum"></a><a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="external">Combination Sum</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a <strong>set</strong> of candidate numbers (<strong>C</strong>) <strong>(without duplicates)</strong> and a target number (<strong>T</strong>), find all unique combinations in <strong>C</strong> where the candidate numbers sums to <strong>T</strong>.</p>
<p>The <strong>same</strong> repeated number may be chosen from <strong>C</strong> unlimited number of times.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p>For example, given candidate set <code>[2, 3, 6, 7]</code> and target <code>7</code>,<br>A solution set is: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [7],</div><div class="line">&gt;   [2, 2, 3]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给一个数组和一个target.求数组中的元素和等于target的所有可能。元素可以多次取。</p>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>回溯</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSum</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; <span class="number">0</span> || start == candidates.length)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt; candidates.length;i++)&#123;</div><div class="line">                result.add(candidates[i]);</div><div class="line">                solve(candidates,target-candidates[i],i);</div><div class="line">                result.remove(result.size()-<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</div><div class="line">        solve(candidates,target,<span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Combination-Sum-II"><a href="#Combination-Sum-II" class="headerlink" title="Combination Sum II"></a><a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="external">Combination Sum II</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a collection of candidate numbers (<strong>C</strong>) and a target number (<strong>T</strong>), find all unique combinations in <strong>C</strong> where the candidate numbers sums to <strong>T</strong>.</p>
<p>Each number in <strong>C</strong> may only be used <strong>once</strong> in the combination.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p>For example, given candidate set <code>[10, 1, 2, 7, 6, 1, 5]</code> and target <code>8</code>,<br>A solution set is: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1, 7],</div><div class="line">&gt;   [1, 2, 5],</div><div class="line">&gt;   [2, 6],</div><div class="line">&gt;   [1, 1, 6]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给一个有重数组和一个target.求数组中的元素和等于target的所有可能。元素不可以多次取。</p>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>这道题与上一题的最大区别就是不能多次取！需要注意的地方就是递归进入时的i需要加一（跳过本元素）</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSum</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; <span class="number">0</span> || start == candidates.length)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt; candidates.length;i++)&#123;</div><div class="line">                <span class="keyword">if</span>(i &gt; start  &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])<span class="keyword">continue</span>; <span class="comment">// 去重</span></div><div class="line">                result.add(candidates[i]);</div><div class="line">                solve(candidates,target-candidates[i],i+<span class="number">1</span>);</div><div class="line">                result.remove(result.size()-<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</div><div class="line">        Arrays.sort(candidates);</div><div class="line">        solve(candidates,target,<span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        CombinationSum test = <span class="keyword">new</span> CombinationSum();</div><div class="line">        <span class="keyword">int</span>[] candidates = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</div><div class="line">        <span class="keyword">int</span> target = <span class="number">7</span>;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; resuts = test.combinationSum(candidates,target);</div><div class="line">        System.out.print(resuts);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Combination-Sum-III"><a href="#Combination-Sum-III" class="headerlink" title="Combination Sum III"></a><a href="https://leetcode.com/problems/combination-sum-iii/" target="_blank" rel="external">Combination Sum III</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Find all possible combinations of <strong>*k*</strong> numbers that add up to a number <strong>*n*</strong>, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p><strong>*Example 1:*</strong></p>
<p>Input: <strong>*k*</strong> = 3, <strong>*n*</strong> = 7</p>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [[1,2,4]]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>*Example 2:*</strong></p>
<p>Input: <strong>*k*</strong> = 3, <strong>*n*</strong> = 9</p>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [[1,2,6], [1,3,5], [2,3,4]]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>求k个数（0-9的数）的和为n的所有组合。</p>
<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>还是回溯问题。</p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(k == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>)&#123;</div><div class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    temp.addAll(result);</div><div class="line">    results.add(temp);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt;= <span class="number">9</span>; i++)&#123;</div><div class="line">      result.add(i);</div><div class="line">      solve(k-<span class="number">1</span>,n-i,i+<span class="number">1</span>);</div><div class="line">      result.remove(result.size()-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Count-Numbers-with-Unique-Digits"><a href="#Count-Numbers-with-Unique-Digits" class="headerlink" title="Count Numbers with Unique Digits"></a><a href="https://leetcode.com/problems/count-numbers-with-unique-digits/" target="_blank" rel="external">Count Numbers with Unique Digits</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a <strong>non-negative</strong> integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10n.</p>
<p><strong>Example:</strong><br>Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding <code>[11,22,33,44,55,66,77,88,99]</code>)</p>
<p><strong>Credits:</strong><br>Special thanks to <a href="https://discuss.leetcode.com/user/memoryless" target="_blank" rel="external">@memoryless</a> for adding this problem and creating all test cases.</p>
</blockquote>
<p>给一个n。求x的个数，其中0&lt;=x&lt;=10n0&lt;=x&lt;=10n ，且x的每一位的数字都不相同。</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">n位数的可能有如下：</div><div class="line"></div><div class="line"><span class="number">0</span>      （就是<span class="number">0</span>）</div><div class="line"><span class="number">1</span> 位数 -&gt; C(<span class="number">9</span>,<span class="number">1</span>)  (从<span class="number">1</span>-<span class="number">9</span>里随机挑选一个)</div><div class="line"><span class="number">2</span> 位数 -&gt; C(<span class="number">9</span>,<span class="number">1</span>) * C(<span class="number">9</span>,<span class="number">1</span>)  (第一位从<span class="number">1</span>-<span class="number">9</span>挑，第二位与第一位不同即可，所以也是<span class="number">9</span>种)</div><div class="line"><span class="number">3</span> 位数 -&gt; C(<span class="number">9</span>,<span class="number">1</span>) * C(<span class="number">9</span>,<span class="number">1</span>) * C(<span class="number">8</span>,<span class="number">1</span>) (第一位从<span class="number">1</span>-<span class="number">9</span>挑，第二位与第一位不同，第三位与前两位不同)</div><div class="line">...</div><div class="line">n 位数</div><div class="line"></div><div class="line">代码：</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> num;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span>[] c = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</div><div class="line">            <span class="keyword">int</span> product = <span class="number">9</span>;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span>(i &lt; n-<span class="number">1</span>)&#123;</div><div class="line">                product *= c[i];</div><div class="line">                num += product;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Beautiful-Arrangement"><a href="#Beautiful-Arrangement" class="headerlink" title="Beautiful Arrangement"></a><a href="https://leetcode.com/problems/beautiful-arrangement/" target="_blank" rel="external">Beautiful Arrangement</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Suppose you have <strong>N</strong> integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these <strong>N</strong> numbers successfully if one of the following is true for the ith position (1 &lt;= i &lt;= N) in this array:</p>
<ol>
<li>The number at the ith position is divisible by <strong>i</strong>.</li>
<li><strong>i</strong> is divisible by the number at the ith position.</li>
</ol>
<p>Now given N, how many beautiful arrangements can you construct?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 2</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: </div><div class="line">&gt;</div><div class="line">&gt; The first beautiful arrangement is [1, 2]:</div><div class="line">&gt;</div><div class="line">&gt; Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).</div><div class="line">&gt;</div><div class="line">&gt; Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).</div><div class="line">&gt;</div><div class="line">&gt; The second beautiful arrangement is [2, 1]:</div><div class="line">&gt;</div><div class="line">&gt; Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).</div><div class="line">&gt;</div><div class="line">&gt; Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>回溯，遇到满足条件的sum++;</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeautifulArrangement</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] map;</div><div class="line">    <span class="keyword">int</span>[] result;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> val)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(idx % val == <span class="number">0</span> || (idx !=<span class="number">0</span> &amp;&amp; val % idx == <span class="number">0</span>))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> N)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(idx == N)&#123;</div><div class="line">            sum++;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;i++)&#123;</div><div class="line">                <span class="keyword">if</span>(!map[i-<span class="number">1</span>] &amp;&amp; isValid(idx+<span class="number">1</span>,i))&#123;</div><div class="line">                    result[idx] = i;</div><div class="line">                    map[i-<span class="number">1</span>] = <span class="keyword">true</span>;</div><div class="line">                    solve(idx+<span class="number">1</span>,N);</div><div class="line">                    map[i-<span class="number">1</span>] = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</div><div class="line">        <span class="keyword">this</span>.result = <span class="keyword">new</span> <span class="keyword">int</span>[N];</div><div class="line">        solve(<span class="number">0</span>,N);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Letter Combinations of a Phone Number"></a><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="external">Letter Combinations of a Phone Number</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:Digit string &quot;23&quot;</div><div class="line">&gt; Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>组合问题，回溯即可</p>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LetterCombinationsofaPhoneNumber</span> </span>&#123;</div><div class="line">    HashMap&lt;Character, <span class="keyword">char</span>[]&gt; table = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    String result = <span class="keyword">new</span> String();</div><div class="line">    List&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildTable</span><span class="params">()</span></span>&#123;</div><div class="line">        table.put(<span class="string">'1'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>]);</div><div class="line">        table.put(<span class="string">'2'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;);</div><div class="line">        table.put(<span class="string">'3'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;);</div><div class="line">        table.put(<span class="string">'4'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>&#125;);</div><div class="line">        table.put(<span class="string">'5'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>&#125;);</div><div class="line">        table.put(<span class="string">'6'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>&#125;);</div><div class="line">        table.put(<span class="string">'7'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>&#125;);</div><div class="line">        table.put(<span class="string">'8'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>&#125;);</div><div class="line">        table.put(<span class="string">'9'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>&#125;);</div><div class="line">        table.put(<span class="string">'0'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">' '</span>&#125;);</div><div class="line">        table.put(<span class="string">'#'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'#'</span>&#125;);</div><div class="line">        table.put(<span class="string">'*'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'*'</span>&#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(String digits,<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(idx == digits.length())&#123;</div><div class="line">            String temp = <span class="keyword">new</span> String();</div><div class="line">            temp += result;</div><div class="line">            <span class="keyword">if</span>(!temp.isEmpty())&#123;</div><div class="line">                results.add(temp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(table.get(digits.charAt(idx)).length == <span class="number">0</span>)&#123;</div><div class="line">                solve(digits,idx+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(table.get(digits.charAt(idx)).length == <span class="number">1</span>)&#123;</div><div class="line">                result += table.get(digits.charAt(idx))[<span class="number">0</span>];</div><div class="line">                solve(digits,idx+<span class="number">1</span>);</div><div class="line">                result = result.substring(<span class="number">0</span>,result.length()-<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; table.get(digits.charAt(idx)).length;i++)&#123;</div><div class="line">                    result += table.get(digits.charAt(idx))[i];</div><div class="line">                    solve(digits,idx+<span class="number">1</span>);</div><div class="line">                    result = result.substring(<span class="number">0</span>,result.length()-<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</div><div class="line">        buildTable();</div><div class="line">        solve(digits,<span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"></div><div class="line">        LetterCombinationsofaPhoneNumber test = <span class="keyword">new</span> LetterCombinationsofaPhoneNumber();</div><div class="line">        String digits = <span class="string">"22"</span>;</div><div class="line">        test.buildTable();</div><div class="line">        List&lt;String&gt; results = test.letterCombinations(digits);</div><div class="line">        System.out.print(results);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Generate-Parentheses"><a href="#Generate-Parentheses" class="headerlink" title="Generate Parentheses"></a><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="external">Generate Parentheses</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given <em>n</em> = 3, a solution set is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   &quot;((()))&quot;,</div><div class="line">&gt;   &quot;(()())&quot;,</div><div class="line">&gt;   &quot;(())()&quot;,</div><div class="line">&gt;   &quot;()(())&quot;,</div><div class="line">&gt;   &quot;()()()&quot;</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>回溯，向2n个位置放<code>‘(’</code>  或<code>‘)’</code> 用变量<code>rightNeed</code> 表示右边还需要的<code>‘)’</code>数量，也就是当前<code>‘(’</code>  与<code>‘)’</code> 的数量差：</p>
<ol>
<li>如果放置过程中出现右括号必做括号多的情况，返回上一层，因为这种情况不可能是结果了，无需向下计算</li>
<li>当2n个括号放置完毕，且左右括号相等时</li>
<li>加入括号有两重方式，加入左括号或者右括号</li>
</ol>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    List&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    String result = <span class="keyword">new</span> String();</div><div class="line">    <span class="keyword">char</span>[] parentheses;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> rightNeed,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(rightNeed &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(idx == <span class="number">2</span>*n)&#123;</div><div class="line">            <span class="keyword">if</span>(rightNeed == <span class="number">0</span>)&#123;</div><div class="line">                String temp = <span class="keyword">new</span> String();</div><div class="line">                temp += result;</div><div class="line">                results.add(temp);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//加入括号分两种情况讨论：left和right</span></div><div class="line">            result += <span class="string">'('</span>;</div><div class="line">            solve(idx+<span class="number">1</span>,rightNeed+<span class="number">1</span>,n);</div><div class="line">            result = result.substring(<span class="number">0</span>,result.length()-<span class="number">1</span>);</div><div class="line"></div><div class="line">            result += <span class="string">')'</span>;</div><div class="line">            solve(idx+<span class="number">1</span>,rightNeed-<span class="number">1</span>,n);</div><div class="line">            result = result.substring(<span class="number">0</span>,result.length()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        solve(<span class="number">0</span>,<span class="number">0</span>,n);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Sudoku-Solver"><a href="#Sudoku-Solver" class="headerlink" title="Sudoku Solver"></a><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="external">Sudoku Solver</a></h3><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>Empty cells are indicated by the character <code>&#39;.&#39;</code>.</p>
<p>You may assume that there will be only one unique solution.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p>
<p>A sudoku puzzle…</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="img"></p>
<p>9×99×9 的数独，填入数字1-9，要求行列不重复，且每个宫内不重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span>[][] usedinLine = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];<span class="comment">//第i行中是否用过数字k</span></div><div class="line"><span class="keyword">boolean</span>[][] usedinCol = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];<span class="comment">//第i列中是否用过数字k</span></div><div class="line"><span class="keyword">boolean</span>[][][] usedinBlock = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];<span class="comment">//第ij个格子中是否用过数字k</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">9</span>;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">9</span>;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)&#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= <span class="number">9</span>; val++) &#123;</div><div class="line">          <span class="keyword">if</span> (!usedinLine[i][val - <span class="number">1</span>] &amp;&amp; !usedinCol[j][val - <span class="number">1</span>] &amp;&amp; !usedinBlock[i / <span class="number">3</span>][j / <span class="number">3</span>][val - <span class="number">1</span>]) &#123;</div><div class="line">            usedinLine[i][val - <span class="number">1</span>] = <span class="keyword">true</span>;</div><div class="line">            usedinCol[j][val - <span class="number">1</span>] = <span class="keyword">true</span>;</div><div class="line">            usedinBlock[i / <span class="number">3</span>][j / <span class="number">3</span>][val - <span class="number">1</span>] = <span class="keyword">true</span>;</div><div class="line">            board[i][j] = (<span class="keyword">char</span>) (val + <span class="number">48</span>);</div><div class="line">            <span class="keyword">if</span> (solve(board)) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            usedinLine[i][val - <span class="number">1</span>] = <span class="keyword">false</span>;</div><div class="line">            usedinCol[j][val - <span class="number">1</span>] = <span class="keyword">false</span>;</div><div class="line">            usedinBlock[i / <span class="number">3</span>][j / <span class="number">3</span>][val - <span class="number">1</span>] = <span class="keyword">false</span>;</div><div class="line">            board[i][j] = <span class="string">'.'</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">9</span>;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">9</span>;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)&#123;</div><div class="line">        usedinLine[i][board[i][j]-<span class="string">'1'</span>] = <span class="keyword">true</span>;</div><div class="line">        usedinCol[j][board[i][j]-<span class="string">'1'</span>] = <span class="keyword">true</span>;</div><div class="line">        usedinBlock[i/<span class="number">3</span>][j/<span class="number">3</span>][board[i][j]-<span class="string">'1'</span>] = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  solve(board);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Wildcard-Matching"><a href="#Wildcard-Matching" class="headerlink" title="Wildcard Matching"></a><a href="https://leetcode.com/problems/wildcard-matching" target="_blank" rel="external">Wildcard Matching</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; &apos;?&apos; Matches any single character.</div><div class="line">&gt; &apos;*&apos; Matches any sequence of characters (including the empty sequence).</div><div class="line">&gt;</div><div class="line">&gt; The matching should cover the entire input string (not partial).</div><div class="line">&gt;</div><div class="line">&gt; The function prototype should be:</div><div class="line">&gt; bool isMatch(const char *s, const char *p)</div><div class="line">&gt;</div><div class="line">&gt; Some examples:</div><div class="line">&gt; isMatch(&quot;aa&quot;,&quot;a&quot;) → false</div><div class="line">&gt; isMatch(&quot;aa&quot;,&quot;aa&quot;) → true</div><div class="line">&gt; isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false</div><div class="line">&gt; isMatch(&quot;aa&quot;, &quot;*&quot;) → true</div><div class="line">&gt; isMatch(&quot;aa&quot;, &quot;a*&quot;) → true</div><div class="line">&gt; isMatch(&quot;ab&quot;, &quot;?*&quot;) → true</div><div class="line">&gt; isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → false</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>被伤透了的一道题。。。凉凉</p>
<p>思路就是：两指针i,j + 回溯</p>
<ol>
<li>两指针所指元素相等或者j指向‘?’，两指针后移递归调用</li>
<li>两指针指的元素不相等，j也没指向‘?’和‘*’，这种情况凑不成一样的了，回溯</li>
<li>如果j指向‘*’i可以选择跳过0\1\2.…一直到可以跳到最后一个元素，然后j也向后跳一个，看后面的是否相等，也就是递归调用了</li>
</ol>
<p>边界条件：</p>
<ol>
<li>两指针都指向末尾了，返回true</li>
<li>j到末尾了，i没有，返回false</li>
<li>i到末尾了，j没有，如果j后面都是*则返回true,否则不可能相等，返回true</li>
</ol>
<p>写完了超时了，因为ij组合会重复计算，所以需要用dp,把算过的存下来</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildcardMatching</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(String s, String p,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    <span class="comment">//边界条件</span></div><div class="line">    <span class="comment">//两指针都遍历到末尾</span></div><div class="line">    <span class="keyword">if</span>(i == s.length() &amp;&amp; j == p.length())&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//j遍历到末尾，i没有</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j == p.length())&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//i指针遍历到末尾，j没有</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == s.length())&#123;</div><div class="line">      <span class="comment">//如果j后面都是*了，则可以相等</span></div><div class="line">      <span class="keyword">while</span>(j &lt; p.length() &amp;&amp; p.charAt(j) == <span class="string">'*'</span>)&#123;</div><div class="line">        j++;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(j == p.length())&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//如果j后面不是全是*则一定不可以</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遇到*，i可以继续向后遍历，判断是否相等，回溯</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</div><div class="line">      <span class="keyword">while</span>(i &lt;= s.length())&#123;</div><div class="line">        <span class="keyword">if</span>(solve(s,p,i,j+<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        i++;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遇到？或者两个字符相等，继续匹配下一个</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j) == <span class="string">'?'</span> || s.charAt(i) == p.charAt(j))&#123;</div><div class="line">      <span class="keyword">return</span> solve(s,p,i+<span class="number">1</span>,j+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//两字符单纯地不相等</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> solve(s,p,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    WildcardMatching test = <span class="keyword">new</span> WildcardMatching();</div><div class="line">    String s = <span class="string">"a"</span>;</div><div class="line">    String p = <span class="string">"aa"</span>;</div><div class="line">    <span class="keyword">boolean</span> a = test.solve(s,p,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">    System.out.print(a);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>改进DP：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span>[][] dp;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String s, String p,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">  <span class="comment">//计算过了 直接返回</span></div><div class="line">  <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//边界条件</span></div><div class="line">  <span class="comment">//两指针都遍历到末尾</span></div><div class="line">  <span class="keyword">if</span>(i == s.length() &amp;&amp; j == p.length())&#123;</div><div class="line">    dp[i][j] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//j遍历到末尾，i没有</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(j == p.length())&#123;</div><div class="line">    dp[i][j] = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//i指针遍历到末尾，j没有</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(i == s.length())&#123;</div><div class="line">    <span class="comment">//如果j后面都是*了，则可以相等</span></div><div class="line">    <span class="keyword">while</span>(j &lt; p.length() &amp;&amp; p.charAt(j) == <span class="string">'*'</span>)&#123;</div><div class="line">      j++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(j == p.length())&#123;</div><div class="line">      dp[i][j] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果j后面不是全是*则一定不可以</span></div><div class="line">    <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//遇到*，i可以继续向后遍历，判断是否相等，回溯</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</div><div class="line">    dp[i][j] = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt;= s.length())&#123;</div><div class="line">      <span class="keyword">if</span>(solve(s,p,i,j+<span class="number">1</span>) == <span class="number">1</span>)&#123;</div><div class="line">        dp[i][j] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> dp[i][j];</div><div class="line">      &#125;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[i-<span class="number">1</span>][j];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//遇到？或者两个字符相等，继续匹配下一个</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j) == <span class="string">'?'</span> || s.charAt(i) == p.charAt(j))&#123;</div><div class="line">    dp[i][j] = solve(s,p,i+<span class="number">1</span>,j+<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//两字符单纯地不相等</span></div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    dp[i][j] = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</div><div class="line">  dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</div><div class="line">  solve(s,p,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> dp[s.length()][p.length()]==<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Regular-Expression-Matching"><a href="#Regular-Expression-Matching" class="headerlink" title="Regular Expression Matching"></a><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="external">Regular Expression Matching</a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; &apos;.&apos; Matches any single character.</div><div class="line">&gt; &apos;*&apos; Matches zero or more of the preceding element.</div><div class="line">&gt;</div><div class="line">&gt; The matching should cover the entire input string (not partial).</div><div class="line">&gt;</div><div class="line">&gt; The function prototype should be:</div><div class="line">&gt; bool isMatch(const char *s, const char *p)</div><div class="line">&gt;</div><div class="line">&gt; Some examples:</div><div class="line">&gt; isMatch(&quot;aa&quot;,&quot;a&quot;) → false</div><div class="line">&gt; isMatch(&quot;aa&quot;,&quot;aa&quot;) → true</div><div class="line">&gt; isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false</div><div class="line">&gt; isMatch(&quot;aa&quot;, &quot;a*&quot;) → true</div><div class="line">&gt; isMatch(&quot;aa&quot;, &quot;.*&quot;) → true</div><div class="line">&gt; isMatch(&quot;ab&quot;, &quot;.*&quot;) → true</div><div class="line">&gt; isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p><code>.</code>可代表任意一个字母</p>
<p><code>*</code> 和它前面的字母组合m在一起，可以用于表示0或任意多个m</p>
<p>思路就是两指针，从后向前匹配，当遇到*时，有两种选择：</p>
<ol>
<li>匹配s中的0个（j-2,i不变），继续向后递归</li>
<li>匹配s中的1个（j不变,i-1），继续向后递归</li>
<li>多个的情况包含在2中</li>
</ol>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegularExpressionMatching</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(String s, String p,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> &amp;&amp; j &lt; <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; <span class="number">0</span>)&#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</div><div class="line">                <span class="keyword">return</span> solve(s,p,i,j-<span class="number">2</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</div><div class="line">            <span class="comment">//如果*前面一个是.或者是跟i指向的字母一样，可以选择匹配1个或者不匹配</span></div><div class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">'.'</span> || p.charAt(j-<span class="number">1</span>) == s.charAt(i))&#123;</div><div class="line">                <span class="keyword">return</span> solve(s, p,i-<span class="number">1</span>,j) || <span class="comment">//匹配了s中的1个字符，j向前移两位，继续，这里匹配了多个字符的情况包含在后续的计算中了</span></div><div class="line">                        solve(s,p,i,j-<span class="number">2</span>);<span class="comment">//匹配了s中的0个字符，j向前移两位，继续</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果*前面不是.也不和i指向的数字一样，只能让他复制0个，继续往后判断</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span>  solve(s, p,i,j-<span class="number">2</span>);<span class="comment">//匹配了s中的0个字符，j向前移两位，继续</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">'.'</span>)&#123;</div><div class="line">            <span class="keyword">return</span> solve(s,p,i-<span class="number">1</span>,j-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//指向字母不一样</span></div><div class="line">        <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> solve(s,p,s.length()-<span class="number">1</span>,p.length()-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        RegularExpressionMatching test = <span class="keyword">new</span> RegularExpressionMatching();</div><div class="line">        String s = <span class="string">"aab"</span>;</div><div class="line">        String p = <span class="string">"c*a*b"</span>;</div><div class="line">        <span class="keyword">boolean</span> a = test.isMatch(s,p);</div><div class="line">        System.out.print(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Subsets-II"><a href="#Subsets-II" class="headerlink" title="Subsets II    "></a><a href="https://leetcode.com/problems/subsets" target="_blank" rel="external"><a href="https://leetcode.com/problems/subsets-ii" target="_blank" rel="external">Subsets II</a>    </a></h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a collection of integers that might contain duplicates, <strong>nums</strong>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
<p>For example,<br>If <strong>nums</strong> = <code>[1,2,2]</code>, a solution is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [2],</div><div class="line">&gt;   [1],</div><div class="line">&gt;   [1,2,2],</div><div class="line">&gt;   [2,2],</div><div class="line">&gt;   [1,2],</div><div class="line">&gt;   []</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>遇到重复元素先排序，然后回溯。需要注意的是遇到重复的元素需要跳过，但是只有在本位置用过的才不可以用相同元素，所以需要加一个flag来验证一下</p>
<h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">if</span>(idx == nums.length)&#123;<span class="keyword">return</span>;&#125;</div><div class="line">  <span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = idx ; i &lt; nums.length;i++)&#123;</div><div class="line">      <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; flag)&#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      result.add(nums[i]);</div><div class="line">      List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">      temp.addAll(result);</div><div class="line">      results.add(temp);</div><div class="line">      solve(nums,i+<span class="number">1</span>);</div><div class="line">      result.remove(result.size()-<span class="number">1</span>);</div><div class="line">      flag = <span class="keyword">true</span>;<span class="comment">//记录在本位置是否用过</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">  Arrays.sort(nums);</div><div class="line">  results.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">  solve(nums,<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Increasing-Subsequences"><a href="#Increasing-Subsequences" class="headerlink" title="Increasing Subsequences"></a><a href="https://leetcode.com/problems/increasing-subsequences" target="_blank" rel="external">Increasing Subsequences</a></h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><blockquote>
<hr>
<p>Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [4, 6, 7, 7]</div><div class="line">&gt; Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>The length of the given array will not exceed 15.</li>
<li>The range of integer in the given array is [-100,100].</li>
<li>The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.</li>
</ol>
</blockquote>
<p>给定数组，列举所有递增子序列</p>
<h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>回溯</p>
<p>如果加入的元素比result中最后一个元素的，就加入结果集合，否则不加入，继续向后。对于重复元素，需要跳过，这里元素无法排序，所以需要一个额外的数组维护元素是否出现过。</p>
<h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncreasingSubsequences</span> </span>&#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] flag= <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">201</span>];</div><div class="line">    <span class="keyword">if</span>(idx == nums.length)&#123;<span class="keyword">return</span>;&#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = idx ; i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(flag[nums[i]+<span class="number">100</span>])&#123;</div><div class="line">          <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果当前result里没有元素或者当前元素比result里面的最后一个元素大，加入元素</span></div><div class="line">        <span class="keyword">if</span>(result.size() == <span class="number">0</span> || nums[i] &gt;= result.get(result.size()-<span class="number">1</span>))&#123;</div><div class="line">          result.add(nums[i]);</div><div class="line">          flag[nums[i]+<span class="number">100</span>] = <span class="keyword">true</span>;<span class="comment">//标志本轮这个元素用过了</span></div><div class="line">          <span class="keyword">if</span>(result.size() &gt; <span class="number">1</span>)&#123;<span class="comment">//如果当前子序列长度大于1,加入结果集</span></div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">          &#125;</div><div class="line">          solve(nums,i+<span class="number">1</span>);<span class="comment">//不管是不是加入结果集了，都要继续下一层</span></div><div class="line">          result.remove(result.size()-<span class="number">1</span>);<span class="comment">//有nums[i]的计算完毕，将其移除</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">    solve(nums,<span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    IncreasingSubsequences test = <span class="keyword">new</span> IncreasingSubsequences();</div><div class="line">    <span class="keyword">int</span>[] nums = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; res = test.findSubsequences(nums);</div><div class="line">    System.out.print(res);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Gray-Code"><a href="#Gray-Code" class="headerlink" title="Gray Code"></a><a href="https://leetcode.com/problems/gray-code/" target="_blank" rel="external">Gray Code</a></h3><h4 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer <em>n</em> representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<p>For example, given <em>n</em> = 2, return <code>[0,1,3,2]</code>. Its gray code sequence is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 00 - 0</div><div class="line">&gt; 01 - 1</div><div class="line">&gt; 11 - 3</div><div class="line">&gt; 10 - 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong><br>For a given <em>n</em>, a gray code sequence is not uniquely defined.</p>
<p>For example, <code>[0,2,3,1]</code> is also a valid gray code sequence according to the above definition.</p>
<p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p>
</blockquote>
<h4 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h4><p> <img src="http://omaby2s5z.bkt.clouddn.com/2018-01-16-18-15-09.png" alt=""></p>
<p>格雷码是很经典的问题，规则其实很简单，在二进制形式下，任何相邻的两个值的二进制表示形式只有一位是不同的，我们可以找找规律。</p>
<p>一位就是简单的：0,1</p>
<p>两位是：00,01,11,10</p>
<p>三位是：000,001,011,010,110,111,101,100</p>
<p>发现什么规律没有？我们把一位的两个数，前面加上0，就是二位的头两个数，前面加上1再反序，就是二位的后两个数。把二位的前面加上0，就是三位的头四个数，把二位的前面加上1再反过来，就是三位的后四个数。</p>
<p>也就是说，对于每多一位的格雷码，前面一半的第一位都是0，后面一半的第一位都是1，其余的位，前后两半正好是中间对称的，前面一半就是少一位的格雷码序列，后面一半时把其反序。</p>
<p>知道这个规律就好做了，我们可以递归来做，每次取n-1位的格雷码来做上述操作，对于一位的格雷码，直接赋值是0,1就可以了。</p>
<p>不过题目要求返回的是十进制数，而不是字符串，所以我们最好直接操作十进制数，这里前面加0其实就不用做什么，前面加1的话可以将1左移n-1位然后与各个数字相加即可。</p>
<p>注意题目说的n是非负数，所以要考虑n=0的情况，测试用例的n=0时返回的是0。</p>
<h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</div><div class="line">    results.add(<span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  results.add(<span class="number">0</span>);</div><div class="line">  results.add(<span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>)&#123; <span class="keyword">return</span> results;&#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(i &lt; n)&#123;</div><div class="line">    <span class="keyword">int</span> len = results.size();</div><div class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">int</span> delta = <span class="number">1</span>&lt;&lt;i;</div><div class="line">      results.add(results.get(len-<span class="number">1</span>) + delta);</div><div class="line">      len--;</div><div class="line">    &#125;</div><div class="line">    i++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006121957" target="_blank" rel="external">liuqi627的博客</a><br><a href="http://www.jianshu.com/p/8f3b8df612ae" target="_blank" rel="external">Jason_Yuan的博客</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c++STL中堆的使用]]></title>
      <url>/2017/11/04/c-STL%E4%B8%AD%E5%A0%86%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="方法一：priority-queue"><a href="#方法一：priority-queue" class="headerlink" title="方法一：priority_queue"></a>方法一：priority_queue</h2><p>这种方法需要<code>#include&lt;queue&gt;</code></p>
<p>最基本的使用方法，对于一串数字建堆：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">riority_queue&lt;<span class="keyword">int</span>&gt; heap;</div></pre></td></tr></table></figure>
<p>这种情况下默认为最大堆，也就是堆顶元素值最大。</p>
<p>如果需要建立最小堆，可以采用如下方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt;qi2;<span class="comment">//最小堆</span></div><div class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt;qi2;<span class="comment">//最大堆</span></div></pre></td></tr></table></figure>
<p>然而在多数情况下，我们还需要记录一些排序元素的额外信息，比如索引之类的，则需要以下三个步骤：</p>
<ol>
<li><p>定义堆中需要存储的结构体：</p>
<p>​</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line"><span class="keyword">int</span> x;</div><div class="line"><span class="keyword">int</span> y;</div><div class="line"><span class="keyword">int</span> val;</div><div class="line">Node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> valin):x(a),y(b),val(valin)&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>确定堆中元素的存储顺序，也就是最大堆还是最小堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">//设置比较函数，确定堆中元素的顺序，是最大堆还是最小堆，</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span>&#123;</div><div class="line">       	<span class="keyword">return</span> a.val&gt;b.val;<span class="comment">//最小堆</span></div><div class="line">      	<span class="comment">//return a.val&lt;b.val;//最大堆</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>建堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; heap;<span class="comment">//建堆</span></div><div class="line">heap.pop();<span class="comment">//出堆</span></div><div class="line">heap.push();<span class="comment">//入堆</span></div><div class="line">heap.top();<span class="comment">//获取堆顶元素</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="方法二：利用vector"><a href="#方法二：利用vector" class="headerlink" title="方法二：利用vector"></a>方法二：利用vector</h2><p>这种法法需要<code>#include&lt;algorithm&gt;</code> <code>#include &lt;functional&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</div><div class="line"><span class="comment">//建堆</span></div><div class="line">make_heap(a.begin(),a.end(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最大堆</span></div><div class="line">make_heap(a.begin(),a.end(), greater&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最小堆</span></div><div class="line"><span class="comment">//pop</span></div><div class="line">pop_heap(a.begin(),a.end(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最大值出堆</span></div><div class="line">pop_heap(a.begin(),a.end(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最小值出堆</span></div><div class="line"><span class="comment">//插入元素</span></div><div class="line">push_heap(a.begin(),a.end(),cmp);</div><div class="line"><span class="comment">//堆排序</span></div><div class="line">sort_heap(a.begin(),a.end(),cmp);</div><div class="line"><span class="comment">// push_heap ( begin , end )   将最后一个元素插入堆中（堆自动调整）</span></div><div class="line"><span class="comment">// pop_heap ( begin , end )   将第一个元素从堆中删去（堆自动调整），并放到最后</span></div><div class="line"><span class="comment">// find ( begin , end , value ) 从begin到end查找value，若找不到，返回end</span></div></pre></td></tr></table></figure>
<p>​     </p>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班】第k大]]></title>
      <url>/2017/11/04/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E7%AC%ACk%E5%A4%A7/</url>
      <content type="html"><![CDATA[<h1 id="求数组-矩阵的第k大元素"><a href="#求数组-矩阵的第k大元素" class="headerlink" title="求数组/矩阵的第k大元素"></a>求数组/矩阵的第k大元素</h1><p>涉及leetcode题目</p>
<ol>
<li><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/" target="_blank" rel="external">278. Kth Smallest Number In Matrix</a></li>
<li><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/" target="_blank" rel="external">373. Kth Smallest Sum In Two Sorted Arrays</a> </li>
<li>Kth Largest in N Arrays</li>
</ol>
<h2 id="278-Kth-Smallest-Number-In-Matrix"><a href="#278-Kth-Smallest-Number-In-Matrix" class="headerlink" title="278. Kth Smallest Number In Matrix"></a>278. Kth Smallest Number In Matrix</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>Given a <em>n</em> x <em>n</em> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
</blockquote>
<p>给定一个<script type="math/tex">n*n</script>的矩阵，满足行递增和列递增，要求返回第k大的元素。</p>
<p><strong>example</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">matrix = [</div><div class="line">   [ 1,  5,  9],</div><div class="line">   [10, 11, 13],</div><div class="line">   [12, 13, 15]</div><div class="line">],</div><div class="line">k = 8,</div><div class="line"></div><div class="line">return 13.</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="方法1：堆"><a href="#方法1：堆" class="headerlink" title="方法1：堆"></a>方法1：堆</h4><p>看到第k大问题，要想到用<strong>堆</strong></p>
<p>因为矩阵满足行递增和列递增，所以矩阵中的每一个元素的右边和下边元素一定比这个元素大。可以从左上角开始将元素放入一个最小堆中，每次从最小堆中取出一个元素，将其右边和下边的元素放入最小堆，这样就可以保证直到取出第k次的元素就是矩阵中第k大的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    Node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> valin):x(a),y(b),val(valin)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">         <span class="keyword">return</span> a.val&gt;b.val;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆</span></div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,matrix[i][j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=matrix.size()||ytemp&gt;=matrix[<span class="number">0</span>].size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,matrix[xadd][ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;      <span class="keyword">if</span>(yadd&gt;=matrix.size()||xtemp&gt;=matrix[<span class="number">0</span>].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法2：二分查找"><a href="#方法2：二分查找" class="headerlink" title="方法2：二分查找"></a>方法2：二分查找</h4><p>利用堆的方法可以解决上面的问题，但是时间复杂度不是很好。</p>
<p>看了leetcode题解，有二分查找的方式更快。</p>
<p>先找到矩阵的最大值max和最小值min，即左上和右下元素，然后以此作为二叉搜索的左右两边，求出其中间值mid，遍历矩阵元素，求出比该中值小的元素的个数count，分一下三种情况讨论：</p>
<ul>
<li>count&lt;k，说明比mid小的元素个数不足k个，则要寻找的值比mid大，故mid++;</li>
<li>count&gt;=k，说明比mid小或和mid值相等的元素个数多于k个，则要寻找的值&lt;=mid，故令max = mid，继续查找;</li>
<li>直到min和max回合，此时就找到了第k个元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> min = matrix[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> max = matrix[rows<span class="number">-1</span>][cols<span class="number">-1</span>];</div><div class="line">    <span class="keyword">while</span>(min &lt; max)&#123;</div><div class="line">        <span class="keyword">int</span> mid = (min+max)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//matrix中记录比mid小的元素的个数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j]&lt;=mid)&#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(count&gt;=k)&#123;</div><div class="line">            max = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            min = mid+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="373-Find-K-Pairs-with-Smallest-Sums"><a href="#373-Find-K-Pairs-with-Smallest-Sums" class="headerlink" title="373. Find K Pairs with Smallest Sums"></a>373. Find K Pairs with Smallest Sums</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>You are given two integer arrays <strong>nums1</strong> and <strong>nums2</strong> sorted in ascending order and an integer <strong>k</strong>.</p>
<p>Define a pair <strong>(u,v)</strong> which consists of one element from the first array and one element from the second array.</p>
<p>Find the k pairs <strong>(u1,v1),(u2,v2) …(uk,vk)</strong> with the smallest sums.</p>
</blockquote>
<p>给定一个整数k和两个数组<script type="math/tex">nums1</script>和<script type="math/tex">nums2</script>，两个数组内部升序排列，分别从两个数组中选择一个元素<script type="math/tex">u</script>和<script type="math/tex">v</script>构成数对<script type="math/tex">(u,v)</script>，返回和最小的前k个数对<script type="math/tex">(u_1,v_1),(u_2,v_2),...,(u_k,v_k)</script></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">Given nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">11</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],  k = <span class="number">3</span></div><div class="line">  </div><div class="line">Return: [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>]</div><div class="line"></div><div class="line">The first <span class="number">3</span> pairs are returned from the sequence:</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">6</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">6</span>]</div></pre></td></tr></table></figure>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题就是278的升级版，两个升序数组中各取一个元素做和，求最小的前k个，可以把两个升序数组看成是矩阵的两个维度：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>7</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>2+1=3</td>
<td>2+7=9</td>
<td>2+11=13</td>
</tr>
<tr>
<td>4</td>
<td>4+1=5</td>
<td>4+7=11</td>
<td>4+11=15</td>
</tr>
<tr>
<td>6</td>
<td>6+1=7</td>
<td>6+7=13</td>
<td>6+11=17</td>
</tr>
</tbody>
</table>
</div>
<p>显然，由元素对生成的矩阵和上题中具有相同的性质，同行同列都递增，所以只需要对上面的代码做轻微的调整即可：记录下元素对在原数组中的idx。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; kSmallestPairs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; results;</div><div class="line">    <span class="keyword">if</span>(nums1.size()==<span class="number">0</span>||nums2.size()==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    <span class="keyword">int</span> len1 = nums1.size();</div><div class="line">    <span class="keyword">int</span> len2 = nums2.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(len1,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len2,<span class="number">0</span>));</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,nums1[i]+nums2[j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> numslen = len1*len2;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> kkk = <span class="number">0</span>; kkk &lt; k&amp;&amp;kkk&lt;numslen;kkk++)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        results.push_back(make_pair(nums1[xtemp],nums2[ytemp]));</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=nums1.size()||ytemp&gt;=nums2.size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,nums1[xadd]+nums2[ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(xtemp&gt;=nums1.size()||yadd&gt;=nums2.size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,nums1[xtemp]+nums2[yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Kth-Largest-in-N-Arrays"><a href="#Kth-Largest-in-N-Arrays" class="headerlink" title="Kth Largest in N Arrays"></a>Kth Largest in N Arrays</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>给定N个无序数组，从中找出第k大的元素</p>
</blockquote>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>看到数组先排序，然后再想思路。寻找第k大的元素，需要维护一个堆。</p>
<ol>
<li>将N个数组中的最大值入堆</li>
<li>每次出堆一个元素，将该元素所在数组中的下一个入堆</li>
<li>循环k次，找到第k大的元素</li>
</ol>
<p>依旧沿用上面题的思路，这次除元素大小外，需要记录的额外信息为元素所在的数组idx1，以及在该数组中的idx2。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">  	<span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="comment">//按行排序,每行第一个入堆</span></div><div class="line">    <span class="keyword">for</span>(inti= <span class="number">0</span> ;i&lt;rows;i++)&#123;</div><div class="line">      sort(matrix[i].begin(),matrix[i].end());</div><div class="line">      <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,<span class="number">0</span>,matrix[i][<span class="number">0</span>])</span></span>;</div><div class="line">      minheap.push(nodetemp);</div><div class="line">      isin[i][j]=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆  </span></div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">      	<span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">       	<span class="keyword">int</span> yadd = ytemp++;</div><div class="line">        <span class="keyword">if</span>(yadd&gt;=matrix[x].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li>见到需要维护集合的最小/最大值的时候要想到<strong>堆</strong></li>
<li>见到第k小，想到用堆维护候选集合，出堆k次</li>
<li>见到数组要往排序上面想，先排序，然后再其他操作</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 九章算法 </tag>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DSP国内硕士论文总结]]></title>
      <url>/2017/11/02/DSP%E5%9B%BD%E5%86%85%E7%A1%95%E5%A3%AB%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>准备开题，先看一下国内的相关硕士学位论文，知网上down的。</p>
<h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><ul>
<li><p><strong>大数据平台下的互联网广告点击率预估模型</strong></p>
<p>基于腾讯社交广告数据集，hive+hadoop环境下实现GBDT+FM分布式点击率预估，用到贝叶斯平滑等，竞赛在分布式环境下的扩展。</p>
</li>
</ul>
<ul>
<li>​</li>
</ul>
<h2 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h2><ul>
<li><p><strong>针对在线广告实时竞价系统的相关算法研究、电子科大、郭威</strong></p>
<p>将竞价策略总结为预算控制和估价算法两个步骤，提出一种<strong>预算步进（buget pacing）算法和一个出价模型</strong></p>
<p>数据集：iPinyou</p>
<p>2.2介绍计算广告核心问题和<strong>结算方式</strong></p>
<p>核心问题：广告主、用户、媒体三方博弈，涉及信息检索、机器学习、最优化三个领域。</p>
<p><strong>结算方式以及适用场景：CPT-&gt;CPM-&gt;CPC-&gt;eCPM</strong> 这里总结的很好</p>
<p>第3章点击率预估：LR\GBDT \FM\在线算法online SGD，FTRL数据集Criteo</p>
<p>第4章设计了一个 <strong>buget pacing(预算步进)</strong> 策略</p>
<p>第5章竞价算法设计：DSP策略中的关键技术图</p>
<p>这个问题通常是一个约束最优化问题，约束是广告主一天的广告预算，最优某个性能指标，如点击数或转化数。</p>
</li>
</ul>
<h2 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h2><ul>
<li><p><strong>在线广告 DSP 平台实时竞价算法的研究与实现 、上海交通、韩静</strong></p>
<p>主要研究实时竞价算法，点击率预估和竞价策略。</p>
<p>ctr预估：LR和GBDT。</p>
<p>竞价策略：提出固定竞价、分组竞价（M6D）、综合竞价（非线性竞价）三种策略，进行数学推导</p>
<p>数据集：iPinyou，评价指标KPI</p>
<p><strong>利用这份数据集做实验的流程</strong> （第四章）：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-02-19-39-45.png" alt=""> </p>
</li>
</ul>
<ul>
<li><p><strong>广告点击率预估的深层神经网络模型研究</strong> 北邮 王孝舒</p>
<p>Criteo竞赛数据</p>
<p>baseline：LR</p>
<p>优化：DNN，分别选取sigmod和Relu作为激活函数进行实验</p>
</li>
<li><p><strong>互联网广告精准投放平台设计与实现 成都理工 葛泽泽</strong></p>
<p>基于hadoop、hive实现DSP平台</p>
<p><strong>国内外发展情况可参考</strong></p>
</li>
<li><p>基于流式计算的广告特征提取系统的设计与实现 钟晓诚 南京大学</p>
<p>做的是搜索广告的</p>
<p>流式广告特征提取系统，实时处理广告数据，不断训练、更新ctr预估模型，基于百度开发的流式计算框架Task Manager，集合HDFS\MapReduce</p>
<p>可以将广告特征数据反映到线上模型的时间缩短至分钟级</p>
<p>​</p>
</li>
<li><p>基于逻辑回归的在线广告ctr优化和预测 浙江大学 代成雷</p>
<p>用了LR和FTRL进行ctr预估</p>
</li>
<li><p>基于深度学习的搜索广告点击率预测方法研究 哈工大 李思琴</p>
<p>GPU、深度学习CTR预估与贝叶斯分类、LR、svm对比</p>
<p><strong>卷积神经网络</strong></p>
<p>KDD2012数据集</p>
<p>特征用到w2v</p>
<p>评估：AUC</p>
<p>​</p>
</li>
<li><p><strong>在线广告中实时竞价机制研究与算法实现 华中师范 朱丽辉</strong></p>
<p>当竞价较低时，提升竞价能大幅增加赢得竞价的概率；当竞价较高时，降低竞价对赢得竞价的概率影响不大。提出了预算再分配模型，将竞价空间分成不同的区间，将预算消耗在最优价格区间。结合上述两点给出了一个基于动态点击率预估的分段竞价算法，很好地解决了小广告主的利益问题。</p>
<p>本文提出了一个＂预算再分配＂的竞价策略：将广告主的整个竞价空间按照价格的高低划分为三个区间Ｐｉ，Ｐ２，Ｐ３，当估价在ＰＩ，Ｐ３的时候，对其进行相应的降价措施，当估价在Ｐ２的时候对其进行提价操作。</p>
<p>核心思想：当广告主的预算在非常有限的情况下，应该放弃那些过高的竞价以及没意义的竞价（估价过低），将预算尽量分配在适当的竞价范围。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-16-22-39-56.png" alt=""> </p>
<p>数据集：ipinyou</p>
</li>
<li><p>​</p>
</li>
</ul>
<h2 id="2014"><a href="#2014" class="headerlink" title="2014"></a>2014</h2><h2 id="2013"><a href="#2013" class="headerlink" title="2013"></a>2013</h2><ul>
<li><p><strong>互联网广告精准投放平台研究 华中师范 李志</strong></p>
<p>实现了一个DSP平台</p>
<p>用贝叶斯分类，对用户特征进行分类</p>
<p><strong>背景写的很好，有国内外DSP产品比较</strong></p>
<p><strong>平台设计和流程需要参考</strong></p>
<p>​</p>
</li>
<li><p>​</p>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      
        <categories>
            
            <category> DSP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hive中静态分区和动态分区]]></title>
      <url>/2017/11/02/Hive%E4%B8%AD%E9%9D%99%E6%80%81%E5%88%86%E5%8C%BA%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA/</url>
      <content type="html"><![CDATA[<h2 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h2><p>两者主要的差别在于：加载数据的时候，静态分区需要手动设定不同的分区，按分区分别导入数据，；而动态分区不需要指定分区key的值，会根据key对应列的值自动分区写入，如果该列值对应的分区目录还没有创建， 会自动创建并写入数据。</p>
<h2 id="静态分区"><a href="#静态分区" class="headerlink" title="静态分区"></a>静态分区</h2><h3 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h3><p>create table zhangsiyao.dt_0802_0815 (itime string,uid string,gid string,app_ver string,unet int ,device_type string,device_os string,client_type string,crtv_id int,country string,province string ,city string,isp string,ad_location string,ad_status string,age_gt string,sex_gt string,income_gt string,marital_status_gt string,sponsor_id int,creative_name string,creative_title string,creative_abstract string,category_id int,create_time string,update_time string) partitioned by (dt string);</p>
<h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>load data local inpath ‘/home/warehouse/user.txt’ overwrite into table teacher partition(work_date=”2016-07-12”);</p>
<p>需要按照分区一个分区一个分区导入数据</p>
<h2 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h2><h3 id="创建分区表（和静态分区一样）"><a href="#创建分区表（和静态分区一样）" class="headerlink" title="创建分区表（和静态分区一样）"></a>创建分区表（和静态分区一样）</h3><p>create table zhangsiyao.dt_0811_0820 (itime string,uid string,gid string,app_ver string,unet int ,device_type string,device_os string,client_type string,crtv_id int,country string,province string ,city string,isp string,ad_location string,ad_status string,age_gt string,sex_gt string,income_gt string,marital_status_gt string,sponsor_id int,creative_name string,creative_title string,creative_abstract string,category_id int,create_time string,update_time string) partitioned by (dt string);</p>
<h3 id="创建数据表（中间数据）"><a href="#创建数据表（中间数据）" class="headerlink" title="创建数据表（中间数据）"></a>创建数据表（中间数据）</h3><p>create table zhangsiyao.data_analy_11_20 as select a.itime,a.uid,a.gid,a.app_ver,a.unet ,a.device_type,a.device_os,a.client_type,a.crtv_id,a.country,a.province,a.city,a.isp,a.ad_location,a.ad_status,a.dt,b.age_gt,b.sex_gt,b.income_gt,b.marital_status_gt,c.sponsor_id,c.creative_name,c.creative_title,c.creative_abstract,c.category_id,c.create_time,c.update_time from (select <em> from ad.wireless_ad_org_final where dt&gt;’2017-08-10’ and crtv_id &lt;&gt;-1) a left join (select </em> from user_portraint.focus_user_portraint_profile where dt&gt;’2017-08-10’) b on (a.dt=b.dt and a.client_type=b.client_type and a.uid=b.uid) left join (select * from ad.ad_creative_ods where dt&gt;’2017-08-10’) c on (a.dt=b.dt and a.crtv_id=c.creative_id);</p>
<h3 id="设置动态分区"><a href="#设置动态分区" class="headerlink" title="设置动态分区"></a>设置动态分区</h3><p>set hive.exec.dynamic.partition=true;(可通过这个语句查看：set hive.exec.dynamic.partition;)<br>set hive.exec.dynamic.partition.mode=nonstrict; （strict要求至少有一个静态分区， nonstrict可以都是动态分区）<br>set hive.exec.max.dynamic.partitions=100000;(如果自动分区数大于这个参数，将会报错)<br>set hive.exec.max.dynamic.partitions.pernode=100000;</p>
<h3 id="导入数据-1"><a href="#导入数据-1" class="headerlink" title="导入数据"></a>导入数据</h3><p>insert overwrite table zhangsiyao.dt_0811_0820 partition(dt) select itime,uid,gid,app_ver,unet,device_type,device_os,client_type,crtv_id,country,province,city,isp,ad_location,ad_status,age_gt,sex_gt,income_gt,marital_status_gt,sponsor_id,creative_name,creative_title,creative_abstract,category_id,create_time,update_time,dt from zhangsiyao.data_analy_11_20 where dt&lt;’2017-08-21’;</p>
<p><strong>这里需要注意的是，用select选择数据导入动态分区时，要把关键字放在最后面，因为动态分区默认以最后一个关键字作为分区关键字</strong></p>
]]></content>
      
        <categories>
            
            <category> hive </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hive </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用Hive中percentile_approx计算等频划分分位点]]></title>
      <url>/2017/11/02/%E5%88%A9%E7%94%A8Hive%E4%B8%ADpercentile-approx%E8%AE%A1%E7%AE%97%E7%AD%89%E9%A2%91%E5%88%92%E5%88%86%E5%88%86%E4%BD%8D%E7%82%B9/</url>
      <content type="html"><![CDATA[<h2 id="等频划分"><a href="#等频划分" class="headerlink" title="等频划分"></a>等频划分</h2><p>等频划分：按照数据的分布情况，每个区间的数据数量一样，平均划分成k个区间</p>
<p>等比划分：按照数据的全部取值情况，平均划分成k个区间</p>
<h2 id="Hive-中计算分位数的函数：percentile-approx"><a href="#Hive-中计算分位数的函数：percentile-approx" class="headerlink" title="Hive 中计算分位数的函数：percentile_approx"></a>Hive 中计算分位数的函数：<code>percentile_approx</code></h2><p>hive 中的<code>percentile_approx</code>函数可以确定等频划分的分位点<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">percentile_approx(col,array(0.2,0.4,0.6,0.8))</div><div class="line">[0.0,4001.0,4061.0]</div></pre></td></tr></table></figure></p>
<p>其中col为要划分的列，array中的数字代表划分的位置，比如(0.2,0.4,0.6,0.8)就是钱20%数量的样本被分到一个区间，然后20%-40%的样本被分到一个区间….</p>
<p>返回值是一个array</p>
<p>如果希望变成一列，可以用<code>explode</code>函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">explode(percentile_approx(cast(col as double),array(0.05,0.5,0.95),9999))as percentile</div><div class="line"></div><div class="line">percentile</div><div class="line">0.0</div><div class="line">4001.1</div><div class="line">4061.0</div></pre></td></tr></table></figure></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">create table zhangsiyao.percentile_of_dt_fea_0818_0820_2 as select explode(percentile_approx(adloc_age_sex_ctr,array(0.25,0.5,0.75))) as adloc_age_sex_ctr_percentile,explode(percentile_approx(adloc_income_ctr,array(0.25,0.5,0.75))) as adloc_income_ctr_percentile,explode(percentile_approx(adloc_marry_ctr,array(0.25,0.5,0.75))) as adloc_marry_ctr_percentile,explode(percentile_approx(adloc_province_ctr,array(0.25,0.5,0.75))) as adloc_province_ctr_percentile,explode(percentile_approx(adloc_clinttype_ctr,array(0.25,0.5,0.75))) as adloc_clinttype_ctr_percentile,explode(percentile_approx(adloc_sponsorid_ctr,array(0.25,0.5,0.75))) as adloc_sponsorid_ctr_percentile,explode(percentile_approx(adloc_categoryid_ctr,array(0.25,0.5,0.75))) as adloc_categoryid_ctr_percentile,explode(percentile_approx(adloc_crtvid_ctr,array(0.25,0.5,0.75))) as adloc_crtvid_ctr_percentile,explode(percentile_approx(adloc_unet_ctr,array(0.25,0.5,0.75))) as adloc_unet_ctr_percentile,explode(percentile_approx(adloc_isp_ctr,array(0.25,0.5,0.75))) as adloc_isp_ctr_percentile,explode(percentile_approx(adloc_appver_ctr,array(0.25,0.5,0.75))) as adloc_appver_ctr_percentile,explode(percentile_approx(adloc_devicetype_ctr ,adloc_deviceos_ctr,array(0.25,0.5,0.75))) as adloc_devicetype_ctr ,adloc_deviceos_ctr_percentile,explode(percentile_approx(age_province_ctr,array(0.25,0.5,0.75))) as age_province_ctr_percentile,explode(percentile_approx(age_marry_ctr,array(0.25,0.5,0.75))) as age_marry_ctr_percentile,explode(percentile_approx(age_categoryid_ctr,array(0.25,0.5,0.75))) as age_categoryid_ctr_percentile,explode(percentile_approx(age_crtvid_ctr,array(0.25,0.5,0.75))) as age_crtvid_ctr_percentile,explode(percentile_approx(sex_marry_ctr,array(0.25,0.5,0.75))) as sex_marry_ctr_percentile,explode(percentile_approx(sex_categoryid_ctr,array(0.25,0.5,0.75))) as sex_categoryid_ctr_percentile,explode(percentile_approx(income_categoryid_ctr,array(0.25,0.5,0.75))) as income_categoryid_ctr_percentile,explode(percentile_approx(income_crtvid_ctr,array(0.25,0.5,0.75))) as income_crtvid_ctr_percentile,explode(percentile_approx(marry_categoryid_ctr,array(0.25,0.5,0.75))) as marry_categoryid_ctr_percentile,explode(percentile_approx(marry_crtvid_ctr,sponsorid_unet_ctr,array(0.25,0.5,0.75))) as marry_crtvid_ctr,sponsorid_unet_ctr_percentile from zhangsiyao.dt_fea_0818_0820;</div></pre></td></tr></table></figure>
<p>由此就找到了将特征等频划分的分位点，可以按照得到的分位点队连续型特征进行分桶操作</p>
]]></content>
      
        <categories>
            
            <category> hive </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hive </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TPC_DS工具生成数据导入Hive]]></title>
      <url>/2017/11/02/TPC-DS%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5Hive/</url>
      <content type="html"><![CDATA[<p>生成步骤</p>
<p>1.在官网上(<a href="http://www.tpc.org/tpcds/" target="_blank" rel="external">http://www.tpc.org/tpcds/</a> )去下载最新的：TPC-DS. </p>
<p>2.解压: 下载的 zip 文件放在 Linux 上解压,并进入他的 tools 目录.</p>
<p>3.编译：make (忽略编译警告，只保证生成过程成功完成). 这里需要Linux安装上了 gcc , gcc c++, expect 等.</p>
<p>4.生成数据：在tools目录下执行：./dsdgen -scale 100 -force (-force:会覆盖原来生成的data,否则不覆盖);生成的25个.dat 的数据文件.</p>
<p>默认只能生成 100GB, 300GB, 1TB, 3TB, 10TB, 30TB and 100TB大小的数据，如果想要生成一个比较小的数据集，可以使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">100M:</div><div class="line">./dsdgen -scale 1000 -dir tmp/ -parallel 1000 -child 1</div></pre></td></tr></table></figure></p>
<ol>
<li>hive中创建相应的数据表，导入之前生成的数据<br>运行脚本<code>hive_create_table.sql</code></li>
</ol>
<p>“hive -f hive_create_table.sql”<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">use tpc_ds;</div><div class="line"></div><div class="line">create table if not exists dbgen_version</div><div class="line">(</div><div class="line">    dv_version varchar(16),</div><div class="line">    dv_create_date date,</div><div class="line">    dv_create_time string,</div><div class="line">    dv_cmdline_args varchar(200) </div><div class="line">)</div><div class="line">row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/dbgen_version_1_10000.dat&quot; overwrite into table tpc_ds.dbgen_version;</div><div class="line"></div><div class="line">create table if not exists customer_address</div><div class="line">(</div><div class="line">    ca_address_sk int,</div><div class="line">    ca_address_id char(16),</div><div class="line">    ca_street_number char(10),</div><div class="line">    ca_street_name varchar(60),</div><div class="line">    ca_street_type char(15),</div><div class="line">    ca_suite_number char(10),</div><div class="line">    ca_city varchar(60),</div><div class="line">    ca_county varchar(30),</div><div class="line">    ca_state char(2),</div><div class="line">    ca_zip char(10),</div><div class="line">    ca_country varchar(20),</div><div class="line">    ca_gmt_offset decimal(5,2),</div><div class="line">    ca_location_type char(20)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/customer_address_1_10000.dat&quot; overwrite into table tpc_ds.customer_address;</div><div class="line"></div><div class="line">create table if not exists customer_demographics</div><div class="line">(</div><div class="line">    cd_demo_sk int,</div><div class="line">    cd_gender char(1),</div><div class="line">    cd_marital_status char(1),</div><div class="line">    cd_education_status char(20),</div><div class="line">    cd_purchase_estimate int,</div><div class="line">    cd_credit_rating char(10),</div><div class="line">    cd_dep_count int,</div><div class="line">    cd_dep_employed_count int,</div><div class="line">    cd_dep_college_count int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/customer_demographics_1_10000.dat&quot; overwrite into table tpc_ds.customer_demographics;</div><div class="line"></div><div class="line">create table if not exists date_dim</div><div class="line">(</div><div class="line">    d_date_sk int,</div><div class="line">    d_date_id char(16) ,</div><div class="line">    d_date date ,</div><div class="line">    d_month_seq int,</div><div class="line">    d_week_seq int,</div><div class="line">    d_quarter_seq int,</div><div class="line">    d_year int,</div><div class="line">    d_dow int,</div><div class="line">    d_moy int,</div><div class="line">    d_dom int,</div><div class="line">    d_qoy int,</div><div class="line">    d_fy_year int,</div><div class="line">    d_fy_quarter_seq int,</div><div class="line">    d_fy_week_seq int,</div><div class="line">    d_day_name char(9),</div><div class="line">    d_quarter_name char(6),</div><div class="line">    d_holiday char(1),</div><div class="line">    d_weekend char(1),</div><div class="line">    d_following_holiday char(1),</div><div class="line">    d_first_dom int,</div><div class="line">    d_last_dom int,</div><div class="line">    d_same_day_ly int,</div><div class="line">    d_same_day_lq int,</div><div class="line">    d_current_day char(1),</div><div class="line">    d_current_week char(1),</div><div class="line">    d_current_month char(1),</div><div class="line">    d_current_quarter char(1),</div><div class="line">    d_current_year char(1)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/date_dim_1_10000.dat&quot; overwrite into table tpc_ds.date_dim;</div><div class="line"></div><div class="line">create table if not exists warehouse</div><div class="line">(</div><div class="line">    w_warehouse_sk int,</div><div class="line">    w_warehouse_id char(16),</div><div class="line">    w_warehouse_name varchar(20),</div><div class="line">    w_warehouse_sq_ft int,</div><div class="line">    w_street_number char(10),</div><div class="line">    w_street_name varchar(60),</div><div class="line">    w_street_type char(15),</div><div class="line">    w_suite_number char(10),</div><div class="line">    w_city varchar(60),</div><div class="line">    w_county varchar(30),</div><div class="line">    w_state char(2),</div><div class="line">    w_zip char(10),</div><div class="line">    w_country varchar(20),</div><div class="line">    w_gmt_offset decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/warehouse_1_10000.dat&quot; overwrite into table tpc_ds.warehouse;</div><div class="line"></div><div class="line">create table if not exists ship_mode</div><div class="line">(</div><div class="line">    sm_ship_mode_sk int,</div><div class="line">    sm_ship_mode_id char(16),</div><div class="line">    sm_type char(30),</div><div class="line">    sm_code char(10),</div><div class="line">    sm_carrier char(20),</div><div class="line">    sm_contract char(20)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/ship_mode_1_10000.dat&quot; overwrite into table tpc_ds.ship_mode;</div><div class="line"></div><div class="line">create table if not exists time_dim</div><div class="line">(</div><div class="line">    t_time_sk int,</div><div class="line">    t_time_id char(16),</div><div class="line">    t_time int,</div><div class="line">    t_hour int,</div><div class="line">    t_minute int,</div><div class="line">    t_second int,</div><div class="line">    t_am_pm char(2),</div><div class="line">    t_shift char(20),</div><div class="line">    t_sub_shift char(20),</div><div class="line">    t_meal_time char(20)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/time_dim_1_10000.dat&quot; overwrite into table tpc_ds.time_dim;</div><div class="line"></div><div class="line">create table if not exists reason</div><div class="line">(</div><div class="line">    r_reason_sk int,</div><div class="line">    r_reason_id char(16),</div><div class="line">    r_reason_desc char(100)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/reason_1_10000.dat&quot; overwrite into table tpc_ds.reason;</div><div class="line"></div><div class="line">create table if not exists income_band</div><div class="line">(</div><div class="line">    ib_income_band_sk int,</div><div class="line">    ib_lower_bound int,</div><div class="line">    ib_upper_bound int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/income_band_1_10000.dat&quot; overwrite into table tpc_ds.income_band;</div><div class="line"></div><div class="line">create table if not exists item</div><div class="line">(</div><div class="line">    i_item_sk int,</div><div class="line">    i_item_id char(16),</div><div class="line">    i_rec_start_date date ,</div><div class="line">    i_rec_end_date date ,</div><div class="line">    i_item_desc varchar(200),</div><div class="line">    i_current_price decimal(7,2),</div><div class="line">    i_wholesale_cost decimal(7,2),</div><div class="line">    i_brand_id int,</div><div class="line">    i_brand char(50),</div><div class="line">    i_class_id int,</div><div class="line">    i_class char(50),</div><div class="line">    i_category_id int,</div><div class="line">    i_category char(50),</div><div class="line">    i_manufact_id int,</div><div class="line">    i_manufact char(50),</div><div class="line">    i_size char(20),</div><div class="line">    i_formulation char(20),</div><div class="line">    i_color char(20),</div><div class="line">    i_units char(10),</div><div class="line">    i_container char(10),</div><div class="line">    i_manager_id int,</div><div class="line">    i_product_name char(50)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/item_1_10000.dat&quot; overwrite into table tpc_ds.item;</div><div class="line"></div><div class="line">create table if not exists store</div><div class="line">(</div><div class="line">    s_store_sk int,</div><div class="line">    s_store_id char(16),</div><div class="line">    s_rec_start_date date ,</div><div class="line">    s_rec_end_date date ,</div><div class="line">    s_closed_date_sk int,</div><div class="line">    s_store_name varchar(50),</div><div class="line">    s_number_employees int,</div><div class="line">    s_floor_space int,</div><div class="line">    s_hours char(20),</div><div class="line">    s_manager varchar(40),</div><div class="line">    s_market_id int,</div><div class="line">    s_geography_class varchar(100),</div><div class="line">    s_market_desc varchar(100),</div><div class="line">    s_market_manager varchar(40),</div><div class="line">    s_division_id int,</div><div class="line">    s_division_name varchar(50),</div><div class="line">    s_company_id int,</div><div class="line">    s_company_name varchar(50),</div><div class="line">    s_street_number varchar(10),</div><div class="line">    s_street_name varchar(60),</div><div class="line">    s_street_type char(15),</div><div class="line">    s_suite_number char(10),</div><div class="line">    s_city varchar(60),</div><div class="line">    s_county varchar(30),</div><div class="line">    s_state char(2),</div><div class="line">    s_zip char(10),</div><div class="line">    s_country varchar(20),</div><div class="line">    s_gmt_offset decimal(5,2),</div><div class="line">    s_tax_precentage decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/store_1_10000.dat&quot; overwrite into table tpc_ds.store;</div><div class="line"></div><div class="line">create table if not exists call_center</div><div class="line">(</div><div class="line">    cc_call_center_sk int,</div><div class="line">    cc_call_center_id char(16),</div><div class="line">    cc_rec_start_date date ,</div><div class="line">    cc_rec_end_date date ,</div><div class="line">    cc_closed_date_sk int,</div><div class="line">    cc_open_date_sk int,</div><div class="line">    cc_name varchar(50),</div><div class="line">    cc_class varchar(50),</div><div class="line">    cc_employees int,</div><div class="line">    cc_sq_ft int,</div><div class="line">    cc_hours char(20),</div><div class="line">    cc_manager varchar(40),</div><div class="line">    cc_mkt_id int,</div><div class="line">    cc_mkt_class char(50),</div><div class="line">    cc_mkt_desc varchar(100),</div><div class="line">    cc_market_manager varchar(40),</div><div class="line">    cc_division int,</div><div class="line">    cc_division_name varchar(50),</div><div class="line">    cc_company int,</div><div class="line">    cc_company_name char(50),</div><div class="line">    cc_street_number char(10),</div><div class="line">    cc_street_name varchar(60),</div><div class="line">    cc_street_type char(15),</div><div class="line">    cc_suite_number char(10),</div><div class="line">    cc_city varchar(60),</div><div class="line">    cc_county varchar(30),</div><div class="line">    cc_state char(2),</div><div class="line">    cc_zip char(10),</div><div class="line">    cc_country varchar(20),</div><div class="line">    cc_gmt_offset decimal(5,2),</div><div class="line">    cc_tax_percentage decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/call_center_1_10000.dat&quot; overwrite into table tpc_ds.call_center;</div><div class="line"></div><div class="line">create table if not exists customer</div><div class="line">(</div><div class="line">    c_customer_sk int,</div><div class="line">    c_customer_id char(16),</div><div class="line">    c_current_cdemo_sk int,</div><div class="line">    c_current_hdemo_sk int,</div><div class="line">    c_current_addr_sk int,</div><div class="line">    c_first_shipto_date_sk int,</div><div class="line">    c_first_sales_date_sk int,</div><div class="line">    c_salutation char(10),</div><div class="line">    c_first_name char(20),</div><div class="line">    c_last_name char(30),</div><div class="line">    c_preferred_cust_flag char(1),</div><div class="line">    c_birth_day int,</div><div class="line">    c_birth_month int,</div><div class="line">    c_birth_year int,</div><div class="line">    c_birth_country varchar(20),</div><div class="line">    c_login char(13),</div><div class="line">    c_email_address char(50),</div><div class="line">    c_last_review_date char(10)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/customer_1_10000.dat&quot; overwrite into table tpc_ds.customer;</div><div class="line"></div><div class="line">create table if not exists web_site</div><div class="line">(</div><div class="line">    web_site_sk int,</div><div class="line">    web_site_id char(16),</div><div class="line">    web_rec_start_date date ,</div><div class="line">    web_rec_end_date date ,</div><div class="line">    web_name varchar(50),</div><div class="line">    web_open_date_sk int,</div><div class="line">    web_close_date_sk int,</div><div class="line">    web_class varchar(50),</div><div class="line">    web_manager varchar(40),</div><div class="line">    web_mkt_id int,</div><div class="line">    web_mkt_class varchar(50),</div><div class="line">    web_mkt_desc varchar(100),</div><div class="line">    web_market_manager varchar(40),</div><div class="line">    web_company_id int,</div><div class="line">    web_company_name char(50),</div><div class="line">    web_street_number char(10),</div><div class="line">    web_street_name varchar(60),</div><div class="line">    web_street_type char(15),</div><div class="line">    web_suite_number char(10),</div><div class="line">    web_city varchar(60),</div><div class="line">    web_county varchar(30),</div><div class="line">    web_state char(2),</div><div class="line">    web_zip char(10),</div><div class="line">    web_country varchar(20),</div><div class="line">    web_gmt_offset decimal(5,2),</div><div class="line">    web_tax_percentage decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_site_1_10000.dat&quot; overwrite into table tpc_ds.web_site;</div><div class="line"></div><div class="line">create table if not exists store_returns</div><div class="line">(</div><div class="line">    sr_returned_date_sk int,</div><div class="line">    sr_return_time_sk int,</div><div class="line">    sr_item_sk int,</div><div class="line">    sr_customer_sk int,</div><div class="line">    sr_cdemo_sk int,</div><div class="line">    sr_hdemo_sk int,</div><div class="line">    sr_addr_sk int,</div><div class="line">    sr_store_sk int,</div><div class="line">    sr_reason_sk int,</div><div class="line">    sr_ticket_number int,</div><div class="line">    sr_return_quantity int,</div><div class="line">    sr_return_amt decimal(7,2),</div><div class="line">    sr_return_tax decimal(7,2),</div><div class="line">    sr_return_amt_inc_tax decimal(7,2),</div><div class="line">    sr_fee decimal(7,2),</div><div class="line">    sr_return_ship_cost decimal(7,2),</div><div class="line">    sr_refunded_cash decimal(7,2),</div><div class="line">    sr_reversed_charge decimal(7,2),</div><div class="line">    sr_store_credit decimal(7,2),</div><div class="line">    sr_net_loss decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/store_returns_1_10000.dat&quot; overwrite into table tpc_ds.store_returns;</div><div class="line"></div><div class="line">create table if not exists household_demographics</div><div class="line">(</div><div class="line">    hd_demo_sk int,</div><div class="line">    hd_income_band_sk int,</div><div class="line">    hd_buy_potential char(15),</div><div class="line">    hd_dep_count int,</div><div class="line">    hd_vehicle_count int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/household_demographics_1_10000.dat&quot; overwrite into table tpc_ds.household_demographics;</div><div class="line"></div><div class="line">create table if not exists web_page</div><div class="line">(</div><div class="line">    wp_web_page_sk int,</div><div class="line">    wp_web_page_id char(16),</div><div class="line">    wp_rec_start_date date ,</div><div class="line">    wp_rec_end_date date ,</div><div class="line">    wp_creation_date_sk int,</div><div class="line">    wp_access_date_sk int,</div><div class="line">    wp_autogen_flag char(1),</div><div class="line">    wp_customer_sk int,</div><div class="line">    wp_url varchar(100),</div><div class="line">    wp_type char(50),</div><div class="line">    wp_char_count int,</div><div class="line">    wp_link_count int,</div><div class="line">    wp_image_count int,</div><div class="line">    wp_max_ad_count int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_page_1_10000.dat&quot; overwrite into table tpc_ds.web_page;</div><div class="line"></div><div class="line">create table if not exists promotion</div><div class="line">(</div><div class="line">    p_promo_sk int,</div><div class="line">    p_promo_id char(16),</div><div class="line">    p_start_date_sk int,</div><div class="line">    p_end_date_sk int,</div><div class="line">    p_item_sk int,</div><div class="line">    p_cost decimal(15,2),</div><div class="line">    p_response_target int,</div><div class="line">    p_promo_name char(50),</div><div class="line">    p_channel_dmail char(1),</div><div class="line">    p_channel_email char(1),</div><div class="line">    p_channel_catalog char(1),</div><div class="line">    p_channel_tv char(1),</div><div class="line">    p_channel_radio char(1),</div><div class="line">    p_channel_press char(1),</div><div class="line">    p_channel_event char(1),</div><div class="line">    p_channel_demo char(1),</div><div class="line">    p_channel_details varchar(100),</div><div class="line">    p_purpose char(15),</div><div class="line">    p_discount_active char(1)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/promotion_1_10000.dat&quot; overwrite into table tpc_ds.promotion;</div><div class="line"></div><div class="line">create table if not exists catalog_page</div><div class="line">(</div><div class="line">    cp_catalog_page_sk int,</div><div class="line">    cp_catalog_page_id char(16),</div><div class="line">    cp_start_date_sk int,</div><div class="line">    cp_end_date_sk int,</div><div class="line">    cp_department varchar(50),</div><div class="line">    cp_catalog_number int,</div><div class="line">    cp_catalog_page_number int,</div><div class="line">    cp_description varchar(100),</div><div class="line">    cp_type varchar(100)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/catalog_page_1_10000.dat&quot; overwrite into table tpc_ds.catalog_page;</div><div class="line"></div><div class="line">create table if not exists inventory</div><div class="line">(</div><div class="line">    inv_date_sk int,</div><div class="line">    inv_item_sk int,</div><div class="line">    inv_warehouse_sk int,</div><div class="line">    inv_quantity_on_hand int)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/inventory_1_10000.dat&quot; overwrite into table tpc_ds.inventory;</div><div class="line"></div><div class="line">create table if not exists catalog_returns</div><div class="line">(</div><div class="line">    cr_returned_date_sk int,</div><div class="line">    cr_returned_time_sk int,</div><div class="line">    cr_item_sk int,</div><div class="line">    cr_refunded_customer_sk int,</div><div class="line">    cr_refunded_cdemo_sk int,</div><div class="line">    cr_refunded_hdemo_sk int,</div><div class="line">    cr_refunded_addr_sk int,</div><div class="line">    cr_returning_customer_sk int,</div><div class="line">    cr_returning_cdemo_sk int,</div><div class="line">    cr_returning_hdemo_sk int,</div><div class="line">    cr_returning_addr_sk int,</div><div class="line">    cr_call_center_sk int,</div><div class="line">    cr_catalog_page_sk int,</div><div class="line">    cr_ship_mode_sk int,</div><div class="line">    cr_warehouse_sk int,</div><div class="line">    cr_reason_sk int,</div><div class="line">    cr_order_number int,</div><div class="line">    cr_return_quantity int,</div><div class="line">    cr_return_amount decimal(7,2),</div><div class="line">    cr_return_tax decimal(7,2),</div><div class="line">    cr_return_amt_inc_tax decimal(7,2),</div><div class="line">    cr_fee decimal(7,2),</div><div class="line">    cr_return_ship_cost decimal(7,2),</div><div class="line">    cr_refunded_cash decimal(7,2),</div><div class="line">    cr_reversed_charge decimal(7,2),</div><div class="line">    cr_store_credit decimal(7,2),</div><div class="line">    cr_net_loss decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/catalog_returns_1_10000.dat&quot; overwrite into table tpc_ds.catalog_returns;</div><div class="line"></div><div class="line">create table if not exists web_returns</div><div class="line">(</div><div class="line">    wr_returned_date_sk int,</div><div class="line">    wr_returned_time_sk int,</div><div class="line">    wr_item_sk int,</div><div class="line">    wr_refunded_customer_sk int,</div><div class="line">    wr_refunded_cdemo_sk int,</div><div class="line">    wr_refunded_hdemo_sk int,</div><div class="line">    wr_refunded_addr_sk int,</div><div class="line">    wr_returning_customer_sk int,</div><div class="line">    wr_returning_cdemo_sk int,</div><div class="line">    wr_returning_hdemo_sk int,</div><div class="line">    wr_returning_addr_sk int,</div><div class="line">    wr_web_page_sk int,</div><div class="line">    wr_reason_sk int,</div><div class="line">    wr_order_number int,</div><div class="line">    wr_return_quantity int,</div><div class="line">    wr_return_amt decimal(7,2),</div><div class="line">    wr_return_tax decimal(7,2),</div><div class="line">    wr_return_amt_inc_tax decimal(7,2),</div><div class="line">    wr_fee decimal(7,2),</div><div class="line">    wr_return_ship_cost decimal(7,2),</div><div class="line">    wr_refunded_cash decimal(7,2),</div><div class="line">    wr_reversed_charge decimal(7,2),</div><div class="line">    wr_account_credit decimal(7,2),</div><div class="line">    wr_net_loss decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_returns_1_10000.dat&quot; overwrite into table tpc_ds.web_returns;</div><div class="line"></div><div class="line">create table if not exists web_sales</div><div class="line">(</div><div class="line">    ws_sold_date_sk int,</div><div class="line">    ws_sold_time_sk int,</div><div class="line">    ws_ship_date_sk int,</div><div class="line">    ws_item_sk int,</div><div class="line">    ws_bill_customer_sk int,</div><div class="line">    ws_bill_cdemo_sk int,</div><div class="line">    ws_bill_hdemo_sk int,</div><div class="line">    ws_bill_addr_sk int,</div><div class="line">    ws_ship_customer_sk int,</div><div class="line">    ws_ship_cdemo_sk int,</div><div class="line">    ws_ship_hdemo_sk int,</div><div class="line">    ws_ship_addr_sk int,</div><div class="line">    ws_web_page_sk int,</div><div class="line">    ws_web_site_sk int,</div><div class="line">    ws_ship_mode_sk int,</div><div class="line">    ws_warehouse_sk int,</div><div class="line">    ws_promo_sk int,</div><div class="line">    ws_order_number int,</div><div class="line">    ws_quantity int,</div><div class="line">    ws_wholesale_cost decimal(7,2),</div><div class="line">    ws_list_price decimal(7,2),</div><div class="line">    ws_sales_price decimal(7,2),</div><div class="line">    ws_ext_discount_amt decimal(7,2),</div><div class="line">    ws_ext_sales_price decimal(7,2),</div><div class="line">    ws_ext_wholesale_cost decimal(7,2),</div><div class="line">    ws_ext_list_price decimal(7,2),</div><div class="line">    ws_ext_tax decimal(7,2),</div><div class="line">    ws_coupon_amt decimal(7,2),</div><div class="line">    ws_ext_ship_cost decimal(7,2),</div><div class="line">    ws_net_paid decimal(7,2),</div><div class="line">    ws_net_paid_inc_tax decimal(7,2),</div><div class="line">    ws_net_paid_inc_ship decimal(7,2),</div><div class="line">    ws_net_paid_inc_ship_tax decimal(7,2),</div><div class="line">    ws_net_profit decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_sales_1_10000.dat&quot; overwrite into table tpc_ds.web_sales;</div><div class="line"></div><div class="line">create table if not exists catalog_sales</div><div class="line">(</div><div class="line">    cs_sold_date_sk int,</div><div class="line">    cs_sold_time_sk int,</div><div class="line">    cs_ship_date_sk int,</div><div class="line">    cs_bill_customer_sk int,</div><div class="line">    cs_bill_cdemo_sk int,</div><div class="line">    cs_bill_hdemo_sk int,</div><div class="line">    cs_bill_addr_sk int,</div><div class="line">    cs_ship_customer_sk int,</div><div class="line">    cs_ship_cdemo_sk int,</div><div class="line">    cs_ship_hdemo_sk int,</div><div class="line">    cs_ship_addr_sk int,</div><div class="line">    cs_call_center_sk int,</div><div class="line">    cs_catalog_page_sk int,</div><div class="line">    cs_ship_mode_sk int,</div><div class="line">    cs_warehouse_sk int,</div><div class="line">    cs_item_sk int,</div><div class="line">    cs_promo_sk int,</div><div class="line">    cs_order_number int,</div><div class="line">    cs_quantity int,</div><div class="line">    cs_wholesale_cost decimal(7,2),</div><div class="line">    cs_list_price decimal(7,2),</div><div class="line">    cs_sales_price decimal(7,2),</div><div class="line">    cs_ext_discount_amt decimal(7,2),</div><div class="line">    cs_ext_sales_price decimal(7,2),</div><div class="line">    cs_ext_wholesale_cost decimal(7,2),</div><div class="line">    cs_ext_list_price decimal(7,2),</div><div class="line">    cs_ext_tax decimal(7,2),</div><div class="line">    cs_coupon_amt decimal(7,2),</div><div class="line">    cs_ext_ship_cost decimal(7,2),</div><div class="line">    cs_net_paid decimal(7,2),</div><div class="line">    cs_net_paid_inc_tax decimal(7,2),</div><div class="line">    cs_net_paid_inc_ship decimal(7,2),</div><div class="line">    cs_net_paid_inc_ship_tax decimal(7,2),</div><div class="line">    cs_net_profit decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/catalog_sales_1_10000.dat&quot; overwrite into table tpc_ds.catalog_sales;</div><div class="line"></div><div class="line">create table if not exists store_sales</div><div class="line">(</div><div class="line">    ss_sold_date_sk int,</div><div class="line">    ss_sold_time_sk int,</div><div class="line">    ss_item_sk int,</div><div class="line">    ss_customer_sk int,</div><div class="line">    ss_cdemo_sk int,</div><div class="line">    ss_hdemo_sk int,</div><div class="line">    ss_addr_sk int,</div><div class="line">    ss_store_sk int,</div><div class="line">    ss_promo_sk int,</div><div class="line">    ss_ticket_number int,</div><div class="line">    ss_quantity int,</div><div class="line">    ss_wholesale_cost decimal(7,2),</div><div class="line">    ss_list_price decimal(7,2),</div><div class="line">    ss_sales_price decimal(7,2),</div><div class="line">    ss_ext_discount_amt decimal(7,2),</div><div class="line">    ss_ext_sales_price decimal(7,2),</div><div class="line">    ss_ext_wholesale_cost decimal(7,2),</div><div class="line">    ss_ext_list_price decimal(7,2),</div><div class="line">    ss_ext_tax decimal(7,2),</div><div class="line">    ss_coupon_amt decimal(7,2),</div><div class="line">    ss_net_paid decimal(7,2),</div><div class="line">    ss_net_paid_inc_tax decimal(7,2),</div><div class="line">    ss_net_profit decimal(7,2))row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/store_sales_1_10000.dat&quot; overwrite into table tpc_ds.store_sales;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【算法导论】动态规划（二）矩阵链乘法]]></title>
      <url>/2017/11/01/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="矩阵链乘法问题"><a href="#矩阵链乘法问题" class="headerlink" title="矩阵链乘法问题"></a>矩阵链乘法问题</h2><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>两个矩阵A和B相乘，维度分别为$ p×q$和$ q×r$，则$A*B$的时间复杂度为$pqr$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">MATRIX_MULTIPLY(A,B)&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;A.rows;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; B.cols;j++)&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; A.cols;k++)&#123;</div><div class="line">        C[i,j] = A[i,k]*B[k,j];</div><div class="line">&#125;&#125;&#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="矩阵链乘法"><a href="#矩阵链乘法" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h3><p>​    首先，给定一个矩阵链 <script type="math/tex"><A_1,A_2,A_3></script>  ，三个矩阵的规模分别为：10×100 ， 100×5 ，5×50 ，计算他们的乘积有两种方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$((A_1A_2)A_3)$</th>
<th style="text-align:left"><script type="math/tex">10*100*5+10*5*50=7500</script></th>
</tr>
</thead>
<tbody>
<tr>
<td>$(A_1(A_2A_3))$</td>
<td style="text-align:left"><script type="math/tex">100*5*50+10*100*50=75000</script></td>
</tr>
</tbody>
</table>
</div>
<p>可以看出，对一串矩阵做乘法操作，乘法的顺序影响到算法的时间复杂度。由此，引出矩阵链乘法问题：</p>
<p><strong>给定n个矩阵的链<script type="math/tex"><A_1,A_2,...,A_n></script>，矩阵<script type="math/tex">A_i</script> 的规模为<script type="math/tex">p_{i-1} \times p_i</script>，确定代价最低的计算顺序，使得计算乘积$A_1A_2A_n$所需标量乘法次数最小。</strong></p>
<a id="more"></a>
<h3 id="用DP解决此问题"><a href="#用DP解决此问题" class="headerlink" title="用DP解决此问题"></a>用DP解决此问题</h3><p>DP四步骤：</p>
<ol>
<li>可以将求解<script type="math/tex">A_1,*A_2*...*A_n</script>所需要的乘法次数问题划分成两个子问题：求解<script type="math/tex">A_1,*A_2*...*A_k</script>所需要的乘法次数+求解<script type="math/tex">A_{k+1},*A_{k+2}*...*A_n</script>所需要的乘法次数+<script type="math/tex">p_0*p_k*p_n</script></li>
<li>​</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 算法导论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
            <tag> 算法导论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【算法导论】动态规划（一）钢条切割]]></title>
      <url>/2017/10/31/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2/</url>
      <content type="html"><![CDATA[<h2 id="1-动态规划（Dynamic-programming）"><a href="#1-动态规划（Dynamic-programming）" class="headerlink" title="1. 动态规划（Dynamic programming）"></a>1. 动态规划（Dynamic programming）</h2><p>这里programming指的是<strong>表格</strong>，而非编程。动态规划通常用来<strong>求解最优化问题</strong></p>
<p>与分治法对比：</p>
<ol>
<li>相同点：都是通过子问题组合求解原问题</li>
<li>不同点：分治法将问题划分为<strong>不相交</strong>的子问题，求解再合并，动态规划应用于<strong>子问题重叠</strong>的情况，即不同的子问题具有公共的子子问题，此时如果用分治法就会出现重复计算求解。为了避免重复动态规划对子问题只求解一次，将其保存在表格中，从而无需每求解一个子子问题时重复计算。</li>
</ol>
<h2 id="2-求解步骤"><a href="#2-求解步骤" class="headerlink" title="2. 求解步骤"></a>2. 求解步骤</h2><ol>
<li>刻画最优解的结构特征</li>
<li>递归定义最优解的值</li>
<li>计算最优解的值，通常采用自底向上的方法</li>
<li>利用计算出的信息构造最优解</li>
</ol>
<p>其中不是所有的题目都会要求4，仅仅要求3，要求4的时候，我们需要在得到3的同事维护一些额外的信息来求出4。</p>
<p>看到这四个步骤的时候，还是挺懵逼的，继续往下看=.=</p>
<a id="more"></a>
<h2 id="3-钢条切割问题"><a href="#3-钢条切割问题" class="headerlink" title="3. 钢条切割问题"></a>3. 钢条切割问题</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Serling公司购买一根长钢管，将其切割成短钢管出售，给定钢管长度和对应的价钱如下表：</p>
<p><img src="https://i.loli.net/2017/10/31/59f7536b8fc8f.png" alt=""> </p>
<p>问题要求根据上面的价格，给出最佳的切割方案，使得收益最大。</p>
<p>以n=4为例，可以将钢条切割成如下图所示的8种情况，其中收益岁大的是(c)：</p>
<p><img src="https://ooo.0o0.ooo/2017/10/30/59f73938d2f50.png" alt=""> </p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>钢条长度为n时，共有$2^{n-1}$种分割方式。</p>
<ol>
<li><p>递归</p>
<p>把长度为n的钢条切割问题转化为：将钢条从左边切下长度为i的一段，对右边剩下的长度为n-i的钢条进行进一步的切割。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CUT-ROD(p,n)//p:价格数组，n：钢条长度</div><div class="line">1 if n==0:</div><div class="line">2 	return 0</div><div class="line">3 q=MIN</div><div class="line">4 for i = 1 to n:</div><div class="line">5 	q=max(q,p[i],CUT-ROD(p,n-i))</div><div class="line">6 return q</div></pre></td></tr></table></figure>
<p>当n=4时，上面递推方式的工作量如图所示，复杂度为$T(n)=2^n$</p>
<p><img src="https://i.loli.net/2017/10/31/59f759167976c.png" alt=""> </p>
</li>
<li><p>动态规划（DP）</p>
<p>可以看出来用上面递归的方式计算，中间会重复求解相同子问题。使用动态规划，<strong>仔细安排求解顺序，对每个子问题只求解一次所以，并把结果保存下来</strong>，供后续使用避免重复计算。</p>
<p>​    对于钢条切割的问题，我们可以将长度为n的钢条切割问题转化为规模更小的子问题：当完成首次切割后，将两段钢条看成<strong>两个独立的钢条切割</strong>问题，通过<strong>组合</strong>两个相关子问题的最优解，选取组合收益最大者，构成原问题的最优解。</p>
<p>因此，将长度为n的钢条切割成两段，共有下面n种切割方式，求解下面n个子问题的最优解，再选取其中最大的作为原问题的最优解。</p>
<script type="math/tex; mode=display">
r_n=max(p_n,r_{1}+r_{n-1},r_{2}+r_{n-2},...,r_{n-1}+r_1)</script><p>​以n=4为例：</p>
<p>$r_1=1$</p>
<p>$r_2=max(p_2,max(r_1)+max(r_1))=max(5,1+1)=5$</p>
<p>$r_3=max(p_3,max(r_1)+max(r_2))=max(8,5+1)=8$</p>
<p>$r_4=max(p_4,max(r_1)+max(r_3),max(r_2)+max(r_2))=max(9,8+1,5+5)=10$</p>
<p>…</p>
<p>​    动态规划两种实现方法：</p>
</li>
</ol>
<ul>
<li><p>自顶向下：</p>
<p>仍按照递归的方式实现，过程中保存每个子问题的解，后续过程中先检查是否已经保存过此解，如果是，直接返回保存的值。就好像带了一个“备忘录”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">memorized-CUT-ROD[] = MIN//用于记录子问题结果</div><div class="line">CUT-ROD(p,n)//p:价格数组，n：钢条长度</div><div class="line">1 if memorized-CUT-ROD[n] &gt; 0:</div><div class="line">2 	return memorized-CUT-ROD[n]</div><div class="line">3 else</div><div class="line">4 	for i = 1 to n:</div><div class="line">5 	q=max(q,p[i],memorized-CUT-ROD(p,n-i))</div><div class="line">6 memorized-CUT-ROD[n] = q</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<ul>
<li><p>自底向上</p>
<p>需要恰当定义子问题的“规模”，使得任何子问题的求解都只依赖于“更小的”子问题，进而将子问题按规律排序，按由小到大的顺序进行求解，当求解某个自问题时，它所以来的子问题都已经求解完毕。</p>
<p>伪代码略，直接上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut_rod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = p.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxvalue(len,<span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;<span class="comment">//i=n-1</span></div><div class="line">        maxvalue[i] = p[i];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (i+<span class="number">1</span>)/<span class="number">2</span>;j++)&#123;</div><div class="line">            maxvalue[i] = max(maxvalue[i],maxvalue[j<span class="number">-1</span>]+maxvalue[i-j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxvalue[n<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 至此，可以求出该问题的最优解了~</p>
</li>
</ul>
<h3 id="重构解"><a href="#重构解" class="headerlink" title="重构解"></a>重构解</h3><p>​    上面的求解过程可以求出最优解的值，但并没有返回解本身（具体的切割方案），为了得到最优解，需要在求解最优解的同时，保存切割信息。扩展上面的算法，使之对子问题不仅保存最优收益值$r_j$，还保存该最优方案对应的第一段钢条的切割长度，也就是第一段钢条的切割位置距离钢条左端的长度$s_j$，最后输出最优方案时，根据$s_j$即可复原出最优解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut_rod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = p.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxvalue(len,<span class="number">0</span>);<span class="comment">//记录最优方案值</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftlen(len,<span class="number">0</span>);<span class="comment">//记录第一段钢条距左端距离</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;<span class="comment">//i=n-1</span></div><div class="line">        maxvalue[i] = p[i];</div><div class="line">        leftlen[i] = i+<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (i+<span class="number">1</span>)/<span class="number">2</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(maxvalue[j<span class="number">-1</span>]+maxvalue[i-j]&gt;maxvalue[i])&#123;</div><div class="line">                maxvalue[i] = maxvalue[j<span class="number">-1</span>]+maxvalue[i-j];</div><div class="line">                leftlen[i] = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//输出最优解方案</span></div><div class="line">    <span class="keyword">int</span> m = n<span class="number">-1</span>;</div><div class="line">    <span class="keyword">while</span>(m&gt;=<span class="number">0</span>)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;leftlen[m]&lt;&lt;<span class="string">"\t"</span>;</div><div class="line">        m -= leftlen[m];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxvalue[n<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如图：</p>
<p>​                <img src="http://omaby2s5z.bkt.clouddn.com/2017-10-31-22-25-25.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> 算法导论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
            <tag> 算法导论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】713.Subarray-Product-Less-Than-K.md]]></title>
      <url>/2017/10/26/%E3%80%90leetcode%E3%80%91713-Subarray-Product-Less-Than-K-md/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Your are given an array of positive integers nums.</p>
<p>Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: nums = [10, 5, 2, 6], k = 100</div><div class="line">Output: 8</div><div class="line">Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</div><div class="line">Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</div></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个正整数组，和一个整数k，求成绩小于k的连续子数组个数</p>
<p>这道题真的是做了很久，想到了用滑窗，用一个数字记录窗口内数字成绩，但是算不明白个数</p>
<p>问题的关键在于:</p>
<p><strong>每次滑窗的末尾向后移动一位之后，满足条件的窗口内新增的连续子数组数目为：end-start+1</strong></p>
<p>因为每次滑窗末尾向后移动一位，新增的子数组必然包含最后一个数字，又必须是连续子数组，所以新增的个数是end-start+1</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>最后附上很简单的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123;</div><div class="line">    int product = 1;</div><div class="line">    int count = 0;</div><div class="line">    int start = 0;</div><div class="line">    int end = 0;</div><div class="line">    while(end &lt; nums.size()&amp;&amp;start&lt;=end)&#123;</div><div class="line">        product = product*nums[end];</div><div class="line">        while(product&gt;=k&amp;&amp;start&lt;=end)&#123;</div><div class="line">            product = product/nums[start];</div><div class="line">            start++;</div><div class="line">        &#125;</div><div class="line">        count+=end-start+1;</div><div class="line">        end++;</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p><img src="http://omaby2s5z.bkt.clouddn.com/blog/171026/1g02kLeb0H.png?imageslim" alt=""><br><img src="http://omaby2s5z.bkt.clouddn.com/201710261713_719.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】 628. Maximum Product of Three Numbers]]></title>
      <url>/2017/08/01/%E3%80%90leetcode%E3%80%91-628-Maximum-Product-of-Three-Numbers/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p>
<p><strong>Example1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: [1,2,3]</div><div class="line">Output: 6</div></pre></td></tr></table></figure></p>
<p><strong>Example1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: [1,2,3,4]</div><div class="line">Output: 24</div></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>The length of the given array will be in range [3,$10^4$] and all elements are in the range [-1000, 1000].<br>Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果数组里面没有负整数，那最大的乘积就是三个最大的数字乘积，题目说明数组中的数字范围是<strong>[-1000, 1000]</strong>，所以会有两种情况：</p>
<ol>
<li>两个最小的负数<script type="math/tex">*</script>一个最大的正数</li>
<li>三个最大的正数相乘</li>
</ol>
<p>所以只需要定义5个变量用来存储两个最小的和三个最大的数字，遍历一遍数组获取5个变量的值，然后返回两种情况中值较大的那种。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int maximumProduct(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">    //声明变量用来存储两个最小的数字和三个最大的数字</div><div class="line">    int min1 = 1001, min2 = 1001, max1 = -1001, max2 = -1001, max3 = -1001;</div><div class="line">    for (int i = 0; i &lt; nums.size(); i++) &#123;</div><div class="line">        //遇到比min1还小的</div><div class="line">        if (nums[i] &lt; min1) &#123;</div><div class="line">            min2 = min1;</div><div class="line">            min1 = nums[i];</div><div class="line">        &#125;</div><div class="line">        else if (nums[i] &lt; min2) &#123;</div><div class="line">            min2 = nums[i];</div><div class="line">        &#125;</div><div class="line">        if (nums[i] &gt; max1) &#123;</div><div class="line">            max3 = max2;</div><div class="line">            max2 = max1;</div><div class="line">            max1 = nums[i];</div><div class="line">        &#125;</div><div class="line">        else if (nums[i] &gt; max2) &#123;</div><div class="line">            max3 = max2;</div><div class="line">            max2 = nums[i];</div><div class="line">        &#125;</div><div class="line">        else if (nums[i] &gt; max3) &#123;</div><div class="line">            max3 = nums[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int x = min1*min2*max1;</div><div class="line">    int y = max1*max2*max3;</div><div class="line">    if (x &gt; y)</div><div class="line">        return x;</div><div class="line">    else</div><div class="line">        return y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://i.loli.net/2017/08/01/597ffda9bb7c7.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】1. Two Sum]]></title>
      <url>/2017/08/01/%E3%80%90leetcode%E3%80%911-Two-Sum/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Given nums = [2, 7, 11, 15], target = 9,</div><div class="line"></div><div class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line"></div><div class="line">return [0, 1].</div></pre></td></tr></table></figure></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给一个数组和一个整数，返回数组中和恰好等于这个整数的两个数组的位置</p>
<p>自己就只想出来了从前向后遍历的方法，时间复杂度$O(n^2)$</p>
<p>代码如下</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">        hash_map&lt;int,int&gt; map;</div><div class="line">        for(int i = 0;i &lt; nums.size();i++)&#123;</div><div class="line">            int res = target-nums[i];</div><div class="line">            if (map.)</div><div class="line">            for(int j = i+1;j &lt; nums.size();j++)&#123;</div><div class="line">                if (res == nums[j])&#123;</div><div class="line">                    result.push_back(i);</div><div class="line">                    result.push_back(j);</div><div class="line">                    return result;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>看了solution才知道这道题正确的打开方式是用hash_map，可以先把数组中的元素存入hash_map中，这样就可以实现O(1)复杂度的按值查找了。</p>
<p>不过还有更好的方式，就是采用边查找边插入的方式，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt; a,int b) &#123;</div><div class="line">    vector&lt;int&gt; res;</div><div class="line">    unordered_map&lt;int, int&gt; map;</div><div class="line">    for (int i = 0; i &lt; a.size(); i++) &#123;</div><div class="line">        int temp = b - a[i];</div><div class="line">        //查看map里是否已经有要找的元素</div><div class="line">        unordered_map&lt;int, int&gt;::iterator it = map.find(temp);</div><div class="line">        //如果没有，把当前元素的值和idx插入map</div><div class="line">        if (it == map.end()) &#123;</div><div class="line">            map.insert(make_pair(a[i], i));</div><div class="line">        &#125;</div><div class="line">        //找到了符合要求的，返回idx</div><div class="line">        else&#123;</div><div class="line">            res.push_back(it-&gt;second);</div><div class="line">            res.push_back(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在查找指定值元素的时候就可以有$O(1)$的复杂度了，遍历的复杂度是$O(n)$,总的复杂度是$O(n)$</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://i.loli.net/2017/08/01/597f5b7c55158.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> hash_table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[归并排序]]></title>
      <url>/2017/07/23/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>分治法</strong><br>将数组分成A、B两组，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？</p>
<p>可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//将两个有序数组合并成一个有序数组</div><div class="line">void merge(int a[], int begin,int mid,int end,int b[]) &#123;</div><div class="line">    int i = begin;</div><div class="line">    int j = mid + 1;</div><div class="line">    int k = 0;</div><div class="line">    while ((i &lt;= mid) &amp;&amp; (j &lt;= end)) &#123;</div><div class="line">        if (a[i] &lt; a[j]) &#123;</div><div class="line">            b[k] = a[i];</div><div class="line">            k++;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            b[k] = a[j];</div><div class="line">            k++;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    while (i&lt;=mid)&#123;</div><div class="line">        b[k] = a[i];</div><div class="line">        k++;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    while (j &lt;= end)&#123;</div><div class="line">        b[k] = a[j];</div><div class="line">        k++;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; k; i++)&#123;</div><div class="line">        a[begin + i] = b[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//归并排序</div><div class="line">void MergeSort(int a[], int begin,int end,int b[]) &#123;</div><div class="line">    if (begin &lt; end) &#123;</div><div class="line">        int mid = (begin + end) / 2;</div><div class="line">        MergeSort(a, begin, mid, b);</div><div class="line">        MergeSort(a, mid + 1, end, b);</div><div class="line">        merge(a, begin, mid, end, b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最坏情况$O(n\log(n))$<br>平均情况$O(n\log(n))$</p>
]]></content>
      
        <categories>
            
            <category> 排序算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[不使用中间变量交换两个数字]]></title>
      <url>/2017/07/22/%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%97%B4%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>给定两个数字a和b，要求不使用中间变量交换二者</p>
<h3 id="一般做法"><a href="#一般做法" class="headerlink" title="一般做法"></a>一般做法</h3><p>一般的做法很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void swap(int &amp;a;int &amp;b)&#123;</div><div class="line">    int temp = a;</div><div class="line">    a = b;</div><div class="line">    b = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="不使用中间变量的做法"><a href="#不使用中间变量的做法" class="headerlink" title="不使用中间变量的做法"></a>不使用中间变量的做法</h3><p>采用位操作符中的异或操作<code>^</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">取反</td>
<td>0变1,1变0</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">左移</td>
<td>后面补0</td>
</tr>
<tr>
<td style="text-align:center">>&gt;</td>
<td style="text-align:center">右移</td>
<td>前面补0，后面吞位</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">位与</td>
<td>只有两个都为1，则为1。<strong>x&amp;…00100…用于提取x某一位</strong></td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">位异或</td>
<td>只有一个为1，则为 1。<strong>用于判断两位是否相同</strong> a^b^a = b 用于交换数值</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>位或</td>
<td>有一个或2个1，则为1。<strong>用于做and运算</strong></td>
</tr>
</tbody>
</table>
</div>
<p>容易发现<code>^</code>的性质：</p>
<ol>
<li>两个相同的数字做<code>^</code>操作得0</li>
<li>任何数字跟0做<code>^</code>操作还是它本身</li>
</ol>
<p>所以可以通过下面的方式交换两个数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void swap(int &amp;a;int &amp;b)&#123;</div><div class="line">    a = a^b;</div><div class="line">    b = b^a;</div><div class="line">    a = a^b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个程序大部分时间正确，但是有个致命缺陷，当a和b指向同一个位置时，计算a^b得0，也就是说a和b所指向的地址是同一个，所以此时a=b=0。所以上面这样写的前提是假设两个指针不会指向同一个位置。这也是编译器优化时经常考虑的一点，这种两个指针指向同一个存储器的情况叫做存储器别名使用（memory aliasing）。</p>
<p>因此正确的程序应该如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void swap(int &amp;a;int &amp;b)&#123;</div><div class="line">    if (a!=b)&#123;</div><div class="line">        a = a^b;</div><div class="line">        b = b^a;</div><div class="line">        a = a^b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[选择排序]]></title>
      <url>/2017/07/22/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每次从无序区选择一个最小的放大有序区的最后</p>
<p>设数组为a[0…n-1]。</p>
<ol>
<li><p>初始时，数组全为无序区为a[0..n-1]。令i=0</p>
</li>
<li><p>在无序区a[i…n-1]中选取一个最小的元素，将其与a[i]交换。交换之后a[0…i]就形成了一个有序区。</p>
</li>
<li><p>i++并重复第二步直到i==n-1。排序完成。</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//选择排序</div><div class="line">void SekectSort(int a[], int len) &#123;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">        int min = a[i];</div><div class="line">        int loc = i;</div><div class="line">        //寻找最小的元素</div><div class="line">        for (int j = i + 1; j &lt; len; j++) &#123;</div><div class="line">            if (a[j] &lt; min) &#123;</div><div class="line">                min = a[j];</div><div class="line">                loc = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //把最小的元素放在有序区后面</div><div class="line">        int temp = a[loc];</div><div class="line">        a[loc] = a[i];</div><div class="line">        a[i] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="external">MoreWindows Blog 白话经典算法系列</a></p>
]]></content>
      
        <categories>
            
            <category> 排序算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[希尔排序]]></title>
      <url>/2017/07/22/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>希尔排序的实质是分组插入排序，又称缩小增量排序。</p>
<p>该方法的基本思想是：</p>
<ol>
<li>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的），对这些子序列分别进行直接插入排序</li>
<li>依次缩减增量再进行排序</li>
<li>待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</li>
</ol>
<p>因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>现在我们要将这样一个数组排序，一共有10个元素</p>
<p><img src="https://i.loli.net/2017/07/20/59701858e5e96.png" alt=""> </p>
<ul>
<li><strong>第一次 增量 gap = 10/2 = 5</strong></li>
</ul>
<p><img src="https://i.loli.net/2017/07/20/59701a2be3ef5.png" alt=""> </p>
<p>整个数组被分成了5个子数组，分别是[49,13]，[38,27]，[65,49]，[97,55]，[26,4]<br>然后对这五个子数组进行插入排序，得到下面结果</p>
<p><img src="https://i.loli.net/2017/07/20/59701b9f8c66f.png" alt=""> </p>
<ul>
<li><strong>第二次 增量 gap = 5/2 = 2</strong></li>
</ul>
<p><img src="https://ooo.0o0.ooo/2017/07/20/59701bfe5a204.png" alt=""> </p>
<p>这次我们把整个数组分成了两个子数组，分别是[13,49,4,38,97],[27,55,49,65,26]<br>对这个两个子数组排序，结果如下：<br><img src="https://i.loli.net/2017/07/20/59701d3805da5.png" alt=""> </p>
<ul>
<li><strong>第三次 增量 gap = 2/2 = 1</strong><br>此时整个数组已经接近有序，对整个数组进行全排列</li>
</ul>
<p><img src="https://i.loli.net/2017/07/20/59701e32a8bb1.png" alt=""> </p>
<p>最终得到数组有序</p>
<p><img src="https://ooo.0o0.ooo/2017/07/20/59701fd2c547a.png" alt=""> </p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//希尔排序</div><div class="line">void HillSort(int a[], int len) &#123;</div><div class="line">    int delta = len/2;</div><div class="line">    while (delta &gt; 0) &#123;</div><div class="line">        for (int i = 0; i &lt; delta; i++) &#123;//分成了delta个子序列</div><div class="line">            //对每个子序列进行插入排序</div><div class="line">            for (int j = i + delta; j &lt; len; j = j + delta) &#123;</div><div class="line">                int jj = j - delta;</div><div class="line">                int temp = a[j];</div><div class="line">                while ((a[jj] &gt; temp)&amp;&amp;(jj&gt;=0)) &#123;</div><div class="line">                    a[jj + delta] = a[jj];</div><div class="line">                    jj -= delta;</div><div class="line">                &#125;</div><div class="line">                //插入</div><div class="line">                a[jj + delta] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        delta = delta / 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><a href="http://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="external">白话经典算法系列</a>原文是这么说的</p>
<blockquote>
<p>很明显，上面的shellsort1代码虽然对直观的理解希尔排序有帮助，但代码量太大了，不够简洁清晰。因此进行下改进和优化，以第二次排序为例，原来是每次从1A到1E，从2A到2E，可以改成从1B开始，先和1A比较，然后取2B与2A比较，再取1C与前面自己组内的数据比较…….。这种每次从数组第gap个元素开始，每个元素与自己组内的数据进行直接插入排序显然也是正确的。</p>
</blockquote>
<p>我理解了一下，思路就是把在序列中提取子序列的过程简化了，我们可以从第gap个元素开始，向后遍历到序列末尾，可以个元素都跟其所在的子序列中位于它前面的数字做插入排序，最终就会得到一个有序数列了~</p>
<p>画个图表示一下吧，还是刚才那个序列，比如说此时进行到第二次排序了，gap=2的情况：</p>
<p>从a[2]开始遍历，此时a[2]所在的子序列为[a[0],a[2],a[4],a[6],a[8]]，需要将a[2]和位于它前面的a[0]比较，插入到合适的位置：</p>
<p><img src="https://i.loli.net/2017/07/22/59731239a3cd2.png" alt=""> </p>
<p>指针后移一位， 同上此时a[3]所在的子序列为[a[1],a[3],a[5],a[7],a[9]]，需要将a[3]和位于它前面的a[1]比较，插入合适的位置：</p>
<p><img src="https://i.loli.net/2017/07/22/59731264440fc.png" alt=""> </p>
<p>接下来指针指向a[4],此时需要将a[4]和位于它前面的a[2]、a[0]比较，插入合适的位置：</p>
<p><img src="https://i.loli.net/2017/07/22/59731282140fd.png" alt=""> </p>
<p>下面重复上面的步骤：</p>
<p><img src="https://i.loli.net/2017/07/22/597312a912c5c.png" alt=""> </p>
<p><img src="https://i.loli.net/2017/07/22/597312ca290dc.png" alt=""> </p>
<p>此处省略剩余步骤…..最终可以将数组排列至有序状态</p>
<p>现在可以上代码了~<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//希尔排序</div><div class="line">void HillSort(int a[], int len) &#123;</div><div class="line">    int delta = len/2;</div><div class="line">    while (delta &gt; 0) &#123;</div><div class="line">        for (int i = delta; i &lt; len; i++) &#123;//遍历</div><div class="line">            //对该元素子前面的子数组进行插入排序</div><div class="line">            int temp = a[i];</div><div class="line">            int jj = i - delta;</div><div class="line">            while ((jj &gt;=0)&amp;&amp;(a[jj]&gt;temp))&#123;</div><div class="line">                swap(a[jj], a[jj+delta]);</div><div class="line">                jj -= delta;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        delta = delta / 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="external">MoreWindows Blog 白话经典算法系列</a></p>
]]></content>
      
        <categories>
            
            <category> 排序算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[插入排序]]></title>
      <url>/2017/07/20/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>直接插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。</p>
<p>设数组为a[0…n-1]。</p>
<ol>
<li><p>初始时，a[0]自成1个有序区，无序区为a[1..n-1]。令i=1</p>
</li>
<li><p>将a[i]并入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。</p>
</li>
<li><p>i++并重复第二步直到i==n-1。排序完成。</p>
</li>
</ol>
<p>在查找某元素应该插入到前面有序序列的位置时，我们可以采用边交换边插入的方式，直到无需交换</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void InsertSort(int a[],int len) &#123;</div><div class="line">    for (int i = 1; i &lt; len; i++) &#123;</div><div class="line">        //查找应该插入的位置</div><div class="line">        for (int j = i; j &gt; 0; j--)&#123;</div><div class="line">            if (a[j - 1] &gt; a[j]) &#123;</div><div class="line">                int temp = a[j];</div><div class="line">                a[j] = a[j - 1];</div><div class="line">                a[j - 1] = temp;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中交换元素部分可以调用STL中的swap函数实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//插入排序</div><div class="line">void InsertSort(int a[],int len) &#123;</div><div class="line">    for (int i = 1; i &lt; len; i++) &#123;</div><div class="line">        //查找应该插入的位置</div><div class="line">        for (int j = i; j &gt; 0; j--)&#123;</div><div class="line">            if (a[j - 1] &gt; a[j]) &#123;</div><div class="line">                swap(a[j], a[j - 1]);</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n^2)$</p>
]]></content>
      
        <categories>
            
            <category> 排序算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[冒泡排序]]></title>
      <url>/2017/07/20/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol>
<li>依次比较相邻的两个数据，如果前面的比后面的大，就将其交换</li>
<li>这样交换一轮之后，整个序列中最大的就“沉”到了最后面的位置</li>
<li>重复上述过程，依次把第二大、第三大…的数字放到后面的位置。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void BubbleSort(int a[], int len) &#123;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;//一共需要遍历len轮</div><div class="line">        for (int j = 0; j &lt; len -1-i; j++) &#123;//后面的len-1个数据</div><div class="line">            if (a[j] &gt; a[j + 1]) &#123;</div><div class="line">                int temp = a[j + 1];</div><div class="line">                a[j + 1] = a[j];</div><div class="line">                a[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来可以优化一下，上面的程序中一共进行了N轮比较，其实如果有一趟没有发生交换就说明这时候每两个相邻数据都已经呈现前边比后边小的状态了，此时已经达到有序状态了，所以后面就无需再继续比较了</p>
<h3 id="改进代码"><a href="#改进代码" class="headerlink" title="改进代码"></a>改进代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void BubbleSort(int a[], int len) &#123;</div><div class="line">    int flag = 1;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;//一共需要遍历len轮</div><div class="line">        int flag = 0;//用来记录本轮是否发生交换</div><div class="line">        for (int j = 0; j &lt; len - 1 - i; j++) &#123;//后面的len-1个数据</div><div class="line">            if (a[j] &gt; a[j + 1]) &#123;</div><div class="line">                int temp = a[j + 1];</div><div class="line">                a[j + 1] = a[j];</div><div class="line">                a[j] = temp;</div><div class="line">                flag = 1;//本轮发生交换了</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (flag == 0) &#123;//如果本轮未发生交换，跳出</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还可以进一步优化，假设有100个数的数组，只有前面10个无序，后面90个都已排好序且都大于前面10个数字，那么在第一趟遍历后，最后发生交换的位置必定小于10，且这个位置之后的数据必定已经有序了，记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。</p>
<p>一般地，冒泡排序在进行过程中，也会出现后面已经排好了的情况，所以如果记录一下有序的位置，下一次就可以不用向后遍历了。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void BubbleSort(int a[], int len) &#123;</div><div class="line">    int k ;//用于记录从那个数据开始之后的数据为</div><div class="line">    int flag = len-1;//用于几率从哪个数据开始之后的数据有序</div><div class="line">    while (flag &gt; 0) &#123;</div><div class="line">        k = flag;//计算到k之前</div><div class="line">        flag = 0;//用于记录本轮是否有交换</div><div class="line">        for (int j = 0; j &lt; k; j++) &#123;//后面的len-1个数据</div><div class="line">            if (a[j] &gt; a[j + 1]) &#123;</div><div class="line">                int temp = a[j + 1];</div><div class="line">                a[j + 1] = a[j];</div><div class="line">                a[j] = temp;</div><div class="line">                flag = j;//本轮交换了，更新交换位置</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结一下冒泡排序的关键点就是相邻元素两两比较交换，执行N轮，如果有某一轮没有发生交换说明已经有序，停止；记录下每一轮交换停止的位置，这之后的数据时有序的，下一轮无需考察。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n^2)$</p>
]]></content>
      
        <categories>
            
            <category> 排序算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[快速排序]]></title>
      <url>/2017/07/17/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>感谢@MoreWindows的白话经典算法系列，浅显易懂，让我终于看懂了快速排序，总结一下</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>从数列中选择一个作为<strong>基准数</strong></li>
<li><strong>分区</strong>操作：把比基准数小的都排在基准数的左边，比基准数大的都排在基准数的右边</li>
<li>对基准数的左边和右边<strong>分治</strong>排序</li>
</ol>
<h3 id="具体实现：挖坑填数-分治法"><a href="#具体实现：挖坑填数-分治法" class="headerlink" title="具体实现：挖坑填数+分治法"></a>具体实现：挖坑填数+分治法</h3><p>这里结合个实际例子说明</p>
<p><img src="https://i.loli.net/2017/07/18/596da83e7801a.png" alt=""> </p>
<p>根据上面的步骤，选取第一个作为<strong>基准数</strong>，接下来我们需要把比它小的数字放到它的左边，比它大的数字放到它的右边，这里就需要重点注意<strong>挖坑填数</strong>的方法了，划重点！！！</p>
<p><img src="https://i.loli.net/2017/07/18/596da86bf0f53.png" alt="">  temp=72</p>
<p>我们先把基准数72保存到变量temp中，这时候就相当于在数组的第一个位置上挖了一个“坑”，如果我们在后边发现有比temp小的数字，就可以把那个比较小的数字填到这个空缺的“坑”里了。</p>
<p><img src="https://i.loli.net/2017/07/18/596dada8c0f65.png" alt=""> </p>
<p>我们定义一个从后向前遍历的指针j，发现a[8]位置上的48比72小，所以我们要把48放到前面去，填补之前72留下的空缺.</p>
<p><img src="https://i.loli.net/2017/07/18/596da9ed5c6da.png" alt=""> </p>
<p>这时候原来存放48的这个位置就空了出来，有了一个新的“坑”，此时指针i向后遍历，如果找到比temp大的数字，便可以填补之前的48留下的坑了。恩，我们找到了a[3]位置上的88，将他填补到之前48留下来的“坑”里。</p>
<p><img src="https://i.loli.net/2017/07/18/596dabf678c11.png" alt=""> </p>
<p>接下来继续重复上面的过程，先从后向前找到比基准值小的，填补在前面的“坑”里，然后再从前向后找比基准值大的，填补刚才空出来的“坑”。直到最终两个指着相遇。</p>
<p><img src="https://i.loli.net/2017/07/18/596dacb08d160.png" alt=""> </p>
<p>而此时空缺的位置，恰好就是基准值temp的位置。将基准值填入空缺位置，至此就完成了一次分区的操作，此时基准数前面的数字都比基准数小，后面的都比基准数大。</p>
<p>接下来就是对基准数前后两段数组分而治之，采用递归调用的思想，将整个数组调整至有序状态。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void quiksort(vector&lt;int&gt; &amp;vec, int i, int j) &#123;</div><div class="line">    if (i &lt; j) &#123;</div><div class="line">        int temp = vec[i];//存储基准值</div><div class="line">        int left = i;</div><div class="line">        int right = j;</div><div class="line">        while (left &lt; right) &#123;</div><div class="line">            //后指针向前遍历，寻找比基准值小的数字</div><div class="line">            while (left &lt; right &amp;&amp; vec[right] &gt;= temp) &#123;</div><div class="line">                right--;</div><div class="line">            &#125;</div><div class="line">            //填数</div><div class="line">            vec[left] = vec[right];</div><div class="line">            //前指针向后遍历，寻找比基准值大的数字</div><div class="line">            while (left &lt; right &amp;&amp; vec[left] &lt;= temp) &#123;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            //填数</div><div class="line">            vec[right] = vec[left];</div><div class="line">        &#125;</div><div class="line">        vec[right] = temp;</div><div class="line">        //递归调用</div><div class="line">        quiksort(vec, i, right - 1);</div><div class="line">        quiksort(vec, right + 1, j);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    int n;</div><div class="line">    int temp;</div><div class="line">    vector&lt;int&gt; vec = &#123;&#125;;</div><div class="line">    scanf_s(&quot;%d&quot;, &amp;n);</div><div class="line">    while (n &gt; 0) &#123;</div><div class="line">        scanf_s(&quot;%d&quot;, &amp;temp);</div><div class="line">        vec.push_back(temp);</div><div class="line">        n--;</div><div class="line">    &#125;</div><div class="line">    quiksort(vec, 0, vec.size() - 1);</div><div class="line">    for (int i = 0; i &lt; vec.size(); i++) &#123;</div><div class="line">        cout &lt;&lt; vec[i]&lt;&lt;&quot; &quot;;</div><div class="line">    &#125;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li>最坏时间复杂度：$O(n^2)$</li>
<li>期望时间复杂度：$O(n\log(n))$</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 排序算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[今日头条-算法岗]]></title>
      <url>/2017/07/17/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1-%E7%AE%97%E6%B3%95%E5%B2%97/</url>
      <content type="html"><![CDATA[<p>昨天去头条面试了，意料之中的挂了23333</p>
<p>没怎么考察算法，就做了个自我介绍，简单介绍了一下项目，问了问ffm的原理，跟fm比起来有哪些优势</p>
<p>紧接着上了两道算法题，两道题都很基础，但自己真心不扎实，难怪人家看不上==</p>
<h2 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h2><p>给一个句子，把句子翻转但单词不翻转<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">input:&quot;I am a coder&quot;</div><div class="line">output:&quot;coder a am I&quot;</div></pre></td></tr></table></figure></p>
<p>对字符串、字符数组这里一直都很懵逼，看到题就知道自己写不出来了，挣扎了一会投降了==<br>而且我的重点都放在了要怎么读进来啊！不会读进来啊！怎么读啊！要好好看c++了啊喂！</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>先翻转整个句子，再把每一个单词翻转过来。翻转字符串的时候前后对换，能减少一半的时间复杂度</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">FILE *fin;</div><div class="line"></div><div class="line">//反转字符串</div><div class="line">void ReverseString(char *begin, char *end) &#123;</div><div class="line">    while (begin &lt; end) &#123;</div><div class="line">        char temp = *begin;</div><div class="line">        *begin = *end;</div><div class="line">        *end = temp;</div><div class="line">        begin++;</div><div class="line">        end--;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//反转句子</div><div class="line">char* ReverseSentance(char *ch) &#123;</div><div class="line">    char *begin = ch;</div><div class="line">    char *end = ch;</div><div class="line"></div><div class="line">    while (*end != &apos;\0&apos;)</div><div class="line">        end++;</div><div class="line">    end--;</div><div class="line">    //反转整个句子</div><div class="line">    ReverseString(begin, end);</div><div class="line"></div><div class="line">    //逐个反转单词</div><div class="line">    begin = ch;</div><div class="line">    end = ch;</div><div class="line">    while ((*begin != &apos;\0&apos;)) &#123;</div><div class="line">        while ((*end != &apos; &apos;) &amp;&amp; (*end != &apos;\0&apos;)) &#123;</div><div class="line">            end++;</div><div class="line">        &#125;</div><div class="line">        ReverseString(begin, end - 1);</div><div class="line">        if (*end != &apos;\0&apos;) &#123;</div><div class="line">            end++;</div><div class="line">        &#125;</div><div class="line">        begin = end;</div><div class="line">    &#125;</div><div class="line">    return ch;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    /*fin = fopen(&quot;test.txt&quot;, &quot;r&quot;);</div><div class="line">    char str[1024];</div><div class="line">    int i = 0;</div><div class="line">    while ((str[i] = getchar()) != &apos;\n&apos;) &#123;</div><div class="line">        i++;</div><div class="line">    &#125; </div><div class="line">    int length = sizeof(str)/sizeof(str[0]);</div><div class="line">    char *array = str;*/</div><div class="line">    char a[] = &quot;I am a coder&quot;;</div><div class="line">    char *array = a;</div><div class="line">    int length = sizeof(a) / sizeof(a[0]);</div><div class="line">    cout &lt;&lt; length;</div><div class="line">    array = ReverseSentance(array);</div><div class="line">    for (int i = 0; i &lt; length-1; i++)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; *array;</div><div class="line">        array++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>给定一个有序数组和一个数字，统计该数字在数组中出现的次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">input:3</div><div class="line">1 2 3 3 4 5 6</div><div class="line">output:2</div></pre></td></tr></table></figure>
<p>我想到了用二分查找来解决，然后我竟然找到了这个数字时候左右分别递归再找==</p>
<p>其实找到了之后就向左向右遍历就可以了，因为数组本身已经是有序的了嘛。。。。</p>
<h3 id="关键思路"><a href="#关键思路" class="headerlink" title="关键思路"></a>关键思路</h3><p><strong>二分查找该数字是否在数组中出现，如果找到了就分别向左侧和右侧探测连续出现了几次</strong></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">FILE *fin;</div><div class="line"></div><div class="line">//二分查找</div><div class="line">int midfind(vector&lt;int&gt; &amp;vec,int head,int tail,int n) &#123;</div><div class="line">    if (head &gt; tail)</div><div class="line">        return -1;</div><div class="line">    else &#123;</div><div class="line">        int mid = (head + tail) / 2;</div><div class="line">        if (vec[mid] == n)</div><div class="line">            return mid;</div><div class="line">        else if (vec[mid] &lt; n) &#123;</div><div class="line">            return midfind(vec, mid + 1, tail, n);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            return midfind(vec, head, mid - 1, n);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    fin = fopen(&quot;test.txt&quot;, &quot;r&quot;);</div><div class="line">    int n;</div><div class="line">    int temp;</div><div class="line">    vector&lt;int&gt; vec;</div><div class="line">    fscanf(fin,&quot;%d&quot;,&amp;n);</div><div class="line">    while (fscanf(fin, &quot;%d&quot;,&amp;temp)!=EOF) &#123;</div><div class="line">        vec.push_back(temp);</div><div class="line">    &#125;</div><div class="line">    int len = vec.size();</div><div class="line">    int pos = midfind(vec, 0, len - 1, n);</div><div class="line">    if (pos == -1)</div><div class="line">        cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;</div><div class="line">    else &#123;</div><div class="line">        int pos1 = pos - 1;</div><div class="line">        int pos2 = pos + 1;</div><div class="line">        int sum = 1;</div><div class="line">        while ((pos1&gt;=0) &amp;&amp; (vec[pos1]==n))</div><div class="line">        &#123;</div><div class="line">            sum++;</div><div class="line">            pos1--;</div><div class="line">        &#125;</div><div class="line">        while ((pos2&lt;len) &amp;&amp; (vec[pos2] == n))</div><div class="line">        &#123;</div><div class="line">            sum++;</div><div class="line">            pos2++;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; sum &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>立flag 好好刷算法了要！！！！！基础很重要！</p>
]]></content>
      
        <categories>
            
            <category> 面经 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Optimal Real-Time Bidding for Display Advertising论文笔记]]></title>
      <url>/2017/07/17/Optimal-Real-Time-Bidding-for-Display-Advertising%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="Optimal-Real-Time-Bidding-for-Display-Advertising——KDD2014"><a href="#Optimal-Real-Time-Bidding-for-Display-Advertising——KDD2014" class="headerlink" title="Optimal Real-Time Bidding for Display Advertising——KDD2014"></a>Optimal Real-Time Bidding for Display Advertising——KDD2014</h2><p>参考着师兄的博客<a href="http://blog.csdn.net/Breada/article/details/50697030" target="_blank" rel="external">计算广告小窥[中]这孙子怎么什么都知道</a>，仔细读完了这篇paper，总结一下，方便日后回顾</p>
<p>ps:十分感谢师兄@<a href="http://blog.csdn.net/breada" target="_blank" rel="external">面包包包包包包</a>，看了师兄的三篇博客可算是入了门，不然真是一头雾水hold不住啊</p>
<p>这篇文章的核心就是提出了一个<strong>非线性的竞价函数</strong>，相比于KDD2012的<a href="http://cwds.uw.edu/sites/default/files/p804.pdf" target="_blank" rel="external">《Bid Optimizing and Inventory Scoring in Targeted Online Advertising》</a>中提出的线性竞价函数，本文认为出价应该与点击率、转化率等指标具有<strong>非线性关系</strong></p>
<p>首先，文章将现实问题用数学方法建模为限制条件下的优化问题，并通过拉格朗日乘子法，求得出价策略的数学表达式（非线性竞价函数）；然后利用iPinYou数据拟合出价策略中的参数；最后，做实验验证结果，发现了一个有意思的结论：相比少量高品质的展示机会，那些大量低品质的展示机会同样可以具有较好的广告效果，值得出价。这个发现对于那些预算不够，同时又想做广告的小广告主来说，简直就是福音。</p>
<a id="more"></a>
<h2 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h2><h3 id="选择合适的出价策略，在预算的限制下实现广告效果最大化"><a href="#选择合适的出价策略，在预算的限制下实现广告效果最大化" class="headerlink" title="选择合适的出价策略，在预算的限制下实现广告效果最大化"></a>选择合适的出价策略，在预算的限制下实现广告效果最大化</h3><p>把这句话用数学的形式表达出来就是下面的样子：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59141e20788bf.png" alt=""> </p>
<p>看起来来有点复杂，其实很简单，两个式子，第一行是优化目标：寻找似的收益最大化的出价函数b()</p>
<p>第二行就是预算约束，就是花的钱不能超过预算约束B</p>
<p>模型中涉及的具体符号定义如下：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59141e0b0486d.png" alt=""> </p>
<h3 id="结合着具体的符号定义，可以解释一下之前建立的数学模型了"><a href="#结合着具体的符号定义，可以解释一下之前建立的数学模型了" class="headerlink" title="结合着具体的符号定义，可以解释一下之前建立的数学模型了"></a>结合着具体的符号定义，可以解释一下之前建立的数学模型了</h3><p>$dx$：x代表一次bid request，也就是一次竞价请求的特征向量，是ADX发给DSP的竞价请求“标识XXX,男性，20-25岁，跑鞋爱好者，广告位为首页”，即一次广告展示机会。之所以是dx而不是x，是因为我们关注的是整个广告推广计划中所有的竞价过程，而非某一次竞价。</p>
<p>$p_x(x)$：广告展示机会的概率密度分布，我的理解是在全网所有的竞价中，满足我DSP要求的、或者是我能收到的bid request所占的比例。因此，$p_x(x)*dx$的物理意义是我能收到的展示机会。</p>
<p>$\theta(x)$：θ是赢得此次竞价所能带来的收益(KPI)，本文用CTR来衡量，CTR越高，收益就越高。</p>
<p>$b(\theta(x),x)$：对于此次展示机会，在能带来收益为θ(x)的情况下，我所出的价格bid。</p>
<p>$\omega(b(\theta(x),x),x)$：对于此次展示机会，在能带来收益为θ(x)的情况下，我的出价bid能获胜的概率是多少。因此，$\omega(b(\theta(x),x),x)<em>p_x(x)</em>dx$表示对于本次我所收到的这个展示机会来说，在该机会能带来收益（如CTR,CVR等）为θ(x)，我出价为bid的情况下，我能打败对手获得此次展示机会的概率。</p>
<p>以$\theta(x)\omega(b(\theta(x),x),x)<em>p_x(x)</em>dx$的物理含义是我出价为bid，赢得这次展示机会后，所能获得的收益。</p>
<p>以$b(\theta(x),x)\omega(b(\theta(x),x),x)<em>p_x(x)</em>dx$的物理含义是我出价为bid，赢得这次展示机会所花费的钱。</p>
<p>$N_T$：生存时间T内广告推广活动中所有的bid request数量</p>
<p>总之还是那句话：<strong>选择合适的出价策略，在预算的限制下实现广告效果最大化</strong></p>
<h2 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h2><p><img src="https://ooo.0o0.ooo/2017/05/11/59141e20788bf.png" alt=""> </p>
<p>经过一系列的化简，我们可以把模型的函数表达式简化成下面的样子，具体过程参考原文</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/591426f75561b.png" alt=""> </p>
<p>现在参数就只有$\theta$了，也就是CTR，接下来要怎么求解最大值呢？这是要一个带约束条件的最优化问题，作者是用了拉格朗日乘子法来解决的</p>
<p>通过拉格朗日乘子法，我们可以将不等式乘一个参数$\lambda$后和等式写进一个公式里(化简过程已省略)，得到如下结果:</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/591427c023edb.png" alt=""> </p>
<p>然后对其求导，令导数为0得到：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59142a08a7855.png" alt=""> </p>
<p>进而求得出价函数$b(\theta)$与赢得竞价概率之间的函数关系为：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59142a857ef5e.png" alt=""> </p>
<p>也就是说，我们想要的出价函数b()与胜率函数w()有关，那我们就来看看他们之间到底有什么关系。作者利用数据集绘制出二者之间的关系如图：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59142bedeeacb.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/05/11/59142c7551aaa.png" alt=""> </p>
<p>我们发现这个函数走势很像$y=\frac{x}{c+x}$啊！！！对，作者也发现了，于是乎就有了下面的非线性竞价函数：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59142c9e5260d.png" alt=""> </p>
<p>然后把（9）带回到（8）中就求得了我们梦寐以求的非线性出价函数：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59142ce77aa66.png" alt=""> </p>
<p>画个图看看上面的两个函数走势吧：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59142d47bf56d.png" alt=""> </p>
<p>还是很符合实际情况的，点击率越高，出价也就越高，出价越高，赢得竞价的可能行也就越高</p>
<p>到此，我们就已经把问题的数学转化和模型求解弄完了，那剩下的关键问题就是要<strong>求解两个参数：$\lambda$和$c$了</strong></p>
<p>可以看出来$c$是可以直接根据历史数据拟合出来的，利用最小二乘法使得均方误差最小即可</p>
<p>难点在于$\lambda$的求解，文章采用的方法是：<strong>通过不断调整以获得在测试数据中得到最大收益（点击量）来获得</strong></p>
<h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><ol>
<li>利用iPinYou实时竞价数据，每一条数据是一个竞价请求，包含其特征、赢得竞价的价格、用户反馈（点击or转化）</li>
<li>将数据集按2:1分割分别作为训练和测试集</li>
<li>流程：用训练数据训练出点击率预估模型和出价函数，根据测试数据特征，计算出一个出价，如果超过数据集中的真实出价，则认为竞价成功</li>
<li>根据真是数据集中的情况进行模型评估</li>
<li>为了对比，将预算分别设置为原始预算的1/64,1/32,1/16,1/8,1/4,1/2进行实验</li>
<li>对比策略：按固定值出价，随机出价，按最大eCPC出价，线性出价</li>
</ol>
<p>经过一系列的实验，文章得出了下面的结论：</p>
<ol>
<li><strong>非线性出价策略赢得的总点击量大，而且单次点击所产生的费用低</strong></li>
<li><strong>预算约束越严格的情况下，相比于线性出价策略，非线性出价策略对于点击量的提升越大</strong></li>
<li>预算越低，$\lambda$的最优解的值越大，出价相对也越低，但是对于低价值的展示机会，非线性出价策略的出价比线性出价策略的出价略高。如下图所示</li>
</ol>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59145d12c4aea.png" alt=""> </p>
<p>我们可以很直观的看出，我们所得到的出价策略是一个非线性的。横坐标θ代表了广告展示计划的品质，ORTB会对低价值的展示机会出高价，这样的结果能为我们带来什么，谁会去要那些低价值的展示机会呢？我们来看下面这张图</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59145cfc4d8d4.png" alt=""> </p>
<p>在此图中，我们盯着一条曲线看，比如蓝色的(1/32)。随着λ增加，收获的点击量是增加的，意味着λ越高，我们的收益越高。对于我们获得的出价策略而言，λ越高，我们的出价是越低的，也就意味着这次展示机会的价值是很低的。这样的结果值得我们深思，我们以为低价值的展示机会是不值钱的，但数据说明，这些看似不值钱的展示所能带来的回报还算不错。特别地，在λ=1e-05时三条曲线的几乎重合，而红色代表有钱的广告主，蓝色代表穷广告主，虽然预算差了16倍，但是获得的收益是相同的，这个结论对于预算有限的小广告主而言，是个天大的好消息：虽然我们钱不多，但只要我们出价合适，依然可以收获很好的广告效果，四两拨千斤，极大的调动了小广告主参加程序化交易的积极性。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/Breada/article/details/50697030" target="_blank" rel="external">计算广告小窥[中]这孙子怎么什么都知道</a></p>
]]></content>
      
        <categories>
            
            <category> RTB </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】169. Majority Element]]></title>
      <url>/2017/04/10/%E3%80%90leetcode%E3%80%91169-Majority-Element/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than <code>⌊ n/2 ⌋</code>times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个数组长度为n，其中有一个元素出现的次数大于<code>⌊ n/2 ⌋</code>，现在我们要找出这个元素</p>
<h2 id="moore-voting算法"><a href="#moore-voting算法" class="headerlink" title="moore-voting算法"></a>moore-voting算法</h2><h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>找出一对不同的元素就去掉它们，最后剩下的一定是所找的元素。</p>
<p>需要<strong>两个指针</strong>和<strong>一个计数器</strong>，其中一个指针指向当前出现次数最大的元素，另一个向后遍历，count存储当前出现次数最大的元素出现的次数</p>
<ol>
<li>当用于遍历的指针2指向元素和指针1指向的元素相等时，count加1，否则减1</li>
<li>当count减至0的时候，指针1需要向后移动到指针2的位置，指针2继续向后遍历</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">    int len = nums.size();</div><div class="line">    int result = 0;</div><div class="line">    int count = 1;</div><div class="line">    int temp = 0;</div><div class="line">    for (int i = 1; i &lt; len; i++) &#123;</div><div class="line">        if (count != 0) &#123;</div><div class="line">            if (nums[i] == nums[temp])</div><div class="line">                count++;</div><div class="line">            else</div><div class="line">                count--;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            temp = i;</div><div class="line">            count = 1;</div><div class="line">        &#125;       </div><div class="line">    &#125;</div><div class="line">    return nums[temp];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/04/10/58eb46e839db1.png" alt=""> </p>
<h2 id="bit-manipulation"><a href="#bit-manipulation" class="headerlink" title="bit manipulation"></a>bit manipulation</h2><h3 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h3><p>把数字都转化为二进制处理。如果majority element第i位上的数字是1，那么所有数字第i位上为1的总个数一定会大于<code>⌊ n/2 ⌋</code>,反之，如果majority element第i位上的数字是0，那么所有数字第i位上为0的总个数一定会大于<code>⌊ n/2 ⌋</code></p>
<p>所以，如果我们统计所有的n个数字的第i位上1(或者0)的个数，看是否大于<code>⌊ n/2 ⌋</code>，就可以确定majority element第i位到底是0还是1了</p>
<p>int型数据一共有32bit，所有需要计算32个二进制位。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int i,j,count,major=0;</div><div class="line">        for(i=0;i&lt;32;i++)</div><div class="line">        &#123;</div><div class="line">            for(j=0,count=0;j&lt;nums.size();j++)</div><div class="line">            &#123;</div><div class="line">                if((nums[j]&gt;&gt;i&amp;1)==1)</div><div class="line">                    count++;</div><div class="line">            &#125;</div><div class="line">            if(count&gt;nums.size()/2)</div><div class="line">                major+=(1&lt;&lt;i);</div><div class="line">        &#125;</div><div class="line">        return major;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/04/10/58eb4bc45530f.png" alt=""> </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在用bit manipulation方法时，在已经确定了定majority element第i位到底是0还是1之后恢复majority element的时候，遇到了一个问题，查了很久，在这里总结一下</p>
<p>一开始我用了下面这样的方法恢复majority element</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for (int i = 0; i &lt; 32; i++) &#123;</div><div class="line">    if (countones[i] &gt; len / 2)</div><div class="line">        result += pow(2, i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是我们平时手算二进制转化成10进制的方法，但是发现遇到负数的时候就不能正确恢复了==</p>
<p>然后就查啊查，发现：</p>
<p><strong>int类型默认是signed的</strong>，也就是说带符号的，32bit中<strong>最高的那一位是用来表示符号的，最高位是0表示非负数，最高位是1表示负数</strong>，所以能够表示的整数的范围是$-2^{31}-1$~$2^{31}-1$。关于负数的二进制表示，之前写过一篇博客 <a href="https://siyaozhang.github.io/2017/04/04/c-%E5%8F%96%E5%8F%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E2%80%9C-%E2%80%9D/" target="_blank" rel="external">负数的二进制表示</a>，可以看出来确实负数的二进制表示最高位是1</p>
<p>所以用上面的方法<strong>不断叠加</strong>$2^i$（<strong>正数</strong>）是<strong>永远都不会恢复到原来的负数</strong>的，因为最高位永远都不会由0变为1，而且$2^{31}$已经超过int型的表示范围了。</p>
<p>因此，还是要<strong>用bit运算根据各个位是0还是1来恢复出原来的majority element</strong>，这样无论是正是负就都不会出错了。</p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bit manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[北邮ACM2017练习赛B. 斐波那契数列 矩阵快速幂]]></title>
      <url>/2017/04/08/%E5%8C%97%E9%82%AEACM2017%E7%BB%83%E4%B9%A0%E8%B5%9BB-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://ooo.0o0.ooo/2017/04/08/58e8ff74c74b3.png" alt=""> </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>矩阵快速幂<br>快速幂</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">using namespace std;</div><div class="line">const int mod = 10000;</div><div class="line">const int N = 2;//矩阵的维数,角标从0开始</div><div class="line">struct Matrix</div><div class="line">&#123;</div><div class="line">    long long v[N][N];</div><div class="line">    Matrix()</div><div class="line">    &#123;</div><div class="line">        memset(v,0,sizeof(v));</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">//矩阵的乘法p1*p2</div><div class="line">Matrix multi(Matrix p1,Matrix p2)</div><div class="line">&#123;</div><div class="line">    Matrix res;</div><div class="line">    for(int i=0;i&lt;N;i++)</div><div class="line">        for(int j=0;j&lt;N;j++)</div><div class="line">            if(p1.v[i][j])//代码优化，是0的话就不用计算</div><div class="line">                for(int k=0;k&lt;N;k++)</div><div class="line">                    res.v[i][k]=(res.v[i][k]+(p1.v[i][j]*p2.v[j][k]))%mod;</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">//矩阵的快速幂p^k</div><div class="line">Matrix pow(Matrix p,long long k)</div><div class="line">&#123;</div><div class="line">    Matrix t;</div><div class="line">    for(int i=0;i&lt;N;i++)//初始化为单位矩阵</div><div class="line">        t.v[i][i]=1;</div><div class="line">    while(k)</div><div class="line">    &#123;</div><div class="line">        if(k&amp;1)</div><div class="line">            t=multi(t,p);</div><div class="line">        p=multi(p,p);</div><div class="line">        k=k&gt;&gt;1;</div><div class="line">    &#125;</div><div class="line">    return t;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    long long n;</div><div class="line">    Matrix e,ans;</div><div class="line">    e.v[0][0]=e.v[0][1]=e.v[1][0]=1;</div><div class="line">    e.v[1][1]=0;</div><div class="line">    while(scanf(&quot;%I64dd&quot;,&amp;n)!=EOF&amp;&amp;n!=-1)</div><div class="line">    &#123;</div><div class="line">        ans = pow(e,n);</div><div class="line">        printf(&quot;%I64d\n&quot;,ans.v[0][1]);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[北邮ACM2017练习赛A. Email Adress]]></title>
      <url>/2017/04/08/%E5%8C%97%E9%82%AEACM2017%E7%BB%83%E4%B9%A0%E8%B5%9BA-Email-Adress/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>大概就是给一串字符，表示email地址，其中<code>@</code>用at表示，<code>.</code>用dot表示，当然了字母串里可能本来就有at和dot。<br>所以要想将给定的字符串恢复成尽可能短的email地址需要注意下面几条：</p>
<ol>
<li>只能含有一个<code>@</code>，且不能在开头处，即除开头外遇到的第一个at转化成<code>@</code>，其余还是at</li>
<li>除开头和结尾的dot不能转化成<code>.</code>以外其余的全部转化成<code>.</code></li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">char arrin[10000];</div><div class="line">FILE *fin;</div><div class="line">int main()&#123;</div><div class="line">    fin=fopen(&quot;in.txt&quot;,&quot;r&quot;);</div><div class="line">    char ch;</div><div class="line">    while(~fscanf(fin,&quot;%c&quot;,&amp;ch))&#123;</div><div class="line">        int i =1;</div><div class="line">        bool atflag = false;</div><div class="line">        memset(arrin,0,10000);</div><div class="line">        //存入字符串 </div><div class="line">        arrin[0]=ch;</div><div class="line">        while(fscanf(fin,&quot;%c&quot;,&amp;ch) &amp;&amp; ch!=&apos;\n&apos;)&#123;</div><div class="line">            arrin[i]=ch;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        //arrin[i]=-1;</div><div class="line">        //计算输出</div><div class="line">        printf(&quot;%c&quot;,arrin[0]);</div><div class="line">        for(int j =1;j &lt; i;j++)&#123;</div><div class="line">            if(arrin[j] == &apos;a&apos; &amp;&amp; arrin[j+1] == &apos;t&apos; &amp;&amp; atflag == false)&#123;//第一次遇到at </div><div class="line">                printf(&quot;%c&quot;,&apos;@&apos;);</div><div class="line">                atflag = true;</div><div class="line">                j+=1;</div><div class="line">            &#125;</div><div class="line">            else if(arrin[j] == &apos;d&apos; &amp;&amp; arrin[j+1] == &apos;o&apos; &amp;&amp; arrin[j+2] == &apos;t&apos; &amp;&amp; arrin[j+3] != &apos;\0&apos;)&#123;//dot不在结尾的情况 </div><div class="line">                printf(&quot;%c&quot;,&apos;.&apos;);</div><div class="line">                j+=2;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                printf(&quot;%c&quot;,arrin[j]);</div><div class="line">            &#125;   </div><div class="line">        &#125;   </div><div class="line">        printf(&quot;\n&quot;);   </div><div class="line">    &#125; </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[北邮ACM2017网预 Square Coins-动态规划]]></title>
      <url>/2017/04/05/%E5%8C%97%E9%82%AEACM2017%E7%BD%91%E9%A2%84-Square-Coins-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Artoria, also known as Saber-chan, was born into a time of chaos and war that began with the demise of the Roman empire. Somewhere in the far east, people in Utopia know nothing about war or conflicts. They live in peace for quite a long time and developed a strange currency system. In particular, they use square coins. Not only have they square shapes but also their values are square integers. Coins with values of all square numbers up to 289 (=172), i.e., 1-credit coins, 4-credit coins, 9-credit coins, …, and 289-credit coins, are available in Utopia.</p>
<p>According to the Utopia currency system, there are four combinations of coins to pay ten credits:</p>
<p>ten 1-credit coins,<br>one 4-credit coin and six 1-credit coins,<br>two 4-credit coins and two 1-credit coins, and<br>one 9-credit coin and one 1-credit coin.</p>
<p>Your mission is to count the number of ways to pay a given amount using coins of Utopia. The answer may be very big, please output the answer module 1000000009.</p>
<p><strong>input</strong></p>
<p>The input begins with a line containing a single integer T(1≤T≤2000), indicating the number of test cases. Each of the next T lines each containing an integer meaning an amount to be paid. You may assume that all the amounts are positive and less than 2000. </p>
<p><strong>output</strong></p>
<p>For each of the given amount, output one line containing a single integer representing the number of combinations of coins module 1000000009. No other characters should appear in the output.</p>
<p><strong>sample</strong><br>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2</div><div class="line">10</div><div class="line">30</div></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">4</div><div class="line">27</div></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一共有17种面值的硬币，个数不限，给定一个数值n，给出有多少种组合方式</p>
<p>利用<strong>动态规划</strong>的思想，可以预先计算好组成n的组合方式</p>
<p><strong>dp[i+coin[j]] = dp[i+coin[j]]+dp[i]</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">int dp[2005];</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    vector&lt;int&gt; result;</div><div class="line">    memset(dp, 0, 2005);</div><div class="line">    dp[0] = 1;</div><div class="line">    for (int i = 1; i &lt;= 17; i++) &#123;</div><div class="line">        for (int j = 0; j &lt; 2005; j++) &#123;</div><div class="line">            dp[j + i*i] = (dp[j + i*i] + dp[j])% 1000000009;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int N;</div><div class="line">    scanf(&quot;%d&quot;, &amp;N);</div><div class="line">    while (N) &#123;</div><div class="line">        int n;</div><div class="line">        scanf(&quot;%d&quot;, &amp;n);</div><div class="line">        printf(&quot;%d\n&quot;,dp[n]);</div><div class="line">        N--;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    //system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[增强学习]]></title>
      <url>/2017/04/04/%E5%A2%9E%E5%BC%BA%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>增强学习</p>
<p>机器学习中的一个领域，关注智能体如何基于环境而采取一系列的行动，以取得最大化的预期利益或回报</p>
<p>特点</p>
<p>试错学习(Trail-and-error)，由于没有直接的指导信息，智能体要以不断与环境进行交互，通过试错的方式来获得最佳策略。</p>
<p>延迟回报，增强学习的指导信息很少，而且往往是在事后（最后一个状态）才给出的，这就导致了一个问题，就是获得正回报或者负回报以后，如何将回报分配给前面的状态。</p>
<p>例子</p>
<p>比如下象棋，每一步都是一个决策过程，但决策的结果事后才知道<br>再比如机器人的行走，移动过程中不知道如何挪动<br>一种可行的思路是设计一个回报函数，每执行一步决策后，向agent进行汇报，比如四足机器人，如果他向前走了一步（接近目标），那么回报函数为正，后退为负。这样，我们对每一步进行评价，得到相应的回报函数，我们只需要找到一条回报值最大的路径（每步的回报之和最大），就认为是最佳的路径。</p>
]]></content>
      
        <categories>
            
            <category> deep learning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[word2vec（文本深度表示模型）]]></title>
      <url>/2017/04/04/word2vec%EF%BC%88%E6%96%87%E6%9C%AC%E6%B7%B1%E5%BA%A6%E8%A1%A8%E7%A4%BA%E6%A8%A1%E5%9E%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>简介</p>
<p>Word2vec 是 Google 在 2013 年年中开源的一款将词表征为实数值向量的高效工具, 其利用深度学习的思想，可以通过训练，把对文本内容的处理简化为 K 维向量空间中的向量运算，而向量空间上的相似度可以用来表示文本语义上的相似度。Word2vec输出的词向量可以被用来做很多 NLP 相关的工作，比如聚类、找同义词、词性分析等等。如果换个思路， 把词当做特征，那么Word2vec就可以把特征映射到 K 维向量空间，可以为文本数据寻求更加深层次的特征表示 。</p>
<p>Word2vec 使用的是 Distributed representation 的词向量表示方式。Distributed representation 最早由 Hinton在 1986 年提出[4]。其基本思想是 通过训练将每个词映射成 K 维实数向量（K 一般为模型中的超参数），通过词之间的距离（比如 cosine 相似度、欧氏距离等）来判断它们之间的语义相似度.其采用一个 三层的神经网络 ，输入层-隐层-输出层。有个核心的技术是 根据词频用Huffman编码 ，使得所有词频相似的词隐藏层激活的内容基本一致，出现频率越高的词语，他们激活的隐藏层数目越少，这样有效的降低了计算的复杂度。而Word2vec大受欢迎的一个原因正是其高效性，Mikolov 在论文[2]中指出，一个优化的单机版本一天可训练上千亿词。</p>
<p>这个三层神经网络本身是 对语言模型进行建模 ，但也同时 获得一种单词在向量空间上的表示 ，而这个副作用才是Word2vec的真正目标。</p>
<p>与潜在语义分析（Latent Semantic Index, LSI）、潜在狄立克雷分配（Latent Dirichlet Allocation，LDA）的经典过程相比，Word2vec利用了词的上下文，语义信息更加地丰富。</p>
<p>参考文献</p>
<p>有道技术沙龙-Deep Learning实战之word2vec</p>
<p>卷积和pooling</p>
<p>Deep Learning in NLP （一）词向量和语言模型</p>
]]></content>
      
        <categories>
            
            <category> deep learning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[北邮ACM2017热身赛-A题]]></title>
      <url>/2017/04/04/%E5%8C%97%E9%82%AEACM2017-A%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://ooo.0o0.ooo/2017/04/04/58e34e2ccb0cc.png" alt=""> </p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个列数字，求这列数字中的三元组$(a_i,a_j,a_k)$满足下面两个条件</p>
<ol>
<li>$a_i\leq a_j\leq a_k$</li>
<li>$a_i+a_j+a_k=0$<br>注意：<strong>重复的只算一次</strong></li>
</ol>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先排序</p>
<p>三个元素和为0，那么一定有两个元素大于等于0，一个小于0；或者两个小于等于0，一个大于0。总之<strong>不能三个元素都同号</strong></p>
<p>设三个指针，low从前往后扫描，high从后往前扫描，mid在这两个指针中间从前往后扫描：<br>先固定low指针，从前往后扫描，知道元素值&gt;=0时停止</p>
<ul>
<li>当三个指针指向的元素和为0时，记录下来。</li>
<li>当三个指针指向的元素和&gt;0时，high向前移动。</li>
<li>当三个指针指向的元素和&lt;0时，mid向后移动。</li>
</ul>
<p>需要注意的地方：</p>
<ol>
<li>同一个指针扫过的<strong>相等的元素只计算第一次</strong>，后面的要略过</li>
<li>元素值的平方已经超过int的最大位数，要用<strong>long long</strong>型</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line"> </div><div class="line">int main() &#123;</div><div class="line">    int arr[2005] = &#123; 0 &#125;;</div><div class="line">    char c;</div><div class="line">    vector&lt;int&gt; output;</div><div class="line">    int samplenum;</div><div class="line">    cin &gt;&gt; samplenum;</div><div class="line">    while (samplenum)</div><div class="line">    &#123;</div><div class="line">        long long result = 0;</div><div class="line">        int len;</div><div class="line">        cin &gt;&gt; len;</div><div class="line">        getchar();</div><div class="line">        int ii = 0;</div><div class="line">        //读入数据</div><div class="line">        while ((c = getchar()) != &apos;\n&apos;)</div><div class="line">        &#123;</div><div class="line">            if (c != &apos; &apos;)//把这句判断条件改动  </div><div class="line">            &#123;</div><div class="line">                ungetc(c, stdin);</div><div class="line">                cin &gt;&gt; arr[ii++];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //排序</div><div class="line">        sort(arr, arr + len);</div><div class="line">        //low指针从前向后遍历</div><div class="line">        for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">            if (i &gt; 0 &amp;&amp; arr[i] == arr[i - 1]) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            int lo = i + 1;</div><div class="line">            int hi = len - 1;</div><div class="line">            while (lo &lt; hi) &#123;</div><div class="line">                if ((arr[i] + arr[lo] + arr[hi]) == 0) &#123;</div><div class="line">                    long long aa = (long long)arr[i] * arr[i];</div><div class="line">                    long long bb = (long long)arr[lo] * arr[lo];</div><div class="line">                    long long cc = (long long)arr[hi] * arr[hi];</div><div class="line">                    long long aaa = aa + bb + cc;</div><div class="line">                    result += aaa;</div><div class="line">                    //略过相同元素</div><div class="line">                    while (lo + 1 &lt;= hi &amp;&amp; arr[lo + 1] == arr[lo]) &#123;</div><div class="line">                        lo++;</div><div class="line">                    &#125;</div><div class="line">                    while (hi - 1 &gt;= lo &amp;&amp; arr[hi - 1] == arr[hi]) &#123;</div><div class="line">                        hi--;</div><div class="line">                    &#125;</div><div class="line">                    lo++;</div><div class="line">                    hi--;</div><div class="line">                &#125;</div><div class="line">                else if ((arr[i] + arr[lo] + arr[hi]) &gt; 0) &#123;</div><div class="line">                    hi--;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    lo++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        output.push_back(result % 1000000007);</div><div class="line">        samplenum--;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line"> </div><div class="line">    for (int i = 0; i &lt; output.size(); i++)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; output[i] &lt;&lt; endl;</div><div class="line">    &#125;   </div><div class="line">    //system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[北邮ACM2017热身赛-D题]]></title>
      <url>/2017/04/04/%E5%8C%97%E9%82%AEACM2017-D%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://ooo.0o0.ooo/2017/04/04/58e35af64bb4e.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/04/04/58e35b082f8e5.png" alt=""> </p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个整数，将它分解成连续素数的和，求这样的分解方法数</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先利用素数筛打出素数表</p>
<p>然后</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">vector&lt;int&gt; primes;</div><div class="line">bool is_prime[1000006];</div><div class="line"></div><div class="line">//建立素数表和存储素数的vector</div><div class="line">void init_primes()</div><div class="line">&#123;</div><div class="line">    memset(is_prime,true, 1000005);</div><div class="line">    is_prime[0] = is_prime[1] = false;</div><div class="line">    for (int i = 2; i &lt;= 1000005; ++i)&#123;</div><div class="line">        if (is_prime[i])&#123;</div><div class="line">            primes.push_back(i);</div><div class="line">            for (int j = 2; j*i &lt;= 1000005; j++)&#123;</div><div class="line">                is_prime[i*j] = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main()&#123;</div><div class="line">    vector&lt;int&gt; output;</div><div class="line">    init_primes();</div><div class="line">    int primesnum = primes.size();</div><div class="line">    int n;</div><div class="line">    while (cin &gt;&gt; n)&#123;</div><div class="line">        //i是分解形式的首个素数，j是最后一个素数</div><div class="line">        int i = 0, j = 0, sum = 0, result = 0;</div><div class="line">        while(true)&#123;</div><div class="line">            while (sum &lt; n &amp;&amp; j &lt; primesnum)&#123;</div><div class="line">                sum += primes[j++];</div><div class="line">            &#125;</div><div class="line">            //加到最后一个素数了，和还是小于n，说明后面没有满足条件的分解方式了，跳出循环结束运算</div><div class="line">            if (sum &lt; n)&#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            else if (sum == n)&#123;</div><div class="line">                ++result;</div><div class="line">            &#125;</div><div class="line">            //i向后移</div><div class="line">            sum -= primes[i++];</div><div class="line">        &#125;</div><div class="line">        output.push_back(result);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    for (int i = 0; i &lt; output.size(); i++) &#123;</div><div class="line">        cout &lt;&lt; output[i] &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    //system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[准确率、召回率、F1、ROC、AUC]]></title>
      <url>/2017/04/04/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%87%86%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87%E3%80%81F1%E3%80%81ROC%E3%80%81AUC/</url>
      <content type="html"><![CDATA[<h2 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h2><p>对学习器的<strong>泛化性能</strong>进行评估<br>在预测任务中，给定样例集$D=\lbrace (x_1,y_1),(x_2,y_),…,(x_n,y_n)\rbrace$，其中$y_i$是$x_n$的真实标记,估计学习器的性能就是<strong>把预测的结果$f(x)$与实际值进行比较</strong></p>
<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p><strong>回归</strong>任务中常用的是“<strong>均方误差</strong>”：</p>
<script type="math/tex; mode=display">E(f,D) = \frac{m}{1}\sum_{i=1}^{m}(f(x_i)-y_i)^2</script><p>下面介绍<strong>分类任务中常用的度量指标</strong></p>
<h3 id="1-错误率与精度"><a href="#1-错误率与精度" class="headerlink" title="1. 错误率与精度"></a>1. 错误率与精度</h3><p><strong>错误率</strong>就是分类错误的样本数占样本总数的比例</p>
<script type="math/tex; mode=display">E(f,D)=\frac{m}{1}\sum_{i=1}^{m}(f(x_i) \neq y_i)^2</script><p><strong>精度</strong>就是$1-E$</p>
<h3 id="2-准确率、召回率和F1"><a href="#2-准确率、召回率和F1" class="headerlink" title="2. 准确率、召回率和F1"></a>2. 准确率、召回率和F1</h3><p>错误率和精度不能满足所有任务的需求<br>比如在web搜索中，我们经常会关心，<strong>检索出来的信息有多少是用户关心</strong>的，或者用户<strong>真正关心的数据中有多少被检索出来</strong>了，所以引入<strong>“准确率”和“召回率”</strong></p>
<p>分类据结果的混淆矩阵为<br><img src="https://ooo.0o0.ooo/2017/04/01/58dfad37d9823.png" alt=""> </p>
<p><strong>准确率</strong>和<strong>召回率</strong>定义为：</p>
<script type="math/tex; mode=display">P=\frac{TP}{TP+FP}</script><script type="math/tex; mode=display">r=\frac{TP}{TP+FN}</script><p><strong>准确率和召回率是一组矛盾的度量</strong>，一般准确率高时，召回率往往偏低；召回率高时，准确率往往偏低<br>如何理解二者之间的矛盾呢，我们依然沿用上面的例子，如果我们想尽可能多地返回<strong>用户关心的信息</strong>，就可以返回大量的信息，此时用户关心的结果可能都被选上了，但是也返回了大量用户不关心的信息，准确率较低；反之，如果我们希望返回的信息中心用户关心的比例比较高，就可以只返回那些有把握的信息，但这样就会漏掉不少可能也是用户关心的信息，也就是召回率比较低。</p>
<p>下图为P-R曲线，可以直观的反映准确率和召回率之间的矛盾，评估模型时，可以根据曲线下方面积进行模型比较，面积大者效果比较好<br><img src="https://ooo.0o0.ooo/2017/04/01/58dfaf3b77185.png" alt=""> </p>
<p>在实际应用时中，我们可以<strong>结合实际情况，权衡两个指标的重要程度</strong>，因此引入$F_{\beta}$指标：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfad605dae8.png" alt=""> </p>
<p>$\beta&gt;1$时准去率相对更重要，$\beta&lt;1$召回率相对更重要。当$\beta=1$时，就是我们常用的F1度量形式</p>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfaeb332ca9.png" alt=""> </p>
<h3 id="3-ROC、AUC"><a href="#3-ROC、AUC" class="headerlink" title="3. ROC、AUC"></a>3. ROC、AUC</h3><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p><strong>体现了“一般情况下”泛化性能的好坏</strong></p>
<p>很多机器学习器是为测试样本产生一个<strong>实值或概率预测</strong>，然后再设定一个<strong>阈值t</strong>，<strong>高于这个阈值就预测为正类</strong>，反之预测为负类。针对不同的任务，选取的阈值t也不一样，<strong>ROC体现了综合考虑学习器在不同任务下的“期望泛化能力”的好坏</strong></p>
<h4 id="ROC曲线"><a href="#ROC曲线" class="headerlink" title="ROC曲线"></a>ROC曲线</h4><p>先看看ROC曲线长什么样</p>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfb6ba0e55d.png" alt=""> </p>
<p>横轴：“<strong>假正例率（false positive rate）</strong>”——负样本预测成正类的比例</p>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfb64788070.png" alt=""> </p>
<p>纵轴：“<strong>真正例率（true positive rate）</strong>”——正样本预测成正类的比例</p>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfb6335754e.png" alt=""> </p>
<p>为了方便理解公式，再贴一下混淆矩阵</p>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfad37d9823.png" alt=""> </p>
<p>现在来解释一下ROC曲线：曲线上的每一点都是一个<strong>（TPR,FPR）点对</strong>，表示的是对于<strong>一个模型</strong>，<strong>选择一个阈值t作为分类的依据</strong>，得到的假正例率和真正例率构成的点对。</p>
<ul>
<li><p>(0,0)表示所有样本都预测成负类的情况</p>
</li>
<li><p>(1,1)表示所有样本都预测成正类的情况</p>
</li>
<li><p>(0,1)表示所有样本都预测正确的情况</p>
</li>
<li><p>虚线表示随机预测的情况</p>
</li>
</ul>
<h4 id="绘制ROC曲线"><a href="#绘制ROC曲线" class="headerlink" title="绘制ROC曲线"></a>绘制ROC曲线</h4><ul>
<li>给出20个测试样本</li>
<li>“class”为样本的真实属性</li>
<li>“score”是预测值，表示样本属于正样本的概率</li>
</ul>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfba441c81f.png" alt=""> </p>
<p><strong>步骤</strong>：</p>
<ul>
<li>从高到低依次选取“score”作为阈值，概率大于该阈值的预测成正类，反之预测成反类</li>
<li>每次选取一个不同的阈值会都会得到一个(FPR,TPR)点对，即ROC曲线上的一点。这样一来，我们一共得到了20组(FPR,TPR)点对，将它们画在ROC曲线的结果如下图：</li>
</ul>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfbb4601c4f.png" alt=""> </p>
<ul>
<li>当我们将阈值设置为1和0时，分别可以得到ROC曲线上的(0,0)和(1,1)两个点。<strong>将这些(FPR,TPR)对连接起来，就得到了ROC曲线</strong>。</li>
<li>当<strong>阈值的取值越多，ROC曲线越平滑</strong>。</li>
</ul>
<h4 id="AUC（area-under-ROC-curve）"><a href="#AUC（area-under-ROC-curve）" class="headerlink" title="AUC（area under ROC curve）"></a>AUC（area under ROC curve）</h4><ul>
<li>AUC的值就是处<strong>于ROC曲线下方部分面积的大小</strong></li>
<li>通常，AUC的值介于0.5到1.0之间，<strong>越接近1表示模型的泛化能力越好</strong></li>
<li><strong>较大的AUC代表了较好的performance</strong></li>
</ul>
<h4 id="AUC的计算方法"><a href="#AUC的计算方法" class="headerlink" title="AUC的计算方法"></a>AUC的计算方法</h4><p>形式化地看，AUC考虑的是<strong>样本预测的排序质量</strong>，也就是在M×N(M为正类样本的数目，N为负类样本的数目)个正负样本对中，有多少个组中的正样本的score大于负样本的score（正样本排在负样本前面）</p>
<ol>
<li>从误差方面入手，即由模型计算出来的分数，负样本比正样本高的概率。如果给定$m_+$个正例和$m_-$个负例，令$D_+$和$D_-$分别表是正、负例集合，则排序“损失”定义为</li>
</ol>
<p><img src="https://ooo.0o0.ooo/2017/04/04/58e349099c736.png" alt=""><br>即考虑每一对正、反例对，如果正例的预测值小于反例，则记一个罚分，如果相等，记0.5个罚分。对应于RUC曲线上半部分的面积，那么RUC曲线下半部分的面积：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/04/58e3497b012a6.png" alt=""> </p>
<ol>
<li>第二种方法实际上和上述方法是一样的，但是复杂度减小了。</li>
</ol>
<ul>
<li>首先对score从大到小排序</li>
<li>然后令最大score对应的sample 的rank为n，第二大score对应sample的rank为n-1，以此类推</li>
<li>然后把所有的正类样本的rank相加，再减去正类样本的score为最小的那M个值的情况。</li>
<li>得到的就是所有的样本中有多少对正类样本的score大于负类样本的score。</li>
<li>然后再除以M×N。即</li>
</ul>
<script type="math/tex; mode=display">AUC=\frac{(所有的正例位置相加)-M*(M+1)}{M*N}</script><p>另外，特别需要注意的是，再存在score相等的情况时，对相等score的样本，需要 赋予相同的rank(无论这个相等的score是出现在同类样本还是不同类的样本之间，都需要这样处理)。具体操作就是再把所有这些score相等的样本 的rank取平均。然后再使用上述公式。</p>
<h3 id="为什么使用ROC"><a href="#为什么使用ROC" class="headerlink" title="为什么使用ROC"></a>为什么使用ROC</h3><p>既然已经这么多评价标准，为什么还要使用ROC和AUC呢？因为ROC曲线有个很好的特性：<strong>当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变</strong>。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。下图是ROC曲线和Precision-Recall曲线的对比： </p>
<p><img src="https://ooo.0o0.ooo/2017/04/04/58e342f8b9196.png" alt=""> </p>
<p>在上图中，(a)和(c)为ROC曲线，(b)和(d)为Precision-Recall曲线。(a)和(b)展示的是分类其在原始测试集（正负样本分布平衡）的结果，(c)和(d)是将测试集中负样本的数量增加到原来的10倍后，分类器的结果。可以明显的看出，<strong>ROC曲线基本保持原貌</strong>，而Precision-Recall曲线则变化较大。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zybuluo.com/frank-shaw/note/152851" target="_blank" rel="external">评价分类器性能指标之AUC、ROC</a></p>
]]></content>
      
        <categories>
            
            <category> machine learning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[腾讯2017笔试——16进制]]></title>
      <url>/2017/04/04/%E8%85%BE%E8%AE%AF2017%E7%AC%94%E8%AF%95%E2%80%94%E2%80%9416%E8%BF%9B%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://ooo.0o0.ooo/2017/04/03/58e262eeb3a6e.png" alt=""> </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>关键点：</p>
<p><strong>运算时都用10进制运算</strong></p>
<ol>
<li><p><strong>16进制的输出</strong>，用cout&lt;&lt;hex&lt;&lt;“十进制表达”<br>c++可以表达十进制、八进制、十六进制，不能直接表达2进制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include&lt;iostream&gt;  </div><div class="line">using namespace std;  </div><div class="line">void main()  </div><div class="line">&#123;  </div><div class="line">    int a,b,c;  </div><div class="line">    a=10; //十进制  </div><div class="line">    b=010;//八进制  </div><div class="line">    c=0x10; //十六进制  </div><div class="line">    cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl;  </div><div class="line">    cout&lt;&lt;&quot;b=&quot;&lt;&lt;b&lt;&lt;endl;  </div><div class="line">    cout&lt;&lt;&quot;c=&quot;&lt;&lt;c&lt;&lt;endl;  </div><div class="line">    cout&lt;&lt;&quot;a(八进制)=&quot;&lt;&lt;oct&lt;&lt;a&lt;&lt;endl;  </div><div class="line">    cout&lt;&lt;&quot;a(十六进制)=&quot;&lt;&lt;hex&lt;&lt;a&lt;&lt;endl;  </div><div class="line">    cout&lt;&lt;&quot;a(重新变回十进制)=&quot;&lt;&lt;dec&lt;&lt;a&lt;&lt;endl;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>前导0的补齐</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">cout.fill(&apos;0&apos;);//设置填充字符</div><div class="line">cout.width(8);//设置宽度为8</div><div class="line">cout&lt;&lt;hex&lt;&lt;num;//输出16进制表示</div></pre></td></tr></table></figure>
</li>
<li><p><strong>空格、回车的输出条件</strong></p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include&quot;stdafx.h&quot;</div><div class="line">#include&lt;iostream&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int atr[26];//26个字母对应的10进制数字</div><div class="line">char charr[16];//存储16个字母</div><div class="line">FILE *fin;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    //26个字母的对应的10进制数字，97开始</div><div class="line">    for (int i = 0; i &lt; 26; i++) &#123;</div><div class="line">        atr[i] = 97 + i;</div><div class="line">    &#125;</div><div class="line">    fin = fopen(&quot;in.txt&quot;, &quot;r&quot;);</div><div class="line">    int i = 1;//记录偏移的次数</div><div class="line">    char ch;</div><div class="line">    int nums = 0;//记录读入的字母个数</div><div class="line">    while (fscanf(fin,&quot;%c&quot;, &amp;ch)!= EOF)</div><div class="line">    &#123;</div><div class="line">        charr[nums % 16] = ch;</div><div class="line">        if (nums % 16 == 0) &#123;//每格16个字母输出一次偏移量</div><div class="line">            cout.fill(&apos;0&apos;);//前面补0</div><div class="line">            cout.width(8);//补齐之后宽度为8</div><div class="line">            cout &lt;&lt;  hex&lt;&lt; 16 * i ;//hex为输出16进制表示</div><div class="line">            printf(&quot;  &quot;);//偏移量</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        //输出字母对应的十六进制数字表示</div><div class="line">        cout &lt;&lt;  hex &lt;&lt;atr[ch - &apos;a&apos;] &lt;&lt; &quot; &quot;;</div><div class="line">        if ((nums+1) % 8 == 0) &#123;</div><div class="line">            cout &lt;&lt; &quot; &quot;;//每隔8个多输出一个空格</div><div class="line">        &#125;</div><div class="line">        //输出16个字母构成的字母串</div><div class="line">        if ((nums + 1) % 16 == 0) &#123;</div><div class="line">            for (int j = 0; j &lt; 16; j++) &#123;</div><div class="line">                cout &lt;&lt; charr[j];</div><div class="line">            &#125;</div><div class="line">            cout &lt;&lt;endl;//输出回车</div><div class="line">        &#125;</div><div class="line">        nums++;</div><div class="line">    &#125;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[腾讯2017笔试——二叉排序树]]></title>
      <url>/2017/04/04/%E8%85%BE%E8%AE%AF2017%E7%AC%94%E8%AF%95%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://ooo.0o0.ooo/2017/04/03/58e250806556e.png" alt=""> </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>对于二叉排序树的任何一个节点，其<strong>左子树的元素都小于右子树的元素</strong></li>
<li><strong>满二叉排序树树</strong>，树的结构可以确定</li>
</ul>
<p>如果树的深度是$k$，满二叉树有$2^k-1$个元素，按从小到大的顺序排列为：$[a_1,a_2,…,a_{2^k-1}]$，则该满二叉树的结构如下：</p>
<ol>
<li>根节点的元素为$a_{\frac{2^k}{2}}$，$[a_1,a_2,…,a_{\frac{2^k}{2}-1}]$中的元素在根节点的左子树中，$[a_{\frac{2^k}{2}+1},…,a_{2^k-1}]$中的元素在根节点的右子树中</li>
<li>对左子树、右子树两个区间再分别做1中的操作，得到最终的二叉排序树</li>
</ol>
<p>给定三个节点，根据二叉排序树的性质，可以知道<strong>包含这三个节点的最小子树的根节点的值，一定在这三个节点值构成的区间$[min,max]$内</strong></p>
<p><img src="https://ooo.0o0.ooo/2017/04/03/58e260ca6dcb7.png" alt=""> </p>
<p>所以我们可以从上至下遍历二叉排序树</p>
<ol>
<li>如果根节点root值包含在三个节点值构成的最大区间内，则根节root点就是所求</li>
<li>如果根节点值小于min，则令右子树的根节点为root</li>
<li>如果根节点值大于min，则对左子树的根节点为root</li>
</ol>
<p>重复上述操作，直到找到一个节点值为$t$，$t\in[min,max]$，该节点即为所求</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include&quot;stdafx.h&quot;</div><div class="line">#include&lt;iostream&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">FILE *fin;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    fin = fopen(&quot;in.txt&quot;, &quot;r&quot;);</div><div class="line">    int k ,a,b,c;</div><div class="line">    int max, min;</div><div class="line">    fscanf(fin,&quot;%d&quot;, &amp;k);</div><div class="line">    fscanf(fin, &quot;%d&quot;, &amp;a);</div><div class="line">    fscanf(fin, &quot;%d&quot;, &amp;b);</div><div class="line">    fscanf(fin, &quot;%d&quot;, &amp;c);</div><div class="line">    //求三个节点值最大的max和最小的min</div><div class="line">    if (a &gt; b&amp;&amp;a &gt; c) &#123;</div><div class="line">        max = a;</div><div class="line">        if (b &gt; c) &#123;</div><div class="line">            min = c;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">            min = b;</div><div class="line">    &#125;</div><div class="line">    if (b &gt; c&amp;&amp;b &gt; a) &#123;</div><div class="line">        max = b;</div><div class="line">        if (a &gt; c) &#123;</div><div class="line">            min = c;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">            min = a;</div><div class="line">    &#125;</div><div class="line">    if (c &gt; b&amp;&amp;c &gt; a) &#123;</div><div class="line">        max = c;</div><div class="line">        if (b &gt; a) &#123;</div><div class="line">            min = a;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">            min = b;</div><div class="line">    &#125;</div><div class="line">    //搜索</div><div class="line">    int low = 0;</div><div class="line">    int high = pow(2, k);</div><div class="line">    while (true) &#123;</div><div class="line">        int root = (low+high) / 2;</div><div class="line">        if ((max - root)*(min - root) &lt; 0)&#123;</div><div class="line">            cout &lt;&lt; root;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            if (max &lt; root) &#123;</div><div class="line">                high = root;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                low = root;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> binary tree </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[c++ 取反运算符“~”]]></title>
      <url>/2017/04/04/c-%E5%8F%96%E5%8F%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E2%80%9C-%E2%80%9D/</url>
      <content type="html"><![CDATA[<h2 id="取反符"><a href="#取反符" class="headerlink" title="取反符"></a>取反符</h2><p>将<strong>二进制表示</strong>的数字中的<strong>0变为1, 1变为0</strong></p>
<p>但是需要注意的是c++中对int型进行取反操作时，将前面的<strong>前导0也进行了取反</strong>(int型变量为32bit)。</p>
<p>比如1的二进制表示是</p>
<p><strong>00000000 00000000 00000000 00000001</strong></p>
<p><strong>~(00000000 00000000 00000000 00000001) = 11111111 11111111 11111111 11111110</strong></p>
<h2 id="负数的二进制表示"><a href="#负数的二进制表示" class="headerlink" title="负数的二进制表示"></a>负数的二进制表示</h2><p><strong>负数的二进制表示 = 其绝对值的补码</strong></p>
<p><strong>原码</strong>：一个整数，按照绝对值大小转换成的<strong>二进制数</strong>，称为原码。</p>
<p>比如<strong>-3</strong>的原码是：</p>
<p><strong>00000000 00000000 00000000 00000011</strong></p>
<p><strong>反码</strong>：将二进制数<strong>按位取反</strong>，所得的新二进制数称为原二进制数的反码。</p>
<p><strong>-3</strong>的反码是：</p>
<p><strong>11111111 11111111 11111111 11111100</strong></p>
<p><strong>补码</strong>：<strong>反码加1</strong>称为补码。也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。</p>
<p>那么<strong>-3的补码</strong>，也就是<strong>-3的二进制表示</strong>为：</p>
<p><strong>11111111 11111111 11111111 11111100 + 1<br>= 11111111 11111111 11111111 11111101</strong></p>
<p>同理，整数-1在计算机中的二进制表示为：</p>
<p>1、先取1的原码：00000000 00000000 00000000 00000001</p>
<p>2、得反码：     11111111 11111111 11111111 11111110</p>
<p>3、得补码：     11111111 11111111 11111111 11111111</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>只有<strong>~(-1) = 0</strong></p>
<p><strong>其他整型数取反都是非0的</strong></p>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[c++ 中scanf（）函数返回值问题]]></title>
      <url>/2017/04/03/c-%E4%B8%ADscanf()%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>用c++做ACM的时候发现读入数据是一个很头疼的事情，用了各种cin、getline()，发现scanf()最方便，能够<strong>默认分割所有的空白字符</strong>(空格，回车和指标符都行)，然后只需要用外层的for循环来控制读入的个数和存储位置了<br>对于异常情况的处理，比如数据结束，数据格式错误等，就需要我们了解scanf()函数的返回值了</p>
<ol>
<li>首先scanf()函数有返回值且<strong>返回值是int型</strong></li>
<li><p>当scanf()函数按照指定格式正确接收变量时，返回<strong>正确接收变量的个数</strong></p>
</li>
<li><p>当scanf()函数<strong>没有接收到指定格式的变量时，返回值为0</strong></p>
</li>
<li>遇到错误或遇到<strong>end of file</strong>，返回值为<strong>EOF（-1）</strong></li>
</ol>
<p>比如：<br><strong>scanf(“%d%d”, &amp;x, &amp;y);</strong></p>
<ul>
<li>如果x和y都被成功读入，那么scanf的返回值就是2;</li>
<li>如果只有x被成功读入，返回值为1;</li>
<li>如果x和y都未被成功读入，返回值为0;</li>
<li>如果遇到错误或遇到end of file，返回值为EOF（-1）</li>
</ul>
<p>接下来看看结合实际的数据输入格式，到底怎么用</p>
<p><img src="https://ooo.0o0.ooo/2017/04/03/58e20d09f1252.png" alt=""> </p>
<p>现在要将形如上面的数据读入</p>
<ul>
<li>每组数据有两行</li>
<li>第一行的第一个数字告诉我们第二行会有多少个元素</li>
<li>读到输入结束为止</li>
</ul>
<p>上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#define MAX 1000</div><div class="line">FILE *fin;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int arr[MAX];</div><div class="line">    fin = fopen(&quot;in.txt&quot;, &quot;r&quot;);</div><div class="line">    int n,T;</div><div class="line">    while (fscanf(fin,&quot;%d%d&quot;, &amp;n,&amp;T)!= EOF)</div><div class="line">    &#123;</div><div class="line">        for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">            fscanf(fin,&quot;%d&quot;, &amp;arr[i]);</div><div class="line">        &#125;</div><div class="line">        //打印输出读入的数据</div><div class="line">        printf(&quot;%d %d\n&quot;, n, T);</div><div class="line">        for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">            printf(&quot;%d &quot;, arr[i]);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;\n&quot;);</div><div class="line">    &#125;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="https://ooo.0o0.ooo/2017/04/03/58e210cf2ef50.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[微软2017笔试2]]></title>
      <url>/2017/04/01/%E5%BE%AE%E8%BD%AF2017%E7%AC%94%E8%AF%952/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://ooo.0o0.ooo/2017/04/01/58df730ed6544.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/04/01/58df731d63cde.png" alt=""> </p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">const int N = 105;</div><div class="line">int n, m, k;</div><div class="line">int w[N][N];//距离矩阵</div><div class="line">int deep[N];//每层节点数</div><div class="line">int L[N];//叶子节点序号，从小到大，也是距离矩阵的表头</div><div class="line">int vis[N];</div><div class="line">int locfa[N];</div><div class="line">int mp[N][N];//节点标号矩阵</div><div class="line">int fa[N];//父亲节点</div><div class="line">int fur[N], dfur[N];</div><div class="line">bool Check(int x, int y)</div><div class="line">&#123;</div><div class="line">    if (x == y)return true;</div><div class="line">    return w[fur[x]][fur[y]] == 2 + dfur[x] + dfur[y];</div><div class="line">&#125;</div><div class="line">void Solve()</div><div class="line">&#123;</div><div class="line">    while (~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k))</div><div class="line">    &#123;</div><div class="line">        memset(w, -1, sizeof(w));</div><div class="line">        memset(vis, 0, sizeof(vis));</div><div class="line">        //存入每层节点数</div><div class="line">        for (int i = 1; i &lt;= m; i++)</div><div class="line">            scanf(&quot;%d&quot;, deep + i);</div><div class="line">        //读入每层节点标号</div><div class="line">        for (int i = 1; i &lt;= m; i++)</div><div class="line">            for (int j = 1; j &lt;= deep[i]; j++)</div><div class="line">                scanf(&quot;%d&quot;, &amp;mp[i][j]);</div><div class="line">        for (int i = 1; i &lt;= k; i++)</div><div class="line">        &#123;</div><div class="line">            scanf(&quot;%d&quot;, L + i);</div><div class="line">            fur[L[i]] = L[i];</div><div class="line">            dfur[L[i]] = 0;</div><div class="line">            vis[L[i]] = 1;</div><div class="line">        &#125;</div><div class="line">        //存入距离矩阵</div><div class="line">        for (int i = 1; i &lt;= k; i++)</div><div class="line">            for (int j = 1; j &lt;= k; j++)</div><div class="line">                scanf(&quot;%d&quot;, &amp;w[L[i]][L[j]]);</div><div class="line">        //每个节点的父亲设置为自己</div><div class="line">        for (int i = 1; i&lt;m; i++)</div><div class="line">        &#123;</div><div class="line">            for (int j = 1; j &lt;= deep[i]; j++)</div><div class="line">                if (!vis[mp[i][j]])</div><div class="line">                &#123;</div><div class="line">                    locfa[i] = j;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        for (int i = m; i&gt;1; i--)//i is now deep</div><div class="line">        &#123;</div><div class="line">            int st = 1, j = 1;</div><div class="line">            while (st &lt;= deep[i])</div><div class="line">            &#123;</div><div class="line">                while (j &lt;= deep[i])</div><div class="line">                &#123;</div><div class="line">                    if (Check(mp[i][st], mp[i][j]))</div><div class="line">                    &#123;</div><div class="line">                        fa[mp[i][j]] = mp[i - 1][locfa[i - 1]];</div><div class="line">                        j++;</div><div class="line">                    &#125;</div><div class="line">                    else break;</div><div class="line">                &#125;</div><div class="line">                fur[mp[i - 1][locfa[i - 1]]] = fur[mp[i][st]];</div><div class="line">                dfur[mp[i - 1][locfa[i - 1]]] = dfur[mp[i][st]] + 1;</div><div class="line">                st = j, locfa[i - 1]++;</div><div class="line">                while (vis[mp[i - 1][locfa[i - 1]]] == 1)locfa[i - 1]++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        for (int i = 1; i &lt;= n; i++)</div><div class="line">            printf(&quot;%d%c&quot;, fa[i], i == n ? &apos;\n&apos; : &apos; &apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</div><div class="line">    Solve();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先记下来吧，大神的代码，没看太懂==</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】344. Reverse String]]></title>
      <url>/2017/03/30/%E3%80%90leetcode%E3%80%91344-Reverse-String/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Write a function that takes a string as input and returns the string reversed.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Given s = &quot;hello&quot;, return &quot;olleh&quot;.</div></pre></td></tr></table></figure>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>字符串翻转</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><ol>
<li>反向遍历，输入到另一个string中，复杂度$O(n)$</li>
<li>看了tag中有two pointers,一个从前往后一个从后往前，交换数值，复杂度减少一半$O(n/2)$</li>
</ol>
<p><strong>算法复杂度：O(n)</strong></p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;//反向遍历输入另一个string</div><div class="line">public:</div><div class="line">    string reverseString(string s) &#123;</div><div class="line">        string result = &quot;&quot;;</div><div class="line">        int len = s.size();</div><div class="line">        for (int i = len - 1; i &gt;= 0; i--) &#123;</div><div class="line">            result += s[i];</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;//two pointer</div><div class="line">public:</div><div class="line">    string reverseString(string s) &#123;</div><div class="line">         for(auto iter = 0; iter &lt; s.size() / 2; ++iter)</div><div class="line">            swap(s[iter], s[s.size() - 1 - iter]);</div><div class="line">        return s;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/03/14/58c7f3bcc560d.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[北邮acm2017热身赛 Saber's Conjecture 素数筛]]></title>
      <url>/2017/03/29/ACM-Saber-s-Conjecture-%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>In a parallel universe, young Saber-chan does not have a humongous appetite, instead, she likes studying math in her spare time. This afternoon when Saber-chan is plunged in her study, she came across an interesting conjecture: for any even number n greater than or equal to 4, there exists at least one pair of prime numbers p1 and p2 such that n=p1+p2.</p>
<p>This conjecture is actually known as the Goldbach’s conjecture. It is has not been proved nor refused yet. However in this universe, there are more programmers than mathematicians, people tend to prove math findings by programs. As the King of Knights and King of Britain, Saber-chan orders you to write a program that reports the number of all the pairs of prime numbers satisfying the condition in the conjecture for a given even number.</p>
<p>A sequence of even numbers is given as input. Corresponding to each number, the program should output the number of pairs mentioned above. Notice that Saber-chan is interested in the number of essentially different pairs and therefore you should not count (p1,p2) and (p2,p1) separately as two different pairs.</p>
<h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>An integer is given in each input line. You may assume that each integer is even, and is greater than or equal to 4 and less than 215. The end of the input is indicated by a number 0.</p>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>Each output line should contain an integer number. No other characters should appear in the output.</p>
<h3 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h3><p><strong>input:</strong></p>
<p>6</p>
<p>10</p>
<p>12</p>
<p>0</p>
<p><strong>output:</strong></p>
<p>1</p>
<p>2</p>
<p>1</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个数$p$，$p=q_1+q_2$其中$q_1$和$q_2$都是素数，输出这样的$(q_1,q_2)$对数</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>step1：<br>利用素数筛，先枚举出一定范围内的素数</p>
<p>step2：<br>给定一个数p，遍历(2，p/2)中的素数t，如果p-t也是素数，则结果+1。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">//bool f[1024*32];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    //素数表</div><div class="line">    bool sushu[1024 * 32 + 1];</div><div class="line">    int n = 1024 * 32;</div><div class="line">    for (int i = 0; i &lt;= n; i++)</div><div class="line">        sushu[i] = true;</div><div class="line">    sushu[1] = false;</div><div class="line">    for (int i = 2; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        if (sushu[i] == true)</div><div class="line">        &#123;</div><div class="line">            for (int j = 2; j*i &lt;= n; j++)</div><div class="line">                sushu[i*j] = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    vector&lt;int&gt; result;</div><div class="line">    while(cin)&#123;</div><div class="line">        int aaa;</div><div class="line">        cin &gt;&gt; aaa;</div><div class="line">        if (aaa ==0)</div><div class="line">        &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        int sum = 0;</div><div class="line">        for (int i = 2; i &lt;= aaa / 2; i++) &#123;</div><div class="line">            if (sushu[i] == 1) &#123;</div><div class="line">                if (sushu[aaa - i] == 1) &#123;</div><div class="line">                    sum++;</div><div class="line">                &#125;</div><div class="line">            &#125;   </div><div class="line">        &#125;</div><div class="line">        result.push_back(sum);</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; result.size(); i++) &#123;</div><div class="line">        cout &lt;&lt; result[i] &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    //system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h2><p>关于一定范围内素数的枚举，有下面两种素数筛的方法</p>
<h3 id="1-普通筛选法—埃拉托斯特尼筛法"><a href="#1-普通筛选法—埃拉托斯特尼筛法" class="headerlink" title="1. 普通筛选法—埃拉托斯特尼筛法"></a>1. 普通筛选法—埃拉托斯特尼筛法</h3><p><strong>基本思想</strong>：素数的倍数一定不是素数</p>
<p><strong>步骤</strong>:</p>
<p>用一个长度为N+1的数组保存信息（0表示素数，1表示非素数），初始值都置为0（都默认为素数）</p>
<ol>
<li>从第一个素数2开始遍历，把2的倍数都标记为非素数（置为1）</li>
<li>然后向后遍历，找到2后面的下一个素数3，把3的倍数都标记为非素数（置为1）</li>
<li>继续向后遍历，找到素数k，对k进行同样的处理</li>
<li>直到最后，数组中依然为0的数即为素数。</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">bool sushu[1024 * 32 + 1];</div><div class="line">    int n = 1024 * 32;</div><div class="line">    for (int i = 0; i &lt;= n; i++)</div><div class="line">        sushu[i] = true;</div><div class="line">    sushu[1] = false;</div><div class="line">    for (int i = 2; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        if (sushu[i] == true)</div><div class="line">        &#123;</div><div class="line">            for (int j = 2; j*i &lt;= n; j++)</div><div class="line">                sushu[i*j] = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：$O(nlogn)$</p>
<h3 id="2-线性筛法—欧拉筛法"><a href="#2-线性筛法—欧拉筛法" class="headerlink" title="2. 线性筛法—欧拉筛法"></a>2. 线性筛法—欧拉筛法</h3><p><strong>基本思想</strong>：保证每个合数只会被它的<strong>最小质因数</strong>筛去，因此每个数只会被标记一次</p>
<p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#define MAXN 100005</div><div class="line">#define MAXL 1299710</div><div class="line">int prime[MAXN];//最小质因数</div><div class="line">int check[MAXL];//是否为素数</div><div class="line"></div><div class="line">int tot = 0;</div><div class="line">memset(check, 0, sizeof(check));</div><div class="line">for (int i = 2; i &lt; MAXL; ++i)</div><div class="line">&#123;</div><div class="line">  if (!check[i])</div><div class="line">  &#123;</div><div class="line">    prime[tot++] = i;</div><div class="line">  &#125;</div><div class="line">  for (int j = 0; j &lt; tot; ++j)</div><div class="line">  &#123;</div><div class="line">    if (i * prime[j] &gt; MAXL)</div><div class="line">    &#123;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">    check[i*prime[j]] = 1;</div><div class="line">    if (i % prime[j] == 0)</div><div class="line">    &#123;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：$O(n)$</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/grubbyskyer/p/3852421.html" target="_blank" rel="external">Grubbyskyer的博客——线性筛法求素数</a></p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[组合数求解]]></title>
      <url>/2017/03/29/%E7%BB%84%E5%90%88%E6%95%B0%E6%B1%82%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>转自<a href="https://www.oschina.net/code/snippet_203297_11313" target="_blank" rel="external">baoer1024的分享</a></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li>暴力求解，C(n,m)=n<em>(n-1)</em>…*(n-m+1)/m!，n&lt;=15 </li>
<li>打表，C(n,m)=C(n-1,m-1)+C(n-1,m)，n&lt;=10,000 </li>
<li>质因数分解，C(n,m)=n!/(m!*(n-m)!)，C(n,m)=p1a1-b1-c1p2a2-b2-c2…pkak-bk-ck,n&lt;=10,000,000 </li>
<li>Lucas定理，将m,n化为p进制,有:C(n,m)=C(n0,m0)*C(n1,m1)…(mod p)，算一个不是很大的C(n,m)%p,p为素数，化为线性同余方程,用扩展的欧几里德定理求解，n在int范围内，修改一下可以满足long long范围内。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>方案一：<br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Combination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10007</span>;</div><div class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=(n-m+<span class="number">1</span>); --i)</div><div class="line">        ans *= i;</div><div class="line">    <span class="keyword">while</span>(m)</div><div class="line">        ans /= m--;</div><div class="line">    <span class="keyword">return</span> ans % M;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>方案二：<br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10007</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>;</div><div class="line"><span class="keyword">int</span> C[MAXN+<span class="number">1</span>][MAXN+<span class="number">1</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=MAXN; ++i)</div><div class="line">    &#123;</div><div class="line">        C[<span class="number">0</span>][i] = <span class="number">0</span>;</div><div class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=MAXN; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=MAXN; ++j)</div><div class="line">        C[i][j] = (C[i<span class="number">-1</span>][j] + C[i<span class="number">-1</span>][j<span class="number">-1</span>]) % M;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Combination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> C[n][m];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方案三：<br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//用筛法生成素数</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span>;</div><div class="line"><span class="keyword">bool</span> arr[MAXN+<span class="number">1</span>] = &#123;<span class="literal">false</span>&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; produce_prim_number()</div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prim;</div><div class="line">    prim.push_back(<span class="number">2</span>);</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">3</span>; i*i&lt;=MAXN; i+=<span class="number">2</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(!arr[i])</div><div class="line">        &#123;</div><div class="line">            prim.push_back(i);</div><div class="line">            <span class="keyword">for</span>(j=i*i; j&lt;=MAXN; j+=i)</div><div class="line">            arr[j] = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i&lt;=MAXN)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(!arr[i])</div><div class="line">        prim.push_back(i);</div><div class="line">        i+=<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> prim;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//计算n!中素因子p的指数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> rec = p;</div><div class="line">    <span class="keyword">while</span>(x&gt;=rec)</div><div class="line">    &#123;</div><div class="line">        ans += x/rec;</div><div class="line">        rec *= p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//计算n的k次方对M取模，二分法</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> M)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(k)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            ans = (ans * n) % M;</div><div class="line">        &#125;</div><div class="line">        n = (n * n) % M;</div><div class="line">        k &gt;&gt;= <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//计算C(n,m)</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Combination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10007</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prim = produce_prim_number();</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> num;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prim.size() &amp;&amp; prim[i]&lt;=n; ++i)</div><div class="line">    &#123;</div><div class="line">        num = Cal(n, prim[i]) - Cal(m, prim[i]) - Cal(n-m, prim[i]);</div><div class="line">        ans = (ans * Pow(prim[i], num, M)) % M;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>方案四：<br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10007</span>;</div><div class="line"><span class="keyword">int</span> ff[M+<span class="number">5</span>];  <span class="comment">//打表，记录n!，避免重复计算</span></div><div class="line"> </div><div class="line"><span class="comment">//求最大公因数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> gcd(b,a%b);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//解线性同余方程，扩展欧几里德定理</span></div><div class="line"><span class="keyword">int</span> x,y;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Extended_gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">       x=<span class="number">1</span>;</div><div class="line">       y=<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">       Extended_gcd(b,a%b);</div><div class="line">       <span class="keyword">long</span> t=x;</div><div class="line">       x=y;</div><div class="line">       y=t-(a/b)*y;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//计算不大的C(n,m)</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(b&gt;a)</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    b=(ff[a-b]*ff[b])%M;</div><div class="line">    a=ff[a];</div><div class="line">    <span class="keyword">int</span> c=gcd(a,b);</div><div class="line">    a/=c;</div><div class="line">    b/=c;</div><div class="line">    Extended_gcd(b,M);</div><div class="line">    x=(x+M)%M;</div><div class="line">    x=(x*a)%M;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//Lucas定理</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Combination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> a,b;</div><div class="line">    <span class="keyword">while</span>(m||n)</div><div class="line">    &#123;</div><div class="line">             a=n%M;</div><div class="line">        b=m%M;</div><div class="line">        n/=M;</div><div class="line">        m/=M;</div><div class="line">        ans=(ans*C(a,b))%M;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i,m,n;</div><div class="line">    ff[<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=M;i++)  <span class="comment">//预计算n!</span></div><div class="line">    ff[i]=(ff[i<span class="number">-1</span>]*i)%M;</div><div class="line">     </div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n, &amp;m);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,func(n,m));</div><div class="line">     </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ1850 Code-动态规划]]></title>
      <url>/2017/03/29/POJ1850-Code-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Transmitting and memorizing information is a task that requires different coding systems for the best use of the available space. A well known system is that one where a number is associated to a character sequence. It is considered that the words are made only of small characters of the English alphabet a,b,c, …, z (26 characters). From all these words we consider only those whose letters are in lexigraphical order (each character is smaller than the next character). </p>
<p>The coding system works like this: </p>
<ul>
<li>The words are arranged in the increasing order of their length. </li>
<li>The words with the same length are arranged in lexicographical order (the order from the dictionary). </li>
<li>We codify these words by their numbering, starting with a, as follows: </li>
</ul>
<p>a - 1 </p>
<p>b - 2 </p>
<p>… </p>
<p>z - 26 </p>
<p>ab - 27 </p>
<p>… </p>
<p>az - 51 </p>
<p>bc - 52 </p>
<p>… </p>
<p>vwxyz - 83681 </p>
<p>… </p>
<p>Specify for a given word if it can be codified according to this coding system. For the affirmative case specify its code. </p>
<h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>The only line contains a word. There are some constraints: </p>
<ul>
<li>The word is maximum 10 letters length </li>
<li>The English alphabet has 26 characters. </li>
</ul>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>The output will contain the code of the given word, or 0 if the word can not be codified.</p>
<h3 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h3><p><strong>input</strong>: bf</p>
<p><strong>output</strong>: 55</p>
<h2 id="问题陈述"><a href="#问题陈述" class="headerlink" title="问题陈述"></a>问题陈述</h2><p>按照题目给出的例子，给出字母串表标号。</p>
<p>题目中给出的字母串中字母是“<strong>单调递增</strong>”的，也就是没有重复，后一个要大于前一个</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>所谓“标号”，就是某一个字母串<strong>前面的字母串个数+1</strong></p>
<p>问题转化为求字母串<strong>前面的字母串个数</strong></p>
<p>某一个字母串<strong>前面的字母串</strong>有三种情况:</p>
<ol>
<li><strong>长度小于</strong>该字母串</li>
<li>长度等于该字母串，<strong>首字母小于</strong>该字母串首字母</li>
<li>长度和首字母都与该字母串相等，但<strong>位置更靠前</strong></li>
</ol>
<p>因为后面的字母串对前面的字母串有<strong>包含</strong>的关系，所以考虑用<strong>动态规划</strong>来求解，那接下来的重点就是寻找状态转移方程了</p>
<p>用$dp[i][j]$表示长度为$i$首字母为$j$的字母串个数，那么$dp[i+1][j]=dp[i][j+1]+dp[i][j+2]+···+dp[i][‘z’-i]$</p>
<p>光看公式可能理解得不是很好，举个例子吧：<br>比如我们现在想求<strong>长度是5位</strong>，<strong>b打头</strong>的字母串的个数:</p>
<p>b _ _ _ _      ······$dp[5][b]$</p>
<p>那么考虑后面的四位，有下面的22种情况：</p>
<p>b ++c++ _ _ _  ······$dp[4][c]$</p>
<p>b ++d++ _ _ _  ······$dp[4][d]$</p>
<p>b ++e++ _ _ _  ······$dp[4][e]$</p>
<p>···</p>
<p>b ++w++ ++x++ ++y++ ++z++  ······$dp[4][w]$</p>
<p>把上面的22种情况相加，就可以得到长度为5，b打头的所有字母串个数$p[5][b]$</p>
<p>对于其中的$dp[4][j]$也应用上述的方法可以求解</p>
<p>有了上面的思路，就可以由最初的$dp[1][j]=1$逐步求出完整的$dp[i][j]$表了！</p>
<p>好开心是不是，下面算个题试试好不好用吧：</p>
<p>假如我们现在要求字母串“<strong>cefkq</strong>”的序号，也就是这个字母串前面有多少个。回头看那三种情况：</p>
<ol>
<li><strong>长度小于</strong>该字母串 —— 把所有的$dp[4][j]$，$dp[3][j]$，$dp[2][j]$，$dp[1][j]$加起来</li>
<li>长度等于该字母串，<strong>首字母小于</strong>该字母串首字母 —— $dp[5][a]$,$dp[5][b]$加起来</li>
<li>长度和首字母都与该字母串相等，但<strong>位置更靠前</strong> </li>
</ol>
<p>嗯，问题解决了一大部分了，现在就剩第三种情况了！！！！<br>再看一眼字母串“<strong>cefkq</strong>”</p>
<p>长度和首字母都相等，位置比它在前面，那就一位一位考虑呗</p>
<p>第二位是e，<br>c ++d++ _ _ _在它前面！所以又有$dp[4][d]$个在它前面的，加上！</p>
<p>第三位是f，ef中间没有其他字母了，继续往后看</p>
<p>第四位是k，fk中间还有g、h、i、j</p>
<p>c e ++g++ _ _  ······$dp[3][g]$</p>
<p>c e ++h++ _ _  ······$dp[3][h]$</p>
<p>c e ++i++ _ _  ······$dp[3][i]$</p>
<p>c e ++j++ _ _  ······$dp[3][j]$</p>
<p>统统加上！</p>
<p>······</p>
<p>再往后就跟前面一样了，不再赘述了</p>
<p>到这，问题解决了，上代码</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span>;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">string</span> str;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; str;</div><div class="line">    <span class="keyword">int</span> len = str.length();</div><div class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (len&gt;<span class="number">10</span>)&#123;</div><div class="line">        result= <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((str[<span class="number">0</span>]-<span class="string">'a'</span>)&lt;<span class="number">0</span> || (str[<span class="number">0</span>] - <span class="string">'a'</span>)&gt;<span class="number">25</span>)&#123;</div><div class="line">        result= <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//初始化dp表</span></div><div class="line">    <span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">26</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</div><div class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>-i; j++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; <span class="number">27</span>-i; k++) &#123;</div><div class="line">                dp[i][j] += dp[i<span class="number">-1</span>][k];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//dp表每一行总数，也就是长度为k的字母串总数</span></div><div class="line">    <span class="keyword">int</span> sum[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span> - i; j++) &#123;</div><div class="line">            sum[i] += dp[i][j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">int</span> temp = len<span class="number">-2</span>;</div><div class="line">    <span class="comment">//位数小于n的数的个数</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++)&#123;</div><div class="line">        result += sum[i];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//位数=n但首字母比n首字母小的个数</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str[<span class="number">0</span>]-<span class="string">'a'</span>; i++) &#123;</div><div class="line">        result += dp[len<span class="number">-1</span>][i];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//位数=n但中间字母比n小的个数</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">int</span> left = str[i<span class="number">-1</span>] - <span class="string">'a'</span>;</div><div class="line">        <span class="keyword">int</span> now = str[i] - <span class="string">'a'</span>;</div><div class="line">        <span class="keyword">if</span> (now&lt;<span class="number">0</span>|| now&gt;<span class="number">25</span>)&#123;</div><div class="line">            result =  <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (now &lt;= left)&#123;</div><div class="line">            result = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = left+<span class="number">1</span>; j &lt; now; j++)&#123;</div><div class="line">            result += dp[temp][j];</div><div class="line">        &#125;</div><div class="line">        temp--;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; result;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[test]]></title>
      <url>/2017/03/22/test/</url>
      <content type="html"><![CDATA[<p><code>count.py</code></p>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = a &amp; b;<span class="comment">//进位位置</span></div><div class="line">    <span class="keyword">int</span> result = a^b;</div><div class="line">    <span class="keyword">while</span> (c)</div><div class="line">    &#123;</div><div class="line">        c = c &lt;&lt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> t = c;</div><div class="line">        c = result &amp; c;</div><div class="line">        result = result ^ t;</div><div class="line">    &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">   public:</div><div class="line">       int getSum(int a, int b) &#123;</div><div class="line">       int c = a &amp; b;//进位位置</div><div class="line">       int result = a^b;</div><div class="line">       while (c)</div><div class="line">       &#123;</div><div class="line">           c = c &lt;&lt; 1;</div><div class="line">           int t = c;</div><div class="line">           c = result &amp; c;</div><div class="line">           result = result ^ t;</div><div class="line">       &#125;</div><div class="line">           return result;</div><div class="line">       &#125;</div><div class="line">   &#125;;</div></pre></td></tr></table></figure>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo下Markdown与MathJax冲突问题]]></title>
      <url>/2017/03/22/Hexo%E4%B8%8BMarkdown%E4%B8%8EMathJax%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>用markdown写博客，mathjax解析数学公式，二者对于一些符号会发生冲突，到时公式无法正确解析：</p>
<ul>
<li><code>_</code>的转义，在markdown中，<code>_</code>是斜体，但是在latex中，是下标测意思，会出现冲突</li>
<li><code>\\</code>的换行，在markdown中，<code>\\</code>会被转义为<code>\</code>,这样也会影响影响mathjax对公式中的<code>\\</code>进行渲染</li>
<li><code>*</code>的转义，在markdown中，<code>*</code> 是加粗</li>
</ul>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>hexo默认使用<code>marked.js</code>去解析我们写的markdown，比如一些符号，<code>_</code>代表斜体，会被处理为<code>&lt;em&gt;</code>标签，<br>比如<code>x_i</code>在开始被渲染的时候，处理为<code>x&lt;em&gt;i&lt;/em&gt;</code>，这个时候mathjax就无法渲染成下标了。<br>很多符号都有这个问题，比如粗体<code>*</code>,也是无法在mathjax渲染出来的，好在有替代的乘法等,包括<code>\</code>同理。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li><p>更换Hexo的markdown渲染引擎</p>
<p><a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="external">hexo-renderer-kramed</a>引擎是在默认的渲染引擎<a href="https://github.com/hexojs/hexo-renderer-marked" target="_blank" rel="external">hexo-renderer-marked</a>的基础上修改了一些bug，两者比较接近，也比较轻量级。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm uninstall hexo-renderer-marked --save</div><div class="line">npm install hexo-renderer-kramed --save</div></pre></td></tr></table></figure>
</li>
<li><p>修改Hexo渲染源码</p>
</li>
</ol>
<p>找到<code>blog/node_modules\kramed\lib\rules\inline.js</code>文件</p>
<ol>
<li>修改<code>\</code>转义</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">escape: /^\\([\\`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</div><div class="line">改为：</div><div class="line">escape: /^\\([`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</div></pre></td></tr></table></figure>
<ol>
<li><p>修改<code>_</code>转义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</div><div class="line">改为：</div><div class="line">em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</div></pre></td></tr></table></figure>
</li>
<li><p>重新启动hexo（先clean再generate）,问题完美解决。哦，如果不幸还没解决的话，看看是不是还需要在使用的主题中配置mathjax开关。</p>
</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://segmentfault.com/a/1190000007261752" target="_blank" rel="external">Hexo下mathjax的转义问题</a></p>
<p><a href="http://blog.csdn.net/emptyset110/article/details/50123231" target="_blank" rel="external">使Marked.js与MathJax共存</a></p>
]]></content>
      
        <categories>
            
            <category> blog config </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[FFM（field-aware Factorization Machine）——升级版FM]]></title>
      <url>/2017/03/22/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91FFM%EF%BC%88field-aware-Factorization-Machine%EF%BC%89%E2%80%94%E2%80%94%E5%8D%87%E7%BA%A7%E7%89%88FM/</url>
      <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote>
<p>FFM（Field-aware Factorization Machine）最初的概念来自Yu-Chin Juan（阮毓钦，毕业于中国台湾大学，现在美国Criteo工作）与其比赛队员，是他们借鉴了来自<a href="https://kaggle2.blob.core.windows.net/competitions/kddcup2012/2748/media/Opera.pdf" target="_blank" rel="external">Michael Jahrer的论文</a>中的field概念提出了<strong>FM的升级版</strong>模型</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h4><p>对于给定的数据我们进行训练，进而对测试集进行预测，首先我们想到利用<strong>线性模型</strong>进行拟合（也就是一维特征）：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/21/58d0e965ec210.png" alt=""> </p>
<p>进一步，我们考虑加入<strong>二维组合特征</strong>进行拟合：</p>
<h4 id="FM"><a href="#FM" class="headerlink" title="FM"></a>FM</h4><p><img src="https://ooo.0o0.ooo/2017/03/21/58d0e99b2f719.png" alt=""> </p>
<p>也就是<strong>FM</strong>中的交叉特征（二次项），采用<strong>矩阵分解</strong>得到如下形式：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/21/58d0e9cb62988.png" alt=""> </p>
<p>其中$w_{j_1}$和$w_{j_2}$分别为特征$j_1$和$j_1$对应的<strong>隐向量</strong>，对应下图中左边两个矩阵的一行或一列即是一个隐向量。</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c6aa26b83c6.png" alt=""> </p>
<h4 id="FFM"><a href="#FFM" class="headerlink" title="FFM"></a>FFM</h4><p>现在在FM的基础之上，我们<strong>引入field-aware的概念</strong>，可以推得<strong>FFM的二次项形式</strong>如下：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/21/58d0e9fe74136.png" alt=""> </p>
<p>其中$w_{j_1,f_{j_2}}$为<strong>特征$j_1$针对$j_2$所在的类别$f_{j_2}$的隐向量</strong></p>
<p>$w_{j_2,f_{j_1}}$为<strong>特征$j_2$针对$j_1$所在的类别$f_{j_1}$的隐向量</strong></p>
<p>FFM完整的模型方程为</p>
<p><img src="https://ooo.0o0.ooo/2017/03/21/58d1361058228.png" alt=""> </p>
<p>为了便于理解，先看下面的例子</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Clicked?</th>
<th style="text-align:center">Country</th>
<th style="text-align:center">Day</th>
<th style="text-align:center">Ad_type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">USA</td>
<td style="text-align:center">26/11/15</td>
<td style="text-align:center">Movie</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">China</td>
<td style="text-align:center">1/7/14</td>
<td style="text-align:center">Game</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Clicked?</th>
<th style="text-align:center">Country=USA</th>
<th style="text-align:center">Country=China</th>
<th style="text-align:center">Day=26/11/15</th>
<th style="text-align:center">Day=1/7/14</th>
<th style="text-align:center">Day=19/2/15</th>
<th style="text-align:center">Ad_type=Movie</th>
<th style="text-align:center">Ad_type=Game</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>我们对原始数据进行One-Hot编码生成数值特征，这时引入field的概念，把同一个categorical特征经过One-Hot编码生成的数值特征都放到同一个field中。比如：“Day=26/11/15”、“Day=1/7/14”、“Day=19/2/15”这三个特征是由“日期”这一categorical特征生成的，可以放到同一个field中。这时我们再计算隐向量的时候，<strong>隐向量不仅与特征相关，还与field相关</strong>。每一维特征$x_i$针对其它特征的每一种field<br>$f_j$，都会学习一个隐向量 $w_{i,f_j}$。</p>
<p>假设样本的n个特征属于 f 个field，那么FFM的二次项有  nf 个隐向量，如果隐向量的长度为 k ，那么FFM的二次参数有 nfk 个。而在FM模型中，每一维特征的隐向量只有一个<strong>，FM可以看作FFM的特例，是把所有特征都归属到一个field时的FFM模型</strong>。此外，由于隐向量与field相关，FFM二次项并不能够化简，其预测<strong>复杂度是 $O(kn^2)$。</strong></p>
<h3 id="FFM实现"><a href="#FFM实现" class="headerlink" title="FFM实现"></a>FFM实现</h3><p>Yu-Chin Juan实现了一个C++版的FFM模型，源码可从Github下载<a href="https://github.com/guestwalk/libffm" target="_blank" rel="external">https://github.com/guestwalk/libffm</a></p>
<p>该<strong>FFM模型采用logistic loss作为损失函数，和L2惩罚项</strong>，因此只能用于<strong>二元分类</strong>问题。</p>
<p><img src="https://ooo.0o0.ooo/2017/03/21/58d13b9c6f3d1.png" alt=""> </p>
<p>模型<strong>采用SGD进行优化</strong>。</p>
<hr>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://ooo.0o0.ooo/2017/03/21/58d13cd0e100e.png" alt=""> </p>
<p>这条记录可以编码成5个特征，其中“Genre=Comedy”和“Genre=Drama”属于同一个field，“Price”是数值型，不用One-Hot编码转换。<br>利用线性模型进行拟合：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/21/58d13d13d9ec3.png" alt=""> </p>
<p>二维组合特征拟合：<br><img src="https://ooo.0o0.ooo/2017/03/21/58d13d21ddd24.png" alt=""> </p>
<p>FM（隐向量）拟合：<br><img src="https://ooo.0o0.ooo/2017/03/21/58d13d2db61d3.png" alt=""> </p>
<p>FFM拟合：</p>
<p>为了方便说明FFM的样本格式，我们将所有的特征和对应的field映射成整数编号。</p>
<p><img src="https://ooo.0o0.ooo/2017/03/21/58d13cf17aac5.png" alt="">  </p>
<p>FFM的组合特征有10项，如下图所示<br><img src="https://ooo.0o0.ooo/2017/03/21/58d1401cb9e37.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> machine learning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> FFM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】371. Sum of Two Integers]]></title>
      <url>/2017/03/18/%E3%80%90leetcode%E3%80%91371-Sum-of-Two-Integers/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<p>Example:<br>Given a = 1 and b = 2, return 3.</p>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>求两个整数和，不能用加法</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><p>想到了转化成2进制再求和</p>
<ol>
<li>异或（^）操作：<br>1^0 = 0^1 = 1，0^0 = 1^1 = 0，先求出<strong>不考虑进位</strong>情况下的各位数字相加的运算结果d</li>
<li>和（&amp;）操作：<br>1^1 = 1，1^0 = 0^1 = 0^0 = 0，然后求出两个数字对应位置都是1的位，也就是需要进位的位置c。</li>
<li>左移操作（&lt;&lt;）：c&lt;&lt;1，前两步操由于没有进位而漏加的部分</li>
<li>对c和d重复进行上述操作，直到c为0，即没有由于需要进位而漏加的部分。</li>
</ol>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int getSum(int a, int b) &#123;</div><div class="line">    int c = a &amp; b;//进位位置</div><div class="line">    int result = a^b;</div><div class="line">    while (c)</div><div class="line">    &#123;</div><div class="line">        c = c &lt;&lt; 1;</div><div class="line">        int t = c;</div><div class="line">        c = result &amp; c;</div><div class="line">        result = result ^ t;</div><div class="line">    &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/03/18/58cccdf37f8b3.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bit manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【LeetCode】283. Move Zeros]]></title>
      <url>/2017/03/18/%E3%80%90LeetCode%E3%80%91283-Move-Zeros/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
<p>Note:<br>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>把给定数组中的0全部挪到后边，保持其余数字顺序不变</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><p>遍历，把非零元素从前向后赋值给原数组，剩余空位补0。</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int len = nums.size();</div><div class="line">        int j = 0;//赋值指针</div><div class="line">        for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">            if (nums[i] != 0) &#123;</div><div class="line">                nums[j] = nums[i];</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            else continue;</div><div class="line">        &#125;</div><div class="line">        for (; j &lt; len; j++) &#123;//将后面剩余的空位用0补齐</div><div class="line">            nums[j] = 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/03/18/58ccc96ac194d.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【LeetCode】104. Maximum Depth of Binary Tree]]></title>
      <url>/2017/03/17/%E3%80%90LeetCode%E3%80%91104-Maximum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>求二叉树的深度</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><ol>
<li>广度优先遍历：利用STL中的queue（队列）进行广度优先遍历，计算层数</li>
<li>深度优先遍历：递归调用，当前节点的高度=max（左孩子节点高度，右孩子结点高度）+ 1</li>
</ol>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxDepth(TreeNode* root) &#123;//BFS广度优先遍历</div><div class="line">        if (NULL == root)</div><div class="line">            return 0;</div><div class="line">        queue &lt;TreeNode *&gt; que;</div><div class="line">        int nCount = 1;</div><div class="line">        int nDepth = 0;// 记树中每一层上的元素个数</div><div class="line"> </div><div class="line">         que.push(root);</div><div class="line">         while(!que.empty()) &#123;</div><div class="line">             TreeNode *pTemp = que.front();</div><div class="line">             que.pop();</div><div class="line">             nCount --; </div><div class="line">             if (pTemp-&gt;left)</div><div class="line">                 que.push(pTemp-&gt;left);</div><div class="line">             if (pTemp-&gt;right)</div><div class="line">                 que.push(pTemp-&gt;right);</div><div class="line">             </div><div class="line">             if (nCount == 0) &#123;</div><div class="line">                 nDepth ++;</div><div class="line">                 nCount = que.size();</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     return nDepth;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;//DFS深度优先遍历</div><div class="line">public:</div><div class="line">    int maxDepth(TreeNode* root) &#123;</div><div class="line">       if (!root) return 0;</div><div class="line"></div><div class="line">    int ldepth = maxDepth(root-&gt;left);</div><div class="line">    int rdepth = maxDepth(root-&gt;right);</div><div class="line"></div><div class="line">    return 1 + max(ldepth, rdepth);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/03/17/58cb4b776120e.png" alt=""> </p>
<p><img src="https://ooo.0o0.ooo/2017/03/17/58cb4bb9dc6ec.png" alt=""> </p>
<hr>
<p><strong>二叉树的各种遍历以及时间复杂度还要看一下算法导论，看了再来总结</strong></p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[交叉熵]]></title>
      <url>/2017/03/16/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E7%86%B5%E3%80%81%E4%BA%A4%E5%8F%89%E7%86%B5/</url>
      <content type="html"><![CDATA[<h3 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h3><p><strong>衡量随机变量X的不确定性</strong>，熵越大表示随机变量的不确定性越大，即混乱程度越大，等概率分布时，熵最大，为1。</p>
<p>随机变量$X$可能的取值$X=\lbrace x_1,x_2,\cdots,x_n \rbrace$，对应的概率为$p(X=x_i)(i=1,2,\cdots,n)$，随机变量$X$的熵定义为</p>
<p>$H(X) = -{\sum_{i}^{n}{p(x_i)\log{p(x_i)}}}$</p>
<h3 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h3><p>对一随机事件，其真实概率分布为<script type="math/tex">p(i)</script>，从数据中得到的概率分布为<script type="math/tex">q(i)</script>，则我们定义，交叉熵为：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-07-20-56-44.png" alt=""> </p>
<h3 id="相对熵"><a href="#相对熵" class="headerlink" title="相对熵"></a>相对熵</h3><p><strong>又称KL散度，描述两个随机分布间距离的度量</strong></p>
<p>$D(p||q)=H(p,q)-H(p)=\sum_{i}^{} p(i)*log\frac{p(i)}{q(i)}$，</p>
<p>它表示2个函数或概率分布的差异性：差异越大则相对熵越大，差异越小则相对熵越小，特别地，若2者相同则熵为0。注意，KL散度的非对称性。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>交叉熵可在神经网络(机器学习)中作为损失函数，p表示真实标记的分布，q则为训练后的模型的预测标记分布，交叉熵损失函数可以衡量p与q的相似性。交叉熵作为损失函数还有一个好处是使用sigmoid函数在梯度下降时能避免均方误差损失函数学习速率降低的问题，因为学习速率可以被输出的误差所控制。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-07-20-57-30.png" alt=""> </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p> <a href="https://wizyoung.github.io/%E4%BF%A1%E6%81%AF%E7%86%B5%EF%BC%8C%E7%9B%B8%E5%AF%B9%E7%86%B5%EF%BC%8C%E4%BA%A4%E5%8F%89%E7%86%B5%E7%9A%84%E7%90%86%E8%A7%A3/" target="_blank" rel="external">信息熵，相对熵，交叉熵的理解</a></p>
<p><a href="https://www.zhihu.com/question/41252833" target="_blank" rel="external">知乎：如何通俗的解释交叉熵与相对熵</a></p>
]]></content>
      
        <categories>
            
            <category> machine learning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】136. Single Number]]></title>
      <url>/2017/03/15/%E3%80%90leetcode%E3%80%91136-Single-Number/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>输入序列中，每个数字重复出现2次，唯有一个数字只出现一次，找到这个只出现一次的数字</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><ol>
<li>hash_table：遍历输入数组，如果hashtable中没有，说明是第一次出现，存到hash table中，如果发现hashtable中已经有了说明是第二次出现，z在hash表中将其删掉，最终hash table中剩下的就是只出现一次的那个数字</li>
<li>bit manipulation：数组中所有数字做异或操作，出现两次的异或之后得0了，最终剩下的就是只出现一次的那个数字。</li>
</ol>
<p><strong>算法复杂度：O(n)</strong><br>2比1要快一点,因为1还涉及hash table的查找、插入、删除等操作</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;//hash_table</div><div class="line">public:</div><div class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int len = nums.size();</div><div class="line">        unordered_set&lt;int&gt; numset;</div><div class="line">    </div><div class="line">        for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">            if (numset.find(nums[i]) == numset.end()) &#123;//没找到，加入</div><div class="line">                numset.insert(nums[i]);</div><div class="line">            &#125;</div><div class="line">            else//找到了，删除</div><div class="line">            &#123;</div><div class="line">                numset.erase(nums[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        unordered_set&lt;int&gt;::iterator iter = numset.begin();</div><div class="line">        return *iter;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;//逐位异或</div><div class="line">public:</div><div class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">            int len = nums.size();</div><div class="line">    int result = 0;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">        result ^= nums[i];</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/03/15/58c8d54eb147c.png" alt=""> </p>
<p><img src="https://ooo.0o0.ooo/2017/03/15/58c8cf948fa31.png" alt=""> </p>
<hr>
<h3 id="c-STL中list-vector-map-hashmap-的对比"><a href="#c-STL中list-vector-map-hashmap-的对比" class="headerlink" title="c++ STL中list vector map hashmap 的对比"></a>c++ STL中list vector map hashmap 的对比</h3><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>特点：<strong>支持快速的插入和删除，但查找费时。</strong></p>
<p>结构：<strong>线性双向链表</strong>，它的数据由若干个节点构成，每一个节点都包括一个信息块（即实际存储的数据）、一个前驱指针和一个后驱指针。它<strong>无需分配指定的内存大小</strong>且可以<strong>任意伸缩</strong>，这是因为它存储在<strong>非连续的内存</strong>空间中，并且由指针将有序的元素链接起来。查找元素时需要从头一个一个的<strong>顺序查找</strong>，这样目标元素越靠后，它的检索时间就越长。但是它可以迅速地在任何节点进行插入和删除操作。因为list 的每个节点保存着它在链表中的位置，插入或删除一个元素仅对最多三个元素有所影响，不像vector 会对操作点之后的所有元素的存储地址都有所影响，这一点是vector 不可比拟的。</p>
<h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>特点：<strong>支持快速的查找，时间复杂度是$O(\log n)$，但是插入费时。</strong></p>
<p>结构：存诸结构是<strong>完全二叉检索树</strong>，支持快速的查找，但是vector每当<strong>增加元素</strong>的时候，都需要重新<strong>申请</strong>新的更大的<strong>内存空间</strong>，会调用元素的自身的复制构造函数，存在构造成本。在销毁旧内存的时候，会调用析构函数，存在析构成本。</p>
<h4 id="map、set"><a href="#map、set" class="headerlink" title="map、set"></a>map、set</h4><p>特点：<strong>支持快速的查找，时间复杂度是$O(\log n)$，但是插入费时。</strong></p>
<p>结构：map内部自建一颗<strong>红黑树</strong>(一种非严格意义上的平衡二叉树)，这颗树具有对数据<strong>自动排序</strong>的功能，所以在map内部所有的数据都是<strong>有序</strong>的，根据key值快速查找记录，查找的复杂度基本是$O(\log n)$，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次。</p>
<h4 id="hash-map，hash-set"><a href="#hash-map，hash-set" class="headerlink" title="hash_map，hash_set"></a>hash_map，hash_set</h4><p>特点：<strong>数据的快速存储和查找，几乎可以看成是常数时间$O(1)$，但是会消耗比较多的内存</strong><br>结构：基于hash table（哈希表）。 使用一个下标范围比较大的<strong>数组</strong>来存储元素。可以设计一个<strong>函数</strong>（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素。</p>
<p>其插入过程是：<br>得到key<br>通过hash函数得到hash值<br>得到桶号(一般都为hash值对桶数求模)<br>存放key和value在桶内。</p>
<p>其取值过程是:<br>得到key<br>通过hash函数得到hash值<br>得到桶号(一般都为hash值对桶数求模)<br>比较桶的内部元素是否与key相等，若都不相等，则没有找到。<br>取出相等的记录的value。</p>
<p>c++ 中没有hash_map、hash_set标准容器，可以自己定义，重点是做好hash函数的防碰撞。刷题的时候用了STL中的<strong>unordered_set</strong>,也是基于hashtable的</p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bit manipulation </tag>
            
            <tag> hash table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Factorization Machine（FM，因子分解机）]]></title>
      <url>/2017/03/14/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91FM%EF%BC%8C%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3%E6%9C%BA/</url>
      <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote>
<p>Steffen Rendle于2012年提出FM模型，旨在解决<strong>稀疏矩阵</strong>下的<strong>特征组合</strong>问题。传统机器学习问题，一般仅考虑如何对特征赋予权重，而没有考虑<strong>特征间存在相互作用</strong>，FM模型的提出较好地解决了该问题。</p>
</blockquote>
<h3 id="相比于SVM的优势"><a href="#相比于SVM的优势" class="headerlink" title="相比于SVM的优势"></a>相比于SVM的优势</h3><ol>
<li>对于<strong>稀疏数据</strong>有更强的学习能力</li>
<li><strong>线性时间复杂度</strong>，不依赖于支撑向量</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li>回归问题</li>
<li>二分类问题</li>
<li>排序</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="传统线性回归模型"><a href="#传统线性回归模型" class="headerlink" title="传统线性回归模型"></a>传统线性回归模型</h4><p>我们用广告的CTR（点击率）预估问题引出FM模型：根据用户和广告位等相关特征，预测用户是否点击广告。源数据如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Clicked?</th>
<th style="text-align:center">Country</th>
<th style="text-align:center">Day</th>
<th style="text-align:center">Ad_type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">USA</td>
<td style="text-align:center">26/11/15</td>
<td style="text-align:center">Movie</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">China</td>
<td style="text-align:center">1/7/14</td>
<td style="text-align:center">Game</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">China</td>
<td style="text-align:center">19/2/15</td>
<td style="text-align:center">Game</td>
</tr>
</tbody>
</table>
</div>
<p>由于三种特征Country、Day、Ad_type都是categorical类型的，进行ctr预估的时候往往需要经过独热编码（One-Hot Encoding）转换成数值型特征。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Clicked?</th>
<th style="text-align:center">Country=USA</th>
<th style="text-align:center">Country=China</th>
<th style="text-align:center">Day=26/11/15</th>
<th style="text-align:center">Day=1/7/14</th>
<th style="text-align:center">Day=19/2/15</th>
<th style="text-align:center">Ad_type=Movie</th>
<th style="text-align:center">Ad_type=Game</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>再利用<strong>传统的线性回归模型</strong>：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c68f490519b.png" alt=""> </p>
<p>根据训练集训练出模型的参数，进行预测。</p>
<p><strong>该方法存在的问题：</strong></p>
<ul>
<li>经过One-Hot编码之后，大部分样本数据特征是比较稀疏的，上面的样例中，每个样本有7维特征，但平均仅有3维特征具有非零值。而且在实际情况中，one-hot编码后的特征空间维度很大。</li>
<li>更重要的是，通过One-Hot编码方式输入到传统线性模型中进行训练，各特征分量$x_i$和$x_j$是相互独立的，但在实际应用中，通过观察大量的样本数据可以发现，某些特征经过关联之后，与label之间的相关性就会提高。例如，“USA”与“Thanksgiving”、“China”与“Chinese New Year”这样的关联特征，对用户的点击就极有可能有着正向的影响。</li>
</ul>
<h4 id="FM模型"><a href="#FM模型" class="headerlink" title="FM模型"></a>FM模型</h4><p>由于上述问题，所以引入两个（设置多个）<strong>特征之间的组合</strong>十分有意义：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c6943ecf1aa.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/03/13/58c694663d2ce.png" alt=""> </p>
<p>前半部分就是传统的<strong>线性模型</strong>，后半部分引入<strong>两个特征之间的关联特征</strong>。</p>
<p>从上面公式可以看出，组合特征的参数一共有<strong>n(n−1)/2</strong>个， 任意两个参数都是独立的。但是二次项参数训练很<strong>困难</strong>，因为：<strong>数据稀疏性普遍存在</strong>于实际应用场景中，而每个参数$w_{ij}$的训练需要大量 $x_i$和 $x_j$ 都非零的样本，训练样本的不足，很容易导致参数 $x_i$ 和$x_j$训练 不准确，最终将严重影响模型的性能。</p>
<p>那么，如何解决二次项参数的训练问题呢？<strong>矩阵分解</strong>提供了一种解决思路。<br>参考在model-based的协同过滤中的做法：一个rating矩阵可以分解为user矩阵和item矩阵，每个user和item都可以采用一个隐向量表示</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c6aa26b83c6.png" alt=""> </p>
<p>FM模型中二次项系数构成的矩阵是对称正定的，故可以用上面的分解方式<strong>分解成两个低维的矩阵相乘</strong>，即$W={V^T}V$，从而解决数据稀疏导致训练不准确的问题。<strong>至此，FM模型可以化为如下形式</strong>：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c6ab23c0775.png" alt=""> </p>
<p>总结起来一句话就是：<strong>FM引入二维组合特征，然后利用矩阵分解降维减少了训练参数，从而能够适应数据的稀疏性</strong>。<br>具体解释参考<a href="http://tech.meituan.com/deep-understanding-of-ffm-principles-and-practices.html" target="_blank" rel="external">美团技术团队关于FM的介绍</a>需要的时候可以细看</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c6ad4950dc3.png" alt=""> </p>
<hr>
<h3 id="FM模型复杂度"><a href="#FM模型复杂度" class="headerlink" title="FM模型复杂度"></a>FM模型复杂度</h3><h4 id="求解复杂度"><a href="#求解复杂度" class="headerlink" title="求解复杂度"></a>求解复杂度</h4><p>模型参数已经训练出来，将新的数据输入模型求解：<br><img src="https://ooo.0o0.ooo/2017/03/13/58c6943ecf1aa.png" alt=""> </p>
<p>时间复杂度为<strong>$O(kn^2)$</strong></p>
<p>但是如果我们依据公式$ab+ac+bc+\cdots=\frac{(a+b+c+\cdots)^2-(a^2+b^2+c^2+\cdots)}{2}$化简交叉项，具体过程如下：<br><img src="https://ooo.0o0.ooo/2017/03/14/58c758f677ff9.png" alt=""> </p>
<p>此时时间复杂度简化为<strong>$O(kn)$</strong>。由此可见，FM可以在<strong>线性时间</strong>对新样本作出预测。</p>
<h4 id="模型训练复杂度"><a href="#模型训练复杂度" class="headerlink" title="模型训练复杂度"></a>模型训练复杂度</h4><ul>
<li><strong>多元统计回归问题</strong></li>
<li>训练方法：<strong>SGD（随机梯度下降法）</strong><br>记FM模型参数为$\Theta={(w_0,w_1,w_2,\cdots,w_n,v_11,v_12,\cdots,v_nk)}^T$，共有$1+n+kn$个参数，模型各个参数的梯度如下：</li>
</ul>
<p><img src="https://ooo.0o0.ooo/2017/03/14/58c79e8acccee.png" alt=""> </p>
<p><img src="https://ooo.0o0.ooo/2017/03/14/58c7a443cf54c.png" alt=""> </p>
<p>详细推导过程参考<a href="http://blog.csdn.net/itplus/article/details/40536025" target="_blank" rel="external">peghoty的博客</a></p>
<p><strong>时间复杂度为$O(kn)$</strong></p>
<h3 id="开源代码库"><a href="#开源代码库" class="headerlink" title="开源代码库"></a>开源代码库</h3><p>libFM</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://my.oschina.net/keyven/blog/648747" target="_blank" rel="external">因子分解机Factorization Machine</a></p>
<p><a href="http://tech.meituan.com/deep-understanding-of-ffm-principles-and-practices.html" target="_blank" rel="external">深入FFM原理与实践</a></p>
<p><a href="http://blog.csdn.net/itplus/article/details/40536025" target="_blank" rel="external">peghoty的博客：FM学习算法</a></p>
]]></content>
      
        <categories>
            
            <category> machine learning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】412. Fizz Buzz]]></title>
      <url>/2017/03/13/%E3%80%90leetcode%E3%80%91412-Fizz-Buzz/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Write a program that outputs the string representation of numbers from 1 to n.</p>
<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">n = 15,</div><div class="line"></div><div class="line">Return:</div><div class="line">[</div><div class="line">    &quot;1&quot;,</div><div class="line">    &quot;2&quot;,</div><div class="line">    &quot;Fizz&quot;,</div><div class="line">    &quot;4&quot;,</div><div class="line">    &quot;Buzz&quot;,</div><div class="line">    &quot;Fizz&quot;,</div><div class="line">    &quot;7&quot;,</div><div class="line">    &quot;8&quot;,</div><div class="line">    &quot;Fizz&quot;,</div><div class="line">    &quot;Buzz&quot;,</div><div class="line">    &quot;11&quot;,</div><div class="line">    &quot;Fizz&quot;,</div><div class="line">    &quot;13&quot;,</div><div class="line">    &quot;14&quot;,</div><div class="line">    &quot;FizzBuzz&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>太简单啦，略</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><p>遍历赋值，逢15、3、5的倍数赋值“FizzBuzz”，“Fizz”，“Buzz”，其余赋值为自然数顺序数</p>
<p><strong>算法复杂度：O(n)</strong></p>
<p>这里需要注意的是vector的push_back()函数复杂度为O(n)，但是按下标随机访问的时间复杂度为O(1)，所以用下标访问再赋值会比较快</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;string&gt; fizzBuzz(int n) &#123;</div><div class="line">        vector&lt;string&gt; result(n);</div><div class="line">       for (int i = 1; i &lt;= n; ++i) &#123;</div><div class="line">        if (i % 15 == 0) &#123;</div><div class="line">            result[i-1] = &quot;FizzBuzz&quot;;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            if (i % 5 == 0) &#123;</div><div class="line">                result[i-1] = &quot;Buzz&quot;;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                if (i % 3 == 0) &#123;</div><div class="line">                    result[i-1] = &quot;Fizz&quot;;</div><div class="line">                &#125;</div><div class="line">                else</div><div class="line">                &#123;</div><div class="line">                    result[i-1] = to_string(i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/03/13/58c6813fdde1d.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】53. Maximum Subarray]]></title>
      <url>/2017/03/13/%E3%80%90leetcode%E3%80%9153-Maximum-Subarray/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example：</p>
<p>given the array [-2,1,-3,4,-1,2,1,-5,4],<br>the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>求一个数组的最大连续子数组，连续和最大的子数组</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><ol>
<li>遍历，复杂度O(n^2)</li>
<li>分治法，《算法导论》第四章讲过</li>
</ol>
<p>把数组看作A[low..high]，利用分治策略，将数组划分为两个规模尽量相等的子数组，找到数组的中央位置，A[mid]，然后考虑求解两个子数组A[low..mid]和A[mid+1..high]。那么子数组A[i..j]所有的情况共有以下三种：<br><img src="https://ooo.0o0.ooo/2017/03/13/58c661380c603.png" alt=""> </p>
<p>那么我们可以递归的求解A[low..mid]和A[mid+1..high]的最大子数组，因为这两个子问题仍是最大数组问题，只是规模更小。因此剩下的工作就是寻找跨越中点的最大子数组，然后在三者中选取最大者。</p>
<p><strong>算法复杂度：O(nlogn)</strong></p>
<ol>
<li>动态规划</li>
</ol>
<p>当从头遍历数组元素时，对于数组中的任何一个整数有以下两种选择： </p>
<p><strong>加入之前的subArray；自己另起一个新的subArray</strong></p>
<ul>
<li>当之前subArray 的总和大于 0 时，我们认为 其对后续结果是有贡献的，这种情况下，我们选择加入之前的subArray </li>
<li>当之前subArray 的总和小于等于0时，我们认为其对后续结果是没有贡献的，这种情况下，我们选择以当前数字开始，另起一个subArray</li>
</ul>
<p>设状态f(j) 表示 以 nums[j] 为结尾的最大连续子序列的和，则状态转移方程如下：<br><img src="https://ooo.0o0.ooo/2017/03/13/58c66196a6c84.png" alt=""> </p>
<p><strong>时间复杂度O(n)</strong></p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//分治法</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        return findMaxSubArray(nums,0,nums.size()-1);</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    int maxArrayAcrossMid(vector&lt;int&gt;&amp; numsIn, int low, int high) &#123;//求跨越中点的最大子数组数字和</div><div class="line">    int len = (high - low) / 2;</div><div class="line">    int mid = (high + low) / 2;</div><div class="line">    int maxnum = numsIn[mid];</div><div class="line">    int maxnumtemp = numsIn[mid];</div><div class="line">    for (int i = mid - 1; i &gt;= low; i--) &#123;//计算左边最大子数组</div><div class="line">        maxnumtemp += numsIn[i];</div><div class="line">        if (maxnumtemp &gt; maxnum)</div><div class="line">            maxnum = maxnumtemp;</div><div class="line">    &#125;</div><div class="line">    maxnumtemp = maxnum;</div><div class="line">    for (int i = mid + 1; i &lt;= high; i++) &#123;//计算右边最大子数组</div><div class="line">        maxnumtemp += numsIn[i];</div><div class="line">        if (maxnumtemp &gt; maxnum)</div><div class="line">            maxnum = maxnumtemp;</div><div class="line">    &#125;</div><div class="line">    return maxnum;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int findMaxSubArray(vector&lt;int&gt;&amp; nums, int low, int high) &#123;//递归调用求解最大子数组</div><div class="line">    int mid = (low + high) / 2;</div><div class="line">    int maxSum = nums[mid];</div><div class="line">    int acrossmid = 0;</div><div class="line">    int leftmax = 0;</div><div class="line">    int rightmax = 0;</div><div class="line">    if (low == high) &#123;</div><div class="line">        return maxSum;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        acrossmid = maxArrayAcrossMid(nums, low, high);</div><div class="line">        leftmax = findMaxSubArray(nums, low, mid);</div><div class="line">        rightmax = findMaxSubArray(nums, mid + 1, high);</div><div class="line">    &#125;</div><div class="line">    if (acrossmid &gt;= leftmax &amp;&amp; acrossmid &gt;= rightmax) return acrossmid;</div><div class="line">    if (leftmax &gt;= acrossmid &amp;&amp; leftmax &gt;= rightmax) return leftmax;</div><div class="line">    else return rightmax;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">//动态规划</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">            int maxnum = nums[0];</div><div class="line">    int numtemp = nums[0];</div><div class="line">    for (int i = 1; i &lt; nums.size(); i++) &#123;</div><div class="line">        if (numtemp &lt; 0) numtemp = 0;</div><div class="line">        numtemp += nums[i];</div><div class="line">        if (numtemp &gt; maxnum) &#123;</div><div class="line">            maxnum = numtemp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">        return maxnum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/03/13/58c65b79609f7.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Divide and Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GIS]]></title>
      <url>/2017/03/07/GIS/</url>
      <content type="html"><![CDATA[<h2 id="OpenStreetMap"><a href="#OpenStreetMap" class="headerlink" title="OpenStreetMap"></a>OpenStreetMap</h2><p> 开放街道图（OpenStreetMap，简称OSM）是一个网上地图协作计划，目标是创造一个内容自由且能让所有人编辑的世界地图,其osm数据开源，可以自由下载使用。<a href="https://www.openstreetmap.org/" target="_blank" rel="external">https://www.openstreetmap.org/</a></p>
<p><a href="http://download.bbbike.org/osm/bbbike/Beijing/" target="_blank" rel="external">北京osm数据beijing.osm</a><br><a href="http://download.geofabrik.de/asia/china.html" target="_blank" rel="external">中国osm数据china.osm</a></p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>地图数据开源，人人可以编辑，并且可以完整的下载，部署私有的地图服务器</li>
<li>内容丰富，比起ESRI Shapefiles的点、面、线，支持更多复杂的元素</li>
<li>生态圈活跃，从地图数据、数据库、地图渲染、瓦片服务器、前端API，到桌面、Web地图设计工具，具有大量优秀的开源组件</li>
</ul>
<h3 id="osm数据结构"><a href="#osm数据结构" class="headerlink" title="osm数据结构"></a>osm数据结构</h3><p>OpenStreetMap包括空间数据以及属性数据。其中空间数据主要包括三种：点（Nodes）、路（Ways）和关系（Relations），这三种原始构成了整个地图画面。其中，Nodes定义了空间中点的位置；Ways定义了线或区域；Relations（可选的）定义了元素间的关系。</p>
<ol>
<li><strong>Node</strong> 通过经纬度定义了一个地理坐标点。同时，还可以height=<em>标示物体所海拔；通过layer=</em> 和 level=<em>，可以标示物体所在的地图层面与所在建筑物内的层数；通过place=</em> and name=*来表示对象的名称。同时，way也是通过多个点（node）连接成线（面）来构成的。</li>
<li><strong>Way</strong><br>通过2-2000个点（nodes）构成了way。way可表示如下3种图形事物（非闭合线（Open polyline ）、闭合线（Closed polyline）、区域（Area ））。对于超过2000 nodes的way，可以通过分割来处理。<ul>
<li>Open polyline<br>非闭合线：收尾不闭合的线段。通常可用于表示现实中的道路、河流、铁路等。</li>
<li>Closed polyline<br>闭合线：收尾相连的线。例如可以表示现实中的环线地铁。</li>
<li>Area<br>区域：闭合区域。通常使用landuse=* 来标示区域等。 </li>
</ul>
</li>
<li><strong>Relation</strong><br>一个Relation是用来描述两个或多个基元的相互关系（nodes, ways 或者其他的relations），相互的关系通过role来定义，包括：<ul>
<li>route ：定义公路、自行车道、铁路等</li>
<li>多个多边形：定义area例如建筑、河堤等</li>
<li>边界：装门用来定义行政边界</li>
<li>限制：用于描述限制比如“非左转”</li>
</ul>
</li>
<li><strong>Tag </strong><br>标签不是地图基本元素，但是各元素都通过tag来记录数据信息。通过’key’ and a ‘value’来对数据进行记录。例如，可以通过highway=residential来定义居住区道路；同时，可以使用附加的命名空间来添加附加信息，例如：maxspeed:winter=*就表示冬天的最高限速。</li>
</ol>
<h3 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h3><p>GeoFabrik：<a href="http://www.geofabrik.de/" target="_blank" rel="external">http://www.geofabrik.de/</a></p>
<p>Metro Extracts：<a href="http://metro.teczno.com/" target="_blank" rel="external">http://metro.teczno.com/</a></p>
<p>HOT Exports：<a href="http://hot.openstreetmap.org/" target="_blank" rel="external">http://hot.openstreetmap.org/</a></p>
<p>BBBike：<a href="http://extract.bbbike.org/" target="_blank" rel="external">http://extract.bbbike.org/</a></p>
<hr>
<h3 id="GIS体系结构"><a href="#GIS体系结构" class="headerlink" title="GIS体系结构"></a>GIS体系结构</h3><p><img src="https://ooo.0o0.ooo/2017/03/06/58bccd74c1230.png" alt=""> </p>
<blockquote>
<ul>
<li>客户端 - 这里所说的客户端是多样化的，可以是 Web 客户端，移动设备或者是通过 HTTP 连接到 Internet 服务或连接到 GIS Server 的桌面应用程序。</li>
<li>Web 服务器 – Web 服务器包含 Web 应用的部署，以及 Web 服务，它们均使用 GIS Server 上的服务资源。</li>
<li>GIS 服务器 – GIS 服务器主要是提供了地理信息可视化、空间数据管理及分析等一系列服务</li>
<li>GIS 渲染引擎– GIS 渲染引擎能够将地图相关数据可视化，并且提供给用户可交互的平台。</li>
<li>空间数据存储库 – 空间数据存储库可以是不同的数据形式，包括空间数据库、矢量数据文件和光栅数据文件。</li>
</ul>
</blockquote>
<h2 id="系统搭建"><a href="#系统搭建" class="headerlink" title="系统搭建"></a>系统搭建</h2><p>系统环境 Windows10 64bit</p>
<h3 id="所需工具"><a href="#所需工具" class="headerlink" title="所需工具"></a>所需工具</h3><ul>
<li><p><strong>postgresql+postGIS</strong>——Postgresql是一种对象关系型数据库，具备地理信息处理扩展，从而可实现对地理信息的存储；postgis是一个空间数据库，它扩展自Postgresql对象关系型数据库，它添加了地理信息对象通过本地的SQL查询。因为在安装Postgresql是可以选择下载安装postgis所以它是可选的</p>
</li>
<li><p><strong>QGIS</strong>——</p>
</li>
<li><strong>Mapserver</strong></li>
<li><strong>OpenLayers</strong></li>
<li><strong>osm2pgsql</strong>——是由OpenStreetMap开发的一个命令行工具负责将OSM数据导入到基于PostgresSql的Postgis的数据库中，这样GeoServer才能调用数据发布服务器。其次我们还要指定osm2pgsql的gitHub地址因为我们需要的两个文件在里面可以找到一个是900913.sql一个是default.style。</li>
</ul>
<p>以上安装包直接官网下载最新版即可</p>
<h3 id="搭建方法"><a href="#搭建方法" class="headerlink" title="搭建方法"></a>搭建方法</h3><ol>
<li>postgresql+postGIS安装</li>
</ol>
<p>官网下载postgresql，按照提示一步一步安装即可，快结束的时候勾选stack builder，然后用stack builder安装postGIS插件<br>这部分很顺利，不再详细讲述，请直接参考教程：<a href="https://xucheng7112.github.io/2017/02/21/Postgresql+Geoserver%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1%E5%99%A8(%E4%B8%80" target="_blank" rel="external">Postgresql+Geoserver搭建本地地图服务器(一)</a>/)</p>
<p>需要<strong>重点注意</strong>是<br>安装完成后，为了在命令中使用方便我们把Postgresql的bin目录添加到环境变量中，win10很方便，直接搜索框搜索环境变量，把目标目录添加进PATH就行了。<br>此时在开始菜单打开pgAdmin就可以进入到装好的Postgresql数据库管理工具了，可以<strong>在管理界面创建自己的数据库</strong>（create database）。</p>
<ol>
<li>利用Osm2pgsql导入osm数据到postgresql</li>
</ol>
<p>安装好数据库软件，建立了自己的数据库，接下来需要将下载下来的osm数据导入数据库了，由于postgresql数据库不能直接导入osm数据，因此我们需要利用openstreetmap开发的工具Osm2pgsql完成数据导入。安装教程仍参考<a href="https://xucheng7112.github.io/2017/02/21/Postgresql+Geoserver%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1%E5%99%A8(%E4%B8%80" target="_blank" rel="external">Postgresql+Geoserver搭建本地地图服务器(一)</a>/)</p>
<p>不过这里并没有那么顺利，遇到了两个问题，记下来</p>
<ol>
<li>第四步添加EPSG: 900913支持时，github上找不到相应的900913文件，后来终于在<strong>历史版本</strong>中找到了该文件<a href="https://github.com/openstreetmap/osm2pgsql/tree/0.90.x" target="_blank" rel="external">900913.sql所在github目录</a></li>
<li>第五步：添加OSM数据到数据库 osm2pgsql -U postgres -d osm -s -S ./default.style ./shanghai.osm时提示no password supplied 无法连接到数据库。</li>
</ol>
<p>参考了博客<a href="http://blog.csdn.net/hyj_13/article/details/45130017" target="_blank" rel="external">PostgreSQL+PostGIS+OpenStreeMap+GeoServer环境搭建</a>给出的解决办法：在C:\Users\asus\AppData\Roaming\postgresql路径下有一个pgpass.conf文件，每个用户在登陆postgres并且保存密码后都会在该用户目录下保存一个pgpass.conf 文件，里面有该用户的密码按照如下格式进行设置：hostname:port:database:username:password<br>例如：localhost:5432:osm:postgres:123456</p>
<p>在搜索栏输入“%AppData%”回车进入文件夹，但是发现Roaming文件夹下并<strong>没有postgresql以及下面的pgpass.conf</strong>，查了很久，最后直接在AppData\Roaming文件夹下<strong>自己建postgresql\pgpass.conf</strong>按上面的方法配置好久可以了</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-gis-dev/" target="_blank" rel="external">利用 OpenScales+MapServer+PostGIS 快速构建GIS应用</a></p>
<p><a href="https://xucheng7112.github.io/2017/02/21/Postgresql+Geoserver%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1%E5%99%A8(%E4%B8%80" target="_blank" rel="external">Postgresql+Geoserver搭建本地地图服务器(一)</a>/)</p>
<p><a href="https://yq.aliyun.com/articles/16907" target="_blank" rel="external">利用OpenStreetMap（OSM）数据搭建一个地图服务</a></p>
<p><a href="http://blog.csdn.net/hyj_13/article/details/45130017" target="_blank" rel="external">PostgreSQL+PostGIS+OpenStreeMap+GeoServer环境搭建</a></p>
<p><a href="http://blog.csdn.net/scy411082514/article/category/1130386" target="_blank" rel="external">Mr.An 的专栏</a></p>
<p><a href="http://blog.csdn.net/hyj_13" target="_blank" rel="external">黄大仙儿的专栏</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】500. Keyboard Row]]></title>
      <url>/2017/03/07/leetcode500-Keyboard-Row/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below.</p>
<p><img src="https://ooo.0o0.ooo/2017/03/07/58be531ade5c7.png" alt=""> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Example 1:</div><div class="line">Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</div><div class="line">Output: [&quot;Alaska&quot;, &quot;Dad&quot;]</div></pre></td></tr></table></figure>
<p>Note:</p>
<ol>
<li>You may use one character in the keyboard more than once.</li>
<li>You may assume the input string will only contain letters of alphabet.</li>
</ol>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>输入一组单词，用vector容器封装，判断每个单词的所有字母是否在键盘的同一行，如果在同一行，留在vector中，否则移除，最后输出vector</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>建立键盘三行的大小写字母表</li>
<li>遍历vector内的单词</li>
<li>对于每一个单词先确定首字母所在行号，再依次查看后面的字母是否跟首字母在同一行，一旦不一致，立刻从vector中删除该单词</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><ol>
<li>一开始上手打算用字符数组存放键盘表，折腾了好久发现一个严重的问题：数组作为参数传递时，传递的是<strong>指针</strong>，这时候再用sizeof()来求数组的长度实际上求得的是<strong>指针的长度</strong>，而非数组长度，所以数组作为传递参数时需要将其长度也作为一个参数传递，后续运算时才不会出错，所以改用string存储每一行字母。</li>
<li>vector中用earse()删除元素时，返回值为：指向被删除元素的下一个元素的iterator，外层如果用for循环iter++,容易出现越界情况,所以采用了while循环</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) &#123;</div><div class="line">        string str1 = &quot;qwertyuiopQWERTYUIOP&quot;;</div><div class="line">        string str2 = &quot;asdfghjklASDFGHJKL&quot;;</div><div class="line">        string str3 = &quot;zxcvbnmZXCVBNM&quot;;</div><div class="line">        vector&lt;string&gt;::iterator it = words.begin();</div><div class="line">        int logo = 0;</div><div class="line">        while (it != words.end())</div><div class="line">        &#123;</div><div class="line">            int linenum = 0;</div><div class="line">            int linenumt = 0;</div><div class="line">            string word = *it;</div><div class="line">            if (word.length() == 1) &#123;</div><div class="line">                it++;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                int wordlen = word.size();</div><div class="line">            char shouzimu = word[0];</div><div class="line">            string::size_type idx = str1.find(shouzimu);</div><div class="line">            if (idx != string::npos)</div><div class="line">                linenum = 1;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                string::size_type idx = str2.find(shouzimu);</div><div class="line">                if (idx != string::npos)</div><div class="line">                    linenum = 2;</div><div class="line">                else</div><div class="line">                &#123;</div><div class="line">                    string::size_type idx = str3.find(shouzimu);</div><div class="line">                    if (idx != string::npos)</div><div class="line">                        linenum = 3;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            //判断剩余字母是否跟首字母处于同一行</div><div class="line">            for (int i = 1; i &lt; wordlen; i++) &#123;</div><div class="line">                char zimu = word[i];</div><div class="line">                string::size_type idx = str1.find(zimu);</div><div class="line">                if (idx != string::npos)</div><div class="line">                    linenumt = 1;</div><div class="line">                else</div><div class="line">                &#123;</div><div class="line">                    string::size_type idx = str2.find(zimu);</div><div class="line">                    if (idx != string::npos)</div><div class="line">                        linenumt = 2;</div><div class="line">                    else</div><div class="line">                    &#123;</div><div class="line">                        string::size_type idx = str3.find(zimu);</div><div class="line">                        if (idx != string::npos)</div><div class="line">                            linenumt = 3;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (linenumt != linenum) &#123;</div><div class="line">                    it = words.erase(it);//删除当前元素，返回值：指向下一个元素的iter</div><div class="line">                    logo = 1;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    logo = 0;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (logo == 0)</div><div class="line">            &#123;</div><div class="line">                it++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        return words;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>用STL中的unordered_set采用hash表的存储方式，查找时间复杂度最优可达常数，但尝试后并没有实质上的改变，可能是因为数据量不够大，没有凸显出来他的优势。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) &#123;</div><div class="line">    </div><div class="line">        unordered_set&lt;char&gt; row1 &#123;&apos;q&apos;, &apos;w&apos;, &apos;e&apos;, &apos;r&apos;, &apos;t&apos;, &apos;y&apos;,&apos;u&apos;, &apos;i&apos;, &apos;o&apos;, &apos;p&apos;&#125;;</div><div class="line">        unordered_set&lt;char&gt; row2 &#123;&apos;a&apos;, &apos;s&apos;, &apos;d&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;&#125;; </div><div class="line">        unordered_set&lt;char&gt; row3 &#123; &apos;z&apos;, &apos;x&apos;, &apos;c&apos;, &apos;v&apos;, &apos;b&apos; ,&apos;n&apos;, &apos;m&apos;&#125;;</div><div class="line">        vector&lt;unordered_set&lt;char&gt;&gt; rows &#123;row1, row2, row3&#125;;</div><div class="line">        </div><div class="line">        vector&lt;string&gt; validWords;</div><div class="line">        for(int i=0; i&lt;words.size(); ++i)&#123;</div><div class="line">            int row=0;</div><div class="line">            </div><div class="line">            for(int k=0; k&lt;3; ++k)&#123;</div><div class="line">                if(rows[k].count((char)tolower(words[i][0])) &gt; 0) row = k;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            validWords.push_back(words[i]);</div><div class="line">            for(int j=1; j&lt;words[i].size(); ++j)&#123;</div><div class="line">                if(rows[row].count((char)tolower(words[i][j])) == 0)&#123;</div><div class="line">                    validWords.pop_back();</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        return validWords;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>上面两种方法<br> <img src="https://ooo.0o0.ooo/2017/03/07/58be58bb2d36d.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hash table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】476 number complement]]></title>
      <url>/2017/03/05/leetcode476-number-complement/</url>
      <content type="html"><![CDATA[<p>刷题第二天，好巧哦又是一道bit manipulation的</p>
<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>
<p>Note:<br>The given integer is guaranteed to fit within the range of a 32-bit signed integer.<br>You could assume no leading zero bit in the integer’s binary representation.<br>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: 5</div><div class="line">Output: 2</div><div class="line">Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</div></pre></td></tr></table></figure>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: 1</div><div class="line">Output: 0</div><div class="line">Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0.</div></pre></td></tr></table></figure></p>
<p>The above arrows point to positions where the corresponding bits are different.<br>Subscribe to see which companies asked this question.</p>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>就是要将一个整数的二进制表示做取反操作，输出取反后的十进制表示。</p>
<p>需要注意的是二进制表示前面的0，比如5的二进制表示是00000101，如果直接取反得到的是11111010，而我们所要求的是不含前面的占位0的取反十进制表示，也就是(00000)010。</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><ol>
<li>首先要求出来输入的整形数字二进制表示的位数n，也就是不含前导0的二进制表达的位数（如5的二进制表达是101，就是三位）</li>
<li>然后将输入数字与n个1做异或操作，就相当于取反了</li>
</ol>
<p>例：<br>int = 5， 二进制表达为  00000101，位数为3，与00000111做异或运算得到00000010</p>
<p>第2步很好求，知道了位数n之后，${2^n}-1$就是末位为n个1的十进制表示</p>
<p>关键是第1步求十进制表示所占的位数，最开始我尝试了用数学的方式来求解，但是费尽周折仍有bug，于是乎上网搜了搜，发现可以用向右移位判断是否为0的方法，记录下移动的位数，就是十进制表示所占位数，哎，我怎么就没想到</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int findComplement(int num) &#123;</div><div class="line">        int numm = num;</div><div class="line">        int bitnum = 0;</div><div class="line">        while (num) &#123;</div><div class="line">            bitnum++;</div><div class="line">            num = num &gt;&gt; 1;</div><div class="line">        &#125;</div><div class="line">        int sec = pow(2, bitnum)-1;</div><div class="line">        int a = numm^sec; </div><div class="line">        return a;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><p><img src="https://ooo.0o0.ooo/2017/03/05/58bbc628a6a75.png" alt=""> </p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>对于二进制的运算以及位操作符还是不够熟练，不能做到手到擒来，看来这个表要牢记在心<br><img src="https://ooo.0o0.ooo/2017/03/05/58bbc6f6a6428.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bit manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[决策树（三）：多变量决策树]]></title>
      <url>/2017/03/05/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%A4%9A%E5%8F%98%E9%87%8F%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>前面讲到的都是<strong>单变量决策树</strong>，即<strong>每次只选取一个属性</strong>进行划分<br>其实就是确定分类边界，且单变量决策树的决策边界都是平行于坐标轴，如下图<br><img src="https://ooo.0o0.ooo/2017/03/04/58babfd268ac0.png" alt=""> </p>
<p>有些时候我们希望用斜线甚至曲线去进行划分以得到更好的泛化能力：<br><img src="https://ooo.0o0.ooo/2017/03/04/58bac0c658b28.png" alt=""> </p>
<p>这种“斜划分”的方式就是多变量决策树，划分依据不再是单个属性，而是一个形如$\sum\limits_{i=1}^dw_ia_i=t$的线性分类器，${w_i}$和t是需要学习的参数<br><img src="https://ooo.0o0.ooo/2017/03/04/58babffd27b72.png" alt=""> </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[决策树（二）：连续值和缺失处理]]></title>
      <url>/2017/03/05/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%80%BC%E5%92%8C%E7%BC%BA%E5%A4%B1%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="连续值"><a href="#连续值" class="headerlink" title="连续值"></a>连续值</h3><h4 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h4><p>连续值属性<strong>离散化</strong>，<strong>二分法</strong><br>对于连续属性a,有n个样本，考察包含n-1个区间的中点作为候选的划分点：<br><img src="https://ooo.0o0.ooo/2017/03/04/58bab3a529574.png" alt=""> </p>
<h4 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h4><p><img src="https://ooo.0o0.ooo/2017/03/04/58bab4950e852.png" alt=""> </p>
<p>选取能够获得<strong>信息增益最大</strong>的点t进行<strong>二分</strong><br>注意</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><strong>连续值属性</strong>可<strong>多次</strong>作为划分节点（划分值不同），每次划分出两个分支；但<strong>离散值属性只可划分一次</strong>，分出多个分支。</p>
<h3 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h3><p>有些样本缺失某些属性值，如图：<br><img src="https://ooo.0o0.ooo/2017/03/04/58bab8e482daf.png" alt=""><br>如果只要样本有缺失的值就舍弃，会浪费大量数据。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li>如何在缺失值的数据集上进行属性划分。也就是<strong>对于某一个或几个属性，样本有缺失的值，我们如何计算信息增益等指标进行划分属性的选取</strong>。</li>
<li>给定划分属性，若样本在该属性上缺失值，如何划分。也就是<strong>选好了划分属性，对于缺失该的样本，如何将其归类</strong>。</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><img src="https://ooo.0o0.ooo/2017/03/04/58babc3b1bebf.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/03/04/58babc5907282.png" alt=""> </p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里总结一下，针对问题1如何选取分类属性，我们就分别针对每一个属性，计算该<strong>属性值没有缺失样</strong>本的信息增益，选择最大的作为分类属性。<br>确定好分类属性后，对于在该属性值缺失的样本，将其<strong>归入所有的分支节点</strong>，同时按可能的概率更改权重</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[决策树（一）：基础]]></title>
      <url>/2017/03/04/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ol>
<li>使用不熟悉的数据集合，从中提取出一系列规则，能够对新数据进行分类</li>
<li>极大化信息增益$a_* = argmax_{a\in A}{Gain(D,a)}$</li>
</ol>
<h3 id="构建决策树伪代码"><a href="#构建决策树伪代码" class="headerlink" title="构建决策树伪代码"></a>构建决策树伪代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">createBranch()：</div><div class="line">    检测数据集中的每个项是否属于同一个分类：</div><div class="line">    if so </div><div class="line">       return 类标签</div><div class="line">    else</div><div class="line">       寻找划分数据集的最好特征***</div><div class="line">       划分数据集</div><div class="line">       创建分支节点</div><div class="line">            for 每个分支节点，递归调用createBranch()函数</div><div class="line">        return 分支节点</div></pre></td></tr></table></figure>
<h3 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h3><p>显然，构建决策树的关键是<strong>寻找划分数据集的最好特征</strong>，我们希望决策树分支节点包含的样本尽可能属于同一类别——纯度（purity）越高越好</p>
<h2 id="划分选择"><a href="#划分选择" class="headerlink" title="划分选择"></a>划分选择</h2><h3 id="1-信息熵-——-gt-信息增益"><a href="#1-信息熵-——-gt-信息增益" class="headerlink" title="1. 信息熵 ——&gt; 信息增益"></a>1. 信息熵 ——&gt; 信息增益</h3><h5 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h5><ul>
<li>信息论中表示样本的不确定性大小，度量样本集合纯度最常用的指标</li>
<li>样本集合D中第k类占比$p_k$则D的信息熵定义为:<script type="math/tex">Ent(D)=-\sum\limits_{k=1}^{\left |y\right|}p_{k}log_2p_{k}</script></li>
</ul>
<h5 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h5><p>假定离散属性a在D中有V个可能的取值${a^1,a^2,…,a^V}$,若依据属性a对D进行分类，产生V个分支点，根据每个分支点样本数量对分支点赋权重$\left |D^V\right|/D$，于是根据属性a进行划分获得的信息增益为：</p>
<script type="math/tex; mode=display">Gain(D,a) = Ent(D)-\sum\limits_{v=1}^{\left |v\right|}\frac{\left |D^V\right|}{D}Ent(D^v)</script><p>也就是<strong>信息熵的减少量</strong>，越大越好：</p>
<script type="math/tex; mode=display">a_* = argmax_{a\in A}Gain(D,a)</script><p>接下来如果给出下表中关于西瓜的特征数据，据此判断西瓜的好坏<br><img src="https://ooo.0o0.ooo/2017/03/04/58ba9b8304fff.png" alt=""> </p>
<p>我们就可以先算出根节点的信息熵（分为好、坏两类）——&gt;计算依每一个属性进行划分所获得的信息增益，选取信息增益最大的属性作为分支节点——&gt;重复上述过程直到无法分类。得到如下决策树：<br><img src="https://ooo.0o0.ooo/2017/03/04/58ba9d82898b7.png" alt=""> </p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>ID3决策树</p>
<p><strong>思考</strong>：如果我们将数据中“<strong>编号</strong>”这一属性也作为一个候选的划分属性，该属性能够产生17个分支，每个分支只包含一个样本，显然纯度最高，所产生的信息增益也最大，但<strong>不具备泛化能力</strong>。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>实际上<strong>信息增益准则对可取值数目较多的属性有所偏好</strong>（分的越细致的属性越会得到信息增益准则的偏好），但这种偏好会带来<strong>泛化能力差</strong>的不利影响。 </p>
<h3 id="2-增益率"><a href="#2-增益率" class="headerlink" title="2. 增益率"></a>2. 增益率</h3><p><img src="https://ooo.0o0.ooo/2017/03/04/58baa4c1c346e.png" alt=""> </p>
<p>其中IV(a)称为属性a的固有值，属性a的可能取值越多，IV(a)越大，相应地会减小Gain_ration的值。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>与信息增益相反，信息增益准则对可取值数目较少的属性有所偏好，分类性能下降。</p>
<h3 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h3><p>结合信息增益和增益率</p>
<ul>
<li>step1：在候选属性中找出信息增益高于平均水平的属性</li>
<li>step2：在从中选择增益率最高的</li>
</ul>
<h3 id="3-基尼指数"><a href="#3-基尼指数" class="headerlink" title="3. 基尼指数"></a>3. 基尼指数</h3><p><img src="https://ooo.0o0.ooo/2017/03/04/58baa498a3f46.png" alt=""> </p>
<p>用于<strong>度量数据集的纯度</strong>，物理意义：从数据集中随机取两个样本，二者不属于同一类别的概率，<strong>故Gini值越小，数据集纯度越高</strong>。<br>属性a的Gini值定义如下：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/04/58baa6d779529.png" alt=""> </p>
<p>选取使得划分后Gini指数最小的属性作为划分属性，即$a_* = argmax_{a\in A}Gini_index(D,a)$</p>
<h4 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h4><p>采用Gini指数选择属性分类</p>
<h2 id="剪枝处理"><a href="#剪枝处理" class="headerlink" title="剪枝处理"></a>剪枝处理</h2><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p><strong>过拟合</strong>（分支过多，泛化能力差）</p>
<h4 id="方法一：预剪枝"><a href="#方法一：预剪枝" class="headerlink" title="方法一：预剪枝"></a>方法一：预剪枝</h4><ul>
<li>预剪枝是在决策树生成过程中，如果这个节点进行划分，不能带来<strong>泛化性能</strong>的提升，则停止划分并将该节点设置为叶子节点</li>
<li>缺点：“贪心”策略禁止决策树分支展开，容易导致<strong>欠拟合</strong><br><img src="https://ooo.0o0.ooo/2017/03/04/58baaf4ca5634.png" alt=""> </li>
</ul>
<h4 id="方法二：后剪枝"><a href="#方法二：后剪枝" class="headerlink" title="方法二：后剪枝"></a>方法二：后剪枝</h4><ul>
<li>先训练好一棵树，然后自底向上对非叶子节点进行考察，如果将该节点对应的子树替换为叶节点能不能带来<strong>泛化性能</strong>的提升，能就将该子树替换为叶节点。 </li>
<li>优点：泛化能力好</li>
<li>缺点：时间开销大<br><img src="https://ooo.0o0.ooo/2017/03/04/58baaf656713d.png" alt=""> </li>
</ul>
<p>这里的<strong>泛化性能</strong>利用<strong>模型在测试集上的准确率</strong>来衡量</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】461 HammingDistance]]></title>
      <url>/2017/03/04/leetcode461-HammingDistance/</url>
      <content type="html"><![CDATA[<p>从今天开始每天刷一道LeetCode算法题，可不能再偷懒了</p>
<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>
<p>Given two integers x and y, calculate the Hamming distance.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$$</div><div class="line">0  \leq x, y &lt; 2^&#123;31&#125;</div><div class="line">$$</div><div class="line"></div><div class="line">Note:</div><div class="line">0 ≤ x, y &lt; 231.</div><div class="line"></div><div class="line">Example:</div><div class="line"></div><div class="line">Input: x = 1, y = 4</div><div class="line"></div><div class="line">Output: 2</div><div class="line"></div><div class="line">Explanation:</div><div class="line">1   (0 0 0 1)</div><div class="line">4   (0 1 0 0)</div><div class="line">       ↑   ↑</div></pre></td></tr></table></figure>
<p>The above arrows point to positions where the corresponding bits are different.<br>Subscribe to see which companies asked this question.</p>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>求两个数的汉明距离，就是找出这两个数的二进制形式对应位不相同的位，求这样的位的个数</p>
<p>用c++的位操作符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">取反</td>
<td>0变1,1变0</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">左移</td>
<td>后面补0</td>
</tr>
<tr>
<td style="text-align:center">>&gt;</td>
<td style="text-align:center">右移</td>
<td>前面补0，后面吞位</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">位与</td>
<td>只有两个都为1，则为1。<strong>x&amp;…00100…用于提取x某一位</strong></td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">位异或</td>
<td>只有一个为1，则为 1。<strong>用于判断两位是否相同</strong> a^b^a = b 用于交换数值</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>位或</td>
<td>有一个或2个1，则为1。<strong>用于做and运算</strong></td>
</tr>
</tbody>
</table>
</div>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><p>从末位开始逐位判断x和y是否不同（或者做异或操作），不同则在距离上加1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int hammingDistance(int x, int y) &#123;</div><div class="line">        int count = 0;  </div><div class="line">        while(x!=0||y!=0)&#123;  </div><div class="line">            if ((x&amp;1) != (y&amp;1)) count++;  </div><div class="line">            x = x&gt;&gt;1;  </div><div class="line">            y = y&gt;&gt;1;  </div><div class="line">        &#125;  </div><div class="line">    return count;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><p><img src="https://ooo.0o0.ooo/2017/03/05/58bbb2a9ace36.png" alt=""> </p>
<p>太艰难了，第一道题做了小半天，哎，一定要坚持下去</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ol>
<li>《c++ primer》 位操作符 P134</li>
<li><a href="http://blog.csdn.net/a2331046/article/details/53745469" target="_blank" rel="external">wcxdell的专栏</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bit manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ssh-key]]></title>
      <url>/2017/03/04/ssh-key/</url>
      <content type="html"><![CDATA[<h1 id="hexo发布博客-“enter-passhrase-for-key-‘…-rsa-id’”"><a href="#hexo发布博客-“enter-passhrase-for-key-‘…-rsa-id’”" class="headerlink" title="hexo发布博客 “enter passhrase for key ‘…/rsa_id’”"></a>hexo发布博客 “enter passhrase for key ‘…/rsa_id’”</h1><p>用hexo在github上搭建好自己的博客<br>接下来发布博客，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$hexo d</div></pre></td></tr></table></figure>
<p>每次都会出现“enter passphrase for key ‘…/id_rsa’的问题:</p>
<p><img src="http://p1.bqimg.com/567571/ebf9c8fcc2fd8aef.png" alt=""></p>
<p>原因：可能在之前部署博客生成ssh秘钥的时候误为私钥id_rsa设置了密码</p>
<p>解决方法：重置ssh私钥密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[zsy@desktop]$ cd ~/.ssh/</div><div class="line">[zsy@desktop]$ ssh-keygen -f id_rsa -p   #修改ssh私钥passphrase</div><div class="line">Enter new passphrase (empty for no passphrase):</div><div class="line">Enter old passphrase:     #输入之前设置的密码</div><div class="line">Key has comment id_rsa      #验证通过，允许修改</div><div class="line">Enter new passphrase (empty for no passphrase):     #此时不要再设置密码了 直接按空格！！！</div><div class="line">Enter same passphrase again:</div><div class="line">Your identification has been saved with the new passphrase.</div></pre></td></tr></table></figure>
<p>好了，现在没有密码了，hexo d 不需要再次输入密码了，问题解决了~</p>
]]></content>
      
        <categories>
            
            <category> tips </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[hello world]]></title>
      <url>/2017/03/04/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> test </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
